--
-- PostgreSQL database dump
--

-- Dumped from database version 10.23 (Ubuntu 10.23-2.pgdg22.04+1)
-- Dumped by pg_dump version 10.23 (Ubuntu 10.23-2.pgdg22.04+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: acq; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA acq;


ALTER SCHEMA acq OWNER TO evergreen;

--
-- Name: action; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA action;


ALTER SCHEMA action OWNER TO evergreen;

--
-- Name: action_log; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA action_log;


ALTER SCHEMA action_log OWNER TO evergreen;

--
-- Name: action_trigger; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA action_trigger;


ALTER SCHEMA action_trigger OWNER TO evergreen;

--
-- Name: actor; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA actor;


ALTER SCHEMA actor OWNER TO evergreen;

--
-- Name: SCHEMA actor; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON SCHEMA actor IS '
/*
 * Copyright (C) 2009  Equinox Software, Inc. / Georgia Public Library Service
 * Scott McKellar <scott@esilibrary.com>
 *
 * Schema: query
 *
 * Contains tables designed to represent user-defined queries for
 * reports and the like.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: asset; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA asset;


ALTER SCHEMA asset OWNER TO evergreen;

--
-- Name: auditor; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA auditor;


ALTER SCHEMA auditor OWNER TO evergreen;

--
-- Name: authority; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA authority;


ALTER SCHEMA authority OWNER TO evergreen;

--
-- Name: biblio; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA biblio;


ALTER SCHEMA biblio OWNER TO evergreen;

--
-- Name: booking; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA booking;


ALTER SCHEMA booking OWNER TO evergreen;

--
-- Name: cmd; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cmd;


ALTER SCHEMA cmd OWNER TO postgres;

--
-- Name: collectionhq; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA collectionhq;


ALTER SCHEMA collectionhq OWNER TO evergreen;

--
-- Name: config; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA config;


ALTER SCHEMA config OWNER TO evergreen;

--
-- Name: SCHEMA config; Type: COMMENT; Schema: -; Owner: evergreen
--

COMMENT ON SCHEMA config IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * The config schema holds static configuration data for the
 * Open-ILS installation.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: container; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA container;


ALTER SCHEMA container OWNER TO evergreen;

--
-- Name: elastic; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA elastic;


ALTER SCHEMA elastic OWNER TO evergreen;

--
-- Name: envisionware; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA envisionware;


ALTER SCHEMA envisionware OWNER TO evergreen;

--
-- Name: esi; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA esi;


ALTER SCHEMA esi OWNER TO evergreen;

--
-- Name: esi16538; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA esi16538;


ALTER SCHEMA esi16538 OWNER TO evergreen;

--
-- Name: esi_14812; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA esi_14812;


ALTER SCHEMA esi_14812 OWNER TO evergreen;

--
-- Name: evergreen; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA evergreen;


ALTER SCHEMA evergreen OWNER TO evergreen;

--
-- Name: extend_reporter; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA extend_reporter;


ALTER SCHEMA extend_reporter OWNER TO evergreen;

--
-- Name: m_enum; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_enum;


ALTER SCHEMA m_enum OWNER TO evergreen;

--
-- Name: m_test; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA m_test;


ALTER SCHEMA m_test OWNER TO evergreen;

--
-- Name: metabib; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA metabib;


ALTER SCHEMA metabib OWNER TO evergreen;

--
-- Name: migration_tools; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA migration_tools;


ALTER SCHEMA migration_tools OWNER TO evergreen;

--
-- Name: money; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA money;


ALTER SCHEMA money OWNER TO evergreen;

--
-- Name: oai; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA oai;


ALTER SCHEMA oai OWNER TO evergreen;

--
-- Name: offline; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA offline;


ALTER SCHEMA offline OWNER TO evergreen;

--
-- Name: permission; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA permission;


ALTER SCHEMA permission OWNER TO evergreen;

--
-- Name: prod_staff_users; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA prod_staff_users;


ALTER SCHEMA prod_staff_users OWNER TO evergreen;

--
-- Name: query; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA query;


ALTER SCHEMA query OWNER TO evergreen;

--
-- Name: rating; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA rating;


ALTER SCHEMA rating OWNER TO evergreen;

--
-- Name: reporter; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA reporter;


ALTER SCHEMA reporter OWNER TO evergreen;

--
-- Name: search; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA search;


ALTER SCHEMA search OWNER TO evergreen;

--
-- Name: serial; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA serial;


ALTER SCHEMA serial OWNER TO evergreen;

--
-- Name: sip; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA sip;


ALTER SCHEMA sip OWNER TO evergreen;

--
-- Name: sip_temp; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA sip_temp;


ALTER SCHEMA sip_temp OWNER TO evergreen;

--
-- Name: staging; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA staging;


ALTER SCHEMA staging OWNER TO evergreen;

--
-- Name: stats; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA stats;


ALTER SCHEMA stats OWNER TO evergreen;

--
-- Name: unapi; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA unapi;


ALTER SCHEMA unapi OWNER TO evergreen;

--
-- Name: url_verify; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA url_verify;


ALTER SCHEMA url_verify OWNER TO evergreen;

--
-- Name: vandelay; Type: SCHEMA; Schema: -; Owner: evergreen
--

CREATE SCHEMA vandelay;


ALTER SCHEMA vandelay OWNER TO evergreen;

--
-- Name: plperl; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: postgres
--

CREATE OR REPLACE PROCEDURAL LANGUAGE plperl;


ALTER PROCEDURAL LANGUAGE plperl OWNER TO postgres;

--
-- Name: plperlu; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: postgres
--

CREATE OR REPLACE PROCEDURAL LANGUAGE plperlu;


ALTER PROCEDURAL LANGUAGE plperlu OWNER TO postgres;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- Name: cube; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS cube WITH SCHEMA evergreen;


--
-- Name: EXTENSION cube; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION cube IS 'data type for multidimensional cubes';


--
-- Name: dblink; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS dblink WITH SCHEMA evergreen;


--
-- Name: EXTENSION dblink; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION dblink IS 'connect to other PostgreSQL databases from within a database';


--
-- Name: earthdistance; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS earthdistance WITH SCHEMA evergreen;


--
-- Name: EXTENSION earthdistance; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION earthdistance IS 'calculate great-circle distances on the surface of the Earth';


--
-- Name: fuzzystrmatch; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS fuzzystrmatch WITH SCHEMA evergreen;


--
-- Name: EXTENSION fuzzystrmatch; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION fuzzystrmatch IS 'determine similarities and distance between strings';


--
-- Name: hstore; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS hstore WITH SCHEMA evergreen;


--
-- Name: EXTENSION hstore; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION hstore IS 'data type for storing sets of (key, value) pairs';


--
-- Name: intarray; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS intarray WITH SCHEMA public;


--
-- Name: EXTENSION intarray; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION intarray IS 'functions, operators, and index support for 1-D arrays of integers';


--
-- Name: pg_buffercache; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_buffercache WITH SCHEMA evergreen;


--
-- Name: EXTENSION pg_buffercache; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_buffercache IS 'examine the shared buffer cache';


--
-- Name: pg_stat_statements; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_stat_statements WITH SCHEMA evergreen;


--
-- Name: EXTENSION pg_stat_statements; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_stat_statements IS 'track execution statistics of all SQL statements executed';


--
-- Name: pg_trgm; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA public;


--
-- Name: EXTENSION pg_trgm; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_trgm IS 'text similarity measurement and index searching based on trigrams';


--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA evergreen;


--
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- Name: pgstattuple; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pgstattuple WITH SCHEMA evergreen;


--
-- Name: EXTENSION pgstattuple; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgstattuple IS 'show tuple-level statistics';


--
-- Name: unaccent; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS unaccent WITH SCHEMA public;


--
-- Name: EXTENSION unaccent; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION unaccent IS 'text search dictionary that removes accents';


--
-- Name: xml2; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS xml2 WITH SCHEMA evergreen;


--
-- Name: EXTENSION xml2; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION xml2 IS 'XPath querying and XSLT';


--
-- Name: flat_lineitem_detail; Type: TYPE; Schema: acq; Owner: evergreen
--

CREATE TYPE acq.flat_lineitem_detail AS (
	lineitem integer,
	holding integer,
	attr text,
	data text
);


ALTER TYPE acq.flat_lineitem_detail OWNER TO evergreen;

--
-- Name: flat_lineitem_holding_subfield; Type: TYPE; Schema: acq; Owner: evergreen
--

CREATE TYPE acq.flat_lineitem_holding_subfield AS (
	lineitem integer,
	holding integer,
	subfield text,
	data text
);


ALTER TYPE acq.flat_lineitem_holding_subfield OWNER TO evergreen;

--
-- Name: circ_chain_summary; Type: TYPE; Schema: action; Owner: evergreen
--

CREATE TYPE action.circ_chain_summary AS (
	num_circs integer,
	start_time timestamp with time zone,
	checkout_workstation text,
	last_renewal_time timestamp with time zone,
	last_stop_fines text,
	last_stop_fines_time timestamp with time zone,
	last_renewal_workstation text,
	last_checkin_workstation text,
	last_checkin_time timestamp with time zone,
	last_checkin_scan_time timestamp with time zone
);


ALTER TYPE action.circ_chain_summary OWNER TO evergreen;

--
-- Name: circ_matrix_test_result; Type: TYPE; Schema: action; Owner: evergreen
--

CREATE TYPE action.circ_matrix_test_result AS (
	success boolean,
	fail_part text,
	buildrows integer[],
	matchpoint integer,
	circulate boolean,
	duration_rule integer,
	recurring_fine_rule integer,
	max_fine_rule integer,
	hard_due_date integer,
	renewals integer,
	grace_period interval,
	limit_groups integer[]
);


ALTER TYPE action.circ_matrix_test_result OWNER TO evergreen;

--
-- Name: emergency_closing_stage_1_count; Type: TYPE; Schema: action; Owner: evergreen
--

CREATE TYPE action.emergency_closing_stage_1_count AS (
	circulations integer,
	reservations integer,
	holds integer
);


ALTER TYPE action.emergency_closing_stage_1_count OWNER TO evergreen;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: circ_matrix_matchpoint; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.circ_matrix_matchpoint (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    org_unit integer NOT NULL,
    grp integer NOT NULL,
    circ_modifier text,
    marc_type text,
    marc_form text,
    marc_vr_format text,
    ref_flag boolean,
    juvenile_flag boolean,
    is_renewal boolean,
    usr_age_lower_bound interval,
    usr_age_upper_bound interval,
    circulate boolean,
    duration_rule integer,
    recurring_fine_rule integer,
    max_fine_rule integer,
    script_test text,
    total_copy_hold_ratio double precision,
    available_copy_hold_ratio double precision,
    copy_circ_lib integer,
    copy_owning_lib integer,
    hard_due_date integer,
    renewals integer,
    user_home_ou integer,
    grace_period interval,
    marc_bib_level text,
    item_age interval,
    copy_location integer,
    description text,
    renew_extends_due_date boolean DEFAULT false NOT NULL,
    renew_extend_min_interval interval
);


ALTER TABLE config.circ_matrix_matchpoint OWNER TO evergreen;

--
-- Name: found_circ_matrix_matchpoint; Type: TYPE; Schema: action; Owner: evergreen
--

CREATE TYPE action.found_circ_matrix_matchpoint AS (
	success boolean,
	matchpoint config.circ_matrix_matchpoint,
	buildrows integer[]
);


ALTER TYPE action.found_circ_matrix_matchpoint OWNER TO evergreen;

--
-- Name: hold_stats; Type: TYPE; Schema: action; Owner: evergreen
--

CREATE TYPE action.hold_stats AS (
	hold_count integer,
	copy_count integer,
	available_count integer,
	total_copy_ratio double precision,
	available_copy_ratio double precision
);


ALTER TYPE action.hold_stats OWNER TO evergreen;

--
-- Name: matrix_test_result; Type: TYPE; Schema: action; Owner: evergreen
--

CREATE TYPE action.matrix_test_result AS (
	success boolean,
	matchpoint integer,
	fail_part text
);


ALTER TYPE action.matrix_test_result OWNER TO evergreen;

--
-- Name: cascade_setting_summary; Type: TYPE; Schema: actor; Owner: evergreen
--

CREATE TYPE actor.cascade_setting_summary AS (
	name text,
	value json,
	has_org_setting boolean,
	has_user_setting boolean,
	has_workstation_setting boolean
);


ALTER TYPE actor.cascade_setting_summary OWNER TO evergreen;

--
-- Name: org_unit_custom_tree_purpose; Type: TYPE; Schema: actor; Owner: evergreen
--

CREATE TYPE actor.org_unit_custom_tree_purpose AS ENUM (
    'opac'
);


ALTER TYPE actor.org_unit_custom_tree_purpose OWNER TO evergreen;

--
-- Name: heading_purpose; Type: TYPE; Schema: authority; Owner: evergreen
--

CREATE TYPE authority.heading_purpose AS ENUM (
    'main',
    'variant',
    'related'
);


ALTER TYPE authority.heading_purpose OWNER TO evergreen;

--
-- Name: heading_type; Type: TYPE; Schema: authority; Owner: evergreen
--

CREATE TYPE authority.heading_type AS ENUM (
    'personal_name',
    'corporate_name',
    'meeting_name',
    'uniform_title',
    'named_event',
    'chronological_term',
    'topical_term',
    'geographic_name',
    'genre_form_term',
    'medium_of_performance_term'
);


ALTER TYPE authority.heading_type OWNER TO evergreen;

--
-- Name: related_heading_type; Type: TYPE; Schema: authority; Owner: evergreen
--

CREATE TYPE authority.related_heading_type AS ENUM (
    'earlier',
    'later',
    'parent organization',
    'broader',
    'narrower',
    'equivalent',
    'other'
);


ALTER TYPE authority.related_heading_type OWNER TO evergreen;

--
-- Name: variant_heading_type; Type: TYPE; Schema: authority; Owner: evergreen
--

CREATE TYPE authority.variant_heading_type AS ENUM (
    'abbreviation',
    'acronym',
    'translation',
    'expansion',
    'other',
    'hidden'
);


ALTER TYPE authority.variant_heading_type OWNER TO evergreen;

--
-- Name: heading; Type: TYPE; Schema: authority; Owner: evergreen
--

CREATE TYPE authority.heading AS (
	field integer,
	type authority.heading_type,
	purpose authority.heading_purpose,
	variant_type authority.variant_heading_type,
	related_type authority.related_heading_type,
	thesaurus text,
	heading text,
	normalized_heading text
);


ALTER TYPE authority.heading OWNER TO evergreen;

--
-- Name: simple_heading_plus; Type: TYPE; Schema: authority; Owner: evergreen
--

CREATE TYPE authority.simple_heading_plus AS (
	id bigint,
	record bigint,
	atag integer,
	value text,
	sort_value text,
	index_vector tsvector,
	original_text text
);


ALTER TYPE authority.simple_heading_plus OWNER TO evergreen;

--
-- Name: marc21_physical_characteristics; Type: TYPE; Schema: biblio; Owner: evergreen
--

CREATE TYPE biblio.marc21_physical_characteristics AS (
	id integer,
	record bigint,
	ptype text,
	subfield integer,
	value integer
);


ALTER TYPE biblio.marc21_physical_characteristics OWNER TO evergreen;

--
-- Name: record_ff_map; Type: TYPE; Schema: biblio; Owner: evergreen
--

CREATE TYPE biblio.record_ff_map AS (
	record bigint,
	ff_name text,
	ff_value text
);


ALTER TYPE biblio.record_ff_map OWNER TO evergreen;

--
-- Name: copy_alert_type_event; Type: TYPE; Schema: config; Owner: evergreen
--

CREATE TYPE config.copy_alert_type_event AS ENUM (
    'CHECKIN',
    'CHECKOUT'
);


ALTER TYPE config.copy_alert_type_event OWNER TO evergreen;

--
-- Name: copy_alert_type_state; Type: TYPE; Schema: config; Owner: evergreen
--

CREATE TYPE config.copy_alert_type_state AS ENUM (
    'NORMAL',
    'LOST',
    'LOST_AND_PAID',
    'MISSING',
    'DAMAGED',
    'CLAIMSRETURNED',
    'LONGOVERDUE',
    'CLAIMSNEVERCHECKEDOUT'
);


ALTER TYPE config.copy_alert_type_state OWNER TO evergreen;

--
-- Name: marc_record_type; Type: TYPE; Schema: config; Owner: evergreen
--

CREATE TYPE config.marc_record_type AS ENUM (
    'biblio',
    'authority',
    'serial'
);


ALTER TYPE config.marc_record_type OWNER TO evergreen;

--
-- Name: usr_activity_group; Type: TYPE; Schema: config; Owner: evergreen
--

CREATE TYPE config.usr_activity_group AS ENUM (
    'authen',
    'authz',
    'circ',
    'hold',
    'search'
);


ALTER TYPE config.usr_activity_group OWNER TO evergreen;

--
-- Name: barcode_set; Type: TYPE; Schema: evergreen; Owner: evergreen
--

CREATE TYPE evergreen.barcode_set AS (
	type text,
	id bigint,
	barcode text
);


ALTER TYPE evergreen.barcode_set OWNER TO evergreen;

--
-- Name: holdings_maintenance; Type: TYPE; Schema: evergreen; Owner: evergreen
--

CREATE TYPE evergreen.holdings_maintenance AS (
	acn_create_date timestamp with time zone,
	acn_creator bigint,
	acn_deleted boolean,
	acn_edit_date timestamp with time zone,
	acn_editor bigint,
	acn_id bigint,
	label text,
	acn_owning_lib integer,
	acn_record bigint,
	label_sortkey text,
	label_class bigint,
	prefix integer,
	suffix integer,
	age_protect integer,
	alert_message text,
	barcode text,
	call_numer bigint,
	circ_as_type text,
	circ_lib integer,
	circ_modifier text,
	circulate boolean,
	copy_number integer,
	create_date timestamp with time zone,
	active_date timestamp with time zone,
	creator bigint,
	deleted boolean,
	dummy_isbn text,
	deposit boolean,
	deposit_amount numeric(6,2),
	dummy_author text,
	dummy_title text,
	edit_date timestamp with time zone,
	editor bigint,
	fine_level integer,
	holdable boolean,
	id bigint,
	load_duration integer,
	location integer,
	opac_visible boolean,
	price numeric(8,2),
	ref boolean,
	status integer,
	status_changed_time timestamp with time zone,
	mint_condition boolean,
	floating boolean,
	cost numeric(8,2),
	checkin_lib integer,
	checkin_staff integer,
	checkin_time timestamp with time zone,
	circ_circ_lib integer,
	circ_staff integer,
	desk_renewal boolean,
	due_date timestamp with time zone,
	duration interval,
	duration_rule text,
	fine_interval interval,
	circ_id bigint,
	max_fine numeric(6,2),
	max_fine_rule text,
	opac_renewal boolean,
	phone_renewal boolean,
	recurring_fine numeric(6,2),
	recurring_fine_rule text,
	renewal_remaining integer,
	grace_period interval,
	stop_fines text,
	stop_fines_time timestamp with time zone,
	target_copy bigint,
	usr integer,
	xact_finish timestamp with time zone,
	xact_start timestamp with time zone,
	create_time timestamp with time zone,
	workstation integer,
	checkin_workstation integer,
	checkin_scan_time timestamp with time zone,
	parent_circ bigint,
	unrecovered boolean,
	copy_location integer
);


ALTER TYPE evergreen.holdings_maintenance OWNER TO evergreen;

--
-- Name: matched_records; Type: TYPE; Schema: evergreen; Owner: evergreen
--

CREATE TYPE evergreen.matched_records AS (
	create_date timestamp with time zone,
	creator integer,
	edit_date timestamp with time zone,
	id bigint,
	quality integer,
	source integer,
	tcn_source text,
	tcn_value text,
	_id text,
	match_score integer,
	match_quality integer
);


ALTER TYPE evergreen.matched_records OWNER TO evergreen;

--
-- Name: patch; Type: TYPE; Schema: evergreen; Owner: evergreen
--

CREATE TYPE evergreen.patch AS (
	patch text
);


ALTER TYPE evergreen.patch OWNER TO evergreen;

--
-- Name: field_entry_template; Type: TYPE; Schema: metabib; Owner: evergreen
--

CREATE TYPE metabib.field_entry_template AS (
	field_class text,
	field integer,
	facet_field boolean,
	search_field boolean,
	browse_field boolean,
	source bigint,
	value text,
	authority bigint,
	sort_value text,
	display_field boolean,
	browse_nocase boolean
);


ALTER TYPE metabib.field_entry_template OWNER TO evergreen;

--
-- Name: flat_browse_entry_appearance; Type: TYPE; Schema: metabib; Owner: evergreen
--

CREATE TYPE metabib.flat_browse_entry_appearance AS (
	browse_entry bigint,
	value text,
	fields text,
	authorities text,
	sources integer,
	row_number integer,
	accurate boolean,
	pivot_point bigint,
	sees text,
	asources integer,
	aaccurate text
);


ALTER TYPE metabib.flat_browse_entry_appearance OWNER TO evergreen;

--
-- Name: rec_desc_type; Type: TYPE; Schema: metabib; Owner: evergreen
--

CREATE TYPE metabib.rec_desc_type AS (
	item_type text,
	item_form text,
	bib_level text,
	control_type text,
	char_encoding text,
	enc_level text,
	audience text,
	lit_form text,
	type_mat text,
	cat_form text,
	pub_status text,
	item_lang text,
	vr_format text,
	date1 text,
	date2 text
);


ALTER TYPE metabib.rec_desc_type OWNER TO evergreen;

--
-- Name: record_attr_type; Type: TYPE; Schema: metabib; Owner: evergreen
--

CREATE TYPE metabib.record_attr_type AS (
	id bigint,
	attrs evergreen.hstore
);


ALTER TYPE metabib.record_attr_type OWNER TO evergreen;

--
-- Name: auth_n_bib; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.auth_n_bib AS (
	primary_auth bigint,
	auths bigint[],
	bibs bigint[]
);


ALTER TYPE public.auth_n_bib OWNER TO evergreen;

--
-- Name: ean13; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.ean13;


--
-- Name: ean13_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.ean13_in(cstring) RETURNS public.ean13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ean13_in';


ALTER FUNCTION public.ean13_in(cstring) OWNER TO evergreen;

--
-- Name: ean13_out(public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.ean13_out(public.ean13) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ean13_out';


ALTER FUNCTION public.ean13_out(public.ean13) OWNER TO evergreen;

--
-- Name: ean13; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.ean13 (
    INTERNALLENGTH = 8,
    INPUT = public.ean13_in,
    OUTPUT = public.ean13_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.ean13 OWNER TO evergreen;

--
-- Name: TYPE ean13; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE public.ean13 IS 'International European Article Number (EAN13)';


--
-- Name: isbn; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.isbn;


--
-- Name: isbn_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isbn_in(cstring) RETURNS public.isbn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isbn_in';


ALTER FUNCTION public.isbn_in(cstring) OWNER TO evergreen;

--
-- Name: isn_out(public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isn_out(public.isbn) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isn_out';


ALTER FUNCTION public.isn_out(public.isbn) OWNER TO evergreen;

--
-- Name: isbn; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.isbn (
    INTERNALLENGTH = 8,
    INPUT = public.isbn_in,
    OUTPUT = public.isn_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.isbn OWNER TO evergreen;

--
-- Name: TYPE isbn; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE public.isbn IS 'International Standard Book Number (ISBN)';


--
-- Name: isbn13; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.isbn13;


--
-- Name: ean13_out(public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.ean13_out(public.isbn13) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ean13_out';


ALTER FUNCTION public.ean13_out(public.isbn13) OWNER TO evergreen;

--
-- Name: isbn13_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isbn13_in(cstring) RETURNS public.isbn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isbn_in';


ALTER FUNCTION public.isbn13_in(cstring) OWNER TO evergreen;

--
-- Name: isbn13; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.isbn13 (
    INTERNALLENGTH = 8,
    INPUT = public.isbn13_in,
    OUTPUT = public.ean13_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.isbn13 OWNER TO evergreen;

--
-- Name: TYPE isbn13; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE public.isbn13 IS 'International Standard Book Number 13 (ISBN13)';


--
-- Name: ismn; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.ismn;


--
-- Name: ismn_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.ismn_in(cstring) RETURNS public.ismn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ismn_in';


ALTER FUNCTION public.ismn_in(cstring) OWNER TO evergreen;

--
-- Name: isn_out(public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isn_out(public.ismn) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isn_out';


ALTER FUNCTION public.isn_out(public.ismn) OWNER TO evergreen;

--
-- Name: ismn; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.ismn (
    INTERNALLENGTH = 8,
    INPUT = public.ismn_in,
    OUTPUT = public.isn_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.ismn OWNER TO evergreen;

--
-- Name: TYPE ismn; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE public.ismn IS 'International Standard Music Number (ISMN)';


--
-- Name: ismn13; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.ismn13;


--
-- Name: ean13_out(public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.ean13_out(public.ismn13) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ean13_out';


ALTER FUNCTION public.ean13_out(public.ismn13) OWNER TO evergreen;

--
-- Name: ismn13_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.ismn13_in(cstring) RETURNS public.ismn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ismn_in';


ALTER FUNCTION public.ismn13_in(cstring) OWNER TO evergreen;

--
-- Name: ismn13; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.ismn13 (
    INTERNALLENGTH = 8,
    INPUT = public.ismn13_in,
    OUTPUT = public.ean13_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.ismn13 OWNER TO evergreen;

--
-- Name: TYPE ismn13; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE public.ismn13 IS 'International Standard Music Number 13 (ISMN13)';


--
-- Name: issn; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.issn;


--
-- Name: isn_out(public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isn_out(public.issn) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isn_out';


ALTER FUNCTION public.isn_out(public.issn) OWNER TO evergreen;

--
-- Name: issn_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.issn_in(cstring) RETURNS public.issn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'issn_in';


ALTER FUNCTION public.issn_in(cstring) OWNER TO evergreen;

--
-- Name: issn; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.issn (
    INTERNALLENGTH = 8,
    INPUT = public.issn_in,
    OUTPUT = public.isn_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.issn OWNER TO evergreen;

--
-- Name: TYPE issn; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE public.issn IS 'International Standard Serial Number (ISSN)';


--
-- Name: issn13; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.issn13;


--
-- Name: ean13_out(public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.ean13_out(public.issn13) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ean13_out';


ALTER FUNCTION public.ean13_out(public.issn13) OWNER TO evergreen;

--
-- Name: issn13_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.issn13_in(cstring) RETURNS public.issn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'issn_in';


ALTER FUNCTION public.issn13_in(cstring) OWNER TO evergreen;

--
-- Name: issn13; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.issn13 (
    INTERNALLENGTH = 8,
    INPUT = public.issn13_in,
    OUTPUT = public.ean13_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.issn13 OWNER TO evergreen;

--
-- Name: TYPE issn13; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE public.issn13 IS 'International Standard Serial Number 13 (ISSN13)';


--
-- Name: tablefunc_crosstab_2; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.tablefunc_crosstab_2 AS (
	row_name text,
	category_1 text,
	category_2 text
);


ALTER TYPE public.tablefunc_crosstab_2 OWNER TO postgres;

--
-- Name: tablefunc_crosstab_3; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.tablefunc_crosstab_3 AS (
	row_name text,
	category_1 text,
	category_2 text,
	category_3 text
);


ALTER TYPE public.tablefunc_crosstab_3 OWNER TO postgres;

--
-- Name: tablefunc_crosstab_4; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.tablefunc_crosstab_4 AS (
	row_name text,
	category_1 text,
	category_2 text,
	category_3 text,
	category_4 text
);


ALTER TYPE public.tablefunc_crosstab_4 OWNER TO postgres;

--
-- Name: upc; Type: SHELL TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.upc;


--
-- Name: isn_out(public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isn_out(public.upc) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isn_out';


ALTER FUNCTION public.isn_out(public.upc) OWNER TO evergreen;

--
-- Name: upc_in(cstring); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.upc_in(cstring) RETURNS public.upc
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'upc_in';


ALTER FUNCTION public.upc_in(cstring) OWNER TO evergreen;

--
-- Name: upc; Type: TYPE; Schema: public; Owner: evergreen
--

CREATE TYPE public.upc (
    INTERNALLENGTH = 8,
    INPUT = public.upc_in,
    OUTPUT = public.isn_out,
    ALIGNMENT = double,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.upc OWNER TO evergreen;

--
-- Name: TYPE upc; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TYPE public.upc IS 'Universal Product Code (UPC)';


--
-- Name: highlight_result; Type: TYPE; Schema: search; Owner: evergreen
--

CREATE TYPE search.highlight_result AS (
	id bigint,
	source bigint,
	field integer,
	value text,
	highlight text
);


ALTER TYPE search.highlight_result OWNER TO evergreen;

--
-- Name: symspell_lookup_output; Type: TYPE; Schema: search; Owner: evergreen
--

CREATE TYPE search.symspell_lookup_output AS (
	suggestion text,
	suggestion_count integer,
	lev_distance integer,
	pg_trgm_sim numeric,
	qwerty_kb_match numeric,
	soundex_sim numeric,
	input text,
	norm_input text,
	prefix_key text,
	prefix_key_count integer,
	word_pos integer
);


ALTER TYPE search.symspell_lookup_output OWNER TO evergreen;

--
-- Name: authority_queue_queue_type; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE vandelay.authority_queue_queue_type AS ENUM (
    'authority'
);


ALTER TYPE vandelay.authority_queue_queue_type OWNER TO evergreen;

--
-- Name: bib_queue_queue_type; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE vandelay.bib_queue_queue_type AS ENUM (
    'bib',
    'acq'
);


ALTER TYPE vandelay.bib_queue_queue_type OWNER TO evergreen;

--
-- Name: compile_profile; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE vandelay.compile_profile AS (
	add_rule text,
	replace_rule text,
	preserve_rule text,
	strip_rule text
);


ALTER TYPE vandelay.compile_profile OWNER TO evergreen;

--
-- Name: flat_marc; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE vandelay.flat_marc AS (
	tag character(3),
	ind1 text,
	ind2 text,
	subfield text,
	value text
);


ALTER TYPE vandelay.flat_marc OWNER TO evergreen;

--
-- Name: match_set_test_result; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE vandelay.match_set_test_result AS (
	record bigint,
	quality integer
);


ALTER TYPE vandelay.match_set_test_result OWNER TO evergreen;

--
-- Name: tcn_data; Type: TYPE; Schema: vandelay; Owner: evergreen
--

CREATE TYPE vandelay.tcn_data AS (
	tcn text,
	tcn_source text,
	used boolean
);


ALTER TYPE vandelay.tcn_data OWNER TO evergreen;

--
-- Name: isbn(public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isbn(public.ean13) RETURNS public.isbn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isbn_cast_from_ean13';


ALTER FUNCTION public.isbn(public.ean13) OWNER TO evergreen;

--
-- Name: CAST (public.ean13 AS public.isbn); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ean13 AS public.isbn) WITH FUNCTION public.isbn(public.ean13);


--
-- Name: isbn13(public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isbn13(public.ean13) RETURNS public.isbn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'isbn_cast_from_ean13';


ALTER FUNCTION public.isbn13(public.ean13) OWNER TO evergreen;

--
-- Name: CAST (public.ean13 AS public.isbn13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ean13 AS public.isbn13) WITH FUNCTION public.isbn13(public.ean13);


--
-- Name: ismn(public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.ismn(public.ean13) RETURNS public.ismn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ismn_cast_from_ean13';


ALTER FUNCTION public.ismn(public.ean13) OWNER TO evergreen;

--
-- Name: CAST (public.ean13 AS public.ismn); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ean13 AS public.ismn) WITH FUNCTION public.ismn(public.ean13);


--
-- Name: ismn13(public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.ismn13(public.ean13) RETURNS public.ismn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'ismn_cast_from_ean13';


ALTER FUNCTION public.ismn13(public.ean13) OWNER TO evergreen;

--
-- Name: CAST (public.ean13 AS public.ismn13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ean13 AS public.ismn13) WITH FUNCTION public.ismn13(public.ean13);


--
-- Name: issn(public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.issn(public.ean13) RETURNS public.issn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'issn_cast_from_ean13';


ALTER FUNCTION public.issn(public.ean13) OWNER TO evergreen;

--
-- Name: CAST (public.ean13 AS public.issn); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ean13 AS public.issn) WITH FUNCTION public.issn(public.ean13);


--
-- Name: issn13(public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.issn13(public.ean13) RETURNS public.issn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'issn_cast_from_ean13';


ALTER FUNCTION public.issn13(public.ean13) OWNER TO evergreen;

--
-- Name: CAST (public.ean13 AS public.issn13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ean13 AS public.issn13) WITH FUNCTION public.issn13(public.ean13);


--
-- Name: upc(public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.upc(public.ean13) RETURNS public.upc
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'upc_cast_from_ean13';


ALTER FUNCTION public.upc(public.ean13) OWNER TO evergreen;

--
-- Name: CAST (public.ean13 AS public.upc); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ean13 AS public.upc) WITH FUNCTION public.upc(public.ean13);


--
-- Name: CAST (public.isbn AS public.ean13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.isbn AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.isbn AS public.isbn13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.isbn AS public.isbn13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.isbn13 AS public.ean13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.isbn13 AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.isbn13 AS public.isbn); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.isbn13 AS public.isbn) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.ismn AS public.ean13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ismn AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.ismn AS public.ismn13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ismn AS public.ismn13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.ismn13 AS public.ean13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ismn13 AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.ismn13 AS public.ismn); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ismn13 AS public.ismn) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.issn AS public.ean13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.issn AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.issn AS public.issn13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.issn AS public.issn13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.issn13 AS public.ean13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.issn13 AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.issn13 AS public.issn); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.issn13 AS public.issn) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: CAST (public.upc AS public.ean13); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.upc AS public.ean13) WITHOUT FUNCTION AS ASSIGNMENT;


--
-- Name: attribute_debits(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.attribute_debits() RETURNS void
    LANGUAGE plpgsql
    AS $$
/*
Function to attribute expenditures and encumbrances to funding source credits,
and thereby to funding sources.

Read the debits in chonological order, attributing each one to one or
more funding source credits.  Constraints:

1. Don't attribute more to a credit than the amount of the credit.

2. For a given fund, don't attribute more to a funding source than the
source has allocated to that fund.

3. Attribute debits to credits with deadlines before attributing them to
credits without deadlines.  Otherwise attribute to the earliest credits
first, based on the deadline date when present, or on the effective date
when there is no deadline.  Use funding_source_credit.id as a tie-breaker.
This ordering is defined by an ORDER BY clause on the view
acq.ordered_funding_source_credit.

Start by truncating the table acq.debit_attribution.  Then insert a row
into that table for each attribution.  If a debit cannot be fully
attributed, insert a row for the unattributable balance, with the 
funding_source_credit and credit_amount columns NULL.
*/
DECLARE
	curr_fund_source_bal RECORD;
	seqno                INT;     -- sequence num for credits applicable to a fund
	fund_credit          RECORD;  -- current row in temp t_fund_credit table
	fc                   RECORD;  -- used for loading t_fund_credit table
	sc                   RECORD;  -- used for loading t_fund_credit table
	--
	-- Used exclusively in the main loop:
	--
	deb                 RECORD;   -- current row from acq.fund_debit table
	curr_credit_bal     RECORD;   -- current row from temp t_credit table
	debit_balance       NUMERIC;  -- amount left to attribute for current debit
	conv_debit_balance  NUMERIC;  -- debit balance in currency of the fund
	attr_amount         NUMERIC;  -- amount being attributed, in currency of debit
	conv_attr_amount    NUMERIC;  -- amount being attributed, in currency of source
	conv_cred_balance   NUMERIC;  -- credit_balance in the currency of the fund
	conv_alloc_balance  NUMERIC;  -- allocated balance in the currency of the fund
	attrib_count        INT;      -- populates id of acq.debit_attribution
BEGIN
	--
	-- Load a temporary table.  For each combination of fund and funding source,
	-- load an entry with the total amount allocated to that fund by that source.
	-- This sum may reflect transfers as well as original allocations.  We will
	-- reduce this balance whenever we attribute debits to it.
	--
	CREATE TEMP TABLE t_fund_source_bal
	ON COMMIT DROP AS
		SELECT
			fund AS fund,
			funding_source AS source,
			sum( amount ) AS balance
		FROM
			acq.fund_allocation
		GROUP BY
			fund,
			funding_source
		HAVING
			sum( amount ) > 0;
	--
	CREATE INDEX t_fund_source_bal_idx
		ON t_fund_source_bal( fund, source );
	-------------------------------------------------------------------------------
	--
	-- Load another temporary table.  For each fund, load zero or more
	-- funding source credits from which that fund can get money.
	--
	CREATE TEMP TABLE t_fund_credit (
		fund        INT,
		seq         INT,
		credit      INT
	) ON COMMIT DROP;
	--
	FOR fc IN
		SELECT DISTINCT fund
		FROM acq.fund_allocation
		ORDER BY fund
	LOOP                  -- Loop over the funds
		seqno := 1;
		FOR sc IN
			SELECT
				ofsc.id
			FROM
				acq.ordered_funding_source_credit AS ofsc
			WHERE
				ofsc.funding_source IN
				(
					SELECT funding_source
					FROM acq.fund_allocation
					WHERE fund = fc.fund
				)
    		ORDER BY
    		    ofsc.sort_priority,
    		    ofsc.sort_date,
    		    ofsc.id
		LOOP                        -- Add each credit to the list
			INSERT INTO t_fund_credit (
				fund,
				seq,
				credit
			) VALUES (
				fc.fund,
				seqno,
				sc.id
			);
			--RAISE NOTICE 'Fund % credit %', fc.fund, sc.id;
			seqno := seqno + 1;
		END LOOP;     -- Loop over credits for a given fund
	END LOOP;         -- Loop over funds
	--
	CREATE INDEX t_fund_credit_idx
		ON t_fund_credit( fund, seq );
	-------------------------------------------------------------------------------
	--
	-- Load yet another temporary table.  This one is a list of funding source
	-- credits, with their balances.  We shall reduce those balances as we
	-- attribute debits to them.
	--
	CREATE TEMP TABLE t_credit
	ON COMMIT DROP AS
        SELECT
            fsc.id AS credit,
            fsc.funding_source AS source,
            fsc.amount AS balance,
            fs.currency_type AS currency_type
        FROM
            acq.funding_source_credit AS fsc,
            acq.funding_source fs
        WHERE
            fsc.funding_source = fs.id
			AND fsc.amount > 0;
	--
	CREATE INDEX t_credit_idx
		ON t_credit( credit );
	--
	-------------------------------------------------------------------------------
	--
	-- Now that we have loaded the lookup tables: loop through the debits,
	-- attributing each one to one or more funding source credits.
	-- 
	truncate table acq.debit_attribution;
	--
	attrib_count := 0;
	FOR deb in
		SELECT
			fd.id,
			fd.fund,
			fd.amount,
			f.currency_type,
			fd.encumbrance
		FROM
			acq.fund_debit fd,
			acq.fund f
		WHERE
			fd.fund = f.id
		ORDER BY
			fd.id
	LOOP
		--RAISE NOTICE 'Debit %, fund %', deb.id, deb.fund;
		--
		debit_balance := deb.amount;
		--
		-- Loop over the funding source credits that are eligible
		-- to pay for this debit
		--
		FOR fund_credit IN
			SELECT
				credit
			FROM
				t_fund_credit
			WHERE
				fund = deb.fund
			ORDER BY
				seq
		LOOP
			--RAISE NOTICE '   Examining credit %', fund_credit.credit;
			--
			-- Look up the balance for this credit.  If it's zero, then
			-- it's not useful, so treat it as if you didn't find it.
			-- (Actually there shouldn't be any zero balances in the table,
			-- but we check just to make sure.)
			--
			SELECT *
			INTO curr_credit_bal
			FROM t_credit
			WHERE
				credit = fund_credit.credit
				AND balance > 0;
			--
			IF curr_credit_bal IS NULL THEN
				--
				-- This credit is exhausted; try the next one.
				--
				CONTINUE;
			END IF;
			--
			--
			-- At this point we have an applicable credit with some money left.
			-- Now see if the relevant funding_source has any money left.
			--
			-- Look up the balance of the allocation for this combination of
			-- fund and source.  If you find such an entry, but it has a zero
			-- balance, then it's not useful, so treat it as unfound.
			-- (Actually there shouldn't be any zero balances in the table,
			-- but we check just to make sure.)
			--
			SELECT *
			INTO curr_fund_source_bal
			FROM t_fund_source_bal
			WHERE
				fund = deb.fund
				AND source = curr_credit_bal.source
				AND balance > 0;
			--
			IF curr_fund_source_bal IS NULL THEN
				--
				-- This fund/source doesn't exist or is already exhausted,
				-- so we can't use this credit.  Go on to the next one.
				--
				CONTINUE;
			END IF;
			--
			-- Convert the available balances to the currency of the fund
			--
			conv_alloc_balance := curr_fund_source_bal.balance * acq.exchange_ratio(
				curr_credit_bal.currency_type, deb.currency_type );
			conv_cred_balance := curr_credit_bal.balance * acq.exchange_ratio(
				curr_credit_bal.currency_type, deb.currency_type );
			--
			-- Determine how much we can attribute to this credit: the minimum
			-- of the debit amount, the fund/source balance, and the
			-- credit balance
			--
			--RAISE NOTICE '   deb bal %', debit_balance;
			--RAISE NOTICE '      source % balance %', curr_credit_bal.source, conv_alloc_balance;
			--RAISE NOTICE '      credit % balance %', curr_credit_bal.credit, conv_cred_balance;
			--
			conv_attr_amount := NULL;
			attr_amount := debit_balance;
			--
			IF attr_amount > conv_alloc_balance THEN
				attr_amount := conv_alloc_balance;
				conv_attr_amount := curr_fund_source_bal.balance;
			END IF;
			IF attr_amount > conv_cred_balance THEN
				attr_amount := conv_cred_balance;
				conv_attr_amount := curr_credit_bal.balance;
			END IF;
			--
			-- If we're attributing all of one of the balances, then that's how
			-- much we will deduct from the balances, and we already captured
			-- that amount above.  Otherwise we must convert the amount of the
			-- attribution from the currency of the fund back to the currency of
			-- the funding source.
			--
			IF conv_attr_amount IS NULL THEN
				conv_attr_amount := attr_amount * acq.exchange_ratio(
					deb.currency_type, curr_credit_bal.currency_type );
			END IF;
			--
			-- Insert a row to record the attribution
			--
			attrib_count := attrib_count + 1;
			INSERT INTO acq.debit_attribution (
				id,
				fund_debit,
				debit_amount,
				funding_source_credit,
				credit_amount
			) VALUES (
				attrib_count,
				deb.id,
				attr_amount,
				curr_credit_bal.credit,
				conv_attr_amount
			);
			--
			-- Subtract the attributed amount from the various balances
			--
			debit_balance := debit_balance - attr_amount;
			curr_fund_source_bal.balance := curr_fund_source_bal.balance - conv_attr_amount;
			--
			IF curr_fund_source_bal.balance <= 0 THEN
				--
				-- This allocation is exhausted.  Delete it so
				-- that we don't waste time looking at it again.
				--
				DELETE FROM t_fund_source_bal
				WHERE
					fund = curr_fund_source_bal.fund
					AND source = curr_fund_source_bal.source;
			ELSE
				UPDATE t_fund_source_bal
				SET balance = balance - conv_attr_amount
				WHERE
					fund = curr_fund_source_bal.fund
					AND source = curr_fund_source_bal.source;
			END IF;
			--
			IF curr_credit_bal.balance <= 0 THEN
				--
				-- This funding source credit is exhausted.  Delete it
				-- so that we don't waste time looking at it again.
				--
				--DELETE FROM t_credit
				--WHERE
				--	credit = curr_credit_bal.credit;
				--
				DELETE FROM t_fund_credit
				WHERE
					credit = curr_credit_bal.credit;
			ELSE
				UPDATE t_credit
				SET balance = curr_credit_bal.balance
				WHERE
					credit = curr_credit_bal.credit;
			END IF;
			--
			-- Are we done with this debit yet?
			--
			IF debit_balance <= 0 THEN
				EXIT;       -- We've fully attributed this debit; stop looking at credits.
			END IF;
		END LOOP;       -- End loop over credits
		--
		IF debit_balance <> 0 THEN
			--
			-- We weren't able to attribute this debit, or at least not
			-- all of it.  Insert a row for the unattributed balance.
			--
			attrib_count := attrib_count + 1;
			INSERT INTO acq.debit_attribution (
				id,
				fund_debit,
				debit_amount,
				funding_source_credit,
				credit_amount
			) VALUES (
				attrib_count,
				deb.id,
				debit_balance,
				NULL,
				NULL
			);
		END IF;
	END LOOP;   -- End of loop over debits
END;
$$;


ALTER FUNCTION acq.attribute_debits() OWNER TO evergreen;

--
-- Name: audit_acq_lineitem_func(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.audit_acq_lineitem_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO acq.acq_lineitem_history
                SELECT	nextval('acq.acq_lineitem_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    OLD.*;
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION acq.audit_acq_lineitem_func() OWNER TO evergreen;

--
-- Name: audit_acq_purchase_order_func(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.audit_acq_purchase_order_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO acq.acq_purchase_order_history
                SELECT	nextval('acq.acq_purchase_order_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    OLD.*;
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION acq.audit_acq_purchase_order_func() OWNER TO evergreen;

--
-- Name: copy_fund_tags(integer, integer); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.copy_fund_tags(old_fund_id integer, new_fund_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
fund_tag_rec	RECORD;
BEGIN
       
	FOR fund_tag_rec IN SELECT * FROM acq.fund_tag_map WHERE fund=old_fund_id LOOP
                BEGIN
		     INSERT INTO acq.fund_tag_map(fund, tag) VALUES(new_fund_id, fund_tag_rec.tag);
                EXCEPTION
			WHEN unique_violation THEN
			--    RAISE NOTICE 'Fund tag already propagated', old_fund.id;
			CONTINUE;
		END;
	END LOOP;
	RETURN;
END;
$$;


ALTER FUNCTION acq.copy_fund_tags(old_fund_id integer, new_fund_id integer) OWNER TO evergreen;

--
-- Name: create_acq_auditor(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.create_acq_auditor(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM acq.create_acq_seq(sch, tbl);
    PERFORM acq.create_acq_history(sch, tbl);
    PERFORM acq.create_acq_func(sch, tbl);
    PERFORM acq.create_acq_update_trigger(sch, tbl);
    PERFORM acq.create_acq_lifecycle(sch, tbl);
    RETURN TRUE;
END;
$$;


ALTER FUNCTION acq.create_acq_auditor(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_acq_func(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.create_acq_func(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE OR REPLACE FUNCTION acq.audit_$$ || sch || $$_$$ || tbl || $$_func ()
        RETURNS TRIGGER AS $func$
        BEGIN
            INSERT INTO acq.$$ || sch || $$_$$ || tbl || $$_history
                SELECT	nextval('acq.$$ || sch || $$_$$ || tbl || $$_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    OLD.*;
            RETURN NULL;
        END;
        $func$ LANGUAGE 'plpgsql';
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_func(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_acq_history(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.create_acq_history(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TABLE acq.$$ || sch || $$_$$ || tbl || $$_history (
            audit_id	BIGINT				PRIMARY KEY,
            audit_time	TIMESTAMP WITH TIME ZONE	NOT NULL,
            audit_action	TEXT				NOT NULL,
            LIKE $$ || sch || $$.$$ || tbl || $$
        );
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_history(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_acq_lifecycle(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.create_acq_lifecycle(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE OR REPLACE VIEW acq.$$ || sch || $$_$$ || tbl || $$_lifecycle AS
            SELECT	-1, now() as audit_time, '-' as audit_action, *
              FROM	$$ || sch || $$.$$ || tbl || $$
                UNION ALL
            SELECT	*
              FROM	acq.$$ || sch || $$_$$ || tbl || $$_history;
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_lifecycle(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_acq_seq(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.create_acq_seq(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE SEQUENCE acq.$$ || sch || $$_$$ || tbl || $$_pkey_seq;
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_seq(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_acq_update_trigger(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.create_acq_update_trigger(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TRIGGER audit_$$ || sch || $$_$$ || tbl || $$_update_trigger
            AFTER UPDATE OR DELETE ON $$ || sch || $$.$$ || tbl || $$ FOR EACH ROW
            EXECUTE PROCEDURE acq.audit_$$ || sch || $$_$$ || tbl || $$_func ();
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION acq.create_acq_update_trigger(sch text, tbl text) OWNER TO evergreen;

--
-- Name: exchange_ratio(text, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.exchange_ratio(from_ex text, to_ex text) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    rat NUMERIC;
BEGIN
    IF from_ex = to_ex THEN
        RETURN 1.0;
    END IF;

    SELECT ratio INTO rat FROM acq.exchange_rate WHERE from_currency = from_ex AND to_currency = to_ex;

    IF FOUND THEN
        RETURN rat;
    ELSE
        SELECT ratio INTO rat FROM acq.exchange_rate WHERE from_currency = to_ex AND to_currency = from_ex;
        IF FOUND THEN
            RETURN 1.0/rat;
        END IF;
    END IF;

    RETURN NULL;

END;
$$;


ALTER FUNCTION acq.exchange_ratio(from_ex text, to_ex text) OWNER TO evergreen;

--
-- Name: exchange_ratio(text, text, numeric); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.exchange_ratio(text, text, numeric) RETURNS numeric
    LANGUAGE sql
    AS $_$
    SELECT $3 * acq.exchange_ratio($1, $2);
$_$;


ALTER FUNCTION acq.exchange_ratio(text, text, numeric) OWNER TO evergreen;

--
-- Name: export_invoices(boolean); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.export_invoices(dry_run boolean DEFAULT false) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    num_invoices INTEGER;
BEGIN
    -- DROP instead of TRUNCATE so it's easier to modify 
    -- columns later if needed by simply modifying this function.
    DROP TABLE IF EXISTS acq.last_invoice_export;

    CREATE TABLE acq.last_invoice_export AS 
        SELECT 
            * 
        FROM
            (
            SELECT
                acq.invoice.ID AS internal_id,
                acq.invoice.inv_ident AS vendor_inv_id,
                acq.provider.ID AS provider_id,
                to_char( acq.invoice.recv_date, 'MM/DD/YYYY' ) AS recv_date,
                SUM ( acq.fund_debit.amount ) :: money AS amount_paid,
                acq.fund_debit.fund AS fund_id,
                'inv_detail' AS entry_type,
                acq.fund.code AS fund_code,
                acq.fund.NAME AS fund_name,
                acq.provider.code AS provider_code,
                acq.provider.NAME AS provider_name,
                acq.fund.YEAR AS fund_year,
                acq.fund_tag.NAME AS fund_tag,
                acq.invoice_entry.ID,
                acq.invoice.close_date,
                acq.invoice.closed_by 
            FROM
                acq.invoice
                INNER JOIN acq.provider ON acq.invoice.provider = acq.provider.ID 
                INNER JOIN acq.invoice_entry ON acq.invoice_entry.invoice = acq.invoice.ID 
                FULL OUTER JOIN acq.fund_debit ON acq.fund_debit.invoice_entry = acq.invoice_entry.ID 
                INNER JOIN acq.fund ON acq.fund_debit.fund = acq.fund.ID 
                LEFT JOIN acq.fund_tag_map ON acq.fund_tag_map.fund = acq.fund.ID 
                LEFT JOIN acq.fund_tag ON acq.fund_tag_map.tag = acq.fund_tag.ID 
            WHERE
                    acq.invoice.close_date IS NOT NULL
                AND acq.provider.prepayment_required = 'f' 
                AND acq.invoice.erp_export_date IS NULL
            GROUP BY
                acq.invoice.ID,
                acq.invoice.inv_ident,
                acq.provider.ID,
                acq.fund_debit.fund,
                acq.fund.code,
                acq.fund.NAME,
                acq.fund.YEAR,
                acq.fund_tag.NAME,
                acq.invoice_entry.ID UNION ALL
            SELECT
                acq.invoice.ID AS internal_id,
                acq.invoice.inv_ident AS vendor_inv_id,
                acq.provider.ID AS provider_id,
                to_char( acq.invoice.recv_date, 'MM/DD/YYYY' ) AS recv_date,
                SUM ( acq.fund_debit.amount ) :: money AS amount_paid,
                acq.fund_debit.fund AS fund_id,
                acq.invoice_item_type.NAME AS entry_type,
                acq.fund.code AS fund_code,
                acq.fund.NAME AS fund_name,
                acq.provider.code AS provider_code,
                acq.provider.NAME AS provider_name,
                acq.fund.YEAR AS fund_year,
                acq.fund_tag.NAME AS fund_tag,
                acq.invoice_item.ID,
                acq.invoice.close_date,
                acq.invoice.closed_by 
            FROM
                acq.invoice
                INNER JOIN acq.provider ON acq.invoice.provider = acq.provider.ID 
                INNER JOIN acq.invoice_item ON acq.invoice_item.invoice = acq.invoice.ID 
                INNER JOIN acq.invoice_item_type ON acq.invoice_item.inv_item_type = acq.invoice_item_type.code
                FULL OUTER JOIN acq.fund_debit ON acq.invoice_item.fund_debit = acq.fund_debit.ID 
                INNER JOIN acq.fund ON acq.fund_debit.fund = acq.fund.ID 
                LEFT JOIN acq.fund_tag_map ON acq.fund_tag_map.fund = acq.fund.ID 
                LEFT JOIN acq.fund_tag ON acq.fund_tag_map.tag = acq.fund_tag.ID 
            WHERE
                    acq.invoice.close_date IS NOT NULL
                AND acq.provider.prepayment_required = 'f' 
                AND acq.invoice.erp_export_date IS NULL
            GROUP BY
                acq.invoice.ID,
                acq.invoice.inv_ident,
                acq.provider.ID,
                acq.fund_debit.fund,
                acq.invoice_item_type.NAME,
                acq.fund.code,
                acq.fund.NAME,
                acq.provider.code,
                acq.provider.NAME,
                acq.fund.YEAR,
                acq.fund_tag.NAME,
                acq.invoice_item.ID 
            ) AS inv 
        ORDER BY 
            1
    ;

    -- Stamp the selected invoices as exported.
    IF NOT dry_run THEN
        UPDATE acq.invoice 
        SET erp_export_date = NOW() 
        WHERE id IN (
            SELECT DISTINCT(internal_id) FROM acq.last_invoice_export
        );
    END IF;

    SELECT INTO num_invoices COUNT(*) FROM acq.last_invoice_export;
    RAISE NOTICE '% Invoices stamped as exported', num_invoices;

    RETURN num_invoices;
END;
$$;


ALTER FUNCTION acq.export_invoices(dry_run boolean) OWNER TO evergreen;

--
-- Name: extract_holding_attr_table(integer, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.extract_holding_attr_table(lineitem integer, tag text) RETURNS SETOF acq.flat_lineitem_holding_subfield
    LANGUAGE plpgsql
    AS $$
DECLARE
    counter INT;
    lida    acq.flat_lineitem_holding_subfield%ROWTYPE;
BEGIN

    SELECT  COUNT(*) INTO counter
      FROM  oils_xpath_table(
                'id',
                'marc',
                'acq.lineitem',
                '//*[@tag="' || tag || '"]',
                'id=' || lineitem
            ) as t(i int,c text);

    FOR i IN 1 .. counter LOOP
        FOR lida IN
            SELECT  * 
              FROM  (   SELECT  id,i,t,v
                          FROM  oils_xpath_table(
                                    'id',
                                    'marc',
                                    'acq.lineitem',
                                    '//*[@tag="' || tag || '"][position()=' || i || ']/*/@code|' ||
                                        '//*[@tag="' || tag || '"][position()=' || i || ']/*[@code]',
                                    'id=' || lineitem
                                ) as t(id int,t text,v text)
                    )x
        LOOP
            RETURN NEXT lida;
        END LOOP;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION acq.extract_holding_attr_table(lineitem integer, tag text) OWNER TO evergreen;

--
-- Name: extract_provider_holding_data(integer); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.extract_provider_holding_data(lineitem_i integer) RETURNS SETOF acq.flat_lineitem_detail
    LANGUAGE plpgsql
    AS $$
DECLARE
    prov_i  INT;
    tag_t   TEXT;
    lida    acq.flat_lineitem_detail%ROWTYPE;
BEGIN
    SELECT provider INTO prov_i FROM acq.lineitem WHERE id = lineitem_i;
    IF NOT FOUND THEN RETURN; END IF;

    SELECT holding_tag INTO tag_t FROM acq.provider WHERE id = prov_i;
    IF NOT FOUND OR tag_t IS NULL THEN RETURN; END IF;

    FOR lida IN
        SELECT  lineitem_i,
                h.holding,
                a.name,
                h.data
          FROM  acq.extract_holding_attr_table( lineitem_i, tag_t ) h
                JOIN acq.provider_holding_subfield_map a USING (subfield)
          WHERE a.provider = prov_i
    LOOP
        RETURN NEXT lida;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION acq.extract_provider_holding_data(lineitem_i integer) OWNER TO evergreen;

--
-- Name: fap_limit_100(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.fap_limit_100() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
--
total_percent numeric;
--
BEGIN
    SELECT
        sum( percent )
    INTO
        total_percent
    FROM
        acq.fund_allocation_percent AS fap
    WHERE
        fap.funding_source = NEW.funding_source;
    --
    IF total_percent > 100 THEN
        RAISE EXCEPTION 'Total percentages exceed 100 for funding_source %',
            NEW.funding_source;
    ELSE
        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION acq.fap_limit_100() OWNER TO evergreen;

--
-- Name: find_bad_fy(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.find_bad_fy() RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
	first_row  BOOLEAN;
	curr_year  RECORD;
	prev_year  RECORD;
	return_rec RECORD;
BEGIN
	first_row := true;
	FOR curr_year in
		SELECT
			id,
			calendar,
			year,
			year_begin,
			year_end
		FROM
			acq.fiscal_year
		ORDER BY
			calendar,
			year_begin
	LOOP
		--
		IF first_row THEN
			first_row := FALSE;
		ELSIF curr_year.calendar    = prev_year.calendar THEN
			IF curr_year.year_begin > prev_year.year_end THEN
				-- This ugly kludge works around the fact that older
				-- versions of PostgreSQL don't support RETURN QUERY SELECT
				FOR return_rec IN SELECT
					prev_year.id,
					prev_year.year,
					'Gap between fiscal years'::TEXT
				LOOP
					RETURN NEXT return_rec;
				END LOOP;
			ELSIF curr_year.year_begin < prev_year.year_end THEN
				FOR return_rec IN SELECT
					prev_year.id,
					prev_year.year,
					'Overlapping fiscal years'::TEXT
				LOOP
					RETURN NEXT return_rec;
				END LOOP;
			ELSIF curr_year.year < prev_year.year THEN
				FOR return_rec IN SELECT
					prev_year.id,
					prev_year.year,
					'Fiscal years out of order'::TEXT
				LOOP
					RETURN NEXT return_rec;
				END LOOP;
			END IF;
		END IF;
		--
		prev_year := curr_year;
	END LOOP;
	--
	RETURN;
END;
$$;


ALTER FUNCTION acq.find_bad_fy() OWNER TO evergreen;

--
-- Name: fund_alloc_percent_val(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.fund_alloc_percent_val() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
--
DECLARE
--
dummy int := 0;
--
BEGIN
    SELECT
        1
    INTO
        dummy
    FROM
        acq.fund
    WHERE
        org = NEW.org
        AND code = NEW.fund_code
        LIMIT 1;
    --
    IF dummy = 1 then
        RETURN NEW;
    ELSE
        RAISE EXCEPTION 'No fund exists for org % and code %', NEW.org, NEW.fund_code;
    END IF;
END;
$$;


ALTER FUNCTION acq.fund_alloc_percent_val() OWNER TO evergreen;

--
-- Name: po_org_name_date_unique(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.po_org_name_date_unique() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	collision INT;
BEGIN
	--
	-- If order_date is not null, then make sure we don't have a collision
	-- on order_date (truncated to day), org, and name
	--
	IF NEW.order_date IS NULL THEN
		RETURN NEW;
	END IF;
	--
	-- In the WHERE clause, we compare the order_dates without regard to time of day.
	-- We use a pair of inequalities instead of comparing truncated dates so that the
	-- query can do an indexed range scan.
	--
	SELECT 1 INTO collision
	FROM acq.purchase_order
	WHERE
		ordering_agency = NEW.ordering_agency
		AND name = NEW.name
		AND order_date >= date_trunc( 'day', NEW.order_date )
		AND order_date <  date_trunc( 'day', NEW.order_date ) + '1 day'::INTERVAL
		AND id <> NEW.id;
	--
	IF collision IS NULL THEN
		-- okay, no collision
		RETURN NEW;
	ELSE
		-- collision; nip it in the bud
		RAISE EXCEPTION 'Colliding purchase orders: ordering_agency %, date %, name ''%''',
			NEW.ordering_agency, NEW.order_date, NEW.name;
	END IF;
END;
$$;


ALTER FUNCTION acq.po_org_name_date_unique() OWNER TO evergreen;

--
-- Name: propagate_funds_by_org_tree(integer, integer, integer, boolean); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.propagate_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, include_desc boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
--
new_id      INT;
old_fund    RECORD;
org_found   BOOLEAN;
--
BEGIN
	--
	-- Sanity checks
	--
	IF old_year IS NULL THEN
		RAISE EXCEPTION 'Input year argument is NULL';
	ELSIF old_year NOT BETWEEN 2008 and 2200 THEN
		RAISE EXCEPTION 'Input year is out of range';
	END IF;
	--
	IF user_id IS NULL THEN
		RAISE EXCEPTION 'Input user id argument is NULL';
	END IF;
	--
	IF org_unit_id IS NULL THEN
		RAISE EXCEPTION 'Org unit id argument is NULL';
	ELSE
		SELECT TRUE INTO org_found
		FROM actor.org_unit
		WHERE id = org_unit_id;
		--
		IF org_found IS NULL THEN
			RAISE EXCEPTION 'Org unit id is invalid';
		END IF;
	END IF;
	--
	-- Loop over the applicable funds
	--
	FOR old_fund in SELECT * FROM acq.fund
	WHERE
		year = old_year
		AND propagate
		AND ( ( include_desc AND org IN ( SELECT id FROM actor.org_unit_descendants( org_unit_id ) ) )
                OR (NOT include_desc AND org = org_unit_id ) )
    
	LOOP
		BEGIN
			INSERT INTO acq.fund (
				org,
				name,
				year,
				currency_type,
				code,
				rollover,
				propagate,
				balance_warning_percent,
				balance_stop_percent
			) VALUES (
				old_fund.org,
				old_fund.name,
				old_year + 1,
				old_fund.currency_type,
				old_fund.code,
				old_fund.rollover,
				true,
				old_fund.balance_warning_percent,
				old_fund.balance_stop_percent
			)
			RETURNING id INTO new_id;
		EXCEPTION
			WHEN unique_violation THEN
				--RAISE NOTICE 'Fund % already propagated', old_fund.id;
				CONTINUE;
		END;

		PERFORM acq.copy_fund_tags(old_fund.id,new_id);

		--RAISE NOTICE 'Propagating fund % to fund %',
		--	old_fund.code, new_id;
	END LOOP;
END;
$$;


ALTER FUNCTION acq.propagate_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, include_desc boolean) OWNER TO evergreen;

--
-- Name: propagate_funds_by_org_unit(integer, integer, integer); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.propagate_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer) RETURNS void
    LANGUAGE sql
    AS $_$
    SELECT acq.propagate_funds_by_org_tree( $1, $2, $3, FALSE );
$_$;


ALTER FUNCTION acq.propagate_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer) OWNER TO evergreen;

--
-- Name: purchase_order_name_default(); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.purchase_order_name_default() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.name IS NULL THEN
		NEW.name := NEW.id::TEXT;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION acq.purchase_order_name_default() OWNER TO evergreen;

--
-- Name: rollover_funds_by_org_tree(integer, integer, integer, boolean, boolean); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.rollover_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean DEFAULT false, include_desc boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
--
new_fund    INT;
new_year    INT := old_year + 1;
org_found   BOOL;
perm_ous    BOOL;
xfer_amount NUMERIC := 0;
roll_fund   RECORD;
deb         RECORD;
detail      RECORD;
roll_distrib_forms BOOL;
--
BEGIN
    --
    -- Sanity checks
    --
    IF old_year IS NULL THEN
        RAISE EXCEPTION 'Input year argument is NULL';
    ELSIF old_year NOT BETWEEN 2008 and 2200 THEN
        RAISE EXCEPTION 'Input year is out of range';
    END IF;
    --
    IF user_id IS NULL THEN
        RAISE EXCEPTION 'Input user id argument is NULL';
    END IF;
    --
    IF org_unit_id IS NULL THEN
        RAISE EXCEPTION 'Org unit id argument is NULL';
    ELSE
        --
        -- Validate the org unit
        --
        SELECT TRUE
        INTO org_found
        FROM actor.org_unit
        WHERE id = org_unit_id;
        --
        IF org_found IS NULL THEN
            RAISE EXCEPTION 'Org unit id % is invalid', org_unit_id;
        ELSIF encumb_only THEN
            SELECT INTO perm_ous value::BOOL FROM
            actor.org_unit_ancestor_setting(
                'acq.fund.allow_rollover_without_money', org_unit_id
            );
            IF NOT FOUND OR NOT perm_ous THEN
                RAISE EXCEPTION 'Encumbrance-only rollover not permitted at org %', org_unit_id;
            END IF;
        END IF;
    END IF;
    --
    -- Loop over the propagable funds to identify the details
    -- from the old fund plus the id of the new one, if it exists.
    --
    FOR roll_fund in
    SELECT
        oldf.id AS old_fund,
        oldf.org,
        oldf.name,
        oldf.currency_type,
        oldf.code,
        oldf.rollover,
        newf.id AS new_fund_id
    FROM
        acq.fund AS oldf
        LEFT JOIN acq.fund AS newf
            ON ( oldf.code = newf.code AND oldf.org = newf.org )
    WHERE
            oldf.year = old_year
        AND oldf.propagate
        AND newf.year = new_year
        AND ( ( include_desc AND oldf.org IN ( SELECT id FROM actor.org_unit_descendants( org_unit_id ) ) )
                OR (NOT include_desc AND oldf.org = org_unit_id ) )
    LOOP
        --RAISE NOTICE 'Processing fund %', roll_fund.old_fund;
        --
        IF roll_fund.new_fund_id IS NULL THEN
            --
            -- The old fund hasn't been propagated yet.  Propagate it now.
            --
            INSERT INTO acq.fund (
                org,
                name,
                year,
                currency_type,
                code,
                rollover,
                propagate,
                balance_warning_percent,
                balance_stop_percent
            ) VALUES (
                roll_fund.org,
                roll_fund.name,
                new_year,
                roll_fund.currency_type,
                roll_fund.code,
                true,
                true,
                roll_fund.balance_warning_percent,
                roll_fund.balance_stop_percent
            )
            RETURNING id INTO new_fund;

                PERFORM acq.copy_fund_tags(roll_fund.id,new_fund);

        ELSE
            new_fund = roll_fund.new_fund_id;
        END IF;
        --
        -- Determine the amount to transfer
        --
        SELECT amount
        INTO xfer_amount
        FROM acq.fund_spent_balance
        WHERE fund = roll_fund.old_fund;
        --
        IF xfer_amount <> 0 THEN
            IF NOT encumb_only AND roll_fund.rollover THEN
                --
                -- Transfer balance from old fund to new
                --
                --RAISE NOTICE 'Transferring % from fund % to %', xfer_amount, roll_fund.old_fund, new_fund;
                --
                PERFORM acq.transfer_fund(
                    roll_fund.old_fund,
                    xfer_amount,
                    new_fund,
                    xfer_amount,
                    user_id,
                    'Rollover'
                );
            ELSE
                --
                -- Transfer balance from old fund to the void
                --
                -- RAISE NOTICE 'Transferring % from fund % to the void', xfer_amount, roll_fund.old_fund;
                --
                PERFORM acq.transfer_fund(
                    roll_fund.old_fund,
                    xfer_amount,
                    NULL,
                    NULL,
                    user_id,
                    'Rollover into the void'
                );
            END IF;
        END IF;
        --
        IF roll_fund.rollover THEN
            --
            -- Move any lineitems from the old fund to the new one
            -- where the associated debit is an encumbrance.
            --
            -- Any other tables tying expenditure details to funds should
            -- receive similar treatment.  At this writing there are none.
            --
            UPDATE acq.lineitem_detail
            SET fund = new_fund
            WHERE
                fund = roll_fund.old_fund -- this condition may be redundant
                AND fund_debit in
                (
                    SELECT id
                    FROM acq.fund_debit
                    WHERE
                        fund = roll_fund.old_fund
                        AND encumbrance
                );
            --
            -- Move encumbrance debits from the old fund to the new fund
            --
            UPDATE acq.fund_debit
            SET fund = new_fund
            wHERE
                fund = roll_fund.old_fund
                AND encumbrance;
        END IF;

        -- Rollover distribution formulae funds
        SELECT INTO roll_distrib_forms value::BOOL FROM
            actor.org_unit_ancestor_setting(
                'acq.fund.rollover_distrib_forms', org_unit_id
            );

        IF roll_distrib_forms THEN
            UPDATE acq.distribution_formula_entry 
                SET fund = roll_fund.new_fund_id
                WHERE fund = roll_fund.old_fund;
        END IF;

        --
        -- Mark old fund as inactive, now that we've closed it
        --
        UPDATE acq.fund
        SET active = FALSE
        WHERE id = roll_fund.old_fund;
    END LOOP;
END;
$$;


ALTER FUNCTION acq.rollover_funds_by_org_tree(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean, include_desc boolean) OWNER TO evergreen;

--
-- Name: rollover_funds_by_org_unit(integer, integer, integer, boolean); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.rollover_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean DEFAULT false) RETURNS void
    LANGUAGE sql
    AS $_$
    SELECT acq.rollover_funds_by_org_tree( $1, $2, $3, $4, FALSE );
$_$;


ALTER FUNCTION acq.rollover_funds_by_org_unit(old_year integer, user_id integer, org_unit_id integer, encumb_only boolean) OWNER TO evergreen;

--
-- Name: transfer_fund(integer, numeric, integer, numeric, integer, text); Type: FUNCTION; Schema: acq; Owner: evergreen
--

CREATE FUNCTION acq.transfer_fund(old_fund integer, old_amount numeric, new_fund integer, new_amount numeric, user_id integer, xfer_note text) RETURNS void
    LANGUAGE plpgsql
    AS $$
/* -------------------------------------------------------------------------------

Function to transfer money from one fund to another.

A transfer is represented as a pair of entries in acq.fund_allocation, with a
negative amount for the old (losing) fund and a positive amount for the new
(gaining) fund.  In some cases there may be more than one such pair of entries
in order to pull the money from different funding sources, or more specifically
from different funding source credits.  For each such pair there is also an
entry in acq.fund_transfer.

Since funding_source is a non-nullable column in acq.fund_allocation, we must
choose a funding source for the transferred money to come from.  This choice
must meet two constraints, so far as possible:

1. The amount transferred from a given funding source must not exceed the
amount allocated to the old fund by the funding source.  To that end we
compare the amount being transferred to the amount allocated.

2. We shouldn't transfer money that has already been spent or encumbered, as
defined by the funding attribution process.  We attribute expenses to the
oldest funding source credits first.  In order to avoid transferring that
attributed money, we reverse the priority, transferring from the newest funding
source credits first.  There can be no guarantee that this approach will
avoid overcommitting a fund, but no other approach can do any better.

In this context the age of a funding source credit is defined by the
deadline_date for credits with deadline_dates, and by the effective_date for
credits without deadline_dates, with the proviso that credits with deadline_dates
are all considered "older" than those without.

----------

In the signature for this function, there is one last parameter commented out,
named "funding_source_in".  Correspondingly, the WHERE clause for the query
driving the main loop has an OR clause commented out, which references the
funding_source_in parameter.

If these lines are uncommented, this function will allow the user optionally to
restrict a fund transfer to a specified funding source.  If the source
parameter is left NULL, then there will be no such restriction.

------------------------------------------------------------------------------- */ 
DECLARE
	same_currency      BOOLEAN;
	currency_ratio     NUMERIC;
	old_fund_currency  TEXT;
	old_remaining      NUMERIC;  -- in currency of old fund
	new_fund_currency  TEXT;
	new_fund_active    BOOLEAN;
	new_remaining      NUMERIC;  -- in currency of new fund
	curr_old_amt       NUMERIC;  -- in currency of old fund
	curr_new_amt       NUMERIC;  -- in currency of new fund
	source_addition    NUMERIC;  -- in currency of funding source
	source_deduction   NUMERIC;  -- in currency of funding source
	orig_allocated_amt NUMERIC;  -- in currency of funding source
	allocated_amt      NUMERIC;  -- in currency of fund
	source             RECORD;
    old_fund_row       acq.fund%ROWTYPE;
    new_fund_row       acq.fund%ROWTYPE;
    old_org_row        actor.org_unit%ROWTYPE;
    new_org_row        actor.org_unit%ROWTYPE;
BEGIN
	--
	-- Sanity checks
	--
	IF old_fund IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: old fund id is NULL';
	END IF;
	--
	IF old_amount IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: amount to transfer is NULL';
	END IF;
	--
	-- The new fund and its amount must be both NULL or both not NULL.
	--
	IF new_fund IS NOT NULL AND new_amount IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: amount to transfer to receiving fund is NULL';
	END IF;
	--
	IF new_fund IS NULL AND new_amount IS NOT NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: receiving fund is NULL, its amount is not NULL';
	END IF;
	--
	IF user_id IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: user id is NULL';
	END IF;
	--
	-- Initialize the amounts to be transferred, each denominated
	-- in the currency of its respective fund.  They will be
	-- reduced on each iteration of the loop.
	--
	old_remaining := old_amount;
	new_remaining := new_amount;
	--
	-- RAISE NOTICE 'Transferring % in fund % to % in fund %',
	--	old_amount, old_fund, new_amount, new_fund;
	--
	-- Get the currency types of the old and new funds.
	--
	SELECT
		currency_type
	INTO
		old_fund_currency
	FROM
		acq.fund
	WHERE
		id = old_fund;
	--
	IF old_fund_currency IS NULL THEN
		RAISE EXCEPTION 'acq.transfer_fund: old fund id % is not defined', old_fund;
	END IF;
	--
	IF new_fund IS NOT NULL THEN
		SELECT
			currency_type,
			active
		INTO
			new_fund_currency,
			new_fund_active
		FROM
			acq.fund
		WHERE
			id = new_fund;
		--
		IF new_fund_currency IS NULL THEN
			RAISE EXCEPTION 'acq.transfer_fund: new fund id % is not defined', new_fund;
		ELSIF NOT new_fund_active THEN
			--
			-- No point in putting money into a fund from whence you can't spend it
			--
			RAISE EXCEPTION 'acq.transfer_fund: new fund id % is inactive', new_fund;
		END IF;
		--
		IF new_amount = old_amount THEN
			same_currency := true;
			currency_ratio := 1;
		ELSE
			--
			-- We'll have to translate currency between funds.  We presume that
			-- the calling code has already applied an appropriate exchange rate,
			-- so we'll apply the same conversion to each sub-transfer.
			--
			same_currency := false;
			currency_ratio := new_amount / old_amount;
		END IF;
	END IF;

    -- Fetch old and new fund's information
    -- in order to construct the allocation notes
    SELECT INTO old_fund_row * FROM acq.fund WHERE id = old_fund;
    SELECT INTO old_org_row * FROM actor.org_unit WHERE id = old_fund_row.org;
    SELECT INTO new_fund_row * FROM acq.fund WHERE id = new_fund;
    SELECT INTO new_org_row * FROM actor.org_unit WHERE id = new_fund_row.org;

	--
	-- Identify the funding source(s) from which we want to transfer the money.
	-- The principle is that we want to transfer the newest money first, because
	-- we spend the oldest money first.  The priority for spending is defined
	-- by a sort of the view acq.ordered_funding_source_credit.
	--
	FOR source in
		SELECT
			ofsc.id,
			ofsc.funding_source,
			ofsc.amount,
			ofsc.amount * acq.exchange_ratio( fs.currency_type, old_fund_currency )
				AS converted_amt,
			fs.currency_type
		FROM
			acq.ordered_funding_source_credit AS ofsc,
			acq.funding_source fs
		WHERE
			ofsc.funding_source = fs.id
			and ofsc.funding_source IN
			(
				SELECT funding_source
				FROM acq.fund_allocation
				WHERE fund = old_fund
			)
			-- and
			-- (
			-- 	ofsc.funding_source = funding_source_in
			-- 	OR funding_source_in IS NULL
			-- )
		ORDER BY
			ofsc.sort_priority desc,
			ofsc.sort_date desc,
			ofsc.id desc
	LOOP
		--
		-- Determine how much money the old fund got from this funding source,
		-- denominated in the currency types of the source and of the fund.
		-- This result may reflect transfers from previous iterations.
		--
		SELECT
			COALESCE( sum( amount ), 0 ),
			COALESCE( sum( amount )
				* acq.exchange_ratio( source.currency_type, old_fund_currency ), 0 )
		INTO
			orig_allocated_amt,     -- in currency of the source
			allocated_amt           -- in currency of the old fund
		FROM
			acq.fund_allocation
		WHERE
			fund = old_fund
			and funding_source = source.funding_source;
		--	
		-- Determine how much to transfer from this credit, in the currency
		-- of the fund.   Begin with the amount remaining to be attributed:
		--
		curr_old_amt := old_remaining;
		--
		-- Can't attribute more than was allocated from the fund:
		--
		IF curr_old_amt > allocated_amt THEN
			curr_old_amt := allocated_amt;
		END IF;
		--
		-- Can't attribute more than the amount of the current credit:
		--
		IF curr_old_amt > source.converted_amt THEN
			curr_old_amt := source.converted_amt;
		END IF;
		--
		curr_old_amt := trunc( curr_old_amt, 2 );
		--
		old_remaining := old_remaining - curr_old_amt;
		--
		-- Determine the amount to be deducted, if any,
		-- from the old allocation.
		--
		IF old_remaining > 0 THEN
			--
			-- In this case we're using the whole allocation, so use that
			-- amount directly instead of applying a currency translation
			-- and thereby inviting round-off errors.
			--
			source_deduction := - curr_old_amt;
		ELSE 
			source_deduction := trunc(
				( - curr_old_amt ) *
					acq.exchange_ratio( old_fund_currency, source.currency_type ),
				2 );
		END IF;
		--
		IF source_deduction <> 0 THEN
			--
			-- Insert negative allocation for old fund in fund_allocation,
			-- converted into the currency of the funding source
			--
			INSERT INTO acq.fund_allocation (
				funding_source,
				fund,
				amount,
				allocator,
				note
			) VALUES (
				source.funding_source,
				old_fund,
				source_deduction,
				user_id,
				'Transfer to fund ' || new_fund_row.code || ' ('
                                    || new_fund_row.year || ') ('
                                    || new_org_row.shortname || ')'
			);
		END IF;
		--
		IF new_fund IS NOT NULL THEN
			--
			-- Determine how much to add to the new fund, in
			-- its currency, and how much remains to be added:
			--
			IF same_currency THEN
				curr_new_amt := curr_old_amt;
			ELSE
				IF old_remaining = 0 THEN
					--
					-- This is the last iteration, so nothing should be left
					--
					curr_new_amt := new_remaining;
					new_remaining := 0;
				ELSE
					curr_new_amt := trunc( curr_old_amt * currency_ratio, 2 );
					new_remaining := new_remaining - curr_new_amt;
				END IF;
			END IF;
			--
			-- Determine how much to add, if any,
			-- to the new fund's allocation.
			--
			IF old_remaining > 0 THEN
				--
				-- In this case we're using the whole allocation, so use that amount
				-- amount directly instead of applying a currency translation and
				-- thereby inviting round-off errors.
				--
				source_addition := curr_new_amt;
			ELSIF source.currency_type = old_fund_currency THEN
				--
				-- In this case we don't need a round trip currency translation,
				-- thereby inviting round-off errors:
				--
				source_addition := curr_old_amt;
			ELSE 
				source_addition := trunc(
					curr_new_amt *
						acq.exchange_ratio( new_fund_currency, source.currency_type ),
					2 );
			END IF;
			--
			IF source_addition <> 0 THEN
				--
				-- Insert positive allocation for new fund in fund_allocation,
				-- converted to the currency of the founding source
				--
				INSERT INTO acq.fund_allocation (
					funding_source,
					fund,
					amount,
					allocator,
					note
				) VALUES (
					source.funding_source,
					new_fund,
					source_addition,
					user_id,
				    'Transfer from fund ' || old_fund_row.code || ' ('
                                          || old_fund_row.year || ') ('
                                          || old_org_row.shortname || ')'
				);
			END IF;
		END IF;
		--
		IF trunc( curr_old_amt, 2 ) <> 0
		OR trunc( curr_new_amt, 2 ) <> 0 THEN
			--
			-- Insert row in fund_transfer, using amounts in the currency of the funds
			--
			INSERT INTO acq.fund_transfer (
				src_fund,
				src_amount,
				dest_fund,
				dest_amount,
				transfer_user,
				note,
				funding_source_credit
			) VALUES (
				old_fund,
				trunc( curr_old_amt, 2 ),
				new_fund,
				trunc( curr_new_amt, 2 ),
				user_id,
				xfer_note,
				source.id
			);
		END IF;
		--
		if old_remaining <= 0 THEN
			EXIT;                   -- Nothing more to be transferred
		END IF;
	END LOOP;
END;
$$;


ALTER FUNCTION acq.transfer_fund(old_fund integer, old_amount numeric, new_fund integer, new_amount numeric, user_id integer, xfer_note text) OWNER TO evergreen;

--
-- Name: age_circ_on_delete(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.age_circ_on_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
found char := 'N';
BEGIN

    -- If there are any renewals for this circulation, don't archive or delete
    -- it yet.   We'll do so later, when we archive and delete the renewals.

    SELECT 'Y' INTO found
    FROM action.circulation
    WHERE parent_circ = OLD.id
    LIMIT 1;

    IF found = 'Y' THEN
        RETURN NULL;  -- don't delete
	END IF;

    -- Archive a copy of the old row to action.aged_circulation

    INSERT INTO action.aged_circulation
        (id,usr_post_code, usr_home_ou, usr_profile, usr_birth_year, copy_call_number, copy_location,
        copy_owning_lib, copy_circ_lib, copy_bib_record, xact_start, xact_finish, target_copy,
        circ_lib, circ_staff, checkin_staff, checkin_lib, renewal_remaining, grace_period, due_date,
        stop_fines_time, checkin_time, create_time, duration, fine_interval, recurring_fine,
        max_fine, phone_renewal, desk_renewal, opac_renewal, duration_rule, recurring_fine_rule,
        max_fine_rule, stop_fines, workstation, checkin_workstation, checkin_scan_time, parent_circ,
        auto_renewal, auto_renewal_remaining)
      SELECT
        id,usr_post_code, usr_home_ou, usr_profile, usr_birth_year, copy_call_number, copy_location,
        copy_owning_lib, copy_circ_lib, copy_bib_record, xact_start, xact_finish, target_copy,
        circ_lib, circ_staff, checkin_staff, checkin_lib, renewal_remaining, grace_period, due_date,
        stop_fines_time, checkin_time, create_time, duration, fine_interval, recurring_fine,
        max_fine, phone_renewal, desk_renewal, opac_renewal, duration_rule, recurring_fine_rule,
        max_fine_rule, stop_fines, workstation, checkin_workstation, checkin_scan_time, parent_circ,
        auto_renewal, auto_renewal_remaining
        FROM action.all_circulation WHERE id = OLD.id;

    -- Migrate billings and payments to aged tables

    SELECT 'Y' INTO found FROM config.global_flag 
        WHERE name = 'history.money.age_with_circs' AND enabled;

    IF found = 'Y' THEN
        PERFORM money.age_billings_and_payments_for_xact(OLD.id);
    END IF;

    -- Break the link with the user in action_trigger.event (warning: event_output may essentially have this information)
    UPDATE
        action_trigger.event e
    SET
        context_user = NULL
    FROM
        action.all_circulation c
    WHERE
            c.id = OLD.id
        AND e.context_user = c.usr
        AND e.target = c.id
        AND e.event_def IN (
            SELECT id
            FROM action_trigger.event_definition
            WHERE hook in (SELECT key FROM action_trigger.hook WHERE core_type = 'circ')
        )
    ;

    RETURN OLD;
END;
$$;


ALTER FUNCTION action.age_circ_on_delete() OWNER TO evergreen;

--
-- Name: age_hold_on_delete(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.age_hold_on_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    hold_transit action.hold_transit_copy%ROWTYPE;
BEGIN

    SELECT INTO hold_transit * FROM action.hold_transit_copy
    WHERE hold = OLD.id AND cancel_time IS NULL AND dest_recv_time IS NULL;

    IF FOUND THEN

        -- set the transiting copy to canceled transit if it's currently in transit.
        UPDATE asset.copy SET status = 18 -- canceled transit
        WHERE status = 6 /* in transit */ AND id = hold_transit.target_copy;

        -- now cancel the transit
        UPDATE action.hold_transit_copy SET cancel_time = NOW() 
        WHERE id = hold_transit.id;

    END IF;

    -- now archive the hold request

    INSERT INTO action.aged_hold_request
           (usr_post_code,
            usr_home_ou,
            usr_profile,
            usr_birth_year,
            staff_placed,
            id,
            request_time,
            capture_time,
            fulfillment_time,
            checkin_time,
            return_time,
            prev_check_time,
            expire_time,
            cancel_time,
            cancel_cause,
            cancel_note,
            target,
            current_copy,
            fulfillment_staff,
            fulfillment_lib,
            request_lib,
            selection_ou,
            selection_depth,
            pickup_lib,
            hold_type,
            holdable_formats,
            phone_notify,
            email_notify,
            sms_notify,
            frozen,
            thaw_date,
            shelf_time,
            cut_in_line,
            mint_condition,
            shelf_expire_time,
            current_shelf_lib)
      SELECT 
           usr_post_code,
           usr_home_ou,
           usr_profile,
           usr_birth_year,
           staff_placed,
           id,
           request_time,
           capture_time,
           fulfillment_time,
           checkin_time,
           return_time,
           prev_check_time,
           expire_time,
           cancel_time,
           cancel_cause,
           cancel_note,
           target,
           current_copy,
           fulfillment_staff,
           fulfillment_lib,
           request_lib,
           selection_ou,
           selection_depth,
           pickup_lib,
           hold_type,
           holdable_formats,
           phone_notify,
           email_notify,
           sms_notify,
           frozen,
           thaw_date,
           shelf_time,
           cut_in_line,
           mint_condition,
           shelf_expire_time,
           current_shelf_lib
        FROM action.all_hold_request WHERE id = OLD.id;

    RETURN OLD;
END;
$$;


ALTER FUNCTION action.age_hold_on_delete() OWNER TO evergreen;

--
-- Name: age_parent_circ_on_delete(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.age_parent_circ_on_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    -- Having deleted a renewal, we can delete the original circulation (or a previous
    -- renewal, if that's what parent_circ is pointing to).  That deletion will trigger
    -- deletion of any prior parents, etc. recursively.

    IF OLD.parent_circ IS NOT NULL THEN
        DELETE FROM action.circulation
        WHERE id = OLD.parent_circ;
    END IF;

    RETURN OLD;
END;
$$;


ALTER FUNCTION action.age_parent_circ_on_delete() OWNER TO evergreen;

--
-- Name: aged_circulation; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.aged_circulation (
    usr_post_code text,
    usr_home_ou integer NOT NULL,
    usr_profile integer NOT NULL,
    usr_birth_year integer,
    copy_call_number integer NOT NULL,
    copy_location integer NOT NULL,
    copy_owning_lib integer NOT NULL,
    copy_circ_lib integer NOT NULL,
    copy_bib_record bigint NOT NULL,
    id bigint NOT NULL,
    xact_start timestamp with time zone NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint NOT NULL,
    circ_lib integer NOT NULL,
    circ_staff integer NOT NULL,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer NOT NULL,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone NOT NULL,
    duration interval,
    fine_interval interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean NOT NULL,
    desk_renewal boolean NOT NULL,
    opac_renewal boolean NOT NULL,
    duration_rule text NOT NULL,
    recurring_fine_rule text NOT NULL,
    max_fine_rule text NOT NULL,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval NOT NULL,
    auto_renewal boolean DEFAULT false NOT NULL,
    auto_renewal_remaining integer
);


ALTER TABLE action.aged_circulation OWNER TO evergreen;

--
-- Name: billable_xact; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.billable_xact (
    id bigint NOT NULL,
    usr integer NOT NULL,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean
);


ALTER TABLE money.billable_xact OWNER TO evergreen;

--
-- Name: billable_xact_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE money.billable_xact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.billable_xact_id_seq OWNER TO evergreen;

--
-- Name: billable_xact_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE money.billable_xact_id_seq OWNED BY money.billable_xact.id;


--
-- Name: circulation; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass),
    target_copy bigint NOT NULL,
    circ_lib integer NOT NULL,
    circ_staff integer NOT NULL,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer NOT NULL,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text NOT NULL,
    recurring_fine_rule text NOT NULL,
    max_fine_rule text NOT NULL,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval NOT NULL,
    copy_location integer DEFAULT 1 NOT NULL,
    auto_renewal boolean DEFAULT false NOT NULL,
    auto_renewal_remaining integer,
    CONSTRAINT circulation_stop_fines_check CHECK ((stop_fines = ANY (ARRAY['CHECKIN'::text, 'CLAIMSRETURNED'::text, 'LOST'::text, 'MAXFINES'::text, 'RENEW'::text, 'LONGOVERDUE'::text, 'CLAIMSNEVERCHECKEDOUT'::text])))
)
INHERITS (money.billable_xact);


ALTER TABLE action.circulation OWNER TO evergreen;

--
-- Name: all_circulation_slim; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW action.all_circulation_slim AS
 SELECT circulation.id,
    circulation.usr,
    circulation.xact_start,
    circulation.xact_finish,
    circulation.unrecovered,
    circulation.target_copy,
    circulation.circ_lib,
    circulation.circ_staff,
    circulation.checkin_staff,
    circulation.checkin_lib,
    circulation.renewal_remaining,
    circulation.grace_period,
    circulation.due_date,
    circulation.stop_fines_time,
    circulation.checkin_time,
    circulation.create_time,
    circulation.duration,
    circulation.fine_interval,
    circulation.recurring_fine,
    circulation.max_fine,
    circulation.phone_renewal,
    circulation.desk_renewal,
    circulation.opac_renewal,
    circulation.duration_rule,
    circulation.recurring_fine_rule,
    circulation.max_fine_rule,
    circulation.stop_fines,
    circulation.workstation,
    circulation.checkin_workstation,
    circulation.copy_location,
    circulation.checkin_scan_time,
    circulation.auto_renewal,
    circulation.auto_renewal_remaining,
    circulation.parent_circ
   FROM action.circulation
UNION ALL
 SELECT aged_circulation.id,
    NULL::integer AS usr,
    aged_circulation.xact_start,
    aged_circulation.xact_finish,
    aged_circulation.unrecovered,
    aged_circulation.target_copy,
    aged_circulation.circ_lib,
    aged_circulation.circ_staff,
    aged_circulation.checkin_staff,
    aged_circulation.checkin_lib,
    aged_circulation.renewal_remaining,
    aged_circulation.grace_period,
    aged_circulation.due_date,
    aged_circulation.stop_fines_time,
    aged_circulation.checkin_time,
    aged_circulation.create_time,
    aged_circulation.duration,
    aged_circulation.fine_interval,
    aged_circulation.recurring_fine,
    aged_circulation.max_fine,
    aged_circulation.phone_renewal,
    aged_circulation.desk_renewal,
    aged_circulation.opac_renewal,
    aged_circulation.duration_rule,
    aged_circulation.recurring_fine_rule,
    aged_circulation.max_fine_rule,
    aged_circulation.stop_fines,
    aged_circulation.workstation,
    aged_circulation.checkin_workstation,
    aged_circulation.copy_location,
    aged_circulation.checkin_scan_time,
    aged_circulation.auto_renewal,
    aged_circulation.auto_renewal_remaining,
    aged_circulation.parent_circ
   FROM action.aged_circulation;


ALTER TABLE action.all_circulation_slim OWNER TO evergreen;

--
-- Name: all_circ_chain(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.all_circ_chain(ctx_circ_id integer) RETURNS SETOF action.all_circulation_slim
    LANGUAGE plpgsql
    AS $$
DECLARE
    tmp_circ action.all_circulation_slim%ROWTYPE;
    circ_0 action.all_circulation_slim%ROWTYPE;
BEGIN

    SELECT INTO tmp_circ * FROM action.all_circulation_slim WHERE id = ctx_circ_id;

    IF tmp_circ IS NULL THEN
        RETURN NEXT tmp_circ;
    END IF;
    circ_0 := tmp_circ;

    -- find the front of the chain
    WHILE TRUE LOOP
        SELECT INTO tmp_circ * FROM action.all_circulation_slim 
            WHERE id = tmp_circ.parent_circ;
        IF tmp_circ IS NULL THEN
            EXIT;
        END IF;
        circ_0 := tmp_circ;
    END LOOP;

    -- now send the circs to the caller, oldest to newest
    tmp_circ := circ_0;
    WHILE TRUE LOOP
        IF tmp_circ IS NULL THEN
            EXIT;
        END IF;
        RETURN NEXT tmp_circ;
        SELECT INTO tmp_circ * FROM action.all_circulation_slim 
            WHERE parent_circ = tmp_circ.id;
    END LOOP;

END;
$$;


ALTER FUNCTION action.all_circ_chain(ctx_circ_id integer) OWNER TO evergreen;

--
-- Name: apply_fieldset(integer, text, text, text); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    statement TEXT;
    where_clause TEXT;
    fs_status TEXT;
    fs_pkey_value TEXT;
    fs_query TEXT;
    sep CHAR;
    status_code TEXT;
    msg TEXT;
    fs_id INT;
    fsg_id INT;
    update_count INT;
    cv RECORD;
    fs_obj action.fieldset%ROWTYPE;
    fs_group action.fieldset_group%ROWTYPE;
    rb_row RECORD;
BEGIN
    -- Sanity checks
    IF fieldset_id IS NULL THEN
        RETURN 'Fieldset ID parameter is NULL';
    END IF;
    IF table_name IS NULL THEN
        RETURN 'Table name parameter is NULL';
    END IF;
    IF pkey_name IS NULL THEN
        RETURN 'Primary key name parameter is NULL';
    END IF;

    SELECT
        status,
        quote_literal( pkey_value )
    INTO
        fs_status,
        fs_pkey_value
    FROM
        action.fieldset
    WHERE
        id = fieldset_id;

    --
    -- Build the WHERE clause.  This differs according to whether it's a
    -- single-row fieldset or a query-based fieldset.
    --
    IF query IS NULL        AND fs_pkey_value IS NULL THEN
        RETURN 'Incomplete fieldset: neither a primary key nor a query available';
    ELSIF query IS NOT NULL AND fs_pkey_value IS NULL THEN
        fs_query := rtrim( query, ';' );
        where_clause := 'WHERE ' || pkey_name || ' IN ( '
                     || fs_query || ' )';
    ELSIF query IS NULL     AND fs_pkey_value IS NOT NULL THEN
        where_clause := 'WHERE ' || pkey_name || ' = ';
        IF pkey_name = 'id' THEN
            where_clause := where_clause || fs_pkey_value;
        ELSIF pkey_name = 'code' THEN
            where_clause := where_clause || quote_literal(fs_pkey_value);
        ELSE
            RETURN 'Only know how to handle "id" and "code" pkeys currently, received ' || pkey_name;
        END IF;
    ELSE  -- both are not null
        RETURN 'Ambiguous fieldset: both a primary key and a query provided';
    END IF;

    IF fs_status IS NULL THEN
        RETURN 'No fieldset found for id = ' || fieldset_id;
    ELSIF fs_status = 'APPLIED' THEN
        RETURN 'Fieldset ' || fieldset_id || ' has already been applied';
    END IF;

    SELECT * INTO fs_obj FROM action.fieldset WHERE id = fieldset_id;
    SELECT * INTO fs_group FROM action.fieldset_group WHERE id = fs_obj.fieldset_group;

    IF fs_group.can_rollback THEN
        -- This is part of a non-rollback group.  We need to record the current values for future rollback.

        INSERT INTO action.fieldset_group (can_rollback, name, creator, owning_lib, container, container_type)
            VALUES (FALSE, 'ROLLBACK: '|| fs_group.name, fs_group.creator, fs_group.owning_lib, fs_group.container, fs_group.container_type);

        fsg_id := CURRVAL('action.fieldset_group_id_seq');

        FOR rb_row IN EXECUTE 'SELECT * FROM ' || table_name || ' ' || where_clause LOOP
            IF pkey_name = 'id' THEN
                fs_pkey_value := rb_row.id;
            ELSIF pkey_name = 'code' THEN
                fs_pkey_value := rb_row.code;
            ELSE
                RETURN 'Only know how to handle "id" and "code" pkeys currently, received ' || pkey_name;
            END IF;
            INSERT INTO action.fieldset (fieldset_group,owner,owning_lib,status,classname,name,pkey_value)
                VALUES (fsg_id, fs_obj.owner, fs_obj.owning_lib, 'PENDING', fs_obj.classname, fs_obj.name || ' ROLLBACK FOR ' || fs_pkey_value, fs_pkey_value);

            fs_id := CURRVAL('action.fieldset_id_seq');
            sep := '';
            FOR cv IN
                SELECT  DISTINCT col
                FROM    action.fieldset_col_val
                WHERE   fieldset = fieldset_id
            LOOP
                EXECUTE 'INSERT INTO action.fieldset_col_val (fieldset, col, val) ' || 
                    'SELECT '|| fs_id || ', '||quote_literal(cv.col)||', '||cv.col||' FROM '||table_name||' WHERE '||pkey_name||' = '||fs_pkey_value;
            END LOOP;
        END LOOP;
    END IF;

    statement := 'UPDATE ' || table_name || ' SET';

    sep := '';
    FOR cv IN
        SELECT  col,
                val
        FROM    action.fieldset_col_val
        WHERE   fieldset = fieldset_id
    LOOP
        statement := statement || sep || ' ' || cv.col
                     || ' = ' || coalesce( quote_literal( cv.val ), 'NULL' );
        sep := ',';
    END LOOP;

    IF sep = '' THEN
        RETURN 'Fieldset ' || fieldset_id || ' has no column values defined';
    END IF;
    statement := statement || ' ' || where_clause;

    --
    -- Execute the update
    --
    BEGIN
        EXECUTE statement;
        GET DIAGNOSTICS update_count = ROW_COUNT;

        IF update_count = 0 THEN
            RAISE data_exception;
        END IF;

        IF fsg_id IS NOT NULL THEN
            UPDATE action.fieldset_group SET rollback_group = fsg_id WHERE id = fs_group.id;
        END IF;

        IF fs_group.id IS NOT NULL THEN
            UPDATE action.fieldset_group SET complete_time = now() WHERE id = fs_group.id;
        END IF;

        UPDATE action.fieldset SET status = 'APPLIED', applied_time = now() WHERE id = fieldset_id;

    EXCEPTION WHEN data_exception THEN
        msg := 'No eligible rows found for fieldset ' || fieldset_id;
        UPDATE action.fieldset SET status = 'ERROR', applied_time = now() WHERE id = fieldset_id;
        RETURN msg;

    END;

    RETURN msg;

EXCEPTION WHEN OTHERS THEN
    msg := 'Unable to apply fieldset ' || fieldset_id || ': ' || sqlerrm;
    UPDATE action.fieldset SET status = 'ERROR', applied_time = now() WHERE id = fieldset_id;
    RETURN msg;

END;
$$;


ALTER FUNCTION action.apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text) OWNER TO evergreen;

--
-- Name: FUNCTION apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text); Type: COMMENT; Schema: action; Owner: evergreen
--

COMMENT ON FUNCTION action.apply_fieldset(fieldset_id integer, table_name text, pkey_name text, query text) IS '
/**
 * Applies a specified fieldset, using a supplied table name and primary
 * key name.  The query parameter should be non-null only for
 * query-based fieldsets.
 *
 * Returns NULL if successful, or an error message if not.
 */
';


--
-- Name: archive_stat_cats(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.archive_stat_cats() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO action.archive_actor_stat_cat(xact, stat_cat, value)
        SELECT NEW.id, asceum.stat_cat, asceum.stat_cat_entry
        FROM actor.stat_cat_entry_usr_map asceum
             JOIN actor.stat_cat sc ON asceum.stat_cat = sc.id
        WHERE NEW.usr = asceum.target_usr AND sc.checkout_archive;
    INSERT INTO action.archive_asset_stat_cat(xact, stat_cat, value)
        SELECT NEW.id, ascecm.stat_cat, asce.value
        FROM asset.stat_cat_entry_copy_map ascecm
             JOIN asset.stat_cat sc ON ascecm.stat_cat = sc.id
             JOIN asset.stat_cat_entry asce ON ascecm.stat_cat_entry = asce.id
        WHERE NEW.target_copy = ascecm.owning_copy AND sc.checkout_archive;
    RETURN NULL;
END;
$$;


ALTER FUNCTION action.archive_stat_cats() OWNER TO evergreen;

--
-- Name: archived_hold_request_insert_trigger(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.archived_hold_request_insert_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF ( NEW.request_time >= '2013-01-01' AND NEW.request_time < '2014-01-01' )
    THEN INSERT INTO action.archived_hold_request_2013 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2012-01-01' AND NEW.request_time < '2013-01-01' )
    THEN INSERT INTO action.archived_hold_request_2012 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2011-01-01' AND NEW.request_time < '2012-01-01' )
    THEN INSERT INTO action.archived_hold_request_2011 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2010-01-01' AND NEW.request_time < '2011-01-01' )
    THEN INSERT INTO action.archived_hold_request_2010 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2009-01-01' AND NEW.request_time < '2010-01-01' )
    THEN INSERT INTO action.archived_hold_request_2009 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2008-01-01' AND NEW.request_time < '2009-01-01' )
    THEN INSERT INTO action.archived_hold_request_2008 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2007-01-01' AND NEW.request_time < '2008-01-01' )
    THEN INSERT INTO action.archived_hold_request_2007 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2006-01-01' AND NEW.request_time < '2007-01-01' )
    THEN INSERT INTO action.archived_hold_request_2006 VALUES (NEW.*);
ELSEIF ( NEW.request_time >= '2005-01-01' AND NEW.request_time < '2006-01-01' )
    THEN INSERT INTO action.archived_hold_request_2005 VALUES (NEW.*);
ELSE
    RAISE EXCEPTION 'request_time out of range for insert into archived_hold_request_* child tables.';
END IF;
RETURN NULL;
END;
$$;


ALTER FUNCTION action.archived_hold_request_insert_trigger() OWNER TO evergreen;

--
-- Name: circ_chain(bigint); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.circ_chain(ctx_circ_id bigint) RETURNS SETOF action.circulation
    LANGUAGE plpgsql
    AS $$
DECLARE
    tmp_circ action.circulation%ROWTYPE;
    circ_0 action.circulation%ROWTYPE;
BEGIN

    SELECT INTO tmp_circ * FROM action.circulation WHERE id = ctx_circ_id;

    IF tmp_circ IS NULL THEN
        RETURN NEXT tmp_circ;
    END IF;
    circ_0 := tmp_circ;

    -- find the front of the chain
    WHILE TRUE LOOP
        SELECT INTO tmp_circ * FROM action.circulation WHERE id = tmp_circ.parent_circ;
        IF tmp_circ IS NULL THEN
            EXIT;
        END IF;
        circ_0 := tmp_circ;
    END LOOP;

    -- now send the circs to the caller, oldest to newest
    tmp_circ := circ_0;
    WHILE TRUE LOOP
        IF tmp_circ IS NULL THEN
            EXIT;
        END IF;
        RETURN NEXT tmp_circ;
        SELECT INTO tmp_circ * FROM action.circulation WHERE parent_circ = tmp_circ.id;
    END LOOP;

END;
$$;


ALTER FUNCTION action.circ_chain(ctx_circ_id bigint) OWNER TO evergreen;

--
-- Name: circulation_claims_returned(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.circulation_claims_returned() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF OLD.stop_fines IS NULL OR OLD.stop_fines <> NEW.stop_fines THEN
		IF NEW.stop_fines = 'CLAIMSRETURNED' THEN
			UPDATE actor.usr SET claims_returned_count = claims_returned_count + 1 WHERE id = NEW.usr;
		END IF;
		IF NEW.stop_fines = 'CLAIMSNEVERCHECKEDOUT' THEN
			UPDATE actor.usr SET claims_never_checked_out_count = claims_never_checked_out_count + 1 WHERE id = NEW.usr;
		END IF;
		IF NEW.stop_fines = 'LOST' THEN
			UPDATE asset.copy SET status = 3 WHERE id = NEW.target_copy;
		END IF;
	END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION action.circulation_claims_returned() OWNER TO evergreen;

--
-- Name: copy_calculated_proximity(integer, integer, integer, text, integer, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.copy_calculated_proximity(pickup integer, request integer, vacp_cl integer, vacp_cm text, vacn_ol integer, vacl_ol integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    baseline_prox   NUMERIC;
    aoupa           actor.org_unit_proximity_adjustment%ROWTYPE;
BEGIN

    -- First, gather the baseline proximity of "here" to pickup lib
    SELECT prox INTO baseline_prox FROM actor.org_unit_proximity WHERE from_org = vacp_cl AND to_org = pickup;

    -- Find any absolute adjustments, and set the baseline prox to that
    SELECT  adj.* INTO aoupa
      FROM  actor.org_unit_proximity_adjustment adj
            LEFT JOIN actor.org_unit_ancestors_distance(vacp_cl) acp_cl ON (acp_cl.id = adj.item_circ_lib)
            LEFT JOIN actor.org_unit_ancestors_distance(vacn_ol) acn_ol ON (acn_ol.id = adj.item_owning_lib)
            LEFT JOIN actor.org_unit_ancestors_distance(vacl_ol) acl_ol ON (acl_ol.id = adj.copy_location)
            LEFT JOIN actor.org_unit_ancestors_distance(pickup) ahr_pl ON (ahr_pl.id = adj.hold_pickup_lib)
            LEFT JOIN actor.org_unit_ancestors_distance(request) ahr_rl ON (ahr_rl.id = adj.hold_request_lib)
      WHERE (adj.circ_mod IS NULL OR adj.circ_mod = vacp_cm) AND
            (adj.item_circ_lib IS NULL OR adj.item_circ_lib = acp_cl.id) AND
            (adj.item_owning_lib IS NULL OR adj.item_owning_lib = acn_ol.id) AND
            (adj.copy_location IS NULL OR adj.copy_location = acl_ol.id) AND
            (adj.hold_pickup_lib IS NULL OR adj.hold_pickup_lib = ahr_pl.id) AND
            (adj.hold_request_lib IS NULL OR adj.hold_request_lib = ahr_rl.id) AND
            absolute_adjustment AND
            COALESCE(acp_cl.id, acn_ol.id, acl_ol.id, ahr_pl.id, ahr_rl.id) IS NOT NULL
      ORDER BY
            COALESCE(acp_cl.distance,999)
                + COALESCE(acn_ol.distance,999)
                + COALESCE(acl_ol.distance,999)
                + COALESCE(ahr_pl.distance,999)
                + COALESCE(ahr_rl.distance,999),
            adj.pos
      LIMIT 1;

    IF FOUND THEN
        baseline_prox := aoupa.prox_adjustment;
    END IF;

    -- Now find any relative adjustments, and change the baseline prox based on them
    FOR aoupa IN
        SELECT  adj.*
          FROM  actor.org_unit_proximity_adjustment adj
                LEFT JOIN actor.org_unit_ancestors_distance(vacp_cl) acp_cl ON (acp_cl.id = adj.item_circ_lib)
                LEFT JOIN actor.org_unit_ancestors_distance(vacn_ol) acn_ol ON (acn_ol.id = adj.item_owning_lib)
                LEFT JOIN actor.org_unit_ancestors_distance(vacl_ol) acl_ol ON (acn_ol.id = adj.copy_location)
                LEFT JOIN actor.org_unit_ancestors_distance(pickup) ahr_pl ON (ahr_pl.id = adj.hold_pickup_lib)
                LEFT JOIN actor.org_unit_ancestors_distance(request) ahr_rl ON (ahr_rl.id = adj.hold_request_lib)
          WHERE (adj.circ_mod IS NULL OR adj.circ_mod = vacp_cm) AND
                (adj.item_circ_lib IS NULL OR adj.item_circ_lib = acp_cl.id) AND
                (adj.item_owning_lib IS NULL OR adj.item_owning_lib = acn_ol.id) AND
                (adj.copy_location IS NULL OR adj.copy_location = acl_ol.id) AND
                (adj.hold_pickup_lib IS NULL OR adj.hold_pickup_lib = ahr_pl.id) AND
                (adj.hold_request_lib IS NULL OR adj.hold_request_lib = ahr_rl.id) AND
                NOT absolute_adjustment AND
                COALESCE(acp_cl.id, acn_ol.id, acl_ol.id, ahr_pl.id, ahr_rl.id) IS NOT NULL
    LOOP
        baseline_prox := baseline_prox + aoupa.prox_adjustment;
    END LOOP;

    RETURN baseline_prox;
END;
$$;


ALTER FUNCTION action.copy_calculated_proximity(pickup integer, request integer, vacp_cl integer, vacp_cm text, vacn_ol integer, vacl_ol integer) OWNER TO evergreen;

--
-- Name: copy_related_hold_stats(bigint); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.copy_related_hold_stats(copy_id bigint) RETURNS action.hold_stats
    LANGUAGE plpgsql
    AS $$
DECLARE
    output          action.hold_stats%ROWTYPE;
    hold_count      INT := 0;
    copy_count      INT := 0;
    available_count INT := 0;
    hold_map_data   RECORD;
BEGIN

    output.hold_count := 0;
    output.copy_count := 0;
    output.available_count := 0;

    SELECT  COUNT( DISTINCT m.hold ) INTO hold_count
      FROM  action.hold_copy_map m
            JOIN action.hold_request h ON (m.hold = h.id)
      WHERE m.target_copy = copy_id
            AND NOT h.frozen
            -- KCLS: on-shelf holds do not impact hold/copy ratio
            AND h.shelf_time IS NULL; 

    output.hold_count := hold_count;

    IF output.hold_count > 0 THEN
        FOR hold_map_data IN
            SELECT  DISTINCT m.target_copy,
                    acp.status
              FROM  action.hold_copy_map m
                    JOIN asset.copy acp ON (m.target_copy = acp.id)
                    JOIN action.hold_request h ON (m.hold = h.id)
              WHERE m.hold IN ( 
                SELECT DISTINCT hold FROM action.hold_copy_map WHERE target_copy = copy_id ) 
                AND NOT h.frozen AND h.shelf_time IS NULL
        LOOP
            output.copy_count := output.copy_count + 1;
            IF hold_map_data.status IN ( -- KCLS custom copy status flag
                SELECT id FROM config.copy_status WHERE hold_ratio_avail) THEN
                output.available_count := output.available_count + 1;
            END IF;
        END LOOP;
        output.total_copy_ratio = output.copy_count::FLOAT / output.hold_count::FLOAT;
        output.available_copy_ratio = output.available_count::FLOAT / output.hold_count::FLOAT;

    END IF;

    RETURN output;

END;
$$;


ALTER FUNCTION action.copy_related_hold_stats(copy_id bigint) OWNER TO evergreen;

--
-- Name: copy_transit_is_unique(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.copy_transit_is_unique() RETURNS trigger
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    PERFORM * FROM action.transit_copy 
        WHERE target_copy = NEW.target_copy 
              AND dest_recv_time IS NULL 
              AND cancel_time IS NULL;
    IF FOUND THEN
        RAISE EXCEPTION 'Copy id=% is already in transit', NEW.target_copy;
    END IF;
    RETURN NULL;
END;
$$;


ALTER FUNCTION action.copy_transit_is_unique() OWNER TO evergreen;

--
-- Name: emergency_closing_stage_1(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.emergency_closing_stage_1(e_closing integer) RETURNS SETOF action.emergency_closing_stage_1_count
    LANGUAGE plpgsql
    AS $$
DECLARE
    tmp     INT;
    touched action.emergency_closing_stage_1_count%ROWTYPE;
BEGIN
    -- First, gather circs
    INSERT INTO action.emergency_closing_circulation (emergency_closing, circulation)
        SELECT  e_closing,
                circ.id
          FROM  actor.org_unit_closed closing
                JOIN action.emergency_closing ec ON (closing.emergency_closing = ec.id AND ec.id = e_closing)
                JOIN action.circulation circ ON (
                    circ.circ_lib = closing.org_unit
                    AND circ.due_date BETWEEN closing.close_start AND (closing.close_end + '1s'::INTERVAL)
                    AND circ.xact_finish IS NULL
                )
          WHERE NOT EXISTS (SELECT 1 FROM action.emergency_closing_circulation t WHERE t.emergency_closing = e_closing AND t.circulation = circ.id);

    GET DIAGNOSTICS tmp = ROW_COUNT;
    touched.circulations := tmp;

    INSERT INTO action.emergency_closing_reservation (emergency_closing, reservation)
        SELECT  e_closing,
                res.id
          FROM  actor.org_unit_closed closing
                JOIN action.emergency_closing ec ON (closing.emergency_closing = ec.id AND ec.id = e_closing)
                JOIN booking.reservation res ON (
                    res.pickup_lib = closing.org_unit
                    AND res.end_time BETWEEN closing.close_start AND (closing.close_end + '1s'::INTERVAL)
                )
          WHERE NOT EXISTS (SELECT 1 FROM action.emergency_closing_reservation t WHERE t.emergency_closing = e_closing AND t.reservation = res.id);

    GET DIAGNOSTICS tmp = ROW_COUNT;
    touched.reservations := tmp;

    INSERT INTO action.emergency_closing_hold (emergency_closing, hold)
        SELECT  e_closing,
                hold.id
          FROM  actor.org_unit_closed closing
                JOIN action.emergency_closing ec ON (closing.emergency_closing = ec.id AND ec.id = e_closing)
                JOIN action.hold_request hold ON (
                    pickup_lib = closing.org_unit
                    AND hold.shelf_expire_time BETWEEN closing.close_start AND (closing.close_end + '1s'::INTERVAL)
                    AND hold.fulfillment_time IS NULL
                    AND hold.cancel_time IS NULL
                )
          WHERE NOT EXISTS (SELECT 1 FROM action.emergency_closing_hold t WHERE t.emergency_closing = e_closing AND t.hold = hold.id);

    GET DIAGNOSTICS tmp = ROW_COUNT;
    touched.holds := tmp;

    UPDATE  action.emergency_closing
      SET   process_start_time = NOW(),
            last_update_time = NOW()
      WHERE id = e_closing;

    RETURN NEXT touched;
END;
$$;


ALTER FUNCTION action.emergency_closing_stage_1(e_closing integer) OWNER TO evergreen;

--
-- Name: emergency_closing_stage_2_circ(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.emergency_closing_stage_2_circ(circ_closing_entry integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    circ            action.circulation%ROWTYPE;
    e_closing       action.emergency_closing%ROWTYPE;
    e_c_circ        action.emergency_closing_circulation%ROWTYPE;
    closing         actor.org_unit_closed%ROWTYPE;
    adjacent        actor.org_unit_closed%ROWTYPE;
    bill            money.billing%ROWTYPE;
    last_bill       money.billing%ROWTYPE;
    day_number      INT;
    hoo_close       TIME WITHOUT TIME ZONE;
    plus_days       INT;
    avoid_negative  BOOL;
    extend_grace    BOOL;
    new_due_date    TEXT;
BEGIN
    -- Gather objects involved
    SELECT  * INTO e_c_circ
      FROM  action.emergency_closing_circulation
      WHERE id = circ_closing_entry;

    IF e_c_circ.process_time IS NOT NULL THEN
        -- Already processed ... moving on
        RETURN FALSE;
    END IF;

    SELECT  * INTO e_closing
      FROM  action.emergency_closing
      WHERE id = e_c_circ.emergency_closing;

    IF e_closing.process_start_time IS NULL THEN
        -- Huh... that's odd. And wrong.
        RETURN FALSE;
    END IF;

    SELECT  * INTO closing
      FROM  actor.org_unit_closed
      WHERE emergency_closing = e_closing.id;

    SELECT  * INTO circ
      FROM  action.circulation
      WHERE id = e_c_circ.circulation;

    -- Record the processing
    UPDATE  action.emergency_closing_circulation
      SET   original_due_date = circ.due_date,
            process_time = NOW()
      WHERE id = circ_closing_entry;

    UPDATE  action.emergency_closing
      SET   last_update_time = NOW()
      WHERE id = e_closing.id;

    SELECT value::BOOL INTO avoid_negative FROM actor.org_unit_ancestor_setting('bill.prohibit_negative_balance_on_overdues', circ.circ_lib);
    SELECT value::BOOL INTO extend_grace FROM actor.org_unit_ancestor_setting('circ.grace.extend', circ.circ_lib);

    new_due_date := evergreen.find_next_open_time( closing.org_unit, circ.due_date, EXTRACT(EPOCH FROM circ.duration)::INT % 86400 > 0 )::TEXT;
    UPDATE action.circulation SET due_date = new_due_date::TIMESTAMPTZ WHERE id = circ.id;

    -- Now, see if we need to get rid of some fines
    SELECT  * INTO last_bill
      FROM  money.billing b
      WHERE b.xact = circ.id
            AND NOT b.voided
            AND b.btype = 1
      ORDER BY billing_ts DESC
      LIMIT 1;

    FOR bill IN
        SELECT  *
          FROM  money.billing b
          WHERE b.xact = circ.id
                AND b.btype = 1
                AND NOT b.voided
                AND (
                    b.billing_ts BETWEEN closing.close_start AND new_due_date::TIMESTAMPTZ
                    OR (extend_grace AND last_bill.billing_ts <= new_due_date::TIMESTAMPTZ + circ.grace_period)
                )
                AND NOT EXISTS (SELECT 1 FROM money.account_adjustment a WHERE a.billing = b.id)
          ORDER BY billing_ts
    LOOP
        IF avoid_negative THEN
            PERFORM FROM money.materialized_billable_xact_summary WHERE id = circ.id AND balance_owed < bill.amount;
            EXIT WHEN FOUND; -- We can't go negative, and voiding this bill would do that...
        END IF;

        UPDATE  money.billing
          SET   voided = TRUE,
                void_time = NOW(),
                note = COALESCE(note,'') || ' :: Voided by emergency closing handler'
          WHERE id = bill.id;
    END LOOP;
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION action.emergency_closing_stage_2_circ(circ_closing_entry integer) OWNER TO evergreen;

--
-- Name: emergency_closing_stage_2_hold(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.emergency_closing_stage_2_hold(hold_closing_entry integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    hold        action.hold_request%ROWTYPE;
    e_closing   action.emergency_closing%ROWTYPE;
    e_c_hold    action.emergency_closing_hold%ROWTYPE;
    closing     actor.org_unit_closed%ROWTYPE;
    day_number  INT;
    hoo_close   TIME WITHOUT TIME ZONE;
    plus_days   INT;
BEGIN
    -- Gather objects involved
    SELECT  * INTO e_c_hold
      FROM  action.emergency_closing_hold
      WHERE id = hold_closing_entry;

    IF e_c_hold.process_time IS NOT NULL THEN
        -- Already processed ... moving on
        RETURN FALSE;
    END IF;

    SELECT  * INTO e_closing
      FROM  action.emergency_closing
      WHERE id = e_c_hold.emergency_closing;

    IF e_closing.process_start_time IS NULL THEN
        -- Huh... that's odd. And wrong.
        RETURN FALSE;
    END IF;

    SELECT  * INTO closing
      FROM  actor.org_unit_closed
      WHERE emergency_closing = e_closing.id;

    SELECT  * INTO hold
      FROM  action.hold_request h
      WHERE id = e_c_hold.hold;

    -- Record the processing
    UPDATE  action.emergency_closing_hold
      SET   original_shelf_expire_time = hold.shelf_expire_time,
            process_time = NOW()
      WHERE id = hold_closing_entry;

    UPDATE  action.emergency_closing
      SET   last_update_time = NOW()
      WHERE id = e_closing.id;

    UPDATE  action.hold_request
      SET   shelf_expire_time = evergreen.find_next_open_time(closing.org_unit, hold.shelf_expire_time, TRUE)
      WHERE id = hold.id;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION action.emergency_closing_stage_2_hold(hold_closing_entry integer) OWNER TO evergreen;

--
-- Name: emergency_closing_stage_2_reservation(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.emergency_closing_stage_2_reservation(res_closing_entry integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    res             booking.reservation%ROWTYPE;
    e_closing       action.emergency_closing%ROWTYPE;
    e_c_res         action.emergency_closing_reservation%ROWTYPE;
    closing         actor.org_unit_closed%ROWTYPE;
    adjacent        actor.org_unit_closed%ROWTYPE;
    bill            money.billing%ROWTYPE;
    day_number      INT;
    hoo_close       TIME WITHOUT TIME ZONE;
    plus_days       INT;
    avoid_negative  BOOL;
    new_due_date    TEXT;
BEGIN
    -- Gather objects involved
    SELECT  * INTO e_c_res
      FROM  action.emergency_closing_reservation
      WHERE id = res_closing_entry;

    IF e_c_res.process_time IS NOT NULL THEN
        -- Already processed ... moving on
        RETURN FALSE;
    END IF;

    SELECT  * INTO e_closing
      FROM  action.emergency_closing
      WHERE id = e_c_res.emergency_closing;

    IF e_closing.process_start_time IS NULL THEN
        -- Huh... that's odd. And wrong.
        RETURN FALSE;
    END IF;

    SELECT  * INTO closing
      FROM  actor.org_unit_closed
      WHERE emergency_closing = e_closing.id;

    SELECT  * INTO res
      FROM  booking.reservation
      WHERE id = e_c_res.reservation;

    IF res.pickup_lib IS NULL THEN -- Need to be far enough along to have a pickup lib
        RETURN FALSE;
    END IF;

    -- Record the processing
    UPDATE  action.emergency_closing_reservation
      SET   original_end_time = res.end_time,
            process_time = NOW()
      WHERE id = res_closing_entry;

    UPDATE  action.emergency_closing
      SET   last_update_time = NOW()
      WHERE id = e_closing.id;

    SELECT value::BOOL INTO avoid_negative FROM actor.org_unit_ancestor_setting('bill.prohibit_negative_balance_on_overdues', res.pickup_lib);

    new_due_date := evergreen.find_next_open_time( closing.org_unit, res.end_time, EXTRACT(EPOCH FROM res.booking_interval)::INT % 86400 > 0 )::TEXT;
    UPDATE booking.reservation SET end_time = new_due_date::TIMESTAMPTZ WHERE id = res.id;

    -- Now, see if we need to get rid of some fines
    FOR bill IN
        SELECT  *
          FROM  money.billing b
          WHERE b.xact = res.id
                AND b.btype = 1
                AND NOT b.voided
                AND b.billing_ts BETWEEN closing.close_start AND new_due_date::TIMESTAMPTZ
                AND NOT EXISTS (SELECT 1 FROM money.account_adjustment a WHERE a.billing = b.id)
    LOOP
        IF avoid_negative THEN
            PERFORM FROM money.materialized_billable_xact_summary WHERE id = res.id AND balance_owed < bill.amount;
            EXIT WHEN FOUND; -- We can't go negative, and voiding this bill would do that...
        END IF;

        UPDATE  money.billing
          SET   voided = TRUE,
                void_time = NOW(),
                note = COALESCE(note,'') || ' :: Voided by emergency closing handler'
          WHERE id = bill.id;
    END LOOP;
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION action.emergency_closing_stage_2_reservation(res_closing_entry integer) OWNER TO evergreen;

--
-- Name: fill_circ_copy_location(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.fill_circ_copy_location() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    SELECT INTO NEW.copy_location location FROM asset.copy WHERE id = NEW.target_copy;
    RETURN NEW;
END;
$$;


ALTER FUNCTION action.fill_circ_copy_location() OWNER TO evergreen;

--
-- Name: usr; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.usr (
    id integer NOT NULL,
    card integer,
    profile integer NOT NULL,
    usrname text NOT NULL,
    email text,
    passwd text NOT NULL,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer NOT NULL,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text NOT NULL,
    second_given_name text,
    family_name text NOT NULL,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer NOT NULL,
    dob date,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL,
    last_update_time timestamp with time zone,
    pref_prefix text,
    pref_first_given_name text,
    pref_second_given_name text,
    pref_family_name text,
    pref_suffix text,
    name_keywords text,
    name_kw_tsvector tsvector,
    guardian text,
    locale text
);


ALTER TABLE actor.usr OWNER TO evergreen;

--
-- Name: TABLE usr; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.usr IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * User objects
 *
 * This table contains the core User objects that describe both
 * staff members and patrons.  The difference between the two
 * types of users is based on the user''s permissions.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: copy; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy (
    id bigint NOT NULL,
    circ_lib integer NOT NULL,
    creator bigint NOT NULL,
    call_number bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer NOT NULL,
    fine_level integer NOT NULL,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text NOT NULL,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating integer,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2),
    active_date timestamp with time zone,
    CONSTRAINT copy_fine_level_check CHECK ((fine_level = ANY (ARRAY[1, 2, 3]))),
    CONSTRAINT copy_loan_duration_check CHECK ((loan_duration = ANY (ARRAY[1, 2, 3])))
);


ALTER TABLE asset.copy OWNER TO evergreen;

--
-- Name: find_circ_matrix_matchpoint(integer, asset.copy, actor.usr, boolean); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.find_circ_matrix_matchpoint(context_ou integer, item_object asset.copy, user_object actor.usr, renewal boolean) RETURNS action.found_circ_matrix_matchpoint
    LANGUAGE plpgsql
    AS $$
DECLARE
    cn_object       asset.call_number%ROWTYPE;
    rec_descriptor  metabib.rec_descriptor%ROWTYPE;
    cur_matchpoint  config.circ_matrix_matchpoint%ROWTYPE;
    matchpoint      config.circ_matrix_matchpoint%ROWTYPE;
    weights         config.circ_matrix_weights%ROWTYPE;
    user_age        INTERVAL;
    my_item_age     INTERVAL;
    denominator     NUMERIC(6,2);
    row_list        INT[];
    result          action.found_circ_matrix_matchpoint;
BEGIN
    -- Assume failure
    result.success = false;

    -- Fetch useful data
    SELECT INTO cn_object       * FROM asset.call_number        WHERE id = item_object.call_number;
    SELECT INTO rec_descriptor  * FROM metabib.rec_descriptor   WHERE record = cn_object.record;

    -- Pre-generate this so we only calc it once
    IF user_object.dob IS NOT NULL THEN
        SELECT INTO user_age age(user_object.dob);
    END IF;

    -- Ditto
    SELECT INTO my_item_age age(coalesce(item_object.active_date, now()));

    -- Grab the closest set circ weight setting.
    SELECT INTO weights cw.*
      FROM config.weight_assoc wa
           JOIN config.circ_matrix_weights cw ON (cw.id = wa.circ_weights)
           JOIN actor.org_unit_ancestors_distance( context_ou ) d ON (wa.org_unit = d.id)
      WHERE active
      ORDER BY d.distance
      LIMIT 1;

    -- No weights? Bad admin! Defaults to handle that anyway.
    IF weights.id IS NULL THEN
        weights.grp                 := 11.0;
        weights.org_unit            := 10.0;
        weights.circ_modifier       := 5.0;
        weights.copy_location       := 5.0;
        weights.marc_type           := 4.0;
        weights.marc_form           := 3.0;
        weights.marc_bib_level      := 2.0;
        weights.marc_vr_format      := 2.0;
        weights.copy_circ_lib       := 8.0;
        weights.copy_owning_lib     := 8.0;
        weights.user_home_ou        := 8.0;
        weights.ref_flag            := 1.0;
        weights.juvenile_flag       := 6.0;
        weights.is_renewal          := 7.0;
        weights.usr_age_lower_bound := 0.0;
        weights.usr_age_upper_bound := 0.0;
        weights.item_age            := 0.0;
    END IF;

    -- Determine the max (expected) depth (+1) of the org tree and max depth of the permisson tree
    -- If you break your org tree with funky parenting this may be wrong
    -- Note: This CTE is duplicated in the find_hold_matrix_matchpoint function, and it may be a good idea to split it off to a function
    -- We use one denominator for all tree-based checks for when permission groups and org units have the same weighting
    WITH all_distance(distance) AS (
            SELECT depth AS distance FROM actor.org_unit_type
        UNION
            SELECT distance AS distance FROM permission.grp_ancestors_distance((SELECT id FROM permission.grp_tree WHERE parent IS NULL))
    )
    SELECT INTO denominator MAX(distance) + 1 FROM all_distance;

    -- Loop over all the potential matchpoints
    FOR cur_matchpoint IN
        SELECT m.*
          FROM  config.circ_matrix_matchpoint m
                /*LEFT*/ JOIN permission.grp_ancestors_distance( user_object.profile ) upgad ON m.grp = upgad.id
                /*LEFT*/ JOIN actor.org_unit_ancestors_distance( context_ou ) ctoua ON m.org_unit = ctoua.id
                LEFT JOIN actor.org_unit_ancestors_distance( cn_object.owning_lib ) cnoua ON m.copy_owning_lib = cnoua.id
                LEFT JOIN actor.org_unit_ancestors_distance( item_object.circ_lib ) iooua ON m.copy_circ_lib = iooua.id
                LEFT JOIN actor.org_unit_ancestors_distance( user_object.home_ou  ) uhoua ON m.user_home_ou = uhoua.id
          WHERE m.active
                -- Permission Groups
             -- AND (m.grp                      IS NULL OR upgad.id IS NOT NULL) -- Optional Permission Group?
                -- Org Units
             -- AND (m.org_unit                 IS NULL OR ctoua.id IS NOT NULL) -- Optional Org Unit?
                AND (m.copy_owning_lib          IS NULL OR cnoua.id IS NOT NULL)
                AND (m.copy_circ_lib            IS NULL OR iooua.id IS NOT NULL)
                AND (m.user_home_ou             IS NULL OR uhoua.id IS NOT NULL)
                -- Circ Type
                AND (m.is_renewal               IS NULL OR m.is_renewal = renewal)
                -- Static User Checks
                AND (m.juvenile_flag            IS NULL OR m.juvenile_flag = user_object.juvenile)
                AND (m.usr_age_lower_bound      IS NULL OR (user_age IS NOT NULL AND m.usr_age_lower_bound < user_age))
                AND (m.usr_age_upper_bound      IS NULL OR (user_age IS NOT NULL AND m.usr_age_upper_bound > user_age))
                -- Static Item Checks
                AND (m.circ_modifier            IS NULL OR m.circ_modifier = item_object.circ_modifier)
                AND (m.copy_location            IS NULL OR m.copy_location = item_object.location)
                AND (m.marc_type                IS NULL OR m.marc_type = COALESCE(item_object.circ_as_type, rec_descriptor.item_type))
                AND (m.marc_form                IS NULL OR m.marc_form = rec_descriptor.item_form)
                AND (m.marc_bib_level           IS NULL OR m.marc_bib_level = rec_descriptor.bib_level)
                AND (m.marc_vr_format           IS NULL OR m.marc_vr_format = rec_descriptor.vr_format)
                AND (m.ref_flag                 IS NULL OR m.ref_flag = item_object.ref)
                AND (m.item_age                 IS NULL OR (my_item_age IS NOT NULL AND m.item_age > my_item_age))
          ORDER BY
                -- Permission Groups
                CASE WHEN upgad.distance        IS NOT NULL THEN 2^(2*weights.grp - (upgad.distance/denominator)) ELSE 0.0 END +
                -- Org Units
                CASE WHEN ctoua.distance        IS NOT NULL THEN 2^(2*weights.org_unit - (ctoua.distance/denominator)) ELSE 0.0 END +
                CASE WHEN cnoua.distance        IS NOT NULL THEN 2^(2*weights.copy_owning_lib - (cnoua.distance/denominator)) ELSE 0.0 END +
                CASE WHEN iooua.distance        IS NOT NULL THEN 2^(2*weights.copy_circ_lib - (iooua.distance/denominator)) ELSE 0.0 END +
                CASE WHEN uhoua.distance        IS NOT NULL THEN 2^(2*weights.user_home_ou - (uhoua.distance/denominator)) ELSE 0.0 END +
                -- Circ Type                    -- Note: 4^x is equiv to 2^(2*x)
                CASE WHEN m.is_renewal          IS NOT NULL THEN 4^weights.is_renewal ELSE 0.0 END +
                -- Static User Checks
                CASE WHEN m.juvenile_flag       IS NOT NULL THEN 4^weights.juvenile_flag ELSE 0.0 END +
                CASE WHEN m.usr_age_lower_bound IS NOT NULL THEN 4^weights.usr_age_lower_bound ELSE 0.0 END +
                CASE WHEN m.usr_age_upper_bound IS NOT NULL THEN 4^weights.usr_age_upper_bound ELSE 0.0 END +
                -- Static Item Checks
                CASE WHEN m.circ_modifier       IS NOT NULL THEN 4^weights.circ_modifier ELSE 0.0 END +
                CASE WHEN m.copy_location       IS NOT NULL THEN 4^weights.copy_location ELSE 0.0 END +
                CASE WHEN m.marc_type           IS NOT NULL THEN 4^weights.marc_type ELSE 0.0 END +
                CASE WHEN m.marc_form           IS NOT NULL THEN 4^weights.marc_form ELSE 0.0 END +
                CASE WHEN m.marc_vr_format      IS NOT NULL THEN 4^weights.marc_vr_format ELSE 0.0 END +
                CASE WHEN m.ref_flag            IS NOT NULL THEN 4^weights.ref_flag ELSE 0.0 END +
                -- Item age has a slight adjustment to weight based on value.
                -- This should ensure that a shorter age limit comes first when all else is equal.
                -- NOTE: This assumes that intervals will normally be in days.
                CASE WHEN m.item_age            IS NOT NULL THEN 4^weights.item_age - 1 + 86400/EXTRACT(EPOCH FROM m.item_age) ELSE 0.0 END DESC,
                -- Final sort on id, so that if two rules have the same sorting in the previous sort they have a defined order
                -- This prevents "we changed the table order by updating a rule, and we started getting different results"
                m.id LOOP

        -- Record the full matching row list
        row_list := row_list || cur_matchpoint.id;

        -- No matchpoint yet?
        IF matchpoint.id IS NULL THEN
            -- Take the entire matchpoint as a starting point
            matchpoint := cur_matchpoint;
            CONTINUE; -- No need to look at this row any more.
        END IF;

        -- Incomplete matchpoint?
        IF matchpoint.circulate IS NULL THEN
            matchpoint.circulate := cur_matchpoint.circulate;
        END IF;
        IF matchpoint.duration_rule IS NULL THEN
            matchpoint.duration_rule := cur_matchpoint.duration_rule;
        END IF;
        IF matchpoint.recurring_fine_rule IS NULL THEN
            matchpoint.recurring_fine_rule := cur_matchpoint.recurring_fine_rule;
        END IF;
        IF matchpoint.max_fine_rule IS NULL THEN
            matchpoint.max_fine_rule := cur_matchpoint.max_fine_rule;
        END IF;
        IF matchpoint.hard_due_date IS NULL THEN
            matchpoint.hard_due_date := cur_matchpoint.hard_due_date;
        END IF;
        IF matchpoint.total_copy_hold_ratio IS NULL THEN
            matchpoint.total_copy_hold_ratio := cur_matchpoint.total_copy_hold_ratio;
        END IF;
        IF matchpoint.available_copy_hold_ratio IS NULL THEN
            matchpoint.available_copy_hold_ratio := cur_matchpoint.available_copy_hold_ratio;
        END IF;
        IF matchpoint.renewals IS NULL THEN
            matchpoint.renewals := cur_matchpoint.renewals;
        END IF;
        IF matchpoint.grace_period IS NULL THEN
            matchpoint.grace_period := cur_matchpoint.grace_period;
        END IF;
    END LOOP;

    -- Check required fields
    IF matchpoint.circulate             IS NOT NULL AND
       matchpoint.duration_rule         IS NOT NULL AND
       matchpoint.recurring_fine_rule   IS NOT NULL AND
       matchpoint.max_fine_rule         IS NOT NULL THEN
        -- All there? We have a completed match.
        result.success := true;
    END IF;

    -- Include the assembled matchpoint, even if it isn't complete
    result.matchpoint := matchpoint;

    -- Include (for debugging) the full list of matching rows
    result.buildrows := row_list;

    -- Hand the result back to caller
    RETURN result;
END;
$$;


ALTER FUNCTION action.find_circ_matrix_matchpoint(context_ou integer, item_object asset.copy, user_object actor.usr, renewal boolean) OWNER TO evergreen;

--
-- Name: find_circ_matrix_matchpoint(integer, bigint, integer, boolean); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.find_circ_matrix_matchpoint(context_ou integer, match_item bigint, match_user integer, renewal boolean) RETURNS SETOF action.found_circ_matrix_matchpoint
    LANGUAGE plpgsql
    AS $$
DECLARE
    item_object asset.copy%ROWTYPE;
    user_object actor.usr%ROWTYPE;
BEGIN
    SELECT INTO item_object * FROM asset.copy 	WHERE id = match_item;
    SELECT INTO user_object * FROM actor.usr	WHERE id = match_user;

    RETURN QUERY SELECT * FROM action.find_circ_matrix_matchpoint( context_ou, item_object, user_object, renewal );
END;
$$;


ALTER FUNCTION action.find_circ_matrix_matchpoint(context_ou integer, match_item bigint, match_user integer, renewal boolean) OWNER TO evergreen;

--
-- Name: find_hold_matrix_matchpoint(integer, integer, bigint, integer, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.find_hold_matrix_matchpoint(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    requestor_object    actor.usr%ROWTYPE;
    user_object         actor.usr%ROWTYPE;
    item_object         asset.copy%ROWTYPE;
    item_cn_object      asset.call_number%ROWTYPE;
    my_item_age         INTERVAL;
    rec_descriptor      metabib.rec_descriptor%ROWTYPE;
    matchpoint          config.hold_matrix_matchpoint%ROWTYPE;
    weights             config.hold_matrix_weights%ROWTYPE;
    denominator         NUMERIC(6,2);
    v_pickup_ou         ALIAS FOR pickup_ou;
    v_request_ou         ALIAS FOR request_ou;
BEGIN
    SELECT INTO user_object         * FROM actor.usr                WHERE id = match_user;
    SELECT INTO requestor_object    * FROM actor.usr                WHERE id = match_requestor;
    SELECT INTO item_object         * FROM asset.copy               WHERE id = match_item;
    SELECT INTO item_cn_object      * FROM asset.call_number        WHERE id = item_object.call_number;
    SELECT INTO rec_descriptor      * FROM metabib.rec_descriptor   WHERE record = item_cn_object.record;

    SELECT INTO my_item_age age(coalesce(item_object.active_date, now()));

    -- The item's owner should probably be the one determining if the item is holdable
    -- How to decide that is debatable. Decided to default to the circ library (where the item lives)
    -- This flag will allow for setting it to the owning library (where the call number "lives")
    PERFORM * FROM config.internal_flag WHERE name = 'circ.holds.weight_owner_not_circ' AND enabled;

    -- Grab the closest set circ weight setting.
    IF NOT FOUND THEN
        -- Default to circ library
        SELECT INTO weights hw.*
          FROM config.weight_assoc wa
               JOIN config.hold_matrix_weights hw ON (hw.id = wa.hold_weights)
               JOIN actor.org_unit_ancestors_distance( item_object.circ_lib ) d ON (wa.org_unit = d.id)
          WHERE active
          ORDER BY d.distance
          LIMIT 1;
    ELSE
        -- Flag is set, use owning library
        SELECT INTO weights hw.*
          FROM config.weight_assoc wa
               JOIN config.hold_matrix_weights hw ON (hw.id = wa.hold_weights)
               JOIN actor.org_unit_ancestors_distance( item_cn_object.owning_lib ) d ON (wa.org_unit = d.id)
          WHERE active
          ORDER BY d.distance
          LIMIT 1;
    END IF;

    -- No weights? Bad admin! Defaults to handle that anyway.
    IF weights.id IS NULL THEN
        weights.user_home_ou    := 5.0;
        weights.request_ou      := 5.0;
        weights.pickup_ou       := 5.0;
        weights.item_owning_ou  := 5.0;
        weights.item_circ_ou    := 5.0;
        weights.usr_grp         := 7.0;
        weights.requestor_grp   := 8.0;
        weights.circ_modifier   := 4.0;
        weights.marc_type       := 3.0;
        weights.marc_form       := 2.0;
        weights.marc_bib_level  := 1.0;
        weights.marc_vr_format  := 1.0;
        weights.juvenile_flag   := 4.0;
        weights.ref_flag        := 0.0;
        weights.item_age        := 0.0;
    END IF;

    -- Determine the max (expected) depth (+1) of the org tree and max depth of the permisson tree
    -- If you break your org tree with funky parenting this may be wrong
    -- Note: This CTE is duplicated in the find_circ_matrix_matchpoint function, and it may be a good idea to split it off to a function
    -- We use one denominator for all tree-based checks for when permission groups and org units have the same weighting
    WITH all_distance(distance) AS (
            SELECT depth AS distance FROM actor.org_unit_type
        UNION
            SELECT distance AS distance FROM permission.grp_ancestors_distance((SELECT id FROM permission.grp_tree WHERE parent IS NULL))
	)
    SELECT INTO denominator MAX(distance) + 1 FROM all_distance;

    -- To ATTEMPT to make this work like it used to, make it reverse the user/requestor profile ids.
    -- This may be better implemented as part of the upgrade script?
    -- Set usr_grp = requestor_grp, requestor_grp = 1 or something when this flag is already set
    -- Then remove this flag, of course.
    PERFORM * FROM config.internal_flag WHERE name = 'circ.holds.usr_not_requestor' AND enabled;

    IF FOUND THEN
        -- Note: This, to me, is REALLY hacky. I put it in anyway.
        -- If you can't tell, this is a single call swap on two variables.
        SELECT INTO user_object.profile, requestor_object.profile
                    requestor_object.profile, user_object.profile;
    END IF;

    -- Select the winning matchpoint into the matchpoint variable for returning
    SELECT INTO matchpoint m.*
      FROM  config.hold_matrix_matchpoint m
            /*LEFT*/ JOIN permission.grp_ancestors_distance( requestor_object.profile ) rpgad ON m.requestor_grp = rpgad.id
            LEFT JOIN permission.grp_ancestors_distance( user_object.profile ) upgad ON m.usr_grp = upgad.id
            LEFT JOIN actor.org_unit_ancestors_distance( v_pickup_ou ) puoua ON m.pickup_ou = puoua.id
            LEFT JOIN actor.org_unit_ancestors_distance( v_request_ou ) rqoua ON m.request_ou = rqoua.id
            LEFT JOIN actor.org_unit_ancestors_distance( item_cn_object.owning_lib ) cnoua ON m.item_owning_ou = cnoua.id
            LEFT JOIN actor.org_unit_ancestors_distance( item_object.circ_lib ) iooua ON m.item_circ_ou = iooua.id
            LEFT JOIN actor.org_unit_ancestors_distance( user_object.home_ou  ) uhoua ON m.user_home_ou = uhoua.id
      WHERE m.active
            -- Permission Groups
         -- AND (m.requestor_grp        IS NULL OR upgad.id IS NOT NULL) -- Optional Requestor Group?
            AND (m.usr_grp              IS NULL OR upgad.id IS NOT NULL)
            -- Org Units
            AND (m.pickup_ou            IS NULL OR (puoua.id IS NOT NULL AND (puoua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.request_ou           IS NULL OR (rqoua.id IS NOT NULL AND (rqoua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.item_owning_ou       IS NULL OR (cnoua.id IS NOT NULL AND (cnoua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.item_circ_ou         IS NULL OR (iooua.id IS NOT NULL AND (iooua.distance = 0 OR NOT m.strict_ou_match)))
            AND (m.user_home_ou         IS NULL OR (uhoua.id IS NOT NULL AND (uhoua.distance = 0 OR NOT m.strict_ou_match)))
            -- Static User Checks
            AND (m.juvenile_flag        IS NULL OR m.juvenile_flag = user_object.juvenile)
            -- Static Item Checks
            AND (m.circ_modifier        IS NULL OR m.circ_modifier = item_object.circ_modifier)
            AND (m.marc_type            IS NULL OR m.marc_type = COALESCE(item_object.circ_as_type, rec_descriptor.item_type))
            AND (m.marc_form            IS NULL OR m.marc_form = rec_descriptor.item_form)
            AND (m.marc_bib_level       IS NULL OR m.marc_bib_level = rec_descriptor.bib_level)
            AND (m.marc_vr_format       IS NULL OR m.marc_vr_format = rec_descriptor.vr_format)
            AND (m.ref_flag             IS NULL OR m.ref_flag = item_object.ref)
            AND (m.item_age             IS NULL OR (my_item_age IS NOT NULL AND m.item_age > my_item_age))
      ORDER BY
            -- Permission Groups
            CASE WHEN rpgad.distance    IS NOT NULL THEN 2^(2*weights.requestor_grp - (rpgad.distance/denominator)) ELSE 0.0 END +
            CASE WHEN upgad.distance    IS NOT NULL THEN 2^(2*weights.usr_grp - (upgad.distance/denominator)) ELSE 0.0 END +
            -- Org Units
            CASE WHEN puoua.distance    IS NOT NULL THEN 2^(2*weights.pickup_ou - (puoua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN rqoua.distance    IS NOT NULL THEN 2^(2*weights.request_ou - (rqoua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN cnoua.distance    IS NOT NULL THEN 2^(2*weights.item_owning_ou - (cnoua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN iooua.distance    IS NOT NULL THEN 2^(2*weights.item_circ_ou - (iooua.distance/denominator)) ELSE 0.0 END +
            CASE WHEN uhoua.distance    IS NOT NULL THEN 2^(2*weights.user_home_ou - (uhoua.distance/denominator)) ELSE 0.0 END +
            -- Static User Checks       -- Note: 4^x is equiv to 2^(2*x)
            CASE WHEN m.juvenile_flag   IS NOT NULL THEN 4^weights.juvenile_flag ELSE 0.0 END +
            -- Static Item Checks
            CASE WHEN m.circ_modifier   IS NOT NULL THEN 4^weights.circ_modifier ELSE 0.0 END +
            CASE WHEN m.marc_type       IS NOT NULL THEN 4^weights.marc_type ELSE 0.0 END +
            CASE WHEN m.marc_form       IS NOT NULL THEN 4^weights.marc_form ELSE 0.0 END +
            CASE WHEN m.marc_vr_format  IS NOT NULL THEN 4^weights.marc_vr_format ELSE 0.0 END +
            CASE WHEN m.ref_flag        IS NOT NULL THEN 4^weights.ref_flag ELSE 0.0 END +
            -- Item age has a slight adjustment to weight based on value.
            -- This should ensure that a shorter age limit comes first when all else is equal.
            -- NOTE: This assumes that intervals will normally be in days.
            CASE WHEN m.item_age            IS NOT NULL THEN 4^weights.item_age - 86400/EXTRACT(EPOCH FROM m.item_age) ELSE 0.0 END DESC,
            -- Final sort on id, so that if two rules have the same sorting in the previous sort they have a defined order
            -- This prevents "we changed the table order by updating a rule, and we started getting different results"
            m.id;

    -- Return just the ID for now
    RETURN matchpoint.id;
END;
$$;


ALTER FUNCTION action.find_hold_matrix_matchpoint(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) OWNER TO evergreen;

--
-- Name: get_hold_queue_status(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.get_hold_queue_status(integer) RETURNS TABLE(id integer, cut_in_line boolean, request_time timestamp with time zone)
    LANGUAGE sql STABLE
    AS $_$
WITH holds(holdid) AS 
( SELECT acm.hold FROM action.hold_copy_map acm 
  JOIN action.hold_copy_map acm2 USING(target_copy) 
  WHERE acm2.hold=$1) 
  SELECT id, cut_in_line, request_time FROM action.hold_request 
  WHERE id IN (SELECT holdid FROM holds) 
  ORDER BY coalesce(cut_in_line, false ) DESC, request_time; 
$_$;


ALTER FUNCTION action.get_hold_queue_status(integer) OWNER TO evergreen;

--
-- Name: hold_copy_calculated_proximity(integer, bigint, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.hold_copy_calculated_proximity(ahr_id integer, acp_id bigint, copy_context_ou integer DEFAULT NULL::integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    ahr  action.hold_request%ROWTYPE;
    acp  asset.copy%ROWTYPE;
    acn  asset.call_number%ROWTYPE;
    acl  asset.copy_location%ROWTYPE;

    prox NUMERIC;
BEGIN

    SELECT * INTO ahr FROM action.hold_request WHERE id = ahr_id;
    SELECT * INTO acp FROM asset.copy WHERE id = acp_id;
    SELECT * INTO acn FROM asset.call_number WHERE id = acp.call_number;
    SELECT * INTO acl FROM asset.copy_location WHERE id = acp.location;

    IF copy_context_ou IS NULL THEN
        copy_context_ou := acp.circ_lib;
    END IF;

    SELECT action.copy_calculated_proximity(
        ahr.pickup_lib,
        ahr.request_lib,
        copy_context_ou,
        acp.circ_modifier,
        acn.owning_lib,
        acl.owning_lib
    ) INTO prox;

    RETURN prox;
END;
$$;


ALTER FUNCTION action.hold_copy_calculated_proximity(ahr_id integer, acp_id bigint, copy_context_ou integer) OWNER TO evergreen;

--
-- Name: hold_copy_calculated_proximity_update(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.hold_copy_calculated_proximity_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.proximity := action.hold_copy_calculated_proximity(NEW.hold,NEW.target_copy);
    RETURN NEW;
END;
$$;


ALTER FUNCTION action.hold_copy_calculated_proximity_update() OWNER TO evergreen;

--
-- Name: hold_request_clear_map(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.hold_request_clear_map() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  DELETE FROM action.hold_copy_map WHERE hold = NEW.id;
  RETURN NEW;
END;
$$;


ALTER FUNCTION action.hold_request_clear_map() OWNER TO evergreen;

--
-- Name: hold_request_permit_test(integer, integer, bigint, integer, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) RETURNS SETOF action.matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.hold_request_permit_test( $1, $2, $3, $4, $5, FALSE);
$_$;


ALTER FUNCTION action.hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) OWNER TO evergreen;

--
-- Name: hold_request_permit_test(integer, integer, bigint, integer, integer, boolean); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer, retargetting boolean) RETURNS SETOF action.matrix_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    matchpoint_id        INT;
    user_object        actor.usr%ROWTYPE;
    age_protect_object    config.rule_age_hold_protect%ROWTYPE;
    standing_penalty    config.standing_penalty%ROWTYPE;
    transit_range_ou_type    actor.org_unit_type%ROWTYPE;
    transit_source        actor.org_unit%ROWTYPE;
    item_object        asset.copy%ROWTYPE;
    item_cn_object     asset.call_number%ROWTYPE;
    item_status_object  config.copy_status%ROWTYPE;
    item_location_object    asset.copy_location%ROWTYPE;
    ou_skip              actor.org_unit_setting%ROWTYPE;
    calc_age_prox        actor.org_unit_setting%ROWTYPE;
    result            action.matrix_test_result;
    hold_test        config.hold_matrix_matchpoint%ROWTYPE;
    use_active_date   TEXT;
    prox_ou           INT;
    age_protect_date  TIMESTAMP WITH TIME ZONE;
    hold_count        INT;
    hold_transit_prox    NUMERIC;
    frozen_hold_count    INT;
    context_org_list    INT[];
    done            BOOL := FALSE;
    hold_penalty TEXT;
    v_pickup_ou ALIAS FOR pickup_ou;
    v_request_ou ALIAS FOR request_ou;
    item_prox INT;
    pickup_prox INT;
BEGIN
    SELECT INTO user_object * FROM actor.usr WHERE id = match_user;
    SELECT INTO context_org_list ARRAY_AGG(id) FROM actor.org_unit_full_path( v_pickup_ou );

    result.success := TRUE;

    -- The HOLD penalty block only applies to new holds.
    -- The CAPTURE penalty block applies to existing holds.
    hold_penalty := 'HOLD';
    IF retargetting THEN
        hold_penalty := 'CAPTURE';
    END IF;

    -- Fail if we couldn't find a user
    IF user_object.id IS NULL THEN
        result.fail_part := 'no_user';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO item_object * FROM asset.copy WHERE id = match_item;

    -- Fail if we couldn't find a copy
    IF item_object.id IS NULL THEN
        result.fail_part := 'no_item';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO matchpoint_id action.find_hold_matrix_matchpoint(v_pickup_ou, v_request_ou, match_item, match_user, match_requestor);
    result.matchpoint := matchpoint_id;

    SELECT INTO ou_skip * FROM actor.org_unit_setting WHERE name = 'circ.holds.target_skip_me' AND org_unit = item_object.circ_lib;

    -- Fail if the circ_lib for the item has circ.holds.target_skip_me set to true
    IF ou_skip.id IS NOT NULL AND ou_skip.value = 'true' THEN
        result.fail_part := 'circ.holds.target_skip_me';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    -- Fail if user is barred
    IF user_object.barred IS TRUE THEN
        result.fail_part := 'actor.usr.barred';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO item_cn_object * FROM asset.call_number WHERE id = item_object.call_number;
    SELECT INTO item_status_object * FROM config.copy_status WHERE id = item_object.status;
    SELECT INTO item_location_object * FROM asset.copy_location WHERE id = item_object.location;

    -- Fail if we couldn't find any matchpoint (requires a default)
    IF matchpoint_id IS NULL THEN
        result.fail_part := 'no_matchpoint';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO hold_test * FROM config.hold_matrix_matchpoint WHERE id = matchpoint_id;

    IF hold_test.holdable IS FALSE THEN
        result.fail_part := 'config.hold_matrix_test.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF item_object.holdable IS FALSE THEN
        result.fail_part := 'item.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF item_status_object.holdable IS FALSE THEN
        result.fail_part := 'status.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF item_location_object.holdable IS FALSE THEN
        result.fail_part := 'location.holdable';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    IF hold_test.transit_range IS NOT NULL THEN
        SELECT INTO transit_range_ou_type * FROM actor.org_unit_type WHERE id = hold_test.transit_range;
        IF hold_test.distance_is_from_owner THEN
            SELECT INTO transit_source ou.* FROM actor.org_unit ou JOIN asset.call_number cn ON (cn.owning_lib = ou.id) WHERE cn.id = item_object.call_number;
        ELSE
            SELECT INTO transit_source * FROM actor.org_unit WHERE id = item_object.circ_lib;
        END IF;

        PERFORM * FROM actor.org_unit_descendants( transit_source.id, transit_range_ou_type.depth ) WHERE id = v_pickup_ou;

        IF NOT FOUND THEN
            result.fail_part := 'transit_range';
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END IF;
    END IF;

    -- Proximity of user's home_ou to the pickup_lib to see if penalty should be ignored.
    SELECT INTO pickup_prox prox FROM actor.org_unit_proximity WHERE from_org = user_object.home_ou AND to_org = v_pickup_ou;
    -- Proximity of user's home_ou to the items' lib to see if penalty should be ignored.
    IF hold_test.distance_is_from_owner THEN
        SELECT INTO item_prox prox FROM actor.org_unit_proximity WHERE from_org = user_object.home_ou AND to_org = item_cn_object.owning_lib;
    ELSE
        SELECT INTO item_prox prox FROM actor.org_unit_proximity WHERE from_org = user_object.home_ou AND to_org = item_object.circ_lib;
    END IF;

    FOR standing_penalty IN
        SELECT  DISTINCT csp.*
          FROM  actor.usr_standing_penalty usp
                JOIN config.standing_penalty csp ON (csp.id = usp.standing_penalty)
          WHERE usr = match_user
                AND usp.org_unit IN ( SELECT * FROM unnest(context_org_list) )
                AND (usp.stop_date IS NULL or usp.stop_date > NOW())
                AND (csp.ignore_proximity IS NULL OR csp.ignore_proximity < item_prox
                     OR csp.ignore_proximity < pickup_prox)
                AND csp.block_list LIKE '%' || hold_penalty || '%' LOOP

        result.fail_part := standing_penalty.name;
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END LOOP;

    IF hold_test.stop_blocked_user IS TRUE THEN
        FOR standing_penalty IN
            SELECT  DISTINCT csp.*
              FROM  actor.usr_standing_penalty usp
                    JOIN config.standing_penalty csp ON (csp.id = usp.standing_penalty)
              WHERE usr = match_user
                    AND usp.org_unit IN ( SELECT * FROM unnest(context_org_list) )
                    AND (usp.stop_date IS NULL or usp.stop_date > NOW())
                    AND csp.block_list LIKE '%CIRC%' LOOP

            result.fail_part := standing_penalty.name;
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END LOOP;
    END IF;

    IF hold_test.max_holds IS NOT NULL AND NOT retargetting THEN
        SELECT    INTO hold_count COUNT(*)
          FROM    action.hold_request
          WHERE    usr = match_user
            AND fulfillment_time IS NULL
            AND cancel_time IS NULL
            AND CASE WHEN hold_test.include_frozen_holds THEN TRUE ELSE frozen IS FALSE END;

        IF hold_count >= hold_test.max_holds THEN
            result.fail_part := 'config.hold_matrix_test.max_holds';
            result.success := FALSE;
            done := TRUE;
            RETURN NEXT result;
        END IF;
    END IF;

    IF item_object.age_protect IS NOT NULL THEN
        SELECT INTO age_protect_object * FROM config.rule_age_hold_protect WHERE id = item_object.age_protect;
        IF hold_test.distance_is_from_owner THEN
            SELECT INTO use_active_date value FROM actor.org_unit_ancestor_setting('circ.holds.age_protect.active_date', item_cn_object.owning_lib);
        ELSE
            SELECT INTO use_active_date value FROM actor.org_unit_ancestor_setting('circ.holds.age_protect.active_date', item_object.circ_lib);
        END IF;
        IF use_active_date = 'true' THEN
            age_protect_date := COALESCE(item_object.active_date, NOW());
        ELSE
            age_protect_date := item_object.create_date;
        END IF;
        IF age_protect_date + age_protect_object.age > NOW() THEN
            SELECT INTO calc_age_prox * FROM actor.org_unit_setting WHERE name = 'circ.holds.calculated_age_proximity' AND org_unit = item_object.circ_lib;
            IF hold_test.distance_is_from_owner THEN
                prox_ou := item_cn_object.owning_lib;
            ELSE
                prox_ou := item_object.circ_lib;
            END IF;
            IF calc_age_prox.id IS NOT NULL AND calc_age_prox.value = 'true' THEN
                SELECT INTO hold_transit_prox action.copy_calculated_proximity(
                    v_pickup_ou,
                    v_request_ou,
                    prox_ou,
                    item_object.circ_modifier,
                    item_cn_object.owning_lib,
                    item_location_object.owning_lib
                );
            ELSE
                SELECT INTO hold_transit_prox prox::NUMERIC FROM actor.org_unit_proximity WHERE from_org = prox_ou AND to_org = v_pickup_ou;
            END IF;

            IF hold_transit_prox > age_protect_object.prox::NUMERIC THEN
                result.fail_part := 'config.rule_age_hold_protect.prox';
                result.success := FALSE;
                done := TRUE;
                RETURN NEXT result;
            END IF;
        END IF;
    END IF;

    IF NOT done THEN
        RETURN NEXT result;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION action.hold_request_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer, retargetting boolean) OWNER TO evergreen;

--
-- Name: hold_request_queue_pos(bigint); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.hold_request_queue_pos(hold_id bigint) RETURNS bigint
    LANGUAGE sql
    AS $_$
    SELECT subq.queue_position FROM (
        WITH related_holds AS (
            SELECT
                ahr.id AS hold_id,
                COALESCE(ahr.cut_in_line, FALSE) AS cut_in_line,
                ahr.request_time
            FROM reporter.hold_request_record rhrr
            JOIN reporter.hold_request_record rhrr_related
                ON (rhrr_related.bib_record = rhrr.bib_record)
            JOIN action.hold_request ahr ON (ahr.id = rhrr_related.id)
            WHERE rhrr.id = $1
                AND ahr.cancel_time IS NULL
                AND ahr.fulfillment_time IS NULL
        ) SELECT ROW_NUMBER() OVER (
            ORDER BY cut_in_line DESC, request_time
        ) AS queue_position, hold_id FROM related_holds
    ) subq WHERE subq.hold_id = $1
$_$;


ALTER FUNCTION action.hold_request_queue_pos(hold_id bigint) OWNER TO evergreen;

--
-- Name: hold_request_regen_copy_maps(integer, integer[]); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.hold_request_regen_copy_maps(hold_id integer, copy_ids integer[]) RETURNS void
    LANGUAGE sql
    AS $_$
    DELETE FROM action.hold_copy_map WHERE hold = $1;
    INSERT INTO action.hold_copy_map (hold, target_copy) SELECT DISTINCT $1, UNNEST($2);
$_$;


ALTER FUNCTION action.hold_request_regen_copy_maps(hold_id integer, copy_ids integer[]) OWNER TO evergreen;

--
-- Name: hold_retarget_permit_test(integer, integer, bigint, integer, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.hold_retarget_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) RETURNS SETOF action.matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.hold_request_permit_test( $1, $2, $3, $4, $5, TRUE );
$_$;


ALTER FUNCTION action.hold_retarget_permit_test(pickup_ou integer, request_ou integer, match_item bigint, match_user integer, match_requestor integer) OWNER TO evergreen;

--
-- Name: item_user_circ_test(integer, bigint, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.item_user_circ_test(integer, bigint, integer) RETURNS SETOF action.circ_matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.item_user_circ_test( $1, $2, $3, FALSE );
$_$;


ALTER FUNCTION action.item_user_circ_test(integer, bigint, integer) OWNER TO evergreen;

--
-- Name: item_user_circ_test(integer, bigint, integer, boolean); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.item_user_circ_test(circ_ou integer, match_item bigint, match_user integer, renewal boolean) RETURNS SETOF action.circ_matrix_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    user_object             actor.usr%ROWTYPE;
    standing_penalty        config.standing_penalty%ROWTYPE;
    item_object             asset.copy%ROWTYPE;
    item_status_object      config.copy_status%ROWTYPE;
    item_location_object    asset.copy_location%ROWTYPE;
    result                  action.circ_matrix_test_result;
    circ_test               action.found_circ_matrix_matchpoint;
    circ_matchpoint         config.circ_matrix_matchpoint%ROWTYPE;
    circ_limit_set          config.circ_limit_set%ROWTYPE;
    hold_ratio              action.hold_stats%ROWTYPE;
    penalty_type            TEXT;
    items_out               INT;
    context_org_list        INT[];
    done                    BOOL := FALSE;
    item_prox               INT;
    home_prox               INT;
BEGIN
    -- Assume success unless we hit a failure condition
    result.success := TRUE;

    -- Need user info to look up matchpoints
    SELECT INTO user_object * FROM actor.usr WHERE id = match_user AND NOT deleted;

    -- (Insta)Fail if we couldn't find the user
    IF user_object.id IS NULL THEN
        result.fail_part := 'no_user';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    -- Need item info to look up matchpoints
    SELECT INTO item_object * FROM asset.copy WHERE id = match_item AND NOT deleted;

    -- (Insta)Fail if we couldn't find the item 
    IF item_object.id IS NULL THEN
        result.fail_part := 'no_item';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    SELECT INTO circ_test * FROM action.find_circ_matrix_matchpoint(circ_ou, item_object, user_object, renewal);

    circ_matchpoint             := circ_test.matchpoint;
    result.matchpoint           := circ_matchpoint.id;
    result.circulate            := circ_matchpoint.circulate;
    result.duration_rule        := circ_matchpoint.duration_rule;
    result.recurring_fine_rule  := circ_matchpoint.recurring_fine_rule;
    result.max_fine_rule        := circ_matchpoint.max_fine_rule;
    result.hard_due_date        := circ_matchpoint.hard_due_date;
    result.renewals             := circ_matchpoint.renewals;
    result.grace_period         := circ_matchpoint.grace_period;
    result.buildrows            := circ_test.buildrows;

    -- (Insta)Fail if we couldn't find a matchpoint
    IF circ_test.success = false THEN
        result.fail_part := 'no_matchpoint';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
        RETURN;
    END IF;

    -- All failures before this point are non-recoverable
    -- Below this point are possibly overridable failures

    -- Fail if the user is barred
    IF user_object.barred IS TRUE THEN
        result.fail_part := 'actor.usr.barred';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the item can't circulate
    IF item_object.circulate IS FALSE THEN
        result.fail_part := 'asset.copy.circulate';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the item isn't in a circulateable status on a non-renewal
    IF NOT renewal AND item_object.status <> 8 AND item_object.status NOT IN (
        -- KCLS s/is_available/checkout_ok/
        (SELECT id FROM config.copy_status WHERE checkout_ok) ) THEN 
        result.fail_part := 'asset.copy.status';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    -- Alternately, fail if the item isn't checked out on a renewal
    ELSIF renewal AND item_object.status <> 1 THEN
        result.fail_part := 'asset.copy.status';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the item can't circulate because of the shelving location
    SELECT INTO item_location_object * FROM asset.copy_location WHERE id = item_object.location;
    IF item_location_object.circulate IS FALSE THEN
        result.fail_part := 'asset.copy_location.circulate';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Use Circ OU for penalties and such
    SELECT INTO context_org_list ARRAY_AGG(id) FROM actor.org_unit_full_path( circ_ou );

    -- Proximity of user's home_ou to circ_ou to see if penalties should be ignored.
    SELECT INTO home_prox prox FROM actor.org_unit_proximity WHERE from_org = user_object.home_ou AND to_org = circ_ou;

    -- Proximity of user's home_ou to item circ_lib to see if penalties should be ignored.
    SELECT INTO item_prox prox FROM actor.org_unit_proximity WHERE from_org = user_object.home_ou AND to_org = item_object.circ_lib;

    IF renewal THEN
        penalty_type = '%RENEW%';
    ELSE
        penalty_type = '%CIRC%';
    END IF;

    FOR standing_penalty IN
        SELECT  DISTINCT csp.*
          FROM  actor.usr_standing_penalty usp
                JOIN config.standing_penalty csp ON (csp.id = usp.standing_penalty)
          WHERE usr = match_user
                AND usp.org_unit IN ( SELECT * FROM unnest(context_org_list) )
                AND (usp.stop_date IS NULL or usp.stop_date > NOW())
                AND (csp.ignore_proximity IS NULL
                     OR csp.ignore_proximity < home_prox
                     OR csp.ignore_proximity < item_prox)
                AND csp.block_list LIKE penalty_type LOOP

        result.fail_part := standing_penalty.name;
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END LOOP;

    -- Fail if the test is set to hard non-circulating
    IF circ_matchpoint.circulate IS FALSE THEN
        result.fail_part := 'config.circ_matrix_test.circulate';
        result.success := FALSE;
        done := TRUE;
        RETURN NEXT result;
    END IF;

    -- Fail if the total copy-hold ratio is too low
    IF renewal THEN
        -- KCLS JBAS-2377 Limit ratio checks to renewals

        -- Fail if the total copy-hold ratio is too low
        IF circ_matchpoint.total_copy_hold_ratio IS NOT NULL THEN
            SELECT INTO hold_ratio * FROM action.copy_related_hold_stats(match_item);
            IF hold_ratio.total_copy_ratio IS NOT NULL AND hold_ratio.total_copy_ratio < circ_matchpoint.total_copy_hold_ratio THEN
                result.fail_part := 'config.circ_matrix_test.total_copy_hold_ratio';
                result.success := FALSE;
                done := TRUE;
                RETURN NEXT result;
            END IF;
        END IF;

        -- Fail if the available copy-hold ratio is too low
        IF circ_matchpoint.available_copy_hold_ratio IS NOT NULL THEN
            IF hold_ratio.hold_count IS NULL THEN
                SELECT INTO hold_ratio * FROM action.copy_related_hold_stats(match_item);
            END IF;
            IF hold_ratio.available_copy_ratio IS NOT NULL AND hold_ratio.available_copy_ratio < circ_matchpoint.available_copy_hold_ratio THEN
                result.fail_part := 'config.circ_matrix_test.available_copy_hold_ratio';
                result.success := FALSE;
                done := TRUE;
                RETURN NEXT result;
            END IF;
        END IF;

    END IF; -- IF renewal

    -- Fail if the user has too many items out by defined limit sets
    FOR circ_limit_set IN SELECT ccls.* FROM config.circ_limit_set ccls
      JOIN config.circ_matrix_limit_set_map ccmlsm ON ccmlsm.limit_set = ccls.id
      WHERE ccmlsm.active AND ( ccmlsm.matchpoint = circ_matchpoint.id OR
        ( ccmlsm.matchpoint IN (SELECT * FROM unnest(result.buildrows)) AND ccmlsm.fallthrough )
        ) LOOP
            IF circ_limit_set.items_out > 0 AND NOT renewal THEN
                SELECT INTO context_org_list ARRAY_AGG(aou.id)
                  FROM actor.org_unit_full_path( circ_ou ) aou
                    JOIN actor.org_unit_type aout ON aou.ou_type = aout.id
                  WHERE aout.depth >= circ_limit_set.depth;
                IF circ_limit_set.global THEN
                    WITH RECURSIVE descendant_depth AS (
                        SELECT  ou.id,
                            ou.parent_ou
                        FROM  actor.org_unit ou
                        WHERE ou.id IN (SELECT * FROM unnest(context_org_list))
                            UNION
                        SELECT  ou.id,
                            ou.parent_ou
                        FROM  actor.org_unit ou
                            JOIN descendant_depth ot ON (ot.id = ou.parent_ou)
                    ) SELECT INTO context_org_list ARRAY_AGG(ou.id) FROM actor.org_unit ou JOIN descendant_depth USING (id);
                END IF;
                SELECT INTO items_out COUNT(DISTINCT circ.id)
                  FROM action.circulation circ
                    JOIN asset.copy copy ON (copy.id = circ.target_copy)
                    LEFT JOIN action.circulation_limit_group_map aclgm ON (circ.id = aclgm.circ)
                  WHERE circ.usr = match_user
                    AND circ.circ_lib IN (SELECT * FROM unnest(context_org_list))
                    AND circ.checkin_time IS NULL
                    AND circ.xact_finish IS NULL
                    AND (circ.stop_fines IN ('MAXFINES','LONGOVERDUE') OR circ.stop_fines IS NULL)
                    AND (copy.circ_modifier IN (SELECT circ_mod FROM config.circ_limit_set_circ_mod_map WHERE limit_set = circ_limit_set.id)
                        OR copy.location IN (SELECT copy_loc FROM config.circ_limit_set_copy_loc_map WHERE limit_set = circ_limit_set.id)
                        OR aclgm.limit_group IN (SELECT limit_group FROM config.circ_limit_set_group_map WHERE limit_set = circ_limit_set.id)
                    );
                IF items_out >= circ_limit_set.items_out THEN
                    result.fail_part := 'config.circ_matrix_circ_mod_test';
                    result.success := FALSE;
                    done := TRUE;
                    RETURN NEXT result;
                END IF;
            END IF;
            SELECT INTO result.limit_groups result.limit_groups || ARRAY_AGG(limit_group) FROM config.circ_limit_set_group_map WHERE limit_set = circ_limit_set.id AND NOT check_only;
    END LOOP;

    -- If we passed everything, return the successful matchpoint
    IF NOT done THEN
        RETURN NEXT result;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION action.item_user_circ_test(circ_ou integer, match_item bigint, match_user integer, renewal boolean) OWNER TO evergreen;

--
-- Name: item_user_renew_test(integer, bigint, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.item_user_renew_test(integer, bigint, integer) RETURNS SETOF action.circ_matrix_test_result
    LANGUAGE sql
    AS $_$
    SELECT * FROM action.item_user_circ_test( $1, $2, $3, TRUE );
$_$;


ALTER FUNCTION action.item_user_renew_test(integer, bigint, integer) OWNER TO evergreen;

--
-- Name: link_circ_limit_groups(bigint, integer[]); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.link_circ_limit_groups(bigint, integer[]) RETURNS void
    LANGUAGE sql
    AS $_$
    INSERT INTO action.circulation_limit_group_map(circ, limit_group) SELECT $1, id FROM config.circ_limit_group WHERE id IN (SELECT * FROM UNNEST($2));
$_$;


ALTER FUNCTION action.link_circ_limit_groups(bigint, integer[]) OWNER TO evergreen;

--
-- Name: maintain_usr_circ_history(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.maintain_usr_circ_history() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    cur_circ  BIGINT;
    first_circ BIGINT;
BEGIN                                                                          

    -- Any retention value signifies history is enabled.
    -- This assumes that clearing these values via external 
    -- process deletes the action.usr_circ_history rows.
    -- TODO: replace these settings w/ a single bool setting?
    PERFORM 1 FROM actor.usr_setting 
        WHERE usr = NEW.usr AND value IS NOT NULL AND name IN (
            'history.circ.retention_age', 
            'history.circ.retention_start'
        );

    IF NOT FOUND THEN
        RETURN NEW;
    END IF;

    IF TG_OP = 'INSERT' AND NEW.parent_circ IS NULL THEN
        -- Starting a new circulation.  Insert the history row.
        INSERT INTO action.usr_circ_history 
            (usr, xact_start, target_copy, due_date, source_circ)
        VALUES (
            NEW.usr, 
            NEW.xact_start, 
            NEW.target_copy, 
            NEW.due_date, 
            NEW.id
        );

        RETURN NEW;
    END IF;

    -- find the first and last circs in the circ chain 
    -- for the currently modified circ.
    FOR cur_circ IN SELECT id FROM action.circ_chain(NEW.id) LOOP
        IF first_circ IS NULL THEN
            first_circ := cur_circ;
            CONTINUE;
        END IF;
        -- Allow the loop to continue so that at as the loop
        -- completes cur_circ points to the final circulation.
    END LOOP;

    IF NEW.id <> cur_circ THEN
        -- Modifying an intermediate circ.  Ignore it.
        RETURN NEW;
    END IF;

    -- Update the due_date/checkin_time on the history row if the current 
    -- circ is the last circ in the chain and an update is warranted.

    UPDATE action.usr_circ_history 
        SET 
            due_date = NEW.due_date,
            checkin_time = NEW.checkin_time
        WHERE 
            source_circ = first_circ 
            AND (
                due_date <> NEW.due_date OR (
                    (checkin_time IS NULL AND NEW.checkin_time IS NOT NULL) OR
                    (checkin_time IS NOT NULL AND NEW.checkin_time IS NULL) OR
                    (checkin_time <> NEW.checkin_time)
                )
            );
    RETURN NEW;
END;                                                                           
$$;


ALTER FUNCTION action.maintain_usr_circ_history() OWNER TO evergreen;

--
-- Name: migrate_usr_circ_history(integer, integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.migrate_usr_circ_history(usr_limit integer DEFAULT NULL::integer, usr_offset integer DEFAULT NULL::integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    cur_usr   INTEGER;
    cur_circ  action.circulation%ROWTYPE;
    last_circ action.circulation%ROWTYPE;
    circ_counter INTEGER DEFAULT 1;
    usr_counter  INTEGER DEFAULT 1;
BEGIN

    FOR cur_usr IN 
        WITH history_users AS (
            SELECT DISTINCT(au.id) AS id
            FROM actor.usr au 
                JOIN actor.usr_setting aus ON (aus.usr = au.id)
            WHERE 
                NOT au.deleted 
                AND aus.name ~ '^history.circ.retention_' 
        ) SELECT users.id FROM history_users users
            ORDER BY users.id LIMIT usr_limit OFFSET usr_offset
    LOOP

        FOR cur_circ IN SELECT * FROM action.usr_visible_circs(cur_usr) LOOP

            PERFORM TRUE FROM asset.copy WHERE id = cur_circ.target_copy;

            -- Avoid inserting a circ history row when the circulated
            -- item has been (forcibly) removed from the database.
            IF NOT FOUND THEN
                CONTINUE;
            END IF;

            -- Skip this circ if it's already been added to the history table
            PERFORM TRUE FROM action.usr_circ_history 
                WHERE source_circ = cur_circ.id;

            IF FOUND THEN
                CONTINUE;
            END IF;

            -- Find the last circ in the circ chain.
            SELECT INTO last_circ * 
                FROM action.circ_chain(cur_circ.id) 
                ORDER BY xact_start DESC LIMIT 1;

            -- Create the history row.
            -- It's OK if last_circ = cur_circ
            INSERT INTO action.usr_circ_history 
                (usr, xact_start, target_copy, 
                    due_date, checkin_time, source_circ)
            VALUES (
                cur_circ.usr, 
                cur_circ.xact_start, 
                cur_circ.target_copy, 
                last_circ.due_date, 
                last_circ.checkin_time,
                cur_circ.id
            );

            -- useful for alleviating administrator anxiety.
            IF circ_counter % 10000 = 0 THEN
                RAISE NOTICE 'Migrated history for % circs', circ_counter;
            END IF;

            circ_counter := circ_counter + 1;

        END LOOP;

         -- useful for alleviating administrator anxiety.
        IF usr_counter % 500 = 0 THEN
            RAISE NOTICE 'Migrated history for % users', usr_counter;
        END IF;

        usr_counter := usr_counter + 1;
    END LOOP;

END $$;


ALTER FUNCTION action.migrate_usr_circ_history(usr_limit integer, usr_offset integer) OWNER TO evergreen;

--
-- Name: purge_circulations(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.purge_circulations() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    org_keep_age    INTERVAL;
    org_use_last    BOOL = false;
    org_age_is_min  BOOL = false;
    org_keep_count  INT;

    keep_age        INTERVAL;

    target_acp      RECORD;
    circ_chain_head action.circulation%ROWTYPE;
    circ_chain_tail action.circulation%ROWTYPE;

    count_purged    INT;
    num_incomplete  INT;

    last_finished   TIMESTAMP WITH TIME ZONE;
BEGIN

    count_purged := 0;

    SELECT value::INTERVAL INTO org_keep_age FROM config.global_flag WHERE name = 'history.circ.retention_age' AND enabled;

    SELECT value::INT INTO org_keep_count FROM config.global_flag WHERE name = 'history.circ.retention_count' AND enabled;
    IF org_keep_count IS NULL THEN
        RETURN count_purged; -- Gimme a count to keep, or I keep them all, forever
    END IF;

    SELECT enabled INTO org_use_last FROM config.global_flag WHERE name = 'history.circ.retention_uses_last_finished';
    SELECT enabled INTO org_age_is_min FROM config.global_flag WHERE name = 'history.circ.retention_age_is_min';

    -- First, find copies with more than keep_count non-renewal circs
    FOR target_acp IN
        SELECT  target_copy,
                COUNT(*) AS total_real_circs
          FROM  action.circulation
          WHERE parent_circ IS NULL
                AND xact_finish IS NOT NULL
          GROUP BY target_copy
          HAVING COUNT(*) > org_keep_count
    LOOP
        -- And, for those, select circs that are finished and older than keep_age
        FOR circ_chain_head IN
            -- For reference, the subquery uses a window function to order the circs newest to oldest and number them
            -- The outer query then uses that information to skip the most recent set the library wants to keep
            -- End result is we don't care what order they come out in, as they are all potentials for deletion.
            SELECT ac.* FROM action.circulation ac JOIN (
              SELECT  rank() OVER (ORDER BY xact_start DESC), ac.id
                FROM  action.circulation ac
                WHERE ac.target_copy = target_acp.target_copy
                  AND ac.parent_circ IS NULL
                ORDER BY ac.xact_start ) ranked USING (id)
                WHERE ranked.rank > org_keep_count
        LOOP

            SELECT * INTO circ_chain_tail FROM action.circ_chain(circ_chain_head.id) ORDER BY xact_start DESC LIMIT 1;
            SELECT COUNT(CASE WHEN xact_finish IS NULL THEN 1 ELSE NULL END), MAX(xact_finish) INTO num_incomplete, last_finished FROM action.circ_chain(circ_chain_head.id);
            CONTINUE WHEN circ_chain_tail.xact_finish IS NULL OR num_incomplete > 0;

            IF NOT org_use_last THEN
                last_finished := circ_chain_tail.xact_finish;
            END IF;

            keep_age := COALESCE( org_keep_age, '2000 years'::INTERVAL );

            IF org_age_is_min THEN
                keep_age := GREATEST( keep_age, org_keep_age );
            END IF;

            CONTINUE WHEN AGE(NOW(), last_finished) < keep_age;

            -- We've passed the purging tests, purge the circ chain starting at the end
            -- A trigger should auto-purge the rest of the chain.
            DELETE FROM action.circulation WHERE id = circ_chain_tail.id;

            count_purged := count_purged + 1;

        END LOOP;
    END LOOP;

    return count_purged;
END;
$$;


ALTER FUNCTION action.purge_circulations() OWNER TO evergreen;

--
-- Name: purge_circulations_custom(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.purge_circulations_custom(in_time_start timestamp with time zone, in_time_end timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    org_keep_age    INTERVAL;
    org_use_last    BOOL = false;
    org_age_is_min  BOOL = false;
    org_keep_count  INT;

    keep_age        INTERVAL;

    target_acp      RECORD;
    circ_chain_head action.circulation%ROWTYPE;
    circ_chain_tail action.circulation%ROWTYPE;

    count_purged    INT;
    num_incomplete  INT;

    last_finished   TIMESTAMP WITH TIME ZONE;
    cmd_main_loop_item int;
    cmd_count_kept int;
    time_start timestamp with time zone;
BEGIN
    time_start = clock_timestamp();
    count_purged := 0;
    cmd_count_kept := 0;
    cmd_main_loop_item := 0;

    SELECT value::INTERVAL INTO org_keep_age FROM config.global_flag WHERE name = 'history.circ.retention_age' AND enabled;
    raise debug 'in_time_start=%; in_time_end=%; org_keep_age=%',in_time_start,in_time_end,org_keep_age;

    SELECT value::INT INTO org_keep_count FROM config.global_flag WHERE name = 'history.circ.retention_count' AND enabled;
    IF org_keep_count IS NULL THEN
        RETURN count_purged; -- Gimme a count to keep, or I keep them all, forever
    END IF;

    SELECT enabled INTO org_use_last FROM config.global_flag WHERE name = 'history.circ.retention_uses_last_finished';
    SELECT enabled INTO org_age_is_min FROM config.global_flag WHERE name = 'history.circ.retention_age_is_min';

        -- And, for those, select circs that are finished and older than keep_age
        FOR circ_chain_head IN
            SELECT ac.* FROM action.circulation ac
                WHERE 1=1
                  AND ac.parent_circ IS NULL
                  AND xact_finish < now() - coalesce(org_keep_age,'2000 years'::interval)
                  AND xact_finish between in_time_start and in_time_end
                -- Keep the batch sizes in check so we don't try to process
                -- hundreds of thousands in a single run.
                LIMIT 20000
        LOOP
            cmd_main_loop_item := cmd_main_loop_item + 1;
            if (cmd_main_loop_item - 1) % 1000 = 0 then
                raise debug '% Main loop item %...',(extract(epoch from (clock_timestamp()-time_start))/60)::int,cmd_main_loop_item;
            end if;

            SELECT * INTO circ_chain_tail FROM action.circ_chain(circ_chain_head.id) ORDER BY xact_start DESC LIMIT 1;
            SELECT COUNT(CASE WHEN xact_finish IS NULL THEN 1 ELSE NULL END), MAX(xact_finish) INTO num_incomplete, last_finished FROM action.circ_chain(circ_chain_head.id);
            CONTINUE WHEN circ_chain_tail.xact_finish IS NULL OR num_incomplete > 0;

            IF NOT org_use_last THEN
                last_finished := circ_chain_tail.xact_finish;
            END IF;
            
            keep_age := COALESCE( org_keep_age, '2000 years'::INTERVAL );

            IF org_age_is_min THEN
                keep_age := GREATEST( keep_age, org_keep_age );
            END IF;

           if AGE(NOW(), last_finished) < keep_age then
               cmd_count_kept := cmd_count_kept + 1;
           end if;
           CONTINUE WHEN AGE(NOW(), last_finished) < keep_age;

            -- We've passed the purging tests, purge the circ chain starting at the end
            -- A trigger should auto-purge the rest of the chain.
            DELETE FROM action.circulation WHERE id = circ_chain_tail.id;

            count_purged := count_purged + 1;
            if count_purged % 1000 = 0 then
               raise debug 'Purged Chains %', count_purged;
            end if;
        END LOOP;

    raise debug '% Done. Purged Chains=% Kept Chains=%',(extract(epoch from (clock_timestamp()-time_start))/60)::int,count_purged,cmd_count_kept;
    return count_purged;
END;

$$;


ALTER FUNCTION action.purge_circulations_custom(in_time_start timestamp with time zone, in_time_end timestamp with time zone) OWNER TO evergreen;

--
-- Name: FUNCTION purge_circulations_custom(in_time_start timestamp with time zone, in_time_end timestamp with time zone); Type: COMMENT; Schema: action; Owner: evergreen
--

COMMENT ON FUNCTION action.purge_circulations_custom(in_time_start timestamp with time zone, in_time_end timestamp with time zone) IS 'KCLS custom version of action.purge_circulations. Achieves the same results much more quickly by eliminating consideration of global_flag value "history.circ.retention_count", and targeting a specific date range.';


--
-- Name: purge_holds(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.purge_holds() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  current_hold RECORD;
  purged_holds INT;
  cgf_d INTERVAL;
  cgf_f INTERVAL;
  cgf_c INTERVAL;
  prev_usr INT;
  user_start TIMESTAMPTZ;
  user_age INTERVAL;
  user_count INT;
BEGIN
  purged_holds := 0;
  SELECT INTO cgf_d value::INTERVAL FROM config.global_flag WHERE name = 'history.hold.retention_age' AND enabled;
  SELECT INTO cgf_f value::INTERVAL FROM config.global_flag WHERE name = 'history.hold.retention_age_fulfilled' AND enabled;
  SELECT INTO cgf_c value::INTERVAL FROM config.global_flag WHERE name = 'history.hold.retention_age_canceled' AND enabled;
  FOR current_hold IN
    SELECT
      rank() OVER (PARTITION BY usr ORDER BY COALESCE(fulfillment_time, cancel_time) DESC),
      cgf_cs.value::INTERVAL as cgf_cs,
      ahr.*
    FROM
      action.hold_request ahr
      LEFT JOIN config.global_flag cgf_cs ON (ahr.cancel_cause IS NOT NULL AND cgf_cs.name = 'history.hold.retention_age_canceled_' || ahr.cancel_cause AND cgf_cs.enabled)
    WHERE
      (fulfillment_time IS NOT NULL OR cancel_time IS NOT NULL)
  LOOP
    IF prev_usr IS NULL OR prev_usr != current_hold.usr THEN
      prev_usr := current_hold.usr;
      SELECT INTO user_start oils_json_to_text(value)::TIMESTAMPTZ FROM actor.usr_setting WHERE usr = prev_usr AND name = 'history.hold.retention_start';
      SELECT INTO user_age oils_json_to_text(value)::INTERVAL FROM actor.usr_setting WHERE usr = prev_usr AND name = 'history.hold.retention_age';
      SELECT INTO user_count oils_json_to_text(value)::INT FROM actor.usr_setting WHERE usr = prev_usr AND name = 'history.hold.retention_count';
      IF user_start IS NOT NULL THEN
        user_age := LEAST(user_age, AGE(NOW(), user_start));
      END IF;
      IF user_count IS NULL THEN
        user_count := 1000; -- Assumption based on the user visible holds routine
      END IF;
    END IF;
    -- Library keep age trumps user keep anything, for purposes of being able to hold on to things when staff canceled and such.
    IF current_hold.fulfillment_time IS NOT NULL AND current_hold.fulfillment_time > NOW() - COALESCE(cgf_f, cgf_d) THEN
      CONTINUE;
    END IF;
    IF current_hold.cancel_time IS NOT NULL AND current_hold.cancel_time > NOW() - COALESCE(current_hold.cgf_cs, cgf_c, cgf_d) THEN
      CONTINUE;
    END IF;

    -- User keep age needs combining with count. If too old AND within the count, keep!
    IF user_start IS NOT NULL AND COALESCE(current_hold.fulfillment_time, current_hold.cancel_time) > NOW() - user_age AND current_hold.rank <= user_count THEN
      CONTINUE;
    END IF;

    -- All checks should have passed, delete!
    DELETE FROM action.hold_request WHERE id = current_hold.id;
    purged_holds := purged_holds + 1;
  END LOOP;
  RETURN purged_holds;
END;
$$;


ALTER FUNCTION action.purge_holds() OWNER TO evergreen;

--
-- Name: push_circ_due_time(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.push_circ_due_time() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    proper_tz TEXT := COALESCE(
        oils_json_to_text((
            SELECT value
              FROM  actor.org_unit_ancestor_setting('lib.timezone',NEW.circ_lib)
              LIMIT 1
        )),
        CURRENT_SETTING('timezone')
    );
BEGIN

    IF (EXTRACT(EPOCH FROM NEW.duration)::INT % EXTRACT(EPOCH FROM '1 day'::INTERVAL)::INT) = 0 -- day-granular duration
        AND SUBSTRING((NEW.due_date AT TIME ZONE proper_tz)::TIME::TEXT FROM 1 FOR 8) <> '23:59:59' THEN -- has not yet been pushed
        NEW.due_date = ((NEW.due_date AT TIME ZONE proper_tz)::DATE + '1 day'::INTERVAL - '1 second'::INTERVAL) || ' ' || proper_tz;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION action.push_circ_due_time() OWNER TO evergreen;

--
-- Name: summarize_all_circ_chain(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.summarize_all_circ_chain(ctx_circ_id integer) RETURNS action.circ_chain_summary
    LANGUAGE plpgsql
    AS $$

DECLARE

    -- first circ in the chain
    circ_0 action.all_circulation_slim%ROWTYPE;

    -- last circ in the chain
    circ_n action.all_circulation_slim%ROWTYPE;

    -- circ chain under construction
    chain action.circ_chain_summary;
    tmp_circ action.all_circulation_slim%ROWTYPE;

BEGIN
    
    chain.num_circs := 0;
    FOR tmp_circ IN SELECT * FROM action.all_circ_chain(ctx_circ_id) LOOP

        IF chain.num_circs = 0 THEN
            circ_0 := tmp_circ;
        END IF;

        chain.num_circs := chain.num_circs + 1;
        circ_n := tmp_circ;
    END LOOP;

    chain.start_time := circ_0.xact_start;
    chain.last_stop_fines := circ_n.stop_fines;
    chain.last_stop_fines_time := circ_n.stop_fines_time;
    chain.last_checkin_time := circ_n.checkin_time;
    chain.last_checkin_scan_time := circ_n.checkin_scan_time;
    SELECT INTO chain.checkout_workstation name FROM actor.workstation WHERE id = circ_0.workstation;
    SELECT INTO chain.last_checkin_workstation name FROM actor.workstation WHERE id = circ_n.checkin_workstation;

    IF chain.num_circs > 1 THEN
        chain.last_renewal_time := circ_n.xact_start;
        SELECT INTO chain.last_renewal_workstation name FROM actor.workstation WHERE id = circ_n.workstation;
    END IF;

    RETURN chain;

END;
$$;


ALTER FUNCTION action.summarize_all_circ_chain(ctx_circ_id integer) OWNER TO evergreen;

--
-- Name: summarize_circ_chain(bigint); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.summarize_circ_chain(ctx_circ_id bigint) RETURNS action.circ_chain_summary
    LANGUAGE plpgsql
    AS $$

DECLARE

    -- first circ in the chain
    circ_0 action.circulation%ROWTYPE;

    -- last circ in the chain
    circ_n action.circulation%ROWTYPE;

    -- circ chain under construction
    chain action.circ_chain_summary;
    tmp_circ action.circulation%ROWTYPE;

BEGIN
    
    chain.num_circs := 0;
    FOR tmp_circ IN SELECT * FROM action.circ_chain(ctx_circ_id) LOOP

        IF chain.num_circs = 0 THEN
            circ_0 := tmp_circ;
        END IF;

        chain.num_circs := chain.num_circs + 1;
        circ_n := tmp_circ;
    END LOOP;

    chain.start_time := circ_0.xact_start;
    chain.last_stop_fines := circ_n.stop_fines;
    chain.last_stop_fines_time := circ_n.stop_fines_time;
    chain.last_checkin_time := circ_n.checkin_time;
    chain.last_checkin_scan_time := circ_n.checkin_scan_time;
    SELECT INTO chain.checkout_workstation name FROM actor.workstation WHERE id = circ_0.workstation;
    SELECT INTO chain.last_checkin_workstation name FROM actor.workstation WHERE id = circ_n.checkin_workstation;

    IF chain.num_circs > 1 THEN
        chain.last_renewal_time := circ_n.xact_start;
        SELECT INTO chain.last_renewal_workstation name FROM actor.workstation WHERE id = circ_n.workstation;
    END IF;

    RETURN chain;

END;
$$;


ALTER FUNCTION action.summarize_circ_chain(ctx_circ_id bigint) OWNER TO evergreen;

--
-- Name: survey_response_answer_date_fixup(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.survey_response_answer_date_fixup() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	NEW.answer_date := NOW();
	RETURN NEW;
END;
$$;


ALTER FUNCTION action.survey_response_answer_date_fixup() OWNER TO evergreen;

--
-- Name: temp_hold_updates(); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.temp_hold_updates() RETURNS trigger
    LANGUAGE plpgsql COST 500
    AS $$
BEGIN
	INSERT INTO public.temp_holds_table (id, target, hold_type) VALUES (NEW.id, NEW.target, NEW.hold_type);
	RETURN NEW;
END;
$$;


ALTER FUNCTION action.temp_hold_updates() OWNER TO evergreen;

--
-- Name: usr_visible_circ_copies(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.usr_visible_circ_copies(integer) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT DISTINCT(target_copy) FROM action.usr_visible_circs($1)
$_$;


ALTER FUNCTION action.usr_visible_circ_copies(integer) OWNER TO evergreen;

--
-- Name: usr_visible_circs(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.usr_visible_circs(usr_id integer) RETURNS SETOF action.circulation
    LANGUAGE plpgsql
    AS $$
DECLARE
    c               action.circulation%ROWTYPE;
    view_age        INTERVAL;
    usr_view_age    actor.usr_setting%ROWTYPE;
    usr_view_start  actor.usr_setting%ROWTYPE;
BEGIN
    SELECT * INTO usr_view_age FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.circ.retention_age';
    SELECT * INTO usr_view_start FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.circ.retention_start';

    IF usr_view_age.value IS NOT NULL AND usr_view_start.value IS NOT NULL THEN
        -- User opted in and supplied a retention age
        IF oils_json_to_text(usr_view_age.value)::INTERVAL > AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ) THEN
            view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
        ELSE
            view_age := oils_json_to_text(usr_view_age.value)::INTERVAL;
        END IF;
    ELSIF usr_view_start.value IS NOT NULL THEN
        -- User opted in
        view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
    ELSE
        -- User did not opt in
        RETURN;
    END IF;

    FOR c IN
        SELECT  *
          FROM  action.circulation
          WHERE usr = usr_id
                AND parent_circ IS NULL
                AND xact_start > NOW() - view_age
          ORDER BY xact_start DESC
    LOOP
        RETURN NEXT c;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION action.usr_visible_circs(usr_id integer) OWNER TO evergreen;

--
-- Name: hold_request; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.hold_request (
    id integer NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint NOT NULL,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer NOT NULL,
    requestor integer NOT NULL,
    usr integer NOT NULL,
    selection_ou integer NOT NULL,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer NOT NULL,
    hold_type text NOT NULL,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT false NOT NULL,
    shelf_expire_time timestamp with time zone,
    current_shelf_lib integer,
    sms_notify text,
    sms_carrier integer,
    behind_desk boolean DEFAULT false NOT NULL,
    acq_request integer,
    hopeless_date timestamp with time zone,
    CONSTRAINT sms_check CHECK (((sms_notify IS NULL) OR (sms_carrier IS NOT NULL)))
);


ALTER TABLE action.hold_request OWNER TO evergreen;

--
-- Name: usr_visible_holds(integer); Type: FUNCTION; Schema: action; Owner: evergreen
--

CREATE FUNCTION action.usr_visible_holds(usr_id integer) RETURNS SETOF action.hold_request
    LANGUAGE plpgsql
    AS $$
DECLARE
    h               action.hold_request%ROWTYPE;
    view_age        INTERVAL;
    view_count      INT;
    usr_view_count  actor.usr_setting%ROWTYPE;
    usr_view_age    actor.usr_setting%ROWTYPE;
    usr_view_start  actor.usr_setting%ROWTYPE;
BEGIN
    SELECT * INTO usr_view_count FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.hold.retention_count';
    SELECT * INTO usr_view_age FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.hold.retention_age';
    SELECT * INTO usr_view_start FROM actor.usr_setting WHERE usr = usr_id AND name = 'history.hold.retention_start';

    FOR h IN
        SELECT  *
          FROM  action.hold_request
          WHERE usr = usr_id
                AND fulfillment_time IS NULL
                AND cancel_time IS NULL
          ORDER BY request_time DESC
    LOOP
        RETURN NEXT h;
    END LOOP;

    IF usr_view_start.value IS NULL THEN
        RETURN;
    END IF;

    IF usr_view_age.value IS NOT NULL THEN
        -- User opted in and supplied a retention age
        IF oils_json_to_text(usr_view_age.value)::INTERVAL > AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ) THEN
            view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
        ELSE
            view_age := oils_json_to_text(usr_view_age.value)::INTERVAL;
        END IF;
    ELSE
        -- User opted in
        view_age := AGE(NOW(), oils_json_to_text(usr_view_start.value)::TIMESTAMPTZ);
    END IF;

    IF usr_view_count.value IS NOT NULL THEN
        view_count := oils_json_to_text(usr_view_count.value)::INT;
    ELSE
        view_count := 1000;
    END IF;

    -- show some fulfilled/canceled holds
    FOR h IN
        SELECT  *
          FROM  action.hold_request
          WHERE usr = usr_id
                AND ( fulfillment_time IS NOT NULL OR cancel_time IS NOT NULL )
                AND COALESCE(fulfillment_time, cancel_time) > NOW() - view_age
          ORDER BY COALESCE(fulfillment_time, cancel_time) DESC
          LIMIT view_count
    LOOP
        RETURN NEXT h;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION action.usr_visible_holds(usr_id integer) OWNER TO evergreen;

--
-- Name: track_action_circulation(); Type: FUNCTION; Schema: action_log; Owner: evergreen
--

CREATE FUNCTION action_log.track_action_circulation() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    IF TG_OP = 'UPDATE' THEN

        UPDATE action_log.action_circulation 
        SET audit_time = NOW(), audit_action = 'U'
        WHERE id = NEW.id;

        IF NOT FOUND THEN
            INSERT INTO action_log.action_circulation (id, audit_action)
            VALUES (NEW.id, 'U');
        END IF;

        RETURN NEW;

    ELSIF TG_OP = 'INSERT' THEN

        INSERT INTO action_log.action_circulation (id, audit_action)
        VALUES (NEW.id, 'C');

        RETURN NEW;

    ELSIF TG_OP = 'DELETE' THEN

        UPDATE action_log.action_circulation 
        SET audit_time = NOW(), audit_action = 'D'
        WHERE id = OLD.id;

        IF NOT FOUND THEN
            INSERT INTO action_log.action_circulation (id, audit_action)
            VALUES (OLD.id, 'D');
        END IF;

        RETURN OLD;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION action_log.track_action_circulation() OWNER TO evergreen;

--
-- Name: check_valid_retention_interval(); Type: FUNCTION; Schema: action_trigger; Owner: evergreen
--

CREATE FUNCTION action_trigger.check_valid_retention_interval() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    /*
     * 1. Retention intervals are alwyas allowed on active hooks.
     * 2. On passive hooks, retention intervals are only allowed
     *    when the event definition has a max_delay value and the
     *    retention_interval value is greater than the difference 
     *    beteween the delay and max_delay values.
     */ 
    PERFORM TRUE FROM action_trigger.hook 
        WHERE key = NEW.hook AND NOT passive;

    IF FOUND THEN
        RETURN NEW;
    END IF;

    IF NEW.max_delay IS NOT NULL THEN
        IF EXTRACT(EPOCH FROM NEW.retention_interval) > 
            ABS(EXTRACT(EPOCH FROM (NEW.max_delay - NEW.delay))) THEN
            RETURN NEW; -- all good
        ELSE
            RAISE EXCEPTION 'retention_interval is too short for def [%] %', 
                NEW.id, NEW.name;
        END IF;
    ELSE
        RAISE EXCEPTION 'retention_interval requires max_delay for def [%] %', 
            NEW.id, NEW.name;
    END IF;
END;
$$;


ALTER FUNCTION action_trigger.check_valid_retention_interval() OWNER TO evergreen;

--
-- Name: purge_events(); Type: FUNCTION; Schema: action_trigger; Owner: evergreen
--

CREATE FUNCTION action_trigger.purge_events() RETURNS void
    LANGUAGE plpgsql
    AS $$
/**
  * Deleting expired events without simultaneously deleting their outputs
  * creates orphaned outputs.  Deleting their outputs and all of the events 
  * linking back to them, plus any outputs those events link to is messy and 
  * inefficient.  It's simpler to handle them in 2 sweeping steps.
  *
  * 1. Delete expired events.
  * 2. Delete orphaned event outputs.
  *
  * This has the added benefit of removing outputs that may have been
  * orphaned by some other process.  Such outputs are not usuable by
  * the system.
  *
  * This does not guarantee that all events within an event group are
  * purged at the same time.  In such cases, the remaining events will
  * be purged with the next instance of the purge (or soon thereafter).
  * This is another nod toward efficiency over completeness of old 
  * data that's circling the bit bucket anyway.
  */
BEGIN

    DELETE FROM action_trigger.event WHERE id IN (
        SELECT evt.id
        FROM action_trigger.event evt
        JOIN action_trigger.event_definition def ON (def.id = evt.event_def)
        WHERE def.retention_interval IS NOT NULL 
            AND evt.state <> 'pending'
            AND evt.update_time < (NOW() - def.retention_interval)
    );

    CREATE TEMPORARY TABLE tmp_purge_output ON COMMIT DROP AS
        SELECT ateo.id FROM action_trigger.event_output ateo
        LEFT JOIN (
            SELECT template_output AS id
                FROM action_trigger.event WHERE template_output IS NOT NULL
            UNION
            SELECT error_output AS id
                FROM action_trigger.event WHERE error_output IS NOT NULL
            UNION
            SELECT async_output AS id
                FROM action_trigger.event WHERE async_output IS NOT NULL
        ) linked ON (linked.id = ateo.id)
        WHERE linked.id IS NULL
    ;

    DELETE FROM action_trigger.event_output
        WHERE id IN (SELECT id FROM tmp_purge_output);
END;
$$;


ALTER FUNCTION action_trigger.purge_events() OWNER TO evergreen;

--
-- Name: address_alert; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.address_alert (
    id integer NOT NULL,
    owner integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    match_all boolean DEFAULT true NOT NULL,
    alert_message text NOT NULL,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    mailing_address boolean DEFAULT false NOT NULL,
    billing_address boolean DEFAULT false NOT NULL
);


ALTER TABLE actor.address_alert OWNER TO evergreen;

--
-- Name: address_alert_matches(integer, text, text, text, text, text, text, text, boolean, boolean); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.address_alert_matches(org_unit integer, street1 text, street2 text, city text, county text, state text, country text, post_code text, mailing_address boolean DEFAULT false, billing_address boolean DEFAULT false) RETURNS SETOF actor.address_alert
    LANGUAGE sql
    AS $_$

SELECT *
FROM actor.address_alert
WHERE
    active
    AND owner IN (SELECT id FROM actor.org_unit_ancestors($1)) 
    AND (
        (NOT mailing_address AND NOT billing_address)
        OR (mailing_address AND $9)
        OR (billing_address AND $10)
    )
    AND (
            (
                match_all
                AND COALESCE($2, '') ~* COALESCE(street1,   '.*')
                AND COALESCE($3, '') ~* COALESCE(street2,   '.*')
                AND COALESCE($4, '') ~* COALESCE(city,      '.*')
                AND COALESCE($5, '') ~* COALESCE(county,    '.*')
                AND COALESCE($6, '') ~* COALESCE(state,     '.*')
                AND COALESCE($7, '') ~* COALESCE(country,   '.*')
                AND COALESCE($8, '') ~* COALESCE(post_code, '.*')
            ) OR (
                NOT match_all 
                AND (  
                       $2 ~* street1
                    OR $3 ~* street2
                    OR $4 ~* city
                    OR $5 ~* county
                    OR $6 ~* state
                    OR $7 ~* country
                    OR $8 ~* post_code
                )
            )
        )
    ORDER BY actor.org_unit_proximity(owner, $1)
$_$;


ALTER FUNCTION actor.address_alert_matches(org_unit integer, street1 text, street2 text, city text, county text, state text, country text, post_code text, mailing_address boolean, billing_address boolean) OWNER TO evergreen;

--
-- Name: approve_pending_address(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.approve_pending_address(pending_id integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    old_id INT;
BEGIN
    SELECT INTO old_id replaces FROM actor.usr_address where id = pending_id;
    IF old_id IS NULL THEN
        UPDATE actor.usr_address SET pending = 'f' WHERE id = pending_id;
        RETURN pending_id;
    END IF;
    -- address replaces an existing address
    DELETE FROM actor.usr_address WHERE id = -old_id;
    UPDATE actor.usr_address SET id = -id WHERE id = old_id;
    UPDATE actor.usr_address SET replaces = NULL, id = old_id, pending = 'f' WHERE id = pending_id;
    RETURN old_id;
END
$$;


ALTER FUNCTION actor.approve_pending_address(pending_id integer) OWNER TO evergreen;

--
-- Name: FUNCTION approve_pending_address(pending_id integer); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION actor.approve_pending_address(pending_id integer) IS '
/**
 * Replaces an address with a pending address.  This is done by giving the pending 
 * address the ID of the old address.  The replaced address is retained with -id.
 */
';


--
-- Name: au_updated(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.au_updated() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.last_update_time := now();
	RETURN NEW;
END;
$$;


ALTER FUNCTION actor.au_updated() OWNER TO evergreen;

--
-- Name: usr_message; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.usr_message (
    id integer NOT NULL,
    usr integer NOT NULL,
    title text,
    message text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    read_date timestamp with time zone,
    sending_lib integer NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    stop_date timestamp with time zone,
    editor bigint,
    edit_date timestamp with time zone
);


ALTER TABLE actor.usr_message OWNER TO evergreen;

--
-- Name: usr_message_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.usr_message_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_message_id_seq OWNER TO evergreen;

--
-- Name: usr_message_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.usr_message_id_seq OWNED BY actor.usr_message.id;


--
-- Name: usr_standing_penalty; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.usr_standing_penalty (
    id integer DEFAULT nextval('actor.usr_message_id_seq'::regclass) NOT NULL,
    org_unit integer NOT NULL,
    usr integer NOT NULL,
    standing_penalty integer NOT NULL,
    staff integer,
    set_date timestamp with time zone DEFAULT now(),
    stop_date timestamp with time zone,
    usr_message bigint
);


ALTER TABLE actor.usr_standing_penalty OWNER TO evergreen;

--
-- Name: TABLE usr_standing_penalty; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.usr_standing_penalty IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * User standing penalties
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: calculate_system_penalties(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.calculate_system_penalties(match_user integer, context_org integer) RETURNS SETOF actor.usr_standing_penalty
    LANGUAGE plpgsql
    AS $$
DECLARE
    user_object         actor.usr%ROWTYPE;
    new_sp_row          actor.usr_standing_penalty%ROWTYPE;
    existing_sp_row     actor.usr_standing_penalty%ROWTYPE;
    collections_fines   permission.grp_penalty_threshold%ROWTYPE;
    max_fines           permission.grp_penalty_threshold%ROWTYPE;
    max_overdue         permission.grp_penalty_threshold%ROWTYPE;
    max_items_out       permission.grp_penalty_threshold%ROWTYPE;
    max_lost            permission.grp_penalty_threshold%ROWTYPE;
    max_longoverdue     permission.grp_penalty_threshold%ROWTYPE;
    tmp_grp             INT;
    items_overdue       INT;
    items_out           INT;
    items_lost          INT;
    items_longoverdue   INT;
    context_org_list    INT[];
    current_fines        NUMERIC(8,2) := 0.0;
    tmp_fines            NUMERIC(8,2);
    tmp_groc            RECORD;
    tmp_circ            RECORD;
    tmp_org             actor.org_unit%ROWTYPE;
    tmp_penalty         config.standing_penalty%ROWTYPE;
    tmp_depth           INTEGER;
BEGIN
    SELECT INTO user_object * FROM actor.usr WHERE id = match_user;

    -- Max fines
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has a high fine balance
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_fines FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 1 AND org_unit = tmp_org.id;

            IF max_fines.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_fines.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_fines.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_fines.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 1;

        SELECT INTO context_org_list ARRAY_AGG(id) FROM actor.org_unit_full_path( max_fines.org_unit );

        SELECT  SUM(f.balance_owed) INTO current_fines
          FROM  money.materialized_billable_xact_summary f
                JOIN (
                    SELECT  r.id
                      FROM  booking.reservation r
                      WHERE r.usr = match_user
                            AND r.pickup_lib IN (SELECT * FROM unnest(context_org_list))
                            AND xact_finish IS NULL
                                UNION ALL
                    SELECT  g.id
                      FROM  money.grocery g
                      WHERE g.usr = match_user
                            AND g.billing_location IN (SELECT * FROM unnest(context_org_list))
                            AND xact_finish IS NULL
                                UNION ALL
                    SELECT  circ.id
                      FROM  action.circulation circ
                      WHERE circ.usr = match_user
                            AND circ.circ_lib IN (SELECT * FROM unnest(context_org_list))
                            AND xact_finish IS NULL ) l USING (id);

        IF current_fines >= max_fines.threshold THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_fines.org_unit;
            new_sp_row.standing_penalty := 1;
            RETURN NEXT new_sp_row;
        END IF;
    END IF;

    -- Start over for max overdue
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has too many overdue items
    LOOP
        tmp_grp := user_object.profile;
        LOOP

            SELECT * INTO max_overdue FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 2 AND org_unit = tmp_org.id;

            IF max_overdue.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_overdue.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT INTO tmp_org * FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_overdue.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_overdue.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 2;

        SELECT  INTO items_overdue COUNT(*)
          FROM  action.circulation circ
                JOIN  actor.org_unit_full_path( max_overdue.org_unit ) fp ON (circ.circ_lib = fp.id)
          WHERE circ.usr = match_user
            AND circ.checkin_time IS NULL
            AND circ.due_date < NOW()
            AND (circ.stop_fines = 'MAXFINES' OR circ.stop_fines IS NULL);

        IF items_overdue >= max_overdue.threshold::INT THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_overdue.org_unit;
            new_sp_row.standing_penalty := 2;
            RETURN NEXT new_sp_row;
        END IF;
    END IF;

    -- Start over for max out
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has too many checked out items
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_items_out FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 3 AND org_unit = tmp_org.id;

            IF max_items_out.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_items_out.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT INTO tmp_org * FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;


    -- Fail if the user has too many items checked out
    IF max_items_out.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_items_out.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 3;

        SELECT  INTO items_out COUNT(*)
          FROM  action.circulation circ
                JOIN  actor.org_unit_full_path( max_items_out.org_unit ) fp ON (circ.circ_lib = fp.id)
          WHERE circ.usr = match_user
                AND circ.checkin_time IS NULL
                AND (circ.stop_fines IN (
                    SELECT 'MAXFINES'::TEXT
                    UNION ALL
                    SELECT 'LONGOVERDUE'::TEXT
                    UNION ALL
                    SELECT 'LOST'::TEXT
                    WHERE 'true' ILIKE
                    (
                        SELECT CASE
                            WHEN (SELECT value FROM actor.org_unit_ancestor_setting('circ.tally_lost', circ.circ_lib)) ILIKE 'true' THEN 'true'
                            ELSE 'false'
                        END
                    )
                    UNION ALL
                    SELECT 'CLAIMSRETURNED'::TEXT
                    WHERE 'false' ILIKE
                    (
                        SELECT CASE
                            WHEN (SELECT value FROM actor.org_unit_ancestor_setting('circ.do_not_tally_claims_returned', circ.circ_lib)) ILIKE 'true' THEN 'true'
                            ELSE 'false'
                        END
                    )
                    ) OR circ.stop_fines IS NULL)
                AND xact_finish IS NULL;

           IF items_out >= max_items_out.threshold::INT THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_items_out.org_unit;
            new_sp_row.standing_penalty := 3;
            RETURN NEXT new_sp_row;
           END IF;
    END IF;

    -- Start over for max lost
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has too many lost items
    LOOP
        tmp_grp := user_object.profile;
        LOOP

            SELECT * INTO max_lost FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 5 AND org_unit = tmp_org.id;

            IF max_lost.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_lost.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT INTO tmp_org * FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_lost.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
            FROM  actor.usr_standing_penalty
            WHERE usr = match_user
                AND org_unit = max_lost.org_unit
                AND (stop_date IS NULL or stop_date > NOW())
                AND standing_penalty = 5;

        SELECT  INTO items_lost COUNT(*)
        FROM  action.circulation circ
            JOIN  actor.org_unit_full_path( max_lost.org_unit ) fp ON (circ.circ_lib = fp.id)
        WHERE circ.usr = match_user
            AND circ.checkin_time IS NULL
            AND (circ.stop_fines = 'LOST')
            AND xact_finish IS NULL;

        IF items_lost >= max_lost.threshold::INT AND 0 < max_lost.threshold::INT THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_lost.org_unit;
            new_sp_row.standing_penalty := 5;
            RETURN NEXT new_sp_row;
        END IF;
    END IF;

    -- Start over for max longoverdue
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has too many longoverdue items
    LOOP
        tmp_grp := user_object.profile;
        LOOP

            SELECT * INTO max_longoverdue
                FROM permission.grp_penalty_threshold
                WHERE grp = tmp_grp AND
                    penalty = 35 AND
                    org_unit = tmp_org.id;

            IF max_longoverdue.threshold IS NULL THEN
                SELECT parent INTO tmp_grp
                    FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_longoverdue.threshold IS NOT NULL
                OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT INTO tmp_org * FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_longoverdue.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
            FROM  actor.usr_standing_penalty
            WHERE usr = match_user
                AND org_unit = max_longoverdue.org_unit
                AND (stop_date IS NULL or stop_date > NOW())
                AND standing_penalty = 35;

        SELECT INTO items_longoverdue COUNT(*)
        FROM action.circulation circ
            JOIN actor.org_unit_full_path( max_longoverdue.org_unit ) fp
                ON (circ.circ_lib = fp.id)
        WHERE circ.usr = match_user
            AND circ.checkin_time IS NULL
            AND (circ.stop_fines = 'LONGOVERDUE')
            AND xact_finish IS NULL;

        IF items_longoverdue >= max_longoverdue.threshold::INT
                AND 0 < max_longoverdue.threshold::INT THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_longoverdue.org_unit;
            new_sp_row.standing_penalty := 35;
            RETURN NEXT new_sp_row;
        END IF;
    END IF;

    -- Start over for patron exceeds bill warning
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Check for patron exceeds bill warning
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_fines FROM permission.grp_penalty_threshold
                WHERE grp = tmp_grp AND penalty = 36 AND org_unit = tmp_org.id;

            IF max_fines.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_fines.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_fines.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_fines.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 36;

        SELECT INTO context_org_list ARRAY_AGG(id) FROM actor.org_unit_full_path( max_fines.org_unit );

		SELECT  SUM(f.balance_owed) INTO current_fines
		  FROM  money.materialized_billable_xact_summary f
				JOIN (
					SELECT  r.id
					  FROM  booking.reservation r
					  WHERE r.usr = match_user
							AND r.pickup_lib IN (SELECT * FROM unnest(context_org_list))
							AND r.xact_finish IS NULL
								UNION ALL
					SELECT  g.id
					  FROM  money.grocery g
					  WHERE g.usr = match_user
							AND g.billing_location IN (SELECT * FROM unnest(context_org_list))
							AND g.xact_finish IS NULL
								UNION ALL
					SELECT  circ.id
					  FROM  action.circulation circ
					  WHERE circ.usr = match_user
							AND circ.circ_lib IN (SELECT * FROM unnest(context_org_list))
							AND circ.xact_finish IS NULL ) l USING (id);

		IF current_fines >= max_fines.threshold THEN
			new_sp_row.usr := match_user;
			new_sp_row.org_unit := max_fines.org_unit;
			new_sp_row.standing_penalty := 36;
			RETURN NEXT new_sp_row;
		END IF;
	END IF;


    -- Start over for collections warning
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Fail if the user has a collections-level fine balance
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_fines FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 4 AND org_unit = tmp_org.id;

            IF max_fines.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_fines.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_fines.threshold IS NOT NULL THEN

        RETURN QUERY
            SELECT  *
              FROM  actor.usr_standing_penalty
              WHERE usr = match_user
                    AND org_unit = max_fines.org_unit
                    AND (stop_date IS NULL or stop_date > NOW())
                    AND standing_penalty = 4;

        SELECT INTO context_org_list ARRAY_AGG(id) FROM actor.org_unit_full_path( max_fines.org_unit );

        -- KCLS JBAS-2334 Collections processing only counts LOST fines.
        SELECT INTO current_fines * FROM actor.usr_lost_amount_owed(match_user);

        IF current_fines >= max_fines.threshold THEN
            new_sp_row.usr := match_user;
            new_sp_row.org_unit := max_fines.org_unit;
            new_sp_row.standing_penalty := 4;
            RETURN NEXT new_sp_row;
        END IF;
    END IF;

    -- Start over for in collections
    SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;

    -- Remove the in-collections penalty if the user has paid down enough
    -- This penalty is different, because this code is not responsible for creating
    -- new in-collections penalties, only for removing them
    LOOP
        tmp_grp := user_object.profile;
        LOOP
            SELECT * INTO max_fines FROM permission.grp_penalty_threshold WHERE grp = tmp_grp AND penalty = 30 AND org_unit = tmp_org.id;

            IF max_fines.threshold IS NULL THEN
                SELECT parent INTO tmp_grp FROM permission.grp_tree WHERE id = tmp_grp;
            ELSE
                EXIT;
            END IF;

            IF tmp_grp IS NULL THEN
                EXIT;
            END IF;
        END LOOP;

        IF max_fines.threshold IS NOT NULL OR tmp_org.parent_ou IS NULL THEN
            EXIT;
        END IF;

        SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;

    END LOOP;

    IF max_fines.threshold IS NOT NULL THEN

        SELECT INTO context_org_list ARRAY_AGG(id) FROM actor.org_unit_full_path( max_fines.org_unit );

        -- first, see if the user had paid down to the threshold

        -- KCLS JBAS-2334 Collections processing only counts LOST fines.
        SELECT INTO current_fines * FROM actor.usr_lost_amount_owed(match_user);

        IF current_fines IS NULL OR current_fines <= max_fines.threshold THEN
            -- patron has paid down enough

            SELECT INTO tmp_penalty * FROM config.standing_penalty WHERE id = 30;

            IF tmp_penalty.org_depth IS NOT NULL THEN

                -- since this code is not responsible for applying the penalty, it can't
                -- guarantee the current context org will match the org at which the penalty
                --- was applied.  search up the org tree until we hit the configured penalty depth
                SELECT INTO tmp_org * FROM actor.org_unit WHERE id = context_org;
                SELECT INTO tmp_depth depth FROM actor.org_unit_type WHERE id = tmp_org.ou_type;

                WHILE tmp_depth >= tmp_penalty.org_depth LOOP

                    RETURN QUERY
                        SELECT  *
                          FROM  actor.usr_standing_penalty
                          WHERE usr = match_user
                                AND org_unit = tmp_org.id
                                AND (stop_date IS NULL or stop_date > NOW())
                                AND standing_penalty = 30;

                    IF tmp_org.parent_ou IS NULL THEN
                        EXIT;
                    END IF;

                    SELECT * INTO tmp_org FROM actor.org_unit WHERE id = tmp_org.parent_ou;
                    SELECT INTO tmp_depth depth FROM actor.org_unit_type WHERE id = tmp_org.ou_type;
                END LOOP;

            ELSE

                -- no penalty depth is defined, look for exact matches

                RETURN QUERY
                    SELECT  *
                      FROM  actor.usr_standing_penalty
                      WHERE usr = match_user
                            AND org_unit = max_fines.org_unit
                            AND (stop_date IS NULL or stop_date > NOW())
                            AND standing_penalty = 30;
            END IF;

        END IF;

    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION actor.calculate_system_penalties(match_user integer, context_org integer) OWNER TO evergreen;

--
-- Name: change_password(integer, text, text); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.change_password(user_id integer, new_pw text, pw_type text DEFAULT 'main'::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_salt TEXT;
BEGIN
    SELECT actor.create_salt(pw_type) INTO new_salt;

    IF pw_type = 'main' THEN
        -- Only 'main' passwords are required to have
        -- the extra layer of MD5 hashing.
        PERFORM actor.set_passwd(
            user_id, pw_type, md5(new_salt || md5(new_pw)), new_salt
        );

    ELSE
        PERFORM actor.set_passwd(user_id, pw_type, new_pw, new_salt);
    END IF;
END;
$$;


ALTER FUNCTION actor.change_password(user_id integer, new_pw text, pw_type text) OWNER TO evergreen;

--
-- Name: FUNCTION change_password(user_id integer, new_pw text, pw_type text); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION actor.change_password(user_id integer, new_pw text, pw_type text) IS '
Allows setting a salted password for a user by passing actor.usr id and the text of the password.
';


--
-- Name: convert_usr_note_to_message(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.convert_usr_note_to_message() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	sending_ou INTEGER;
BEGIN
	IF NEW.pub THEN
		IF TG_OP = 'UPDATE' THEN
			IF OLD.pub = TRUE THEN
				RETURN NEW;
			END IF;
		END IF;

		SELECT INTO sending_ou aw.owning_lib
		FROM auditor.get_audit_info() agai
		JOIN actor.workstation aw ON (aw.id = agai.eg_ws);
		IF sending_ou IS NULL THEN
			SELECT INTO sending_ou home_ou
			FROM actor.usr
			WHERE id = NEW.creator;
		END IF;
		INSERT INTO actor.usr_message (usr, title, message, sending_lib)
			VALUES (NEW.usr, NEW.title, NEW.value, sending_ou);
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION actor.convert_usr_note_to_message() OWNER TO evergreen;

--
-- Name: create_default_pickup_location(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.create_default_pickup_location() RETURNS trigger
    LANGUAGE plpgsql COST 500
    AS $$

BEGIN          
   
    IF TG_OP = 'INSERT' THEN
	INSERT INTO actor.usr_setting (usr, name, value)
	VALUES (new.id, 'opac.default_pickup_location', '"' || new.home_ou::text || '"');
    END IF;

    IF TG_OP = 'UPDATE' THEN
	PERFORM * FROM actor.usr_setting WHERE usr = new.id AND name ILIKE 'opac.default_pickup_location';

	IF NOT FOUND THEN
	    INSERT INTO actor.usr_setting (usr, name, value)
	    VALUES (new.id, 'opac.default_pickup_location', '"' || new.home_ou::text || '"');
	ELSE
	    UPDATE actor.usr_setting SET value = '"' || new.home_ou::text || '"' WHERE usr = new.id AND name ILIKE 'opac.default_pickup_location' AND value LIKE '""';
	END IF;
	
    END IF;
    RETURN new;
END;
$$;


ALTER FUNCTION actor.create_default_pickup_location() OWNER TO evergreen;

--
-- Name: create_salt(text); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.create_salt(pw_type text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    type_row actor.passwd_type%ROWTYPE;
BEGIN
    /* Returns a new salt based on the passwd_type encryption settings.
     * Returns NULL If the password type is not crypt()'ed.
     */

    SELECT INTO type_row * FROM actor.passwd_type WHERE code = pw_type;

    IF NOT FOUND THEN
        RETURN EXCEPTION 'No such password type: %', pw_type;
    END IF;

    IF type_row.iter_count IS NULL THEN
        -- This password type is unsalted.  That's OK.
        RETURN NULL;
    END IF;

    RETURN gen_salt(type_row.crypt_algo, type_row.iter_count);
END;
$$;


ALTER FUNCTION actor.create_salt(pw_type text) OWNER TO evergreen;

--
-- Name: crypt_pw_insert(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.crypt_pw_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		NEW.passwd = MD5( NEW.passwd );
		RETURN NEW;
	END;
$$;


ALTER FUNCTION actor.crypt_pw_insert() OWNER TO evergreen;

--
-- Name: crypt_pw_update(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.crypt_pw_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		IF NEW.passwd <> OLD.passwd THEN
			NEW.passwd = MD5( NEW.passwd );
		END IF;
		RETURN NEW;
	END;
$$;


ALTER FUNCTION actor.crypt_pw_update() OWNER TO evergreen;

--
-- Name: generate_barcode(text, integer, text); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.generate_barcode(prefix text, numchars integer, seqname text) RETURNS text
    LANGUAGE sql
    AS $_$
/* 
Generate a barcode starting with 'prefix' and followed by 'numchars'
numbers.  The auto portion numbers are generated from the provided
sequence, guaranteeing uniquness across all barcodes generated with
the same sequence.  The number is left-padded with zeros to meet the
numchars size requirement.  Returns NULL if the sequnce value is 
higher than numchars can accommodate .*/
    SELECT NEXTVAL($3); -- bump the sequence up 1
    SELECT CASE                                                                
        WHEN LENGTH(CURRVAL($3)::TEXT) > $2 THEN NULL                          
        ELSE $1 || LPAD(CURRVAL($3)::TEXT, $2, '0')                            
    END; 
$_$;


ALTER FUNCTION actor.generate_barcode(prefix text, numchars integer, seqname text) OWNER TO evergreen;

--
-- Name: get_cascade_setting(text, integer, integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.get_cascade_setting(setting_name text, org_id integer, user_id integer, workstation_id integer) RETURNS actor.cascade_setting_summary
    LANGUAGE plpgsql
    AS $$
DECLARE
    setting_value JSON;
    summary actor.cascade_setting_summary;
    org_setting_type config.org_unit_setting_type%ROWTYPE;
BEGIN

    summary.name := setting_name;

    -- Collect the org setting type status first in case we exit early.
    -- The existance of an org setting type is not considered
    -- privileged information.
    SELECT INTO org_setting_type * 
        FROM config.org_unit_setting_type WHERE name = setting_name;
    IF FOUND THEN
        summary.has_org_setting := TRUE;
    ELSE
        summary.has_org_setting := FALSE;
    END IF;

    -- User and workstation settings have the same priority.
    -- Start with user settings since that's the simplest code path.
    -- The workstation_id is ignored if no user_id is provided.
    IF user_id IS NOT NULL THEN

        SELECT INTO summary.value value FROM actor.usr_setting
            WHERE usr = user_id AND name = setting_name;

        IF FOUND THEN
            -- if we have a value, we have a setting type
            summary.has_user_setting := TRUE;

            IF workstation_id IS NOT NULL THEN
                -- Only inform the caller about the workstation
                -- setting type disposition when a workstation id is
                -- provided.  Otherwise, it's NULL to indicate UNKNOWN.
                summary.has_workstation_setting := FALSE;
            END IF;

            RETURN summary;
        END IF;

        -- no user setting value, but a setting type may exist
        SELECT INTO summary.has_user_setting EXISTS (
            SELECT TRUE FROM config.usr_setting_type 
            WHERE name = setting_name
        );

        IF workstation_id IS NOT NULL THEN 

            IF NOT summary.has_user_setting THEN
                -- A workstation setting type may only exist when a user
                -- setting type does not.

                SELECT INTO summary.value value 
                    FROM actor.workstation_setting         
                    WHERE workstation = workstation_id AND name = setting_name;

                IF FOUND THEN
                    -- if we have a value, we have a setting type
                    summary.has_workstation_setting := TRUE;
                    RETURN summary;
                END IF;

                -- no value, but a setting type may exist
                SELECT INTO summary.has_workstation_setting EXISTS (
                    SELECT TRUE FROM config.workstation_setting_type 
                    WHERE name = setting_name
                );
            END IF;

            -- Finally make use of the workstation to determine the org
            -- unit if none is provided.
            IF org_id IS NULL AND summary.has_org_setting THEN
                SELECT INTO org_id owning_lib 
                    FROM actor.workstation WHERE id = workstation_id;
            END IF;
        END IF;
    END IF;

    -- Some org unit settings are protected by a view permission.
    -- First see if we have any data that needs protecting, then 
    -- check the permission if needed.

    IF NOT summary.has_org_setting THEN
        RETURN summary;
    END IF;

    -- avoid putting the value into the summary until we confirm
    -- the value should be visible to the caller.
    SELECT INTO setting_value value 
        FROM actor.org_unit_ancestor_setting(setting_name, org_id);

    IF NOT FOUND THEN
        -- No value found -- perm check is irrelevant.
        RETURN summary;
    END IF;

    IF org_setting_type.view_perm IS NOT NULL THEN

        IF user_id IS NULL THEN
            RAISE NOTICE 'Perm check required but no user_id provided';
            RETURN summary;
        END IF;

        IF NOT permission.usr_has_perm(
            user_id, (SELECT code FROM permission.perm_list 
                WHERE id = org_setting_type.view_perm), org_id) 
        THEN
            RAISE NOTICE 'Perm check failed for user % on %',
                user_id, org_setting_type.view_perm;
            RETURN summary;
        END IF;
    END IF;

    -- Perm check succeeded or was not necessary.
    summary.value := setting_value;
    RETURN summary;
END;
$$;


ALTER FUNCTION actor.get_cascade_setting(setting_name text, org_id integer, user_id integer, workstation_id integer) OWNER TO evergreen;

--
-- Name: get_cascade_setting_batch(text[], integer, integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.get_cascade_setting_batch(setting_names text[], org_id integer, user_id integer, workstation_id integer) RETURNS SETOF actor.cascade_setting_summary
    LANGUAGE plpgsql
    AS $$
-- Returns a row per setting matching the setting name order.  If no 
-- value is applied, NULL is returned to retain name-response ordering.
DECLARE
    setting_name TEXT;
    summary actor.cascade_setting_summary;
BEGIN
    FOREACH setting_name IN ARRAY setting_names LOOP
        SELECT INTO summary * FROM actor.get_cascade_setting(
            setting_Name, org_id, user_id, workstation_id);
        RETURN NEXT summary;
    END LOOP;
END;
$$;


ALTER FUNCTION actor.get_cascade_setting_batch(setting_names text[], org_id integer, user_id integer, workstation_id integer) OWNER TO evergreen;

--
-- Name: get_salt(integer, text); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.get_salt(pw_usr integer, pw_type text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    pw_salt TEXT;
    type_row actor.passwd_type%ROWTYPE;
BEGIN
    /* Returns the salt for the requested user + type.  If the password 
     * type of "main" is requested and no password exists in actor.passwd, 
     * the user's existing password is migrated and the new salt is returned.
     * Returns NULL if the password type is not crypt'ed (iter_count is NULL).
     */

    SELECT INTO pw_salt salt FROM actor.passwd 
        WHERE usr = pw_usr AND passwd_type = pw_type;

    IF FOUND THEN
        RETURN pw_salt;
    END IF;

    IF pw_type = 'main' THEN
        -- Main password has not yet been migrated. 
        -- Do it now and return the newly created salt.
        RETURN actor.migrate_passwd(pw_usr);
    END IF;

    -- We have no salt to return.  actor.create_salt() needed.
    RETURN NULL;
END;
$$;


ALTER FUNCTION actor.get_salt(pw_usr integer, pw_type text) OWNER TO evergreen;

--
-- Name: ignore_update_default_pickup_location(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.ignore_update_default_pickup_location() RETURNS trigger
    LANGUAGE plpgsql COST 500
    AS $$

BEGIN          
   
    IF TG_OP = 'UPDATE' AND new.value ILIKE '""' AND new.name ILIKE 'opac.default_pickup_location' THEN
	SELECT '"' || au.home_ou::text || '"' INTO new.value FROM actor.usr AS au WHERE au.id = new.usr;
    END IF;

    RETURN new;

END;
$$;


ALTER FUNCTION actor.ignore_update_default_pickup_location() OWNER TO evergreen;

--
-- Name: ignore_update_default_search_location(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.ignore_update_default_search_location() RETURNS trigger
    LANGUAGE plpgsql COST 500
    AS $$

BEGIN          
   
    IF TG_OP = 'UPDATE' AND new.value NOT ILIKE '"1"' AND new.name ILIKE 'opac.default_search_location' THEN
                SELECT '"1"' INTO new.value FROM actor.usr AS au WHERE au.id = new.usr;
    ELSIF TG_OP = 'INSERT' AND new.value NOT ILIKE '"1"' AND new.name ILIKE 'opac.default_search_location' THEN
                SELECT '"1"' INTO new.value FROM actor.usr AS au WHERE au.id = new.usr;
    END IF;

    RETURN new;

END;
$$;


ALTER FUNCTION actor.ignore_update_default_search_location() OWNER TO evergreen;

--
-- Name: usr_activity; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.usr_activity (
    id bigint NOT NULL,
    usr integer,
    etype integer NOT NULL,
    event_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE actor.usr_activity OWNER TO evergreen;

--
-- Name: insert_usr_activity(integer, text, text, text); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.insert_usr_activity(usr integer, ewho text, ewhat text, ehow text) RETURNS SETOF actor.usr_activity
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_row actor.usr_activity%ROWTYPE;
BEGIN
    SELECT id INTO new_row.etype FROM actor.usr_activity_get_type(ewho, ewhat, ehow);
    IF FOUND THEN
        new_row.usr := usr;
        INSERT INTO actor.usr_activity (usr, etype) 
            VALUES (usr, new_row.etype)
            RETURNING * INTO new_row;
        RETURN NEXT new_row;
    END IF;
END;
$$;


ALTER FUNCTION actor.insert_usr_activity(usr integer, ewho text, ewhat text, ehow text) OWNER TO evergreen;

--
-- Name: migrate_passwd(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.migrate_passwd(pw_usr integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    pw_salt TEXT;
    usr_row actor.usr%ROWTYPE;
BEGIN
    /* Migrates legacy actor.usr.passwd value to actor.passwd with 
     * a password type 'main' and returns the new salt.  For backwards
     * compatibility with existing CHAP-style API's, we perform a 
     * layer of intermediate MD5(MD5()) hashing.  This is intermediate
     * hashing is not required of other passwords.
     */

    -- Avoid calling get_salt() here, because it may result in a 
    -- migrate_passwd() call, creating a loop.
    SELECT INTO pw_salt salt FROM actor.passwd 
        WHERE usr = pw_usr AND passwd_type = 'main';

    -- Only migrate passwords that have not already been migrated.
    IF FOUND THEN
        RETURN pw_salt;
    END IF;

    SELECT INTO usr_row * FROM actor.usr WHERE id = pw_usr;

    pw_salt := actor.create_salt('main');

    PERFORM actor.set_passwd(
        pw_usr, 'main', MD5(pw_salt || usr_row.passwd), pw_salt);

    -- clear the existing password
    UPDATE actor.usr SET passwd = '' WHERE id = usr_row.id;

    RETURN pw_salt;
END;
$$;


ALTER FUNCTION actor.migrate_passwd(pw_usr integer) OWNER TO evergreen;

--
-- Name: org_unit; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.org_unit (
    id integer NOT NULL,
    parent_ou integer,
    ou_type integer NOT NULL,
    ill_address integer,
    holds_address integer,
    mailing_address integer,
    billing_address integer,
    shortname text NOT NULL,
    name text NOT NULL,
    email text,
    phone text,
    opac_visible boolean DEFAULT true NOT NULL,
    fiscal_calendar integer DEFAULT 1 NOT NULL
);


ALTER TABLE actor.org_unit OWNER TO evergreen;

--
-- Name: org_unit_ancestor_at_depth(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_ancestor_at_depth(integer, integer) RETURNS actor.org_unit
    LANGUAGE sql STABLE
    AS $_$
	SELECT	a.*
	  FROM	actor.org_unit a
	  WHERE	id = ( SELECT FIRST(x.id)
	  		 FROM	actor.org_unit_ancestors($1) x
			   	JOIN actor.org_unit_type y
					ON x.ou_type = y.id AND y.depth = $2);
$_$;


ALTER FUNCTION actor.org_unit_ancestor_at_depth(integer, integer) OWNER TO evergreen;

--
-- Name: is_json(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.is_json(text) RETURNS boolean
    LANGUAGE plperlu
    AS $_$
    use JSON::XS;                    
    my $json = shift();
    eval { JSON::XS->new->allow_nonref->decode( $json ) };   
    return $@ ? 0 : 1;
$_$;


ALTER FUNCTION evergreen.is_json(text) OWNER TO evergreen;

--
-- Name: org_unit_setting; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.org_unit_setting (
    id bigint NOT NULL,
    org_unit integer NOT NULL,
    name text NOT NULL,
    value text NOT NULL,
    CONSTRAINT aous_must_be_json CHECK (evergreen.is_json(value))
);


ALTER TABLE actor.org_unit_setting OWNER TO evergreen;

--
-- Name: TABLE org_unit_setting; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.org_unit_setting IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Org Unit settings
 *
 * This table contains any arbitrary settings that a client
 * program would like to save for an org unit.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: org_unit_ancestor_setting(text, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_ancestor_setting(setting_name text, org_id integer) RETURNS SETOF actor.org_unit_setting
    LANGUAGE plpgsql STABLE ROWS 1
    AS $$
DECLARE
    setting RECORD;
    cur_org INT;
BEGIN
    cur_org := org_id;
    LOOP
        SELECT INTO setting * FROM actor.org_unit_setting WHERE org_unit = cur_org AND name = setting_name;
        IF FOUND THEN
            RETURN NEXT setting;
            EXIT;
        END IF;
        SELECT INTO cur_org parent_ou FROM actor.org_unit WHERE id = cur_org;
        EXIT WHEN cur_org IS NULL;
    END LOOP;
    RETURN;
END;
$$;


ALTER FUNCTION actor.org_unit_ancestor_setting(setting_name text, org_id integer) OWNER TO evergreen;

--
-- Name: FUNCTION org_unit_ancestor_setting(setting_name text, org_id integer); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION actor.org_unit_ancestor_setting(setting_name text, org_id integer) IS '
/**
* Search "up" the org_unit tree until we find the first occurrence of an 
* org_unit_setting with the given name.
*/
';


--
-- Name: org_unit_ancestor_setting_batch(integer, text[]); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_ancestor_setting_batch(org_id integer, setting_names text[]) RETURNS SETOF actor.org_unit_setting
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    setting RECORD;
    setting_name TEXT;
    cur_org INT;
BEGIN
    FOREACH setting_name IN ARRAY setting_names
    LOOP
        cur_org := org_id;
        LOOP
            SELECT INTO setting * FROM actor.org_unit_setting WHERE org_unit = cur_org AND name = setting_name;
            IF FOUND THEN
                RETURN NEXT setting;
                EXIT;
            END IF;
            SELECT INTO cur_org parent_ou FROM actor.org_unit WHERE id = cur_org;
            EXIT WHEN cur_org IS NULL;
        END LOOP;
    END LOOP;
    RETURN;
END;
$$;


ALTER FUNCTION actor.org_unit_ancestor_setting_batch(org_id integer, setting_names text[]) OWNER TO evergreen;

--
-- Name: FUNCTION org_unit_ancestor_setting_batch(org_id integer, setting_names text[]); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION actor.org_unit_ancestor_setting_batch(org_id integer, setting_names text[]) IS '
For each setting name passed, search "up" the org_unit tree until
we find the first occurrence of an org_unit_setting with the given name.
';


--
-- Name: org_unit_ancestor_setting_batch_by_org(text, integer[]); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_ancestor_setting_batch_by_org(setting_name text, org_ids integer[]) RETURNS SETOF actor.org_unit_setting
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    setting RECORD;
    org_id INTEGER;
BEGIN
    /*  Returns one actor.org_unit_setting row per org unit ID provided.
        When no setting exists for a given org unit, the setting row
        will contain all empty values. */
    FOREACH org_id IN ARRAY org_ids LOOP
        SELECT INTO setting * FROM 
            actor.org_unit_ancestor_setting(setting_name, org_id);
        RETURN NEXT setting;
    END LOOP;
    RETURN;
END;
$$;


ALTER FUNCTION actor.org_unit_ancestor_setting_batch_by_org(setting_name text, org_ids integer[]) OWNER TO evergreen;

--
-- Name: org_unit_ancestors(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_ancestors(integer) RETURNS SETOF actor.org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE org_unit_ancestors_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT ou.parent_ou, ouad.distance+1
            FROM actor.org_unit ou JOIN org_unit_ancestors_distance ouad ON (ou.id = ouad.id)
            WHERE ou.parent_ou IS NOT NULL
    )
    SELECT ou.* FROM actor.org_unit ou JOIN org_unit_ancestors_distance ouad USING (id) ORDER BY ouad.distance DESC;
$_$;


ALTER FUNCTION actor.org_unit_ancestors(integer) OWNER TO evergreen;

--
-- Name: org_unit_ancestors_distance(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_ancestors_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE org_unit_ancestors_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT ou.parent_ou, ouad.distance+1
            FROM actor.org_unit ou JOIN org_unit_ancestors_distance ouad ON (ou.id = ouad.id)
            WHERE ou.parent_ou IS NOT NULL
    )
    SELECT * FROM org_unit_ancestors_distance;
$_$;


ALTER FUNCTION actor.org_unit_ancestors_distance(integer) OWNER TO evergreen;

--
-- Name: org_unit_combined_ancestors(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_combined_ancestors(integer, integer) RETURNS SETOF actor.org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
	SELECT	*
	  FROM	actor.org_unit_ancestors($1)
			UNION
	SELECT	*
	  FROM	actor.org_unit_ancestors($2);
$_$;


ALTER FUNCTION actor.org_unit_combined_ancestors(integer, integer) OWNER TO evergreen;

--
-- Name: org_unit_common_ancestors(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_common_ancestors(integer, integer) RETURNS SETOF actor.org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
	SELECT	*
	  FROM	actor.org_unit_ancestors($1)
			INTERSECT
	SELECT	*
	  FROM	actor.org_unit_ancestors($2);
$_$;


ALTER FUNCTION actor.org_unit_common_ancestors(integer, integer) OWNER TO evergreen;

--
-- Name: org_unit_descendants(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_descendants(integer) RETURNS SETOF actor.org_unit
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE descendant_depth AS (
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
          WHERE ou.id = $1
            UNION ALL
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN descendant_depth ot ON (ot.id = ou.parent_ou)
    ) SELECT ou.* FROM actor.org_unit ou JOIN descendant_depth USING (id);
$_$;


ALTER FUNCTION actor.org_unit_descendants(integer) OWNER TO evergreen;

--
-- Name: org_unit_descendants(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_descendants(integer, integer) RETURNS SETOF actor.org_unit
    LANGUAGE sql STABLE ROWS 100
    AS $_$
    WITH RECURSIVE descendant_depth AS (
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN anscestor_depth ad ON (ad.id = ou.id)
          WHERE ad.depth = $2
            UNION ALL
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN descendant_depth ot ON (ot.id = ou.parent_ou)
    ), anscestor_depth AS (
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
          WHERE ou.id = $1
            UNION ALL
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
          FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN anscestor_depth ot ON (ot.parent_ou = ou.id)
    ) SELECT ou.* FROM actor.org_unit ou JOIN descendant_depth USING (id);
$_$;


ALTER FUNCTION actor.org_unit_descendants(integer, integer) OWNER TO evergreen;

--
-- Name: org_unit_descendants_distance(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_descendants_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE org_unit_descendants_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT ou.id, oudd.distance+1
            FROM actor.org_unit ou JOIN org_unit_descendants_distance oudd ON ou.parent_ou = oudd.id
    )
    SELECT * FROM org_unit_descendants_distance;
$_$;


ALTER FUNCTION actor.org_unit_descendants_distance(integer) OWNER TO evergreen;

--
-- Name: org_unit_full_path(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_full_path(integer) RETURNS SETOF actor.org_unit
    LANGUAGE sql STABLE
    AS $_$
    SELECT  aou.*
      FROM  actor.org_unit AS aou
            JOIN (
                (SELECT au.id, t.depth FROM actor.org_unit_ancestors($1) AS au JOIN actor.org_unit_type t ON (au.ou_type = t.id))
                    UNION
                (SELECT au.id, t.depth FROM actor.org_unit_descendants($1) AS au JOIN actor.org_unit_type t ON (au.ou_type = t.id))
            ) AS ad ON (aou.id=ad.id)
      ORDER BY ad.depth;
$_$;


ALTER FUNCTION actor.org_unit_full_path(integer) OWNER TO evergreen;

--
-- Name: org_unit_full_path(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_full_path(integer, integer) RETURNS SETOF actor.org_unit
    LANGUAGE sql STABLE ROWS 2
    AS $_$
	SELECT	* FROM actor.org_unit_full_path((actor.org_unit_ancestor_at_depth($1, $2)).id)
$_$;


ALTER FUNCTION actor.org_unit_full_path(integer, integer) OWNER TO evergreen;

--
-- Name: org_unit_parent_protect(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_parent_protect() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	DECLARE
		current_aou actor.org_unit%ROWTYPE;
		seen_ous    INT[];
		depth_count INT;
	BEGIN
		current_aou := NEW;
		depth_count := 0;
		seen_ous := ARRAY[NEW.id];

		IF (TG_OP = 'UPDATE') THEN
			IF (NEW.parent_ou IS NOT DISTINCT FROM OLD.parent_ou) THEN
				RETURN NEW; -- Doing an UPDATE with no change, just return it
			END IF;
		END IF;

		LOOP
			IF current_aou.parent_ou IS NULL THEN -- Top of the org tree?
				RETURN NEW; -- No loop. Carry on.
			END IF;
			IF current_aou.parent_ou = ANY(seen_ous) THEN -- Parent is one we have seen?
				RAISE 'OU LOOP: Saw % twice', current_aou.parent_ou; -- LOOP! ABORT!
			END IF;
			-- Get the next one!
			SELECT INTO current_aou * FROM actor.org_unit WHERE id = current_aou.parent_ou;
			seen_ous := seen_ous || current_aou.id;
			depth_count := depth_count + 1;
			IF depth_count = 100 THEN
				RAISE 'OU CHECK TOO DEEP';
			END IF;
		END LOOP;

		RETURN NEW;
	END;
$$;


ALTER FUNCTION actor.org_unit_parent_protect() OWNER TO evergreen;

--
-- Name: org_unit_prox_update(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_prox_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN


IF TG_OP = 'DELETE' THEN

    DELETE FROM actor.org_unit_proximity WHERE (from_org = OLD.id or to_org= OLD.id);

END IF;

IF TG_OP = 'UPDATE' THEN

    IF NEW.parent_ou <> OLD.parent_ou THEN

        DELETE FROM actor.org_unit_proximity WHERE (from_org = OLD.id or to_org= OLD.id);
            INSERT INTO actor.org_unit_proximity (from_org, to_org, prox)
            SELECT  l.id, r.id, actor.org_unit_proximity(l.id,r.id)
                FROM  actor.org_unit l, actor.org_unit r
                WHERE (l.id = NEW.id or r.id = NEW.id);

    END IF;

END IF;

IF TG_OP = 'INSERT' THEN

     INSERT INTO actor.org_unit_proximity (from_org, to_org, prox)
     SELECT  l.id, r.id, actor.org_unit_proximity(l.id,r.id)
         FROM  actor.org_unit l, actor.org_unit r
         WHERE (l.id = NEW.id or r.id = NEW.id);

END IF;

RETURN null;

END;
$$;


ALTER FUNCTION actor.org_unit_prox_update() OWNER TO evergreen;

--
-- Name: org_unit_proximity(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_proximity(integer, integer) RETURNS integer
    LANGUAGE sql STABLE
    AS $_$
	SELECT COUNT(id)::INT FROM (
		SELECT id FROM actor.org_unit_combined_ancestors($1, $2)
			EXCEPT
		SELECT id FROM actor.org_unit_common_ancestors($1, $2)
	) z;
$_$;


ALTER FUNCTION actor.org_unit_proximity(integer, integer) OWNER TO evergreen;

--
-- Name: org_unit_simple_path(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.org_unit_simple_path(integer, integer) RETURNS integer[]
    LANGUAGE sql STABLE
    AS $_$
    WITH RECURSIVE descendant_depth(id, path) AS (
        SELECT  aou.id,
                ARRAY[aou.id]
          FROM  actor.org_unit aou
                JOIN actor.org_unit_type aout ON (aout.id = aou.ou_type)
          WHERE aou.id = $2
            UNION ALL
        SELECT  aou.id,
                dd.path || ARRAY[aou.id]
          FROM  actor.org_unit aou
                JOIN actor.org_unit_type aout ON (aout.id = aou.ou_type)
                JOIN descendant_depth dd ON (dd.id = aou.parent_ou)
    ) SELECT dd.path
        FROM actor.org_unit aou
        JOIN descendant_depth dd USING (id)
        WHERE aou.id = $1 ORDER BY dd.path;
$_$;


ALTER FUNCTION actor.org_unit_simple_path(integer, integer) OWNER TO evergreen;

--
-- Name: permit_remoteauth(text, bigint); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.permit_remoteauth(profile_name text, userid bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    usr               actor.usr%ROWTYPE;
    profile           config.remoteauth_profile%ROWTYPE;
    perm              TEXT;
    context_org_list  INT[];
    home_prox         INT;
    block             TEXT;
    penalty_count     INT;
BEGIN

    SELECT INTO usr * FROM actor.usr WHERE id = userid AND NOT deleted;
    IF usr IS NULL THEN
        RETURN 'not_found';
    END IF;

    IF usr.barred IS TRUE THEN
        RETURN 'blocked';
    END IF;

    SELECT INTO profile * FROM config.remoteauth_profile WHERE name = profile_name;
    SELECT INTO context_org_list ARRAY_AGG(id) FROM actor.org_unit_full_path( profile.context_org );

    -- user's home library must be within the context org
    IF profile.restrict_to_org IS TRUE AND usr.home_ou NOT IN (SELECT * FROM UNNEST(context_org_list)) THEN
        RETURN 'not_found';
    END IF;

    SELECT INTO perm code FROM permission.perm_list WHERE id = profile.perm;
    IF permission.usr_has_perm(usr.id, perm, profile.context_org) IS FALSE THEN
        RETURN 'not_found';
    END IF;
    
    IF usr.expire_date < NOW() AND profile.allow_expired IS FALSE THEN
        RETURN 'expired';
    END IF;

    IF usr.active IS FALSE AND profile.allow_inactive IS FALSE THEN
        RETURN 'blocked';
    END IF;

    -- Proximity of user's home_ou to context_org to see if penalties should be ignored.
    SELECT INTO home_prox prox FROM actor.org_unit_proximity WHERE from_org = usr.home_ou AND to_org = profile.context_org;

    -- Loop through the block list to see if the user has any matching penalties.
    IF profile.block_list IS NOT NULL THEN
        FOR block IN SELECT UNNEST(STRING_TO_ARRAY(profile.block_list, '|')) LOOP
            SELECT INTO penalty_count COUNT(DISTINCT csp.*)
                FROM  actor.usr_standing_penalty usp
                        JOIN config.standing_penalty csp ON (csp.id = usp.standing_penalty)
                WHERE usp.usr = usr.id
                        AND usp.org_unit IN ( SELECT * FROM UNNEST(context_org_list) )
                        AND ( usp.stop_date IS NULL or usp.stop_date > NOW() )
                        AND ( csp.ignore_proximity IS NULL OR csp.ignore_proximity < home_prox )
                        AND csp.block_list ~ block;
            IF penalty_count > 0 THEN
                -- User has penalties that match this block, so auth is not permitted.
                -- Don't bother testing the rest of the block list.
                RETURN 'blocked';
            END IF;
        END LOOP;
    END IF;

    -- User has passed all tests.
    RETURN 'success';

END;
$$;


ALTER FUNCTION actor.permit_remoteauth(profile_name text, userid bigint) OWNER TO evergreen;

--
-- Name: purge_expired_users(integer, interval); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.purge_expired_users(profile_grp integer, expired_for interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    purge_count INTEGER DEFAULT 0;
    user_id INTEGER;
BEGIN
    FOR user_id IN 
        SELECT id FROM actor.usr
        WHERE profile = profile_grp AND NOT deleted
            -- Never purge active users (possible w/ negative intervals)
            AND expire_date < NOW()
            AND (NOW() - expire_date) > expired_for 
    LOOP

        RAISE NOTICE 'Purging user %', user_id;
        PERFORM actor.usr_delete(user_id, NULL::INTEGER);
        purge_count := purge_count + 1;

    END LOOP;
    RETURN purge_count;
END;
$$;


ALTER FUNCTION actor.purge_expired_users(profile_grp integer, expired_for interval) OWNER TO evergreen;

--
-- Name: purge_usr_activity_by_type(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.purge_usr_activity_by_type(act_type integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    cur_usr INTEGER;
BEGIN
    FOR cur_usr IN SELECT DISTINCT(usr) 
        FROM actor.usr_activity WHERE etype = act_type LOOP
        DELETE FROM actor.usr_activity WHERE id IN (
            SELECT id 
            FROM actor.usr_activity 
            WHERE usr = cur_usr AND etype = act_type
            ORDER BY event_time DESC OFFSET 1
        );

    END LOOP;
END $$;


ALTER FUNCTION actor.purge_usr_activity_by_type(act_type integer) OWNER TO evergreen;

--
-- Name: restrict_usr_message_limited(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.restrict_usr_message_limited() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        UPDATE actor.usr_message
        SET    read_date = NEW.read_date,
               deleted   = NEW.deleted
        WHERE  id = NEW.id;
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$;


ALTER FUNCTION actor.restrict_usr_message_limited() OWNER TO evergreen;

--
-- Name: set_passwd(integer, text, text, text); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.set_passwd(pw_usr integer, pw_type text, new_pass text, new_salt text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    pw_salt TEXT;
    pw_text TEXT;
BEGIN
    /* Sets the password value, creating a new actor.passwd row if needed.
     * If the password type supports it, the new_pass value is crypt()'ed.
     * For crypt'ed passwords, the salt comes from one of 3 places in order:
     * new_salt (if present), existing salt (if present), newly created 
     * salt.
     */

    IF new_salt IS NOT NULL THEN
        pw_salt := new_salt;
    ELSE 
        pw_salt := actor.get_salt(pw_usr, pw_type);

        IF pw_salt IS NULL THEN
            /* We have no salt for this user + type.  Assume they want a 
             * new salt.  If this type is unsalted, create_salt() will 
             * return NULL. */
            pw_salt := actor.create_salt(pw_type);
        END IF;
    END IF;

    IF pw_salt IS NULL THEN 
        pw_text := new_pass; -- unsalted, use as-is.
    ELSE
        pw_text := CRYPT(new_pass, pw_salt);
    END IF;

    UPDATE actor.passwd 
        SET passwd = pw_text, salt = pw_salt, edit_date = NOW()
        WHERE usr = pw_usr AND passwd_type = pw_type;

    IF NOT FOUND THEN
        -- no password row exists for this user + type.  Create one.
        INSERT INTO actor.passwd (usr, passwd_type, salt, passwd) 
            VALUES (pw_usr, pw_type, pw_salt, pw_text);
    END IF;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION actor.set_passwd(pw_usr integer, pw_type text, new_pass text, new_salt text) OWNER TO evergreen;

--
-- Name: stat_cat_check(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.stat_cat_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sipfield actor.stat_cat_sip_fields%ROWTYPE;
    use_count INT;
BEGIN
    IF NEW.sip_field IS NOT NULL THEN
        SELECT INTO sipfield * FROM actor.stat_cat_sip_fields WHERE field = NEW.sip_field;
        IF sipfield.one_only THEN
            SELECT INTO use_count count(id) FROM actor.stat_cat WHERE sip_field = NEW.sip_field AND id != NEW.id;
            IF use_count > 0 THEN
                RAISE EXCEPTION 'Sip field cannot be used twice';
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION actor.stat_cat_check() OWNER TO evergreen;

--
-- Name: user_ingest_name_keywords(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.user_ingest_name_keywords() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.name_kw_tsvector := TO_TSVECTOR(
        COALESCE(NEW.prefix, '')                || ' ' || 
        COALESCE(NEW.first_given_name, '')      || ' ' || 
        COALESCE(evergreen.unaccent_and_squash(NEW.first_given_name), '') || ' ' || 
        COALESCE(NEW.second_given_name, '')     || ' ' || 
        COALESCE(evergreen.unaccent_and_squash(NEW.second_given_name), '') || ' ' || 
        COALESCE(NEW.family_name, '')           || ' ' || 
        COALESCE(evergreen.unaccent_and_squash(NEW.family_name), '') || ' ' || 
        COALESCE(NEW.suffix, '')                || ' ' || 
        COALESCE(NEW.pref_prefix, '')            || ' ' || 
        COALESCE(NEW.pref_first_given_name, '')  || ' ' || 
        COALESCE(evergreen.unaccent_and_squash(NEW.pref_first_given_name), '') || ' ' || 
        COALESCE(NEW.pref_second_given_name, '') || ' ' || 
        COALESCE(evergreen.unaccent_and_squash(NEW.pref_second_given_name), '') || ' ' || 
        COALESCE(NEW.pref_family_name, '')       || ' ' || 
        COALESCE(evergreen.unaccent_and_squash(NEW.pref_family_name), '') || ' ' || 
        COALESCE(NEW.pref_suffix, '')            || ' ' || 
        COALESCE(NEW.name_keywords, '')
    );
    RETURN NEW;
END;
$$;


ALTER FUNCTION actor.user_ingest_name_keywords() OWNER TO evergreen;

--
-- Name: usr_activity_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.usr_activity_type (
    id integer NOT NULL,
    ewho text,
    ewhat text,
    ehow text,
    label text NOT NULL,
    egroup config.usr_activity_group NOT NULL,
    enabled boolean DEFAULT true NOT NULL,
    transient boolean DEFAULT false NOT NULL,
    CONSTRAINT one_of_wwh CHECK ((COALESCE(ewho, ewhat, ehow) IS NOT NULL))
);


ALTER TABLE config.usr_activity_type OWNER TO evergreen;

--
-- Name: usr_activity_get_type(text, text, text); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.usr_activity_get_type(ewho text, ewhat text, ehow text) RETURNS SETOF config.usr_activity_type
    LANGUAGE sql
    AS $_$
SELECT * FROM config.usr_activity_type 
    WHERE 
        enabled AND 
        (ewho  IS NULL OR ewho  = $1) AND
        (ewhat IS NULL OR ewhat = $2) AND
        (ehow  IS NULL OR ehow  = $3) 
    ORDER BY 
        -- BOOL comparisons sort false to true
        COALESCE(ewho, '')  != COALESCE($1, ''),
        COALESCE(ewhat,'')  != COALESCE($2, ''),
        COALESCE(ehow, '')  != COALESCE($3, '') 
    LIMIT 1;
$_$;


ALTER FUNCTION actor.usr_activity_get_type(ewho text, ewhat text, ehow text) OWNER TO evergreen;

--
-- Name: usr_activity_transient_trg(); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.usr_activity_transient_trg() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM actor.usr_activity act USING config.usr_activity_type atype
        WHERE atype.transient AND 
            NEW.etype = atype.id AND
            act.etype = atype.id AND
            act.usr = NEW.usr;
    RETURN NEW;
END;
$$;


ALTER FUNCTION actor.usr_activity_transient_trg() OWNER TO evergreen;

--
-- Name: usr_delete(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.usr_delete(src_usr integer, dest_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	old_profile actor.usr.profile%type;
	old_home_ou actor.usr.home_ou%type;
	new_profile actor.usr.profile%type;
	new_home_ou actor.usr.home_ou%type;
	new_name    text;
	new_dob     actor.usr.dob%type;
BEGIN
	SELECT
		id || '-PURGED-' || now(),
		profile,
		home_ou,
		dob
	INTO
		new_name,
		old_profile,
		old_home_ou,
		new_dob
	FROM
		actor.usr
	WHERE
		id = src_usr;
	--
	-- Quit if no such user
	--
	IF old_profile IS NULL THEN
		RETURN;
	END IF;
	--
	perform actor.usr_purge_data( src_usr, dest_usr );
	--
	-- Find the root grp_tree and the root org_unit.  This would be simpler if we 
	-- could assume that there is only one root.  Theoretically, someday, maybe,
	-- there could be multiple roots, so we take extra trouble to get the right ones.
	--
	SELECT
		id
	INTO
		new_profile
	FROM
		permission.grp_ancestors( old_profile )
	WHERE
		parent is null;
	--
	SELECT
		id
	INTO
		new_home_ou
	FROM
		actor.org_unit_ancestors( old_home_ou )
	WHERE
		parent_ou is null;
	--
	-- Truncate date of birth
	--
	IF new_dob IS NOT NULL THEN
		new_dob := date_trunc( 'year', new_dob );
	END IF;
	--
	UPDATE
		actor.usr
		SET
			card = NULL,
			profile = new_profile,
			usrname = new_name,
			email = NULL,
			passwd = random()::text,
			standing = DEFAULT,
			ident_type = 
			(
				SELECT MIN( id )
				FROM config.identification_type
			),
			ident_value = NULL,
			ident_type2 = NULL,
			ident_value2 = NULL,
			net_access_level = DEFAULT,
			photo_url = NULL,
			prefix = NULL,
			first_given_name = new_name,
			second_given_name = NULL,
			family_name = new_name,
			suffix = NULL,
			alias = NULL,
            guardian = NULL,
			day_phone = NULL,
			evening_phone = NULL,
			other_phone = NULL,
			mailing_address = NULL,
			billing_address = NULL,
			home_ou = new_home_ou,
			dob = new_dob,
			active = FALSE,
			master_account = DEFAULT, 
			super_user = DEFAULT,
			barred = FALSE,
			deleted = TRUE,
			juvenile = DEFAULT,
			usrgroup = 0,
			claims_returned_count = DEFAULT,
			credit_forward_balance = DEFAULT,
			last_xact_id = DEFAULT,
			pref_prefix = NULL,
			pref_first_given_name = NULL,
			pref_second_given_name = NULL,
			pref_family_name = NULL,
			pref_suffix = NULL,
			name_keywords = NULL,
			create_date = now(),
			expire_date = now()
	WHERE
		id = src_usr;
END;
$$;


ALTER FUNCTION actor.usr_delete(src_usr integer, dest_usr integer) OWNER TO evergreen;

--
-- Name: FUNCTION usr_delete(src_usr integer, dest_usr integer); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION actor.usr_delete(src_usr integer, dest_usr integer) IS '
/**
 * Logically deletes a user.  Removes personally identifiable information,
 * and purges associated data in other tables.
 */
';


--
-- Name: usr_lost_amount_owed(integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.usr_lost_amount_owed(usr_id integer) RETURNS numeric
    LANGUAGE sql STABLE
    AS $_$
    -- Returns the amount owed by the requested patron in LOST charges.
    -- Negative balances are ignored, so the amount returned can        
    -- conceivably be greater than the total amount owed by the patron. 

    WITH user_lost_bills AS (
        -- Returns one row per active lost billing for the requested user.

        SELECT
            xact.usr,
            xact.id AS xact_id,
            xact.balance_owed,
            bill.id AS bill_id,
            bill.amount AS bill_amount
        FROM money.materialized_billable_xact_summary xact
        JOIN money.billing bill ON bill.xact = xact.id
        WHERE   xact.xact_finish IS NULL
            AND xact.balance_owed > 0
            AND bill.btype = 3 -- Lost Materials
            AND NOT bill.voided
            AND xact.usr = $1 -- usr_id

    ), lost_owed_per_xact AS (
        -- Returns the total amount owed per transaction containing a
        -- LOST billing.  There should only ever be one lost billing per
        -- transaction, but SUM the bills to be safe.

        SELECT
            lost_bills.xact_id,
            lost_bills.usr,
            -- Lost owed per transaction is any remaining balance owed
            -- on the transaction up to the lost billing amount.  This
            -- implies any money applied to the transaction covers the
            -- lost charges last.
            LEAST(lost_bills.balance_owed, SUM(lost_bills.bill_amount)) AS lost_owed
        FROM user_lost_bills lost_bills
        GROUP BY 
            lost_bills.xact_id, 
            lost_bills.usr, 
            lost_bills.balance_owed
    )

    SELECT COALESCE(SUM(lost_per_xact.lost_owed), 0) AS total_lost_owed
    FROM lost_owed_per_xact lost_per_xact

$_$;


ALTER FUNCTION actor.usr_lost_amount_owed(usr_id integer) OWNER TO evergreen;

--
-- Name: usr_merge(integer, integer, boolean, boolean, boolean); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	suffix TEXT;
	bucket_row RECORD;
	picklist_row RECORD;
	queue_row RECORD;
	folder_row RECORD;
BEGIN

    -- Bail if src_usr equals dest_usr because the result of merging a
    -- user with itself is not what you want.
    IF src_usr = dest_usr THEN
        RETURN;
    END IF;

    -- do some initial cleanup 
    UPDATE actor.usr SET card = NULL WHERE id = src_usr;
    UPDATE actor.usr SET mailing_address = NULL WHERE id = src_usr;
    UPDATE actor.usr SET billing_address = NULL WHERE id = src_usr;

    -- actor.*
    IF del_cards THEN
        DELETE FROM actor.card where usr = src_usr;
    ELSE
        IF deactivate_cards THEN
            UPDATE actor.card SET active = 'f' WHERE usr = src_usr;
        END IF;
        UPDATE actor.card SET usr = dest_usr WHERE usr = src_usr;
    END IF;


    IF del_addrs THEN
        DELETE FROM actor.usr_address WHERE usr = src_usr;
    ELSE
        UPDATE actor.usr_address SET usr = dest_usr WHERE usr = src_usr;
    END IF;

    UPDATE actor.usr_message SET usr = dest_usr WHERE usr = src_usr;
    -- dupes are technically OK in actor.usr_standing_penalty, should manually delete them...
    UPDATE actor.usr_standing_penalty SET usr = dest_usr WHERE usr = src_usr;
    PERFORM actor.usr_merge_rows('actor.usr_org_unit_opt_in', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('actor.usr_setting', 'usr', src_usr, dest_usr);

    -- permission.*
    PERFORM actor.usr_merge_rows('permission.usr_perm_map', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('permission.usr_object_perm_map', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('permission.usr_grp_map', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('permission.usr_work_ou_map', 'usr', src_usr, dest_usr);


    -- container.*
	
	-- For each *_bucket table: transfer every bucket belonging to src_usr
	-- into the custody of dest_usr.
	--
	-- In order to avoid colliding with an existing bucket owned by
	-- the destination user, append the source user's id (in parenthesese)
	-- to the name.  If you still get a collision, add successive
	-- spaces to the name and keep trying until you succeed.
	--
	FOR bucket_row in
		SELECT id, name
		FROM   container.biblio_record_entry_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.biblio_record_entry_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR bucket_row in
		SELECT id, name
		FROM   container.call_number_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.call_number_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR bucket_row in
		SELECT id, name
		FROM   container.copy_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.copy_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR bucket_row in
		SELECT id, name
		FROM   container.user_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.user_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = bucket_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	UPDATE container.user_bucket_item SET target_user = dest_usr WHERE target_user = src_usr;

    -- vandelay.*
	-- transfer queues the same way we transfer buckets (see above)
	FOR queue_row in
		SELECT id, name
		FROM   vandelay.queue
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  vandelay.queue
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = queue_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

    UPDATE vandelay.session_tracker SET usr = dest_usr WHERE usr = src_usr;

    -- money.*
    PERFORM actor.usr_merge_rows('money.collections_tracker', 'usr', src_usr, dest_usr);
    PERFORM actor.usr_merge_rows('money.collections_tracker', 'collector', src_usr, dest_usr);
    UPDATE money.billable_xact SET usr = dest_usr WHERE usr = src_usr;
    UPDATE money.billing SET voider = dest_usr WHERE voider = src_usr;
    UPDATE money.bnm_payment SET accepting_usr = dest_usr WHERE accepting_usr = src_usr;

    -- action.*
    UPDATE action.circulation SET usr = dest_usr WHERE usr = src_usr;
    UPDATE action.circulation SET circ_staff = dest_usr WHERE circ_staff = src_usr;
    UPDATE action.circulation SET checkin_staff = dest_usr WHERE checkin_staff = src_usr;
    UPDATE action.usr_circ_history SET usr = dest_usr WHERE usr = src_usr;

    UPDATE action.hold_request SET usr = dest_usr WHERE usr = src_usr;
    UPDATE action.hold_request SET fulfillment_staff = dest_usr WHERE fulfillment_staff = src_usr;
    UPDATE action.hold_request SET requestor = dest_usr WHERE requestor = src_usr;
    UPDATE action.hold_notification SET notify_staff = dest_usr WHERE notify_staff = src_usr;

    UPDATE action.in_house_use SET staff = dest_usr WHERE staff = src_usr;
    UPDATE action.non_cataloged_circulation SET staff = dest_usr WHERE staff = src_usr;
    UPDATE action.non_cataloged_circulation SET patron = dest_usr WHERE patron = src_usr;
    UPDATE action.non_cat_in_house_use SET staff = dest_usr WHERE staff = src_usr;
    UPDATE action.survey_response SET usr = dest_usr WHERE usr = src_usr;

    -- acq.*
    UPDATE acq.fund_allocation SET allocator = dest_usr WHERE allocator = src_usr;
	UPDATE acq.fund_transfer SET transfer_user = dest_usr WHERE transfer_user = src_usr;
    UPDATE acq.invoice SET closed_by = dest_usr WHERE closed_by = src_usr;

	-- transfer picklists the same way we transfer buckets (see above)
	FOR picklist_row in
		SELECT id, name
		FROM   acq.picklist
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  acq.picklist
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = picklist_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

    UPDATE acq.purchase_order SET owner = dest_usr WHERE owner = src_usr;
    UPDATE acq.po_note SET creator = dest_usr WHERE creator = src_usr;
    UPDATE acq.po_note SET editor = dest_usr WHERE editor = src_usr;
    UPDATE acq.provider_note SET creator = dest_usr WHERE creator = src_usr;
    UPDATE acq.provider_note SET editor = dest_usr WHERE editor = src_usr;
    UPDATE acq.lineitem_note SET creator = dest_usr WHERE creator = src_usr;
    UPDATE acq.lineitem_note SET editor = dest_usr WHERE editor = src_usr;
    UPDATE acq.lineitem_usr_attr_definition SET usr = dest_usr WHERE usr = src_usr;

    -- asset.*
    UPDATE asset.copy SET creator = dest_usr WHERE creator = src_usr;
    UPDATE asset.copy SET editor = dest_usr WHERE editor = src_usr;
    UPDATE asset.copy_note SET creator = dest_usr WHERE creator = src_usr;
    UPDATE asset.call_number SET creator = dest_usr WHERE creator = src_usr;
    UPDATE asset.call_number SET editor = dest_usr WHERE editor = src_usr;
    UPDATE asset.call_number_note SET creator = dest_usr WHERE creator = src_usr;

    -- serial.*
    UPDATE serial.record_entry SET creator = dest_usr WHERE creator = src_usr;
    UPDATE serial.record_entry SET editor = dest_usr WHERE editor = src_usr;

    -- reporter.*
    -- It's not uncommon to define the reporter schema in a replica 
    -- DB only, so don't assume these tables exist in the write DB.
    BEGIN
    	UPDATE reporter.template SET owner = dest_usr WHERE owner = src_usr;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
    	UPDATE reporter.report SET owner = dest_usr WHERE owner = src_usr;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
    	UPDATE reporter.schedule SET runner = dest_usr WHERE runner = src_usr;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
		-- transfer folders the same way we transfer buckets (see above)
		FOR folder_row in
			SELECT id, name
			FROM   reporter.template_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.template_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = folder_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
		-- transfer folders the same way we transfer buckets (see above)
		FOR folder_row in
			SELECT id, name
			FROM   reporter.report_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.report_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = folder_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;
    BEGIN
		-- transfer folders the same way we transfer buckets (see above)
		FOR folder_row in
			SELECT id, name
			FROM   reporter.output_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.output_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = folder_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
    EXCEPTION WHEN undefined_table THEN
        -- do nothing
    END;

    -- propagate preferred name values from the source user to the
    -- destination user, but only when values are not being replaced.
    WITH susr AS (SELECT * FROM actor.usr WHERE id = src_usr)
    UPDATE actor.usr SET 
        pref_prefix = 
            COALESCE(pref_prefix, (SELECT pref_prefix FROM susr)),
        pref_first_given_name = 
            COALESCE(pref_first_given_name, (SELECT pref_first_given_name FROM susr)),
        pref_second_given_name = 
            COALESCE(pref_second_given_name, (SELECT pref_second_given_name FROM susr)),
        pref_family_name = 
            COALESCE(pref_family_name, (SELECT pref_family_name FROM susr)),
        pref_suffix = 
            COALESCE(pref_suffix, (SELECT pref_suffix FROM susr))
    WHERE id = dest_usr;

    -- Copy and deduplicate name keywords
    -- String -> array -> rows -> DISTINCT -> array -> string
    WITH susr AS (SELECT * FROM actor.usr WHERE id = src_usr),
         dusr AS (SELECT * FROM actor.usr WHERE id = dest_usr)
    UPDATE actor.usr SET name_keywords = (
        WITH keywords AS (
            SELECT DISTINCT UNNEST(
                REGEXP_SPLIT_TO_ARRAY(
                    COALESCE((SELECT name_keywords FROM susr), '') || ' ' ||
                    COALESCE((SELECT name_keywords FROM dusr), ''),  E'\\s+'
                )
            ) AS parts
        ) SELECT ARRAY_TO_STRING(ARRAY_AGG(kw.parts), ' ') FROM keywords kw
    ) WHERE id = dest_usr;

    -- Finally, delete the source user
    PERFORM actor.usr_delete(src_usr,dest_usr);

END;
$$;


ALTER FUNCTION actor.usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean) OWNER TO evergreen;

--
-- Name: FUNCTION usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION actor.usr_merge(src_usr integer, dest_usr integer, del_addrs boolean, del_cards boolean, deactivate_cards boolean) IS '
/**
 * Merges all user date from src_usr to dest_usr.  When collisions occur, 
 * keep dest_usr''s data and delete src_usr''s data.
 */
';


--
-- Name: usr_merge_rows(text, text, integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    sel TEXT;
    upd TEXT;
    del TEXT;
    cur_row RECORD;
BEGIN
    sel := 'SELECT id::BIGINT FROM ' || table_name || ' WHERE ' || quote_ident(col_name) || ' = ' || quote_literal(src_usr);
    upd := 'UPDATE ' || table_name || ' SET ' || quote_ident(col_name) || ' = ' || quote_literal(dest_usr) || ' WHERE id = ';
    del := 'DELETE FROM ' || table_name || ' WHERE id = ';
    FOR cur_row IN EXECUTE sel LOOP
        BEGIN
            --RAISE NOTICE 'Attempting to merge % %', table_name, cur_row.id;
            EXECUTE upd || cur_row.id;
        EXCEPTION WHEN unique_violation THEN
            --RAISE NOTICE 'Deleting conflicting % %', table_name, cur_row.id;
            EXECUTE del || cur_row.id;
        END;
    END LOOP;
END;
$$;


ALTER FUNCTION actor.usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer) OWNER TO evergreen;

--
-- Name: FUNCTION usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION actor.usr_merge_rows(table_name text, col_name text, src_usr integer, dest_usr integer) IS '
/**
 * Attempts to move each row of the specified table from src_user to dest_user.  
 * Where conflicts exist, the conflicting "source" row is deleted.
 */
';


--
-- Name: usr_purge_data(integer, integer); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.usr_purge_data(src_usr integer, specified_dest_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	suffix TEXT;
	renamable_row RECORD;
	dest_usr INTEGER;
BEGIN

	IF specified_dest_usr IS NULL THEN
		dest_usr := 1; -- Admin user on stock installs
	ELSE
		dest_usr := specified_dest_usr;
	END IF;

    -- action_trigger.event (even doing this, event_output may--and probably does--contain PII and should have a retention/removal policy)
    UPDATE action_trigger.event SET context_user = dest_usr WHERE context_user = src_usr;

	-- acq.*
	UPDATE acq.fund_allocation SET allocator = dest_usr WHERE allocator = src_usr;
	UPDATE acq.lineitem SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.lineitem SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.lineitem SET selector = dest_usr WHERE selector = src_usr;
	UPDATE acq.lineitem_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.lineitem_note SET editor = dest_usr WHERE editor = src_usr;
    UPDATE acq.invoice SET closed_by = dest_usr WHERE closed_by = src_usr;
	DELETE FROM acq.lineitem_usr_attr_definition WHERE usr = src_usr;

	-- Update with a rename to avoid collisions
	FOR renamable_row in
		SELECT id, name
		FROM   acq.picklist
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  acq.picklist
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	UPDATE acq.picklist SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.picklist SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.po_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.po_note SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.purchase_order SET owner = dest_usr WHERE owner = src_usr;
	UPDATE acq.purchase_order SET creator = dest_usr WHERE creator = src_usr;
	UPDATE acq.purchase_order SET editor = dest_usr WHERE editor = src_usr;
	UPDATE acq.claim_event SET creator = dest_usr WHERE creator = src_usr;

	-- action.*
	DELETE FROM action.circulation WHERE usr = src_usr;
	UPDATE action.circulation SET circ_staff = dest_usr WHERE circ_staff = src_usr;
	UPDATE action.circulation SET checkin_staff = dest_usr WHERE checkin_staff = src_usr;
	UPDATE action.hold_notification SET notify_staff = dest_usr WHERE notify_staff = src_usr;
	UPDATE action.hold_request SET fulfillment_staff = dest_usr WHERE fulfillment_staff = src_usr;
	UPDATE action.hold_request SET requestor = dest_usr WHERE requestor = src_usr;
	DELETE FROM action.hold_request WHERE usr = src_usr;
	UPDATE action.in_house_use SET staff = dest_usr WHERE staff = src_usr;
	UPDATE action.non_cat_in_house_use SET staff = dest_usr WHERE staff = src_usr;
	DELETE FROM action.non_cataloged_circulation WHERE patron = src_usr;
	UPDATE action.non_cataloged_circulation SET staff = dest_usr WHERE staff = src_usr;
	DELETE FROM action.survey_response WHERE usr = src_usr;
	UPDATE action.fieldset SET owner = dest_usr WHERE owner = src_usr;
	DELETE FROM action.usr_circ_history WHERE usr = src_usr;

	-- actor.*
	DELETE FROM actor.card WHERE usr = src_usr;
	DELETE FROM actor.stat_cat_entry_usr_map WHERE target_usr = src_usr;
	DELETE FROM actor.usr_privacy_waiver WHERE usr = src_usr;

	-- The following update is intended to avoid transient violations of a foreign
	-- key constraint, whereby actor.usr_address references itself.  It may not be
	-- necessary, but it does no harm.
	UPDATE actor.usr_address SET replaces = NULL
		WHERE usr = src_usr AND replaces IS NOT NULL;
	DELETE FROM actor.usr_address WHERE usr = src_usr;
	DELETE FROM actor.usr_org_unit_opt_in WHERE usr = src_usr;
	UPDATE actor.usr_org_unit_opt_in SET staff = dest_usr WHERE staff = src_usr;
	DELETE FROM actor.usr_setting WHERE usr = src_usr;
	DELETE FROM actor.usr_standing_penalty WHERE usr = src_usr;
	UPDATE actor.usr_message SET title = 'purged', message = 'purged', read_date = NOW() WHERE usr = src_usr;
	DELETE FROM actor.usr_message WHERE usr = src_usr;
	UPDATE actor.usr_standing_penalty SET staff = dest_usr WHERE staff = src_usr;
	UPDATE actor.usr_message SET editor = dest_usr WHERE editor = src_usr;

	-- asset.*
	UPDATE asset.call_number SET creator = dest_usr WHERE creator = src_usr;
	UPDATE asset.call_number SET editor = dest_usr WHERE editor = src_usr;
	UPDATE asset.call_number_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE asset.copy SET creator = dest_usr WHERE creator = src_usr;
	UPDATE asset.copy SET editor = dest_usr WHERE editor = src_usr;
	UPDATE asset.copy_note SET creator = dest_usr WHERE creator = src_usr;

	-- auditor.*
	DELETE FROM auditor.actor_usr_address_history WHERE id = src_usr;
	DELETE FROM auditor.actor_usr_history WHERE id = src_usr;
	UPDATE auditor.asset_call_number_history SET creator = dest_usr WHERE creator = src_usr;
	UPDATE auditor.asset_call_number_history SET editor  = dest_usr WHERE editor  = src_usr;
	UPDATE auditor.asset_copy_history SET creator = dest_usr WHERE creator = src_usr;
	UPDATE auditor.asset_copy_history SET editor  = dest_usr WHERE editor  = src_usr;
	UPDATE auditor.biblio_record_entry_history SET creator = dest_usr WHERE creator = src_usr;
	UPDATE auditor.biblio_record_entry_history SET editor  = dest_usr WHERE editor  = src_usr;

	-- biblio.*
	UPDATE biblio.record_entry SET creator = dest_usr WHERE creator = src_usr;
	UPDATE biblio.record_entry SET editor = dest_usr WHERE editor = src_usr;
	UPDATE biblio.record_note SET creator = dest_usr WHERE creator = src_usr;
	UPDATE biblio.record_note SET editor = dest_usr WHERE editor = src_usr;

	-- container.*
	-- Update buckets with a rename to avoid collisions
	FOR renamable_row in
		SELECT id, name
		FROM   container.biblio_record_entry_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.biblio_record_entry_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR renamable_row in
		SELECT id, name
		FROM   container.call_number_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.call_number_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR renamable_row in
		SELECT id, name
		FROM   container.copy_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.copy_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	FOR renamable_row in
		SELECT id, name
		FROM   container.user_bucket
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  container.user_bucket
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

	DELETE FROM container.user_bucket_item WHERE target_user = src_usr;

	-- money.*
	DELETE FROM money.billable_xact WHERE usr = src_usr;
	DELETE FROM money.collections_tracker WHERE usr = src_usr;
	UPDATE money.collections_tracker SET collector = dest_usr WHERE collector = src_usr;

	-- permission.*
	DELETE FROM permission.usr_grp_map WHERE usr = src_usr;
	DELETE FROM permission.usr_object_perm_map WHERE usr = src_usr;
	DELETE FROM permission.usr_perm_map WHERE usr = src_usr;
	DELETE FROM permission.usr_work_ou_map WHERE usr = src_usr;

	-- reporter.*
	-- Update with a rename to avoid collisions
	BEGIN
		FOR renamable_row in
			SELECT id, name
			FROM   reporter.output_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.output_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = renamable_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	BEGIN
		UPDATE reporter.report SET owner = dest_usr WHERE owner = src_usr;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	-- Update with a rename to avoid collisions
	BEGIN
		FOR renamable_row in
			SELECT id, name
			FROM   reporter.report_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.report_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = renamable_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	BEGIN
		UPDATE reporter.schedule SET runner = dest_usr WHERE runner = src_usr;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	BEGIN
		UPDATE reporter.template SET owner = dest_usr WHERE owner = src_usr;
	EXCEPTION WHEN undefined_table THEN
		-- do nothing
	END;

	-- Update with a rename to avoid collisions
	BEGIN
		FOR renamable_row in
			SELECT id, name
			FROM   reporter.template_folder
			WHERE  owner = src_usr
		LOOP
			suffix := ' (' || src_usr || ')';
			LOOP
				BEGIN
					UPDATE  reporter.template_folder
					SET     owner = dest_usr, name = name || suffix
					WHERE   id = renamable_row.id;
				EXCEPTION WHEN unique_violation THEN
					suffix := suffix || ' ';
					CONTINUE;
				END;
				EXIT;
			END LOOP;
		END LOOP;
	EXCEPTION WHEN undefined_table THEN
	-- do nothing
	END;

	-- vandelay.*
	-- Update with a rename to avoid collisions
	FOR renamable_row in
		SELECT id, name
		FROM   vandelay.queue
		WHERE  owner = src_usr
	LOOP
		suffix := ' (' || src_usr || ')';
		LOOP
			BEGIN
				UPDATE  vandelay.queue
				SET     owner = dest_usr, name = name || suffix
				WHERE   id = renamable_row.id;
			EXCEPTION WHEN unique_violation THEN
				suffix := suffix || ' ';
				CONTINUE;
			END;
			EXIT;
		END LOOP;
	END LOOP;

    UPDATE vandelay.session_tracker SET usr = dest_usr WHERE usr = src_usr;

    -- NULL-ify addresses last so other cleanup (e.g. circ anonymization)
    -- can access the information before deletion.
	UPDATE actor.usr SET
		active = FALSE,
		card = NULL,
		mailing_address = NULL,
		billing_address = NULL
	WHERE id = src_usr;

END;
$$;


ALTER FUNCTION actor.usr_purge_data(src_usr integer, specified_dest_usr integer) OWNER TO evergreen;

--
-- Name: FUNCTION usr_purge_data(src_usr integer, specified_dest_usr integer); Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON FUNCTION actor.usr_purge_data(src_usr integer, specified_dest_usr integer) IS '
Finds rows dependent on a given row in actor.usr and either deletes them
or reassigns them to a different user.
';


--
-- Name: verify_passwd(integer, text, text); Type: FUNCTION; Schema: actor; Owner: evergreen
--

CREATE FUNCTION actor.verify_passwd(pw_usr integer, pw_type text, test_passwd text) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    pw_salt TEXT;
BEGIN
    /* Returns TRUE if the password provided matches the in-db password.  
     * If the password type is salted, we compare the output of CRYPT().
     * NOTE: test_passwd is MD5(salt || MD5(password)) for legacy 
     * 'main' passwords.
     */

    SELECT INTO pw_salt salt FROM actor.passwd 
        WHERE usr = pw_usr AND passwd_type = pw_type;

    IF NOT FOUND THEN
        -- no such password
        RETURN FALSE;
    END IF;

    IF pw_salt IS NULL THEN
        -- Password is unsalted, compare the un-CRYPT'ed values.
        RETURN EXISTS (
            SELECT TRUE FROM actor.passwd WHERE 
                usr = pw_usr AND
                passwd_type = pw_type AND
                passwd = test_passwd
        );
    END IF;

    RETURN EXISTS (
        SELECT TRUE FROM actor.passwd WHERE 
            usr = pw_usr AND
            passwd_type = pw_type AND
            passwd = CRYPT(test_passwd, pw_salt)
    );
END;
$$;


ALTER FUNCTION actor.verify_passwd(pw_usr integer, pw_type text, test_passwd text) OWNER TO evergreen;

--
-- Name: acp_created(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.acp_created() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.active_date IS NULL AND NEW.status IN (SELECT id FROM config.copy_status WHERE copy_active = true) THEN
        NEW.active_date := now();
    END IF;
    IF NEW.status_changed_time IS NULL THEN
        NEW.status_changed_time := now();
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.acp_created() OWNER TO evergreen;

--
-- Name: acp_location_fixer(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.acp_location_fixer() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_copy_location INT;
BEGIN
    IF (TG_OP = 'UPDATE') THEN
        IF NEW.location = OLD.location AND NEW.call_number = OLD.call_number AND NEW.circ_lib = OLD.circ_lib THEN
            RETURN NEW;
        END IF;
    END IF;
    SELECT INTO new_copy_location acpl.id FROM asset.copy_location acpl JOIN actor.org_unit_ancestors_distance((SELECT owning_lib FROM asset.call_number WHERE id = NEW.call_number)) aouad ON acpl.owning_lib = aouad.id WHERE deleted IS FALSE AND name = (SELECT name FROM asset.copy_location WHERE id = NEW.location) ORDER BY distance LIMIT 1;
    IF new_copy_location IS NULL THEN
        SELECT INTO new_copy_location acpl.id FROM asset.copy_location acpl JOIN actor.org_unit_ancestors_distance(NEW.circ_lib) aouad ON acpl.owning_lib = aouad.id WHERE deleted IS FALSE AND name = (SELECT name FROM asset.copy_location WHERE id = NEW.location) ORDER BY distance LIMIT 1;
    END IF;
    IF new_copy_location IS NOT NULL THEN
        NEW.location = new_copy_location;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.acp_location_fixer() OWNER TO evergreen;

--
-- Name: acp_status_changed(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.acp_status_changed() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.status <> OLD.status AND NOT (NEW.status = 0 AND OLD.status = 7) THEN
        NEW.status_changed_time := now();
        IF NEW.active_date IS NULL AND NEW.status IN (SELECT id FROM config.copy_status WHERE copy_active = true) THEN
            NEW.active_date := now();
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.acp_status_changed() OWNER TO evergreen;

--
-- Name: all_visible_flags(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.all_visible_flags() RETURNS text
    LANGUAGE sql STABLE
    AS $$
    SELECT  '(' || ARRAY_TO_STRING(ARRAY_AGG(search.calculate_visibility_attribute(1 << x, 'copy_flags')),'&') || ')'
      FROM  GENERATE_SERIES(0,0) AS x; -- increment as new flags are added.
$$;


ALTER FUNCTION asset.all_visible_flags() OWNER TO evergreen;

--
-- Name: autogenerate_placeholder_barcode(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.autogenerate_placeholder_barcode() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.barcode LIKE '@@%' THEN
		NEW.barcode := '@@' || NEW.id;
	END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION asset.autogenerate_placeholder_barcode() OWNER TO evergreen;

--
-- Name: bib_source_default(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.bib_source_default() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$
    SELECT  '(' || ARRAY_TO_STRING(ARRAY_AGG(search.calculate_visibility_attribute(id, 'bib_source')),'|') || ')'
      FROM  config.bib_source
      WHERE transcendant;
$$;


ALTER FUNCTION asset.bib_source_default() OWNER TO evergreen;

--
-- Name: cache_copy_visibility(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.cache_copy_visibility() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    ocn     asset.call_number%ROWTYPE;
    ncn     asset.call_number%ROWTYPE;
    cid     BIGINT;
    dobib   BOOL;
BEGIN

    SELECT enabled = FALSE INTO dobib FROM config.internal_flag WHERE name = 'ingest.reingest.force_on_same_marc';

    IF TG_TABLE_NAME = 'peer_bib_copy_map' THEN -- Only needs ON INSERT OR DELETE, so handle separately
        IF TG_OP = 'INSERT' THEN
            INSERT INTO asset.copy_vis_attr_cache (record, target_copy, vis_attr_vector) VALUES (
                NEW.peer_record,
                NEW.target_copy,
                asset.calculate_copy_visibility_attribute_set(NEW.target_copy)
            );

            RETURN NEW;
        ELSIF TG_OP = 'DELETE' THEN
            DELETE FROM asset.copy_vis_attr_cache
              WHERE record = OLD.peer_record AND target_copy = OLD.target_copy;

            RETURN OLD;
        END IF;
    END IF;

    IF TG_OP = 'INSERT' THEN -- Handles ON INSERT. ON UPDATE is below.
        IF TG_TABLE_NAME IN ('copy', 'unit') THEN
            SELECT * INTO ncn FROM asset.call_number cn WHERE id = NEW.call_number;
            INSERT INTO asset.copy_vis_attr_cache (record, target_copy, vis_attr_vector) VALUES (
                ncn.record,
                NEW.id,
                asset.calculate_copy_visibility_attribute_set(NEW.id)
            );
        ELSIF TG_TABLE_NAME = 'record_entry' THEN
            NEW.vis_attr_vector := biblio.calculate_bib_visibility_attribute_set(NEW.id, NEW.source, TRUE);
        ELSIF TG_TABLE_NAME = 'call_number' AND NEW.label = '##URI##' AND dobib THEN -- New located URI
            UPDATE  biblio.record_entry
              SET   vis_attr_vector = biblio.calculate_bib_visibility_attribute_set(NEW.record)
              WHERE id = NEW.record;

        END IF;

        RETURN NEW;
    END IF;

    -- handle items first, since with circulation activity
    -- their statuses change frequently
    IF TG_TABLE_NAME IN ('copy', 'unit') THEN -- This handles ON UPDATE OR DELETE. ON INSERT above

        IF TG_OP = 'DELETE' THEN -- Shouldn't get here, normally
            DELETE FROM asset.copy_vis_attr_cache WHERE target_copy = OLD.id;
            RETURN OLD;
        END IF;

        SELECT * INTO ncn FROM asset.call_number cn WHERE id = NEW.call_number;

        IF OLD.deleted <> NEW.deleted THEN
            IF NEW.deleted THEN
                DELETE FROM asset.copy_vis_attr_cache WHERE target_copy = OLD.id;
            ELSE
                INSERT INTO asset.copy_vis_attr_cache (record, target_copy, vis_attr_vector) VALUES (
                    ncn.record,
                    NEW.id,
                    asset.calculate_copy_visibility_attribute_set(NEW.id)
                );
            END IF;

            RETURN NEW;
        ELSIF OLD.location   <> NEW.location OR
            OLD.status       <> NEW.status OR
            OLD.opac_visible <> NEW.opac_visible OR
            OLD.circ_lib     <> NEW.circ_lib OR
            OLD.call_number  <> NEW.call_number
        THEN
            IF OLD.call_number  <> NEW.call_number THEN -- Special check since it's more expensive than the next branch
                SELECT * INTO ocn FROM asset.call_number cn WHERE id = OLD.call_number;

                IF ncn.record <> ocn.record THEN
                    -- We have to use a record-specific WHERE clause
                    -- to avoid modifying the entries for peer-bib copies.
                    UPDATE  asset.copy_vis_attr_cache
                      SET   target_copy = NEW.id,
                            record = ncn.record
                      WHERE target_copy = OLD.id
                            AND record = ocn.record;

                END IF;
            ELSE
                -- Any of these could change visibility, but
                -- we'll save some queries and not try to calculate
                -- the change directly.  We want to update peer-bib
                -- entries in this case, unlike above.
                UPDATE  asset.copy_vis_attr_cache
                  SET   target_copy = NEW.id,
                        vis_attr_vector = asset.calculate_copy_visibility_attribute_set(NEW.id)
                  WHERE target_copy = OLD.id;
            END IF;
        END IF;

    ELSIF TG_TABLE_NAME = 'call_number' THEN

        IF TG_OP = 'DELETE' AND OLD.label = '##URI##' AND dobib THEN -- really deleted located URI, if the delete protection rule is disabled...
            UPDATE  biblio.record_entry
              SET   vis_attr_vector = biblio.calculate_bib_visibility_attribute_set(OLD.record)
              WHERE id = OLD.record;
            RETURN OLD;
        END IF;

        IF OLD.label = '##URI##' AND dobib THEN -- Located URI
            IF OLD.deleted <> NEW.deleted OR OLD.record <> NEW.record OR OLD.owning_lib <> NEW.owning_lib THEN
                UPDATE  biblio.record_entry
                  SET   vis_attr_vector = biblio.calculate_bib_visibility_attribute_set(NEW.record)
                  WHERE id = NEW.record;

                IF OLD.record <> NEW.record THEN -- maybe on merge?
                    UPDATE  biblio.record_entry
                      SET   vis_attr_vector = biblio.calculate_bib_visibility_attribute_set(OLD.record)
                      WHERE id = OLD.record;
                END IF;
            END IF;

        ELSIF OLD.record <> NEW.record OR OLD.owning_lib <> NEW.owning_lib THEN
            UPDATE  asset.copy_vis_attr_cache
              SET   record = NEW.record,
                    vis_attr_vector = asset.calculate_copy_visibility_attribute_set(target_copy)
              WHERE target_copy IN (SELECT id FROM asset.copy WHERE call_number = NEW.id)
                    AND record = OLD.record;

        END IF;

    ELSIF TG_TABLE_NAME = 'record_entry' AND OLD.source IS DISTINCT FROM NEW.source THEN -- Only handles ON UPDATE, INSERT above
        NEW.vis_attr_vector := biblio.calculate_bib_visibility_attribute_set(NEW.id, NEW.source, TRUE);
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.cache_copy_visibility() OWNER TO evergreen;

--
-- Name: FUNCTION cache_copy_visibility(); Type: COMMENT; Schema: asset; Owner: evergreen
--

COMMENT ON FUNCTION asset.cache_copy_visibility() IS '
Trigger function to update the copy OPAC visiblity cache.
';


--
-- Name: calculate_copy_visibility_attribute_set(bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.calculate_copy_visibility_attribute_set(copy_id bigint) RETURNS integer[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    copy_row    asset.copy%ROWTYPE;
    lgroup_map  asset.copy_location_group_map%ROWTYPE;
    attr_set    INT[] := '{}'::INT[];
BEGIN
    SELECT * INTO copy_row FROM asset.copy WHERE id = copy_id;

    attr_set := attr_set || search.calculate_visibility_attribute(copy_row.opac_visible::INT, 'copy_flags');
    attr_set := attr_set || search.calculate_visibility_attribute(copy_row.circ_lib, 'circ_lib');
    attr_set := attr_set || search.calculate_visibility_attribute(copy_row.status, 'status');
    attr_set := attr_set || search.calculate_visibility_attribute(copy_row.location, 'location');

    SELECT  ARRAY_APPEND(
                attr_set,
                search.calculate_visibility_attribute(owning_lib, 'owning_lib')
            ) INTO attr_set
      FROM  asset.call_number
      WHERE id = copy_row.call_number;

    FOR lgroup_map IN SELECT * FROM asset.copy_location_group_map WHERE location = copy_row.location LOOP
        attr_set := attr_set || search.calculate_visibility_attribute(lgroup_map.lgroup, 'location_group');
    END LOOP;

    RETURN attr_set;
END;
$$;


ALTER FUNCTION asset.calculate_copy_visibility_attribute_set(copy_id bigint) OWNER TO evergreen;

--
-- Name: check_delete_copy_location(integer); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.check_delete_copy_location(acpl_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM TRUE FROM asset.copy WHERE location = acpl_id AND NOT deleted LIMIT 1;

    IF FOUND THEN
        RAISE EXCEPTION
            'Copy location % contains active copies and cannot be deleted', acpl_id;
    END IF;
END;
$$;


ALTER FUNCTION asset.check_delete_copy_location(acpl_id integer) OWNER TO evergreen;

--
-- Name: circ_lib_default(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.circ_lib_default() RETURNS text
    LANGUAGE sql STABLE
    AS $$
    SELECT  * FROM asset.invisible_orgs('circ_lib');
$$;


ALTER FUNCTION asset.circ_lib_default() OWNER TO evergreen;

--
-- Name: copy_may_float_to_inventory_workstation(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.copy_may_float_to_inventory_workstation() RETURNS trigger
    LANGUAGE plpgsql COST 50
    AS $$
DECLARE
    copy asset.copy%ROWTYPE;
    workstation actor.workstation%ROWTYPE;
BEGIN
    SELECT * INTO copy FROM asset.copy WHERE id = NEW.copy;
    IF FOUND THEN
        SELECT * INTO workstation FROM actor.workstation WHERE id = NEW.inventory_workstation;
        IF FOUND THEN
           IF copy.floating IS NULL THEN
              IF copy.circ_lib <> workstation.owning_lib THEN
                 RAISE EXCEPTION 'Inventory workstation owning lib (%) does not match copy circ lib (%).',
                       workstation.owning_lib, copy.circ_lib;
              END IF;
           ELSE
              IF NOT evergreen.can_float(copy.floating, copy.circ_lib, workstation.owning_lib) THEN
                 RAISE EXCEPTION 'Copy (%) cannot float to inventory workstation owning lib (%).',
                       copy.id, workstation.owning_lib;
              END IF;
           END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.copy_may_float_to_inventory_workstation() OWNER TO evergreen;

--
-- Name: copy_state(bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.copy_state(cid bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    last_circ_stop      TEXT;
    the_copy        asset.copy%ROWTYPE;
BEGIN

    SELECT * INTO the_copy FROM asset.copy WHERE id = cid;
    IF NOT FOUND THEN RETURN NULL; END IF;

    IF the_copy.status = 3 THEN -- Lost
        RETURN 'LOST';
    ELSIF the_copy.status = 4 THEN -- Missing
        RETURN 'MISSING';
    ELSIF the_copy.status = 14 THEN -- Damaged
        RETURN 'DAMAGED';
    ELSIF the_copy.status = 17 THEN -- Lost and paid
        RETURN 'LOST_AND_PAID';
    END IF;

    SELECT stop_fines INTO last_circ_stop
      FROM  action.circulation
      WHERE target_copy = cid AND checkin_time IS NULL
      ORDER BY xact_start DESC LIMIT 1;

    IF FOUND THEN
        IF last_circ_stop IN (
            'CLAIMSNEVERCHECKEDOUT',
            'CLAIMSRETURNED',
            'LONGOVERDUE'
        ) THEN
            RETURN last_circ_stop;
        END IF;
    END IF;

    RETURN 'NORMAL';
END;
$$;


ALTER FUNCTION asset.copy_state(cid bigint) OWNER TO evergreen;

--
-- Name: get_holdings_maintenance_page(bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.get_holdings_maintenance_page(tcn_value bigint) RETURNS SETOF evergreen.holdings_maintenance
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
   r holdings_maintenance;
   
BEGIN

FOR r IN

SELECT acn.create_date, acn.creator, acn.deleted, acn.edit_date, acn.editor, acn.id, acn.label, acn.owning_lib, acn.record, acn.label_sortkey, acn.label_class, acn.prefix, acn.suffix, acp.age_protect, acp.alert_message, acp.barcode, acp.call_number, acp.circ_as_type, acp.circ_lib, acp.circ_modifier, acp.circulate, acp.copy_number, acp.create_date, acp.active_date, acp.creator, acp.deleted, acp.dummy_isbn, acp.deposit, acp.deposit_amount, acp.dummy_author, acp.dummy_title, acp.edit_date, acp.editor, acp.fine_level, acp.holdable, acp.id, acp.loan_duration, acp.LOCATION, acp.opac_visible, acp.price, acp.REF, acp.STATUS, acp.status_changed_time, acp.mint_condition, acp.floating, acp.COST, circ.checkin_lib, circ.checkin_staff, circ.checkin_time, circ.circ_lib, circ.circ_staff, circ.desk_renewal, circ.due_date, circ.duration, circ.duration_rule, circ.fine_interval, circ.id, circ.max_fine, circ.max_fine_rule, circ.opac_renewal, circ.phone_renewal, circ.recurring_fine, circ.recurring_fine_rule, circ.renewal_remaining, circ.grace_period, circ.stop_fines, circ.stop_fines_time, circ.target_copy, circ.usr, circ.xact_finish, circ.xact_start, circ.create_time, circ.workstation, circ.checkin_workstation, circ.checkin_scan_time, circ.parent_circ, circ.unrecovered, circ.copy_location

	FROM asset.COPY AS acp 

	JOIN asset.call_number acn ON (acp.call_number = acn.id)
	JOIN actor.org_unit aou ON (acn.owning_lib = aou.id)
	JOIN action.circulation circ ON (acp.id = circ.target_copy)


	WHERE acn.record = tcn_value 
		AND circ.xact_start = (
			SELECT c.xact 
			FROM ( 
				SELECT target_copy, max(xact_start) AS xact 
				FROM action.circulation 
				WHERE target_copy = acp.id  
				GROUP BY target_copy) AS c)
		AND aou.parent_ou = '1' 
		AND acn.deleted = 'f' 
		AND acn.LABEL <> '##URI##'
		AND acp.deleted = 'f'

UNION ALL

SELECT acn.create_date, acn.creator, acn.deleted, acn.edit_date, acn.editor, acn.id, acn.label, acn.owning_lib, acn.record, acn.label_sortkey, acn.label_class, acn.prefix, acn.suffix, acp.age_protect, acp.alert_message, acp.barcode, acp.call_number, acp.circ_as_type, acp.circ_lib, acp.circ_modifier, acp.circulate, acp.copy_number, acp.create_date, acp.active_date, acp.creator, acp.deleted, acp.dummy_isbn, acp.deposit, acp.deposit_amount, acp.dummy_author, acp.dummy_title, acp.edit_date, acp.editor, acp.fine_level, acp.holdable, acp.id, acp.loan_duration, acp.LOCATION, acp.opac_visible, acp.price, acp.REF, acp.STATUS, acp.status_changed_time, acp.mint_condition, acp.floating, acp.COST, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null

	FROM asset.COPY AS acp 

	JOIN asset.call_number acn ON (acp.call_number = acn.id)
	JOIN actor.org_unit aou ON (acn.owning_lib = aou.id)


	WHERE acn.record = tcn_value 
		AND acp.id NOT IN (SELECT circ.target_copy
			FROM action.circulation circ
			WHERE circ.target_copy = acp.id)
		AND aou.parent_ou = '1' 
		AND acn.deleted = 'f' 
		AND acn.LABEL <> '##URI##'
		AND acp.deleted = 'f'

UNION ALL

SELECT acn.create_date, acn.creator, acn.deleted, acn.edit_date, acn.editor, acn.id, acn.label, acn.owning_lib, acn.record, acn.label_sortkey, acn.label_class, acn.prefix, acn.suffix, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null

	FROM asset.call_number AS acn
	LEFT OUTER JOIN asset.copy AS acp
	ON acn.id = acp.call_number
	WHERE acn.record = tcn_value
	AND acn.deleted = 'f'
	AND acp.id IS NULL




LOOP
RETURN NEXT r;
END LOOP;

RETURN;

END;
$$;


ALTER FUNCTION asset.get_holdings_maintenance_page(tcn_value bigint) OWNER TO evergreen;

--
-- Name: invisible_orgs(text); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.invisible_orgs(otype text) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
    SELECT  '!(' || ARRAY_TO_STRING(ARRAY_AGG(search.calculate_visibility_attribute(id, $1)),'|') || ')'
      FROM  actor.org_unit
      WHERE NOT opac_visible;
$_$;


ALTER FUNCTION asset.invisible_orgs(otype text) OWNER TO evergreen;

--
-- Name: label_normalizer(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.label_normalizer() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sortkey        TEXT := '';
BEGIN
    sortkey := NEW.label_sortkey;

    IF NEW.label_class IS NULL THEN
            NEW.label_class := COALESCE(
            (
                SELECT substring(value from E'\\d+')::integer
                FROM actor.org_unit_ancestor_setting('cat.default_classification_scheme', NEW.owning_lib)
            ), 1
        );
    END IF;

    EXECUTE 'SELECT ' || acnc.normalizer || '(' || 
       quote_literal( NEW.label ) || ')'
       FROM asset.call_number_class acnc
       WHERE acnc.id = NEW.label_class
       INTO sortkey;
    NEW.label_sortkey = sortkey;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.label_normalizer() OWNER TO evergreen;

--
-- Name: label_normalizer_dewey(text); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.label_normalizer_dewey(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE
    AS $_$
    # Derived from the Koha C4::ClassSortRoutine::Dewey module
    # Copyright (C) 2007 LibLime
    # Licensed under the GPL v2 or later

    use strict;
    use warnings;

    my $init = uc(shift);
    $init =~ s/^\s+//;
    $init =~ s/\s+$//;
    $init =~ s!/!!g;
    $init =~ s/^([\p{IsAlpha}]+)/$1 /;
    my @tokens = split /\.|\s+/, $init;
    my $digit_group_count = 0;
    my $first_digit_group_idx;
    for (my $i = 0; $i <= $#tokens; $i++) {
        if ($tokens[$i] =~ /^\d+$/) {
            $digit_group_count++;
            if ($digit_group_count == 1) {
                $first_digit_group_idx = $i;
            }
            if (2 == $digit_group_count) {
                $tokens[$i] = sprintf("%-15.15s", $tokens[$i]);
                $tokens[$i] =~ tr/ /0/;
            }
        }
    }
    # Pad the first digit_group if there was only one
    if (1 == $digit_group_count) {
        $tokens[$first_digit_group_idx] .= '_000000000000000'
    }
    my $key = join("_", @tokens);
    $key =~ s/[^\p{IsAlnum}_]//g;

    return $key;

$_$;


ALTER FUNCTION asset.label_normalizer_dewey(text) OWNER TO evergreen;

--
-- Name: label_normalizer_generic(text); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.label_normalizer_generic(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE
    AS $_$
    # Created after looking at the Koha C4::ClassSortRoutine::Generic module,
    # thus could probably be considered a derived work, although nothing was
    # directly copied - but to err on the safe side of providing attribution:
    # Copyright (C) 2007 LibLime
    # Copyright (C) 2011 Equinox Software, Inc (Steve Callendar)
    # Licensed under the GPL v2 or later

    use strict;
    use warnings;

    # Converts the callnumber to uppercase
    # Strips spaces from start and end of the call number
    # Converts anything other than letters, digits, and periods into spaces
    # Collapses multiple spaces into a single underscore
    my $callnum = uc(shift);
    $callnum =~ s/^\s//g;
    $callnum =~ s/\s$//g;
    # NOTE: this previously used underscores, but this caused sorting issues
    # for the "before" half of page 0 on CN browse, sorting CNs containing a
    # decimal before "whole number" CNs
    $callnum =~ s/[^A-Z0-9_.]/ /g;
    $callnum =~ s/ {2,}/ /g;

    return $callnum;
$_$;


ALTER FUNCTION asset.label_normalizer_generic(text) OWNER TO evergreen;

--
-- Name: label_normalizer_lc(text); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.label_normalizer_lc(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE
    AS $_$
    use strict;
    use warnings;

    # Library::CallNumber::LC is currently hosted at http://code.google.com/p/library-callnumber-lc/
    # The author hopes to upload it to CPAN some day, which would make our lives easier
    use Library::CallNumber::LC;

    my $callnum = Library::CallNumber::LC->new(shift);
    return $callnum->normalize();

$_$;


ALTER FUNCTION asset.label_normalizer_lc(text) OWNER TO evergreen;

--
-- Name: location_default(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.location_default() RETURNS text
    LANGUAGE sql STABLE
    AS $$
    SELECT  '!(' || ARRAY_TO_STRING(ARRAY_AGG(search.calculate_visibility_attribute(id, 'location')),'|') || ')'
      FROM  asset.copy_location
      WHERE NOT opac_visible;
$$;


ALTER FUNCTION asset.location_default() OWNER TO evergreen;

--
-- Name: location_group_default(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.location_group_default() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$
    SELECT '!()'::TEXT; -- For now, as there's no way to cause a location group to hide all copies.
/*
    SELECT  '!(' || ARRAY_TO_STRING(ARRAY_AGG(search.calculate_visibility_attribute(id, 'location_group')),'|') || ')'
      FROM  asset.copy_location_group
      WHERE NOT opac_visible;
*/
$$;


ALTER FUNCTION asset.location_group_default() OWNER TO evergreen;

--
-- Name: luri_org_default(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.luri_org_default() RETURNS text
    LANGUAGE sql STABLE
    AS $$
    SELECT  * FROM asset.invisible_orgs('luri_org');
$$;


ALTER FUNCTION asset.luri_org_default() OWNER TO evergreen;

--
-- Name: merge_record_assets(bigint, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.merge_record_assets(target_record bigint, source_record bigint) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    moved_objects INT := 0;
    source_cn     asset.call_number%ROWTYPE;
    target_cn     asset.call_number%ROWTYPE;
    metarec       metabib.metarecord%ROWTYPE;
    hold          action.hold_request%ROWTYPE;
    ser_rec       serial.record_entry%ROWTYPE;
    ser_sub       serial.subscription%ROWTYPE;
    acq_lineitem  acq.lineitem%ROWTYPE;
    acq_request   acq.user_request%ROWTYPE;
    booking       booking.resource_type%ROWTYPE;
    source_part   biblio.monograph_part%ROWTYPE;
    target_part   biblio.monograph_part%ROWTYPE;
    multi_home    biblio.peer_bib_copy_map%ROWTYPE;
    uri_count     INT := 0;
    counter       INT := 0;
    uri_datafield TEXT;
    uri_text      TEXT := '';
BEGIN

    -- we don't merge bib -1 
    IF target_record = -1 OR source_record = -1 THEN 
       RETURN 0;
    END IF;

    -- move any 856 entries on records that have at least one MARC-mapped URI entry
    SELECT  INTO uri_count COUNT(*)
      FROM  asset.uri_call_number_map m
            JOIN asset.call_number cn ON (m.call_number = cn.id)
      WHERE cn.record = source_record;

    IF uri_count > 0 THEN
        
        -- This returns more nodes than you might expect:
        -- 7 instead of 1 for an 856 with $u $y $9
        SELECT  COUNT(*) INTO counter
          FROM  oils_xpath_table(
                    'id',
                    'marc',
                    'biblio.record_entry',
                    '//*[@tag="856"]',
                    'id=' || source_record
                ) as t(i int,c text);
    
        FOR i IN 1 .. counter LOOP
            SELECT  '<datafield xmlns="http://www.loc.gov/MARC21/slim"' || 
            ' tag="856"' ||
            ' ind1="' || FIRST(ind1) || '"'  ||
            ' ind2="' || FIRST(ind2) || '">' ||
                        STRING_AGG(
                            '<subfield code="' || subfield || '">' ||
                            regexp_replace(
                                regexp_replace(
                                    regexp_replace(data,'&','&amp;','g'),
                                    '>', '&gt;', 'g'
                                ),
                                '<', '&lt;', 'g'
                            ) || '</subfield>', ''
                        ) || '</datafield>' INTO uri_datafield
              FROM  oils_xpath_table(
                        'id',
                        'marc',
                        'biblio.record_entry',
                        '//*[@tag="856"][position()=' || i || ']/@ind1|' ||
                        '//*[@tag="856"][position()=' || i || ']/@ind2|' ||
                        '//*[@tag="856"][position()=' || i || ']/*/@code|' ||
                        '//*[@tag="856"][position()=' || i || ']/*[@code]',
                        'id=' || source_record
                    ) as t(id int,ind1 text, ind2 text,subfield text,data text);

            -- As most of the results will be NULL, protect against NULLifying
            -- the valid content that we do generate
            uri_text := uri_text || COALESCE(uri_datafield, '');
        END LOOP;

        IF uri_text <> '' THEN
            UPDATE  biblio.record_entry
              SET   marc = regexp_replace(marc,'(</[^>]*record>)', uri_text || E'\\1')
              WHERE id = target_record;
        END IF;

    END IF;

    -- Find and move metarecords to the target record
    SELECT    INTO metarec *
      FROM    metabib.metarecord
      WHERE    master_record = source_record;

    IF FOUND THEN
        UPDATE    metabib.metarecord
          SET    master_record = target_record,
            mods = NULL
          WHERE    id = metarec.id;

        moved_objects := moved_objects + 1;
    END IF;

    -- Find call numbers attached to the source ...
    FOR source_cn IN SELECT * FROM asset.call_number WHERE record = source_record LOOP

        SELECT    INTO target_cn *
          FROM    asset.call_number
          WHERE    label = source_cn.label
            AND prefix = source_cn.prefix
            AND suffix = source_cn.suffix
            AND owning_lib = source_cn.owning_lib
            AND record = target_record
            AND NOT deleted;

        -- ... and if there's a conflicting one on the target ...
        IF FOUND THEN

            -- ... move the copies to that, and ...
            UPDATE    asset.copy
              SET    call_number = target_cn.id
              WHERE    call_number = source_cn.id;

            -- ... move V holds to the move-target call number
            FOR hold IN SELECT * FROM action.hold_request WHERE target = source_cn.id AND hold_type = 'V' LOOP
        
                UPDATE    action.hold_request
                  SET    target = target_cn.id
                  WHERE    id = hold.id;
        
                moved_objects := moved_objects + 1;
            END LOOP;
        
            UPDATE asset.call_number SET deleted = TRUE WHERE id = source_cn.id;

        -- ... if not ...
        ELSE
            -- ... just move the call number to the target record
            UPDATE    asset.call_number
              SET    record = target_record
              WHERE    id = source_cn.id;
        END IF;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Find T holds targeting the source record ...
    FOR hold IN SELECT * FROM action.hold_request WHERE target = source_record AND hold_type = 'T' LOOP

        -- ... and move them to the target record
        UPDATE    action.hold_request
          SET    target = target_record
          WHERE    id = hold.id;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Find serial records targeting the source record ...
    FOR ser_rec IN SELECT * FROM serial.record_entry WHERE record = source_record LOOP
        -- ... and move them to the target record
        UPDATE    serial.record_entry
          SET    record = target_record
          WHERE    id = ser_rec.id;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Find serial subscriptions targeting the source record ...
    FOR ser_sub IN SELECT * FROM serial.subscription WHERE record_entry = source_record LOOP
        -- ... and move them to the target record
        UPDATE    serial.subscription
          SET    record_entry = target_record
          WHERE    id = ser_sub.id;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Find booking resource types targeting the source record ...
    FOR booking IN SELECT * FROM booking.resource_type WHERE record = source_record LOOP
        -- ... and move them to the target record
        UPDATE    booking.resource_type
          SET    record = target_record
          WHERE    id = booking.id;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Find acq lineitems targeting the source record ...
    FOR acq_lineitem IN SELECT * FROM acq.lineitem WHERE eg_bib_id = source_record LOOP
        -- ... and move them to the target record
        UPDATE    acq.lineitem
          SET    eg_bib_id = target_record
          WHERE    id = acq_lineitem.id;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Find acq user purchase requests targeting the source record ...
    FOR acq_request IN SELECT * FROM acq.user_request WHERE eg_bib = source_record LOOP
        -- ... and move them to the target record
        UPDATE    acq.user_request
          SET    eg_bib = target_record
          WHERE    id = acq_request.id;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Find parts attached to the source ...
    FOR source_part IN SELECT * FROM biblio.monograph_part WHERE record = source_record LOOP

        SELECT    INTO target_part *
          FROM    biblio.monograph_part
          WHERE    label = source_part.label
            AND record = target_record;

        -- ... and if there's a conflicting one on the target ...
        IF FOUND THEN

            -- ... move the copy-part maps to that, and ...
            UPDATE    asset.copy_part_map
              SET    part = target_part.id
              WHERE    part = source_part.id;

            -- ... move P holds to the move-target part
            FOR hold IN SELECT * FROM action.hold_request WHERE target = source_part.id AND hold_type = 'P' LOOP
        
                UPDATE    action.hold_request
                  SET    target = target_part.id
                  WHERE    id = hold.id;
        
                moved_objects := moved_objects + 1;
            END LOOP;

        -- ... if not ...
        ELSE
            -- ... just move the part to the target record
            UPDATE    biblio.monograph_part
              SET    record = target_record
              WHERE    id = source_part.id;
        END IF;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- Find multi_home items attached to the source ...
    FOR multi_home IN SELECT * FROM biblio.peer_bib_copy_map WHERE peer_record = source_record LOOP
        -- ... and move them to the target record
        UPDATE    biblio.peer_bib_copy_map
          SET    peer_record = target_record
          WHERE    id = multi_home.id;

        moved_objects := moved_objects + 1;
    END LOOP;

    -- And delete mappings where the item's home bib was merged with the peer bib
    DELETE FROM biblio.peer_bib_copy_map WHERE peer_record = (
        SELECT (SELECT record FROM asset.call_number WHERE id = call_number)
        FROM asset.copy WHERE id = target_copy
    );

    -- Apply merge tracking
    UPDATE biblio.record_entry 
        SET merge_date = NOW() WHERE id = target_record;

    UPDATE biblio.record_entry
        SET merge_date = NOW(), merged_to = target_record
        WHERE id = source_record;

    -- replace book bag entries of source_record with target_record
    UPDATE container.biblio_record_entry_bucket_item
        SET target_biblio_record_entry = target_record
        WHERE bucket IN (SELECT id FROM container.biblio_record_entry_bucket WHERE btype = 'bookbag')
        AND target_biblio_record_entry = source_record;

    -- Finally, "delete" the source record
    UPDATE biblio.record_entry SET active = FALSE WHERE id = source_record;
    DELETE FROM biblio.record_entry WHERE id = source_record;

    -- That's all, folks!
    RETURN moved_objects;
END;
$_$;


ALTER FUNCTION asset.merge_record_assets(target_record bigint, source_record bigint) OWNER TO evergreen;

--
-- Name: metarecord_copy_count(integer, bigint, boolean); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.metarecord_copy_count(place integer, rid bigint, staff boolean) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF staff IS TRUE THEN
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.staff_ou_metarecord_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.staff_lasso_metarecord_copy_count( -place, rid );
        END IF;
    ELSE
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.opac_ou_metarecord_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.opac_lasso_metarecord_copy_count( -place, rid );
        END IF;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION asset.metarecord_copy_count(place integer, rid bigint, staff boolean) OWNER TO evergreen;

--
-- Name: metarecord_has_holdable_copy(bigint, integer); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.metarecord_has_holdable_copy(rid bigint, ou integer DEFAULT NULL::integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
BEGIN
    PERFORM 1
        FROM
            asset.copy acp
            JOIN asset.call_number acn ON acp.call_number = acn.id
            JOIN asset.copy_location acpl ON acp.location = acpl.id
            JOIN config.copy_status ccs ON acp.status = ccs.id
            JOIN metabib.metarecord_source_map mmsm ON acn.record = mmsm.source
        WHERE
            mmsm.metarecord = rid
            AND acp.holdable = true
            AND acpl.holdable = true
            AND ccs.holdable = true
            AND acp.deleted = false
            AND acpl.deleted = false
            AND acp.circ_lib IN (SELECT id FROM actor.org_unit_descendants(COALESCE($2,(SELECT id FROM evergreen.org_top()))))
        LIMIT 1;
    IF FOUND THEN
        RETURN true;
    END IF;
    RETURN FALSE;
END;
$_$;


ALTER FUNCTION asset.metarecord_has_holdable_copy(rid bigint, ou integer) OWNER TO evergreen;

--
-- Name: normalize_affix_sortkey(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.normalize_affix_sortkey() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.label_sortkey := REGEXP_REPLACE(
        evergreen.lpad_number_substrings(
            naco_normalize(NEW.label),
            '0',
            10
        ),
        E'\\s+',
        '',
        'g'
    );
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.normalize_affix_sortkey() OWNER TO evergreen;

--
-- Name: opac_lasso_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.opac_lasso_metarecord_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) JOIN metabib.metarecord_source_map m ON (m.source = b.id) WHERE src.transcendant AND m.metarecord = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        WITH org_list AS (SELECT ARRAY_AGG(id)::BIGINT[] AS orgs FROM actor.org_unit_descendants(ans.id) x),
             available_statuses AS (SELECT ARRAY_AGG(id) AS ids FROM config.copy_status WHERE is_available),
             mask AS (SELECT c_attrs FROM asset.patron_default_visibility_mask() x)
        SELECT  -1,
                ans.id,
                COUNT( av.id ),
                SUM( (cp.status = ANY (available_statuses.ids))::INT ),
                COUNT( av.id ),
                trans
          FROM  mask,
                org_list,
                available_statuses,
                asset.copy_vis_attr_cache av
                JOIN asset.copy cp ON (cp.id = av.target_copy)
                JOIN metabib.metarecord_source_map m ON (m.metarecord = rid AND m.source = av.record)
          WHERE cp.circ_lib = ANY (org_list.orgs) AND av.vis_attr_vector @@ mask.c_attrs::query_int
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.opac_lasso_metarecord_copy_count(i_lasso integer, rid bigint) OWNER TO evergreen;

--
-- Name: opac_lasso_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.opac_lasso_record_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        WITH org_list AS (SELECT ARRAY_AGG(id)::BIGINT[] AS orgs FROM actor.org_unit_descendants(ans.id) x),
             available_statuses AS (SELECT ARRAY_AGG(id) AS ids FROM config.copy_status WHERE is_available),
             mask AS (SELECT c_attrs FROM asset.patron_default_visibility_mask() x)
        SELECT  -1,
                ans.id,
                COUNT( av.id ),
                SUM( (cp.status = ANY (available_statuses.ids))::INT ),
                COUNT( av.id ),
                trans
          FROM  mask,
                org_list,
                asset.copy_vis_attr_cache av
                JOIN asset.copy cp ON (cp.id = av.target_copy AND av.record = rid)
          WHERE cp.circ_lib = ANY (org_list.orgs) AND av.vis_attr_vector @@ mask.c_attrs::query_int
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT -1, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.opac_lasso_record_copy_count(i_lasso integer, rid bigint) OWNER TO evergreen;

--
-- Name: opac_ou_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.opac_ou_metarecord_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) JOIN metabib.metarecord_source_map m ON (m.source = b.id) WHERE src.transcendant AND m.metarecord = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        WITH org_list AS (SELECT ARRAY_AGG(id)::BIGINT[] AS orgs FROM actor.org_unit_descendants(ans.id) x),
             available_statuses AS (SELECT ARRAY_AGG(id) AS ids FROM config.copy_status WHERE is_available),
             mask AS (SELECT c_attrs FROM asset.patron_default_visibility_mask() x)
        SELECT  ans.depth,
                ans.id,
                COUNT( av.id ),
                SUM( (cp.status = ANY (available_statuses.ids))::INT ),
                COUNT( av.id ),
                trans
          FROM  mask,
                org_list,
                available_statuses,
                asset.copy_vis_attr_cache av
                JOIN asset.copy cp ON (cp.id = av.target_copy)
                JOIN metabib.metarecord_source_map m ON (m.metarecord = rid AND m.source = av.record)
          WHERE cp.circ_lib = ANY (org_list.orgs) AND av.vis_attr_vector @@ mask.c_attrs::query_int
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.opac_ou_metarecord_copy_count(org integer, rid bigint) OWNER TO evergreen;

--
-- Name: opac_ou_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.opac_ou_record_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        WITH org_list AS (SELECT ARRAY_AGG(id)::BIGINT[] AS orgs FROM actor.org_unit_descendants(ans.id) x),
             available_statuses AS (SELECT ARRAY_AGG(id) AS ids FROM config.copy_status WHERE is_available),
             mask AS (SELECT c_attrs FROM asset.patron_default_visibility_mask() x)
        SELECT  ans.depth,
                ans.id,
                COUNT( av.id ),
                SUM( (cp.status = ANY (available_statuses.ids))::INT ),
                COUNT( av.id ),
                trans
          FROM  mask,
                available_statuses,
                org_list,
                asset.copy_vis_attr_cache av
                JOIN asset.copy cp ON (cp.id = av.target_copy AND av.record = rid)
                JOIN asset.call_number cn ON (cp.call_number = cn.id AND not cn.deleted)
          WHERE cp.circ_lib = ANY (org_list.orgs) AND av.vis_attr_vector @@ mask.c_attrs::query_int
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.opac_ou_record_copy_count(org integer, rid bigint) OWNER TO evergreen;

--
-- Name: owning_lib_default(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.owning_lib_default() RETURNS text
    LANGUAGE sql STABLE
    AS $$
    SELECT  * FROM asset.invisible_orgs('owning_lib');
$$;


ALTER FUNCTION asset.owning_lib_default() OWNER TO evergreen;

--
-- Name: patron_default_visibility_mask(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.patron_default_visibility_mask() RETURNS TABLE(b_attrs text, c_attrs text)
    LANGUAGE plpgsql STABLE ROWS 1
    AS $$
DECLARE
    copy_flags      TEXT; -- "c" attr

    owning_lib      TEXT; -- "c" attr
    circ_lib        TEXT; -- "c" attr
    status          TEXT; -- "c" attr
    location        TEXT; -- "c" attr
    location_group  TEXT; -- "c" attr

    luri_org        TEXT; -- "b" attr
    bib_sources     TEXT; -- "b" attr

    bib_tests       TEXT := '';
BEGIN
    copy_flags      := asset.all_visible_flags(); -- Will always have at least one

    owning_lib      := NULLIF(asset.owning_lib_default(),'!()');

    circ_lib        := NULLIF(asset.circ_lib_default(),'!()');
    status          := NULLIF(asset.status_default(),'!()');
    location        := NULLIF(asset.location_default(),'!()');
    location_group  := NULLIF(asset.location_group_default(),'!()');

    -- LURIs will be handled at the perl layer directly
    -- luri_org        := NULLIF(asset.luri_org_default(),'!()');
    bib_sources     := NULLIF(asset.bib_source_default(),'()');


    IF luri_org IS NOT NULL AND bib_sources IS NOT NULL THEN
        bib_tests := '('||ARRAY_TO_STRING( ARRAY[luri_org,bib_sources], '|')||')&('||luri_org||')&';
    ELSIF luri_org IS NOT NULL THEN
        bib_tests := luri_org || '&';
    ELSIF bib_sources IS NOT NULL THEN
        bib_tests := bib_sources || '|';
    END IF;

    RETURN QUERY SELECT bib_tests,
        '('||ARRAY_TO_STRING(
            ARRAY[copy_flags,owning_lib,circ_lib,status,location,location_group]::TEXT[],
            '&'
        )||')';
END;
$$;


ALTER FUNCTION asset.patron_default_visibility_mask() OWNER TO evergreen;

--
-- Name: record_copy_count(integer, bigint, boolean); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.record_copy_count(place integer, rid bigint, staff boolean) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF staff IS TRUE THEN
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.staff_ou_record_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.staff_lasso_record_copy_count( -place, rid );
        END IF;
    ELSE
        IF place > 0 THEN
            RETURN QUERY SELECT * FROM asset.opac_ou_record_copy_count( place, rid );
        ELSE
            RETURN QUERY SELECT * FROM asset.opac_lasso_record_copy_count( -place, rid );
        END IF;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION asset.record_copy_count(place integer, rid bigint, staff boolean) OWNER TO evergreen;

--
-- Name: record_has_holdable_copy(bigint, integer); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.record_has_holdable_copy(rid bigint, ou integer DEFAULT NULL::integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
BEGIN
    PERFORM 1
        FROM
            asset.copy acp
            JOIN asset.call_number acn ON acp.call_number = acn.id
            JOIN asset.copy_location acpl ON acp.location = acpl.id
            JOIN config.copy_status ccs ON acp.status = ccs.id
        WHERE
            acn.record = rid
            AND acp.holdable = true
            AND acpl.holdable = true
            AND ccs.holdable = true
            AND acp.deleted = false
            AND acpl.deleted = false
            AND acp.circ_lib IN (SELECT id FROM actor.org_unit_descendants(COALESCE($2,(SELECT id FROM evergreen.org_top()))))
        LIMIT 1;
    IF FOUND THEN
        RETURN true;
    END IF;
    RETURN FALSE;
END;
$_$;


ALTER FUNCTION asset.record_has_holdable_copy(rid bigint, ou integer) OWNER TO evergreen;

--
-- Name: set_copy_tag_value(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.set_copy_tag_value() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.value IS NULL THEN
        NEW.value = NEW.label;        
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.set_copy_tag_value() OWNER TO evergreen;

--
-- Name: staff_lasso_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.staff_lasso_metarecord_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) JOIN metabib.metarecord_source_map m ON (m.source = b.id) WHERE src.transcendant AND m.metarecord = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        SELECT  -1,
                ans.id,
                COUNT( cp.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( cp.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                JOIN asset.call_number cn ON (cn.id = cp.call_number AND NOT cn.deleted)
                JOIN metabib.metarecord_source_map m ON (m.metarecord = rid AND m.source = cn.record)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_lasso_metarecord_copy_count(i_lasso integer, rid bigint) OWNER TO evergreen;

--
-- Name: staff_lasso_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.staff_lasso_record_copy_count(i_lasso integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.org_unit AS id FROM actor.org_lasso_map AS u WHERE lasso = i_lasso LOOP
        RETURN QUERY
        SELECT  -1,
                ans.id,
                COUNT( cp.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( cp.id ), -- KCLS CUSTOM
                --SUM( CASE WHEN cl.opac_visible AND cp.opac_visible THEN 1 ELSE 0 END),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                --JOIN asset.copy_location cl ON (cp.location = cl.id AND NOT cl.deleted)
                JOIN asset.call_number cn ON (cn.record = rid AND cn.id = cp.call_number AND NOT cn.deleted)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT -1, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_lasso_record_copy_count(i_lasso integer, rid bigint) OWNER TO evergreen;

--
-- Name: staff_ou_metarecord_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.staff_ou_metarecord_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE         
    ans RECORD; 
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) JOIN metabib.metarecord_source_map m ON (m.source = b.id) WHERE src.transcendant AND m.metarecord = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        SELECT  ans.depth,
                ans.id,
                COUNT( cp.id ),
                SUM( CASE WHEN cp.status IN (0,7,12) THEN 1 ELSE 0 END ),
                COUNT( cp.id ),
                trans
          FROM
                actor.org_unit_descendants(ans.id) d
                JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                JOIN asset.call_number cn ON (cn.id = cp.call_number AND NOT cn.deleted)
                JOIN metabib.metarecord_source_map m ON (m.metarecord = rid AND m.source = cn.record)
          GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_ou_metarecord_copy_count(org integer, rid bigint) OWNER TO evergreen;

--
-- Name: staff_ou_record_copy_count(integer, bigint); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.staff_ou_record_copy_count(org integer, rid bigint) RETURNS TABLE(depth integer, org_unit integer, visible bigint, available bigint, unshadow bigint, transcendant integer)
    LANGUAGE plpgsql
    AS $$
DECLARE
    ans RECORD;
    trans INT;
BEGIN
    SELECT 1 INTO trans FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = rid;

    FOR ans IN SELECT u.id, t.depth FROM actor.org_unit_ancestors(org) AS u JOIN actor.org_unit_type t ON (u.ou_type = t.id) LOOP
        RETURN QUERY
        WITH available_statuses AS (SELECT ARRAY_AGG(id) AS ids FROM config.copy_status WHERE is_available),
            cp AS(
                SELECT  cp.id,
                        (cp.status = ANY (available_statuses.ids))::INT as available,
                        (cl.opac_visible AND cp.opac_visible)::INT as opac_visible
                  FROM
                        available_statuses,
                        actor.org_unit_descendants(ans.id) d
                        JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                        JOIN asset.copy_location cl ON (cp.location = cl.id AND NOT cl.deleted)
                        JOIN asset.call_number cn ON (cn.record = rid AND cn.id = cp.call_number AND NOT cn.deleted)
            ),
            peer AS (
                SELECT  cp.id,
                        (cp.status = ANY  (available_statuses.ids))::INT as available,
                        (cl.opac_visible AND cp.opac_visible)::INT as opac_visible
                FROM
                        available_statuses,
                        actor.org_unit_descendants(ans.id) d
                        JOIN asset.copy cp ON (cp.circ_lib = d.id AND NOT cp.deleted)
                        JOIN asset.copy_location cl ON (cp.location = cl.id AND NOT cl.deleted)
                        JOIN biblio.peer_bib_copy_map bp ON (bp.peer_record = rid AND bp.target_copy = cp.id)
            )
        SELECT ans.depth, ans.id, count(id), sum(x.available::int), sum(x.opac_visible::int), trans
        FROM ((select * from cp) union (select * from peer)) x
        GROUP BY 1,2,6;

        IF NOT FOUND THEN
            RETURN QUERY SELECT ans.depth, ans.id, 0::BIGINT, 0::BIGINT, 0::BIGINT, trans;
        END IF;

    END LOOP;
    RETURN;
END;
$$;


ALTER FUNCTION asset.staff_ou_record_copy_count(org integer, rid bigint) OWNER TO evergreen;

--
-- Name: stat_cat_check(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.stat_cat_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sipfield asset.stat_cat_sip_fields%ROWTYPE;
    use_count INT;
BEGIN
    IF NEW.sip_field IS NOT NULL THEN
        SELECT INTO sipfield * FROM asset.stat_cat_sip_fields WHERE field = NEW.sip_field;
        IF sipfield.one_only THEN
            SELECT INTO use_count count(id) FROM asset.stat_cat WHERE sip_field = NEW.sip_field AND id != NEW.id;
            IF use_count > 0 THEN
                RAISE EXCEPTION 'Sip field cannot be used twice';
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION asset.stat_cat_check() OWNER TO evergreen;

--
-- Name: status_default(); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.status_default() RETURNS text
    LANGUAGE sql STABLE
    AS $$
    SELECT  '!(' || ARRAY_TO_STRING(ARRAY_AGG(search.calculate_visibility_attribute(id, 'status')),'|') || ')'
      FROM  config.copy_status
      WHERE NOT opac_visible;
$$;


ALTER FUNCTION asset.status_default() OWNER TO evergreen;

--
-- Name: visible_orgs(text); Type: FUNCTION; Schema: asset; Owner: evergreen
--

CREATE FUNCTION asset.visible_orgs(otype text) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
    SELECT  '(' || ARRAY_TO_STRING(ARRAY_AGG(search.calculate_visibility_attribute(id, $1)),'|') || ')'
      FROM  actor.org_unit
      WHERE opac_visible;
$_$;


ALTER FUNCTION asset.visible_orgs(otype text) OWNER TO evergreen;

--
-- Name: audit_acq_fund_debit_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_acq_fund_debit_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_fund_debit_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, fund, origin_amount, origin_currency_type, amount, encumbrance, debit_type, xfer_destination, create_time, invoice_entry )
                SELECT  nextval('auditor.acq_fund_debit_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.fund, OLD.origin_amount, OLD.origin_currency_type, OLD.amount, OLD.encumbrance, OLD.debit_type, OLD.xfer_destination, OLD.create_time, OLD.invoice_entry
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_fund_debit_func() OWNER TO evergreen;

--
-- Name: audit_acq_invoice_entry_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_acq_invoice_entry_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_invoice_entry_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, invoice, purchase_order, lineitem, inv_item_count, phys_item_count, note, billed_per_item, cost_billed, actual_cost, amount_paid )
                SELECT  nextval('auditor.acq_invoice_entry_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.invoice, OLD.purchase_order, OLD.lineitem, OLD.inv_item_count, OLD.phys_item_count, OLD.note, OLD.billed_per_item, OLD.cost_billed, OLD.actual_cost, OLD.amount_paid
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_invoice_entry_func() OWNER TO evergreen;

--
-- Name: audit_acq_invoice_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_acq_invoice_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_invoice_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, receiver, provider, shipper, recv_date, recv_method, inv_type, inv_ident, payment_auth, payment_method, note, close_date, erp_export_date, closed_by )
                SELECT  nextval('auditor.acq_invoice_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.receiver, OLD.provider, OLD.shipper, OLD.recv_date, OLD.recv_method, OLD.inv_type, OLD.inv_ident, OLD.payment_auth, OLD.payment_method, OLD.note, OLD.close_date, OLD.erp_export_date, OLD.closed_by
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_invoice_func() OWNER TO evergreen;

--
-- Name: audit_acq_invoice_item_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_acq_invoice_item_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_invoice_item_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, invoice, purchase_order, fund_debit, inv_item_type, title, author, note, cost_billed, actual_cost, fund, amount_paid, po_item, target )
                SELECT  nextval('auditor.acq_invoice_item_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.invoice, OLD.purchase_order, OLD.fund_debit, OLD.inv_item_type, OLD.title, OLD.author, OLD.note, OLD.cost_billed, OLD.actual_cost, OLD.fund, OLD.amount_paid, OLD.po_item, OLD.target
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_invoice_item_func() OWNER TO evergreen;

--
-- Name: audit_acq_lineitem_detail_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_acq_lineitem_detail_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.acq_lineitem_detail_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, lineitem, fund, fund_debit, eg_copy_id, barcode, cn_label, note, collection_code, circ_modifier, owning_lib, location, recv_time, cancel_reason, receiver )
                SELECT  nextval('auditor.acq_lineitem_detail_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.lineitem, OLD.fund, OLD.fund_debit, OLD.eg_copy_id, OLD.barcode, OLD.cn_label, OLD.note, OLD.collection_code, OLD.circ_modifier, OLD.owning_lib, OLD.location, OLD.recv_time, OLD.cancel_reason, OLD.receiver
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_acq_lineitem_detail_func() OWNER TO evergreen;

--
-- Name: audit_action_trigger_event_definition_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_action_trigger_event_definition_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.action_trigger_event_definition_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, active, owner, name, hook, validator, reactor, cleanup_success, cleanup_failure, delay, max_delay, usr_field, opt_in_setting, delay_field, group_field, template, granularity, repeat_delay, message_template, message_usr_path, message_library_path, message_title, retention_interval, context_usr_path, context_library_path, context_bib_path, context_item_path )
                SELECT  nextval('auditor.action_trigger_event_definition_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.active, OLD.owner, OLD.name, OLD.hook, OLD.validator, OLD.reactor, OLD.cleanup_success, OLD.cleanup_failure, OLD.delay, OLD.max_delay, OLD.usr_field, OLD.opt_in_setting, OLD.delay_field, OLD.group_field, OLD.template, OLD.granularity, OLD.repeat_delay, OLD.message_template, OLD.message_usr_path, OLD.message_library_path, OLD.message_title, OLD.retention_interval, OLD.context_usr_path, OLD.context_library_path, OLD.context_bib_path, OLD.context_item_path
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_action_trigger_event_definition_func() OWNER TO evergreen;

--
-- Name: audit_actor_org_unit_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_actor_org_unit_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.actor_org_unit_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, parent_ou, ou_type, ill_address, holds_address, mailing_address, billing_address, shortname, name, email, phone, opac_visible, fiscal_calendar )
                SELECT  nextval('auditor.actor_org_unit_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.parent_ou, OLD.ou_type, OLD.ill_address, OLD.holds_address, OLD.mailing_address, OLD.billing_address, OLD.shortname, OLD.name, OLD.email, OLD.phone, OLD.opac_visible, OLD.fiscal_calendar
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_actor_org_unit_func() OWNER TO evergreen;

--
-- Name: audit_actor_usr_address_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_actor_usr_address_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.actor_usr_address_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, valid, within_city_limits, address_type, usr, street1, street2, city, county, state, country, post_code, pending, replaces )
                SELECT  nextval('auditor.actor_usr_address_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.valid, OLD.within_city_limits, OLD.address_type, OLD.usr, OLD.street1, OLD.street2, OLD.city, OLD.county, OLD.state, OLD.country, OLD.post_code, OLD.pending, OLD.replaces
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_actor_usr_address_func() OWNER TO evergreen;

--
-- Name: audit_actor_usr_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_actor_usr_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.actor_usr_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, card, profile, usrname, email, passwd, standing, ident_type, ident_value, ident_type2, ident_value2, net_access_level, photo_url, prefix, first_given_name, second_given_name, family_name, suffix, alias, day_phone, evening_phone, other_phone, mailing_address, billing_address, home_ou, dob, active, master_account, super_user, barred, deleted, juvenile, usrgroup, claims_returned_count, credit_forward_balance, last_xact_id, create_date, expire_date, claims_never_checked_out_count, last_update_time, pref_prefix, pref_first_given_name, pref_second_given_name, pref_family_name, pref_suffix, name_keywords, name_kw_tsvector, guardian )
                SELECT  nextval('auditor.actor_usr_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.card, OLD.profile, OLD.usrname, OLD.email, OLD.passwd, OLD.standing, OLD.ident_type, OLD.ident_value, OLD.ident_type2, OLD.ident_value2, OLD.net_access_level, OLD.photo_url, OLD.prefix, OLD.first_given_name, OLD.second_given_name, OLD.family_name, OLD.suffix, OLD.alias, OLD.day_phone, OLD.evening_phone, OLD.other_phone, OLD.mailing_address, OLD.billing_address, OLD.home_ou, OLD.dob, OLD.active, OLD.master_account, OLD.super_user, OLD.barred, OLD.deleted, OLD.juvenile, OLD.usrgroup, OLD.claims_returned_count, OLD.credit_forward_balance, OLD.last_xact_id, OLD.create_date, OLD.expire_date, OLD.claims_never_checked_out_count, OLD.last_update_time, OLD.pref_prefix, OLD.pref_first_given_name, OLD.pref_second_given_name, OLD.pref_family_name, OLD.pref_suffix, OLD.name_keywords, OLD.name_kw_tsvector, OLD.guardian
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_actor_usr_func() OWNER TO evergreen;

--
-- Name: audit_actor_usr_setting_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_actor_usr_setting_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.actor_usr_setting_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, usr, name, value )
                SELECT  nextval('auditor.actor_usr_setting_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.usr, OLD.name, OLD.value
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_actor_usr_setting_func() OWNER TO evergreen;

--
-- Name: audit_asset_call_number_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_asset_call_number_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.asset_call_number_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, creator, create_date, editor, edit_date, record, owning_lib, label, deleted, label_class, label_sortkey, prefix, suffix )
                SELECT  nextval('auditor.asset_call_number_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.creator, OLD.create_date, OLD.editor, OLD.edit_date, OLD.record, OLD.owning_lib, OLD.label, OLD.deleted, OLD.label_class, OLD.label_sortkey, OLD.prefix, OLD.suffix
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_asset_call_number_func() OWNER TO evergreen;

--
-- Name: audit_asset_copy_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_asset_copy_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.asset_copy_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, circ_lib, creator, call_number, editor, create_date, edit_date, copy_number, status, location, loan_duration, fine_level, age_protect, circulate, deposit, ref, holdable, deposit_amount, price, barcode, circ_modifier, circ_as_type, dummy_title, dummy_author, alert_message, opac_visible, deleted, floating, dummy_isbn, status_changed_time, mint_condition, cost, active_date )
                SELECT  nextval('auditor.asset_copy_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.circ_lib, OLD.creator, OLD.call_number, OLD.editor, OLD.create_date, OLD.edit_date, OLD.copy_number, OLD.status, OLD.location, OLD.loan_duration, OLD.fine_level, OLD.age_protect, OLD.circulate, OLD.deposit, OLD.ref, OLD.holdable, OLD.deposit_amount, OLD.price, OLD.barcode, OLD.circ_modifier, OLD.circ_as_type, OLD.dummy_title, OLD.dummy_author, OLD.alert_message, OLD.opac_visible, OLD.deleted, OLD.floating, OLD.dummy_isbn, OLD.status_changed_time, OLD.mint_condition, OLD.cost, OLD.active_date
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_asset_copy_func() OWNER TO evergreen;

--
-- Name: audit_biblio_record_entry_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_biblio_record_entry_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.biblio_record_entry_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, creator, editor, source, quality, create_date, edit_date, active, deleted, fingerprint, tcn_source, tcn_value, marc, last_xact_id, owner, share_depth, cataloging_date, merge_date, merged_to, vis_attr_vector )
                SELECT  nextval('auditor.biblio_record_entry_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.creator, OLD.editor, OLD.source, OLD.quality, OLD.create_date, OLD.edit_date, OLD.active, OLD.deleted, OLD.fingerprint, OLD.tcn_source, OLD.tcn_value, OLD.marc, OLD.last_xact_id, OLD.owner, OLD.share_depth, OLD.cataloging_date, OLD.merge_date, OLD.merged_to, OLD.vis_attr_vector
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_biblio_record_entry_func() OWNER TO evergreen;

--
-- Name: audit_serial_unit_func(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.audit_serial_unit_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        BEGIN
            INSERT INTO auditor.serial_unit_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, id, circ_lib, creator, call_number, editor, create_date, edit_date, copy_number, status, location, loan_duration, fine_level, age_protect, circulate, deposit, ref, holdable, deposit_amount, price, barcode, circ_modifier, circ_as_type, dummy_title, dummy_author, alert_message, opac_visible, deleted, floating, dummy_isbn, status_changed_time, mint_condition, cost, active_date, sort_key, detailed_contents, summary_contents )
                SELECT  nextval('auditor.serial_unit_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.id, OLD.circ_lib, OLD.creator, OLD.call_number, OLD.editor, OLD.create_date, OLD.edit_date, OLD.copy_number, OLD.status, OLD.location, OLD.loan_duration, OLD.fine_level, OLD.age_protect, OLD.circulate, OLD.deposit, OLD.ref, OLD.holdable, OLD.deposit_amount, OLD.price, OLD.barcode, OLD.circ_modifier, OLD.circ_as_type, OLD.dummy_title, OLD.dummy_author, OLD.alert_message, OLD.opac_visible, OLD.deleted, OLD.floating, OLD.dummy_isbn, OLD.status_changed_time, OLD.mint_condition, OLD.cost, OLD.active_date, OLD.sort_key, OLD.detailed_contents, OLD.summary_contents
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $$;


ALTER FUNCTION auditor.audit_serial_unit_func() OWNER TO evergreen;

--
-- Name: clear_audit_info(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.clear_audit_info() RETURNS void
    LANGUAGE plperlu
    AS $_X$
    delete($_SHARED{"eg_audit_user"});
    delete($_SHARED{"eg_audit_ws"});
$_X$;


ALTER FUNCTION auditor.clear_audit_info() OWNER TO evergreen;

--
-- Name: create_auditor(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.create_auditor(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM auditor.create_auditor_seq(sch, tbl);
    PERFORM auditor.create_auditor_history(sch, tbl);
    PERFORM auditor.create_auditor_func(sch, tbl);
    PERFORM auditor.create_auditor_update_trigger(sch, tbl);
    PERFORM auditor.create_auditor_lifecycle(sch, tbl);
    RETURN TRUE;
END;
$$;


ALTER FUNCTION auditor.create_auditor(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_auditor_func(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.create_auditor_func(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    column_list TEXT[];
BEGIN
    SELECT INTO column_list array_agg(a.attname)
        FROM pg_catalog.pg_attribute a
            JOIN pg_catalog.pg_class c ON a.attrelid = c.oid
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
        WHERE relkind = 'r' AND n.nspname = sch AND c.relname = tbl AND a.attnum > 0 AND NOT a.attisdropped;

    EXECUTE $$
        CREATE OR REPLACE FUNCTION auditor.audit_$$ || sch || $$_$$ || tbl || $$_func ()
        RETURNS TRIGGER AS $func$
        BEGIN
            INSERT INTO auditor.$$ || sch || $$_$$ || tbl || $$_history ( audit_id, audit_time, audit_action, audit_user, audit_ws, $$
            || array_to_string(column_list, ', ') || $$ )
                SELECT  nextval('auditor.$$ || sch || $$_$$ || tbl || $$_pkey_seq'),
                    now(),
                    SUBSTR(TG_OP,1,1),
                    eg_user,
                    eg_ws,
                    OLD.$$ || array_to_string(column_list, ', OLD.') || $$
                FROM auditor.get_audit_info();
            RETURN NULL;
        END;
        $func$ LANGUAGE 'plpgsql';
    $$;
    RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_func(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_auditor_history(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.create_auditor_history(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TABLE auditor.$$ || sch || $$_$$ || tbl || $$_history (
            audit_id	BIGINT				PRIMARY KEY,
            audit_time	TIMESTAMP WITH TIME ZONE	NOT NULL,
            audit_action	TEXT				NOT NULL,
            audit_user  INT,
            audit_ws    INT,
            LIKE $$ || sch || $$.$$ || tbl || $$
        );
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_history(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_auditor_lifecycle(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.create_auditor_lifecycle(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    column_list TEXT[];
BEGIN
    SELECT INTO column_list array_agg(a.attname)
        FROM pg_catalog.pg_attribute a
            JOIN pg_catalog.pg_class c ON a.attrelid = c.oid
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
        WHERE relkind = 'r' AND n.nspname = sch AND c.relname = tbl AND a.attnum > 0 AND NOT a.attisdropped;

    EXECUTE $$
        CREATE VIEW auditor.$$ || sch || $$_$$ || tbl || $$_lifecycle AS
            SELECT -1 AS audit_id,
                   now() AS audit_time,
                   '-' AS audit_action,
                   -1 AS audit_user,
                   -1 AS audit_ws,
                   $$ || array_to_string(column_list, ', ') || $$
              FROM $$ || sch || $$.$$ || tbl || $$
                UNION ALL
            SELECT audit_id, audit_time, audit_action, audit_user, audit_ws,
            $$ || array_to_string(column_list, ', ') || $$
              FROM auditor.$$ || sch || $$_$$ || tbl || $$_history;
    $$;
    RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_lifecycle(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_auditor_seq(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.create_auditor_seq(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE SEQUENCE auditor.$$ || sch || $$_$$ || tbl || $$_pkey_seq;
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_seq(sch text, tbl text) OWNER TO evergreen;

--
-- Name: create_auditor_update_trigger(text, text); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.create_auditor_update_trigger(sch text, tbl text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_X$
BEGIN
    EXECUTE $$
        CREATE TRIGGER audit_$$ || sch || $$_$$ || tbl || $$_update_trigger
            AFTER UPDATE OR DELETE ON $$ || sch || $$.$$ || tbl || $$ FOR EACH ROW
            EXECUTE PROCEDURE auditor.audit_$$ || sch || $$_$$ || tbl || $$_func ();
    $$;
	RETURN TRUE;
END;
$_X$;


ALTER FUNCTION auditor.create_auditor_update_trigger(sch text, tbl text) OWNER TO evergreen;

--
-- Name: fix_columns(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.fix_columns() RETURNS void
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    current_table TEXT = ''; -- Storage for post-loop main table name
    current_audit_table TEXT = ''; -- Storage for post-loop audit table name
    query TEXT = ''; -- Storage for built query
    cr RECORD; -- column record object
    alter_t BOOL = false; -- Has the alter table command been appended yet
    auditor_cores TEXT[] = ARRAY[]::TEXT[]; -- Core auditor function list (filled inside of loop)
    core_column TEXT; -- The current core column we are adding
BEGIN
    FOR cr IN
        WITH audit_tables AS ( -- Basic grab of auditor tables. Anything in the auditor namespace, basically. With oids.
            SELECT c.oid AS audit_oid, c.relname AS audit_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            WHERE relkind='r' AND nspname = 'auditor'
        ),
        table_set AS ( -- Union of auditor tables with their "main" tables. With oids.
            SELECT a.audit_oid, a.audit_table, c.oid AS main_oid, n.nspname as main_namespace, c.relname as main_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            JOIN audit_tables a ON a.audit_table = n.nspname || '_' || c.relname || '_history'
            WHERE relkind = 'r'
        ),
        column_lists AS ( -- All columns associated with the auditor or main table, grouped by the main table's oid.
            SELECT DISTINCT ON (main_oid, attname) t.main_oid, a.attname
            FROM table_set t
            JOIN pg_catalog.pg_attribute a ON a.attrelid IN (t.main_oid, t.audit_oid)
            WHERE attnum > 0 AND NOT attisdropped
        ),
        column_defs AS ( -- The motherload, every audit table and main table plus column names and defs.
            SELECT audit_table,
                   main_namespace,
                   main_table,
                   a.attname AS main_column, -- These two will be null for columns that have since been deleted, or for auditor core columns
                   pg_catalog.format_type(a.atttypid, a.atttypmod) AS main_column_def,
                   b.attname AS audit_column, -- These two will be null for columns that have since been added
                   pg_catalog.format_type(b.atttypid, b.atttypmod) AS audit_column_def
            FROM table_set t
            JOIN column_lists c USING (main_oid)
            LEFT JOIN pg_catalog.pg_attribute a ON a.attname = c.attname AND a.attrelid = t.main_oid AND a.attnum > 0 AND NOT a.attisdropped
            LEFT JOIN pg_catalog.pg_attribute b ON b.attname = c.attname AND b.attrelid = t.audit_oid AND b.attnum > 0 AND NOT b.attisdropped
        )
        -- Nice sorted output from the above
        SELECT * FROM column_defs WHERE main_column_def IS DISTINCT FROM audit_column_def ORDER BY main_namespace, main_table, main_column, audit_column
    LOOP
        IF current_table <> (cr.main_namespace || '.' || cr.main_table) THEN -- New table?
            FOR core_column IN SELECT DISTINCT unnest(auditor_cores) LOOP -- Update missing core auditor columns
                IF NOT alter_t THEN -- Add ALTER TABLE if we haven't already
                    query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                    alter_t:=TRUE;
                ELSE
                    query:=query || $$,$$;
                END IF;
                -- Bit of a sneaky bit here. Create audit_id as a bigserial so it gets automatic values and doesn't complain about nulls when becoming a PRIMARY KEY.
                query:=query || $$ ADD COLUMN $$ || CASE WHEN core_column = 'audit_id bigint' THEN $$audit_id bigserial PRIMARY KEY$$ ELSE core_column END;
            END LOOP;
            IF alter_t THEN -- Open alter table = needs a semicolon
                query:=query || $$; $$;
                alter_t:=FALSE;
                IF 'audit_id bigint' = ANY(auditor_cores) THEN -- We added a primary key...
                    -- Fun! Drop the default on audit_id, drop the auto-created sequence, create a new one, and set the current value
                    -- For added fun, we have to execute in chunks due to the parser checking setval/currval arguments at parse time.
                    EXECUTE query;
                    EXECUTE $$ALTER TABLE auditor.$$ || current_audit_table || $$ ALTER COLUMN audit_id DROP DEFAULT; $$ ||
                        $$CREATE SEQUENCE auditor.$$ || current_audit_table || $$_pkey_seq;$$;
                    EXECUTE $$SELECT setval('auditor.$$ || current_audit_table || $$_pkey_seq', currval('auditor.$$ || current_audit_table || $$_audit_id_seq')); $$ ||
                        $$DROP SEQUENCE auditor.$$ || current_audit_table || $$_audit_id_seq;$$;
                    query:='';
                END IF;
            END IF;
            -- New table means we reset the list of needed auditor core columns
            auditor_cores = ARRAY['audit_id bigint', 'audit_time timestamp with time zone', 'audit_action text', 'audit_user integer', 'audit_ws integer'];
            -- And store some values for use later, because we can't rely on cr in all places.
            current_table:=cr.main_namespace || '.' || cr.main_table;
            current_audit_table:=cr.audit_table;
        END IF;
        IF cr.main_column IS NULL AND cr.audit_column LIKE 'audit_%' THEN -- Core auditor column?
            -- Remove core from list of cores
            SELECT INTO auditor_cores array_agg(core) FROM unnest(auditor_cores) AS core WHERE core != (cr.audit_column || ' ' || cr.audit_column_def);
        ELSIF cr.main_column IS NULL THEN -- Main column doesn't exist, and it isn't an auditor column. Needs dropping from the auditor.
            IF NOT alter_t THEN
                query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                alter_t:=TRUE;
            ELSE
                query:=query || $$,$$;
            END IF;
            query:=query || $$ DROP COLUMN $$ || cr.audit_column;
        ELSIF cr.audit_column IS NULL AND cr.main_column IS NOT NULL THEN -- New column auditor doesn't have. Add it.
            IF NOT alter_t THEN
                query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                alter_t:=TRUE;
            ELSE
                query:=query || $$,$$;
            END IF;
            query:=query || $$ ADD COLUMN $$ || cr.main_column || $$ $$ || cr.main_column_def;
        ELSIF cr.main_column IS NOT NULL AND cr.audit_column IS NOT NULL THEN -- Both sides have this column, but types differ. Fix that.
            IF NOT alter_t THEN
                query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
                alter_t:=TRUE;
            ELSE
                query:=query || $$,$$;
            END IF;
            query:=query || $$ ALTER COLUMN $$ || cr.audit_column || $$ TYPE $$ || cr.main_column_def;
        END IF;
    END LOOP;
    FOR core_column IN SELECT DISTINCT unnest(auditor_cores) LOOP -- Repeat this outside of the loop to catch the last table
        IF NOT alter_t THEN
            query:=query || $$ALTER TABLE auditor.$$ || current_audit_table;
            alter_t:=TRUE;
        ELSE
            query:=query || $$,$$;
        END IF;
        -- Bit of a sneaky bit here. Create audit_id as a bigserial so it gets automatic values and doesn't complain about nulls when becoming a PRIMARY KEY.
        query:=query || $$ ADD COLUMN $$ || CASE WHEN core_column = 'audit_id bigint' THEN $$audit_id bigserial PRIMARY KEY$$ ELSE core_column END;
    END LOOP;
    IF alter_t THEN -- Open alter table = needs a semicolon
        query:=query || $$;$$;
        IF 'audit_id bigint' = ANY(auditor_cores) THEN -- We added a primary key...
            -- Fun! Drop the default on audit_id, drop the auto-created sequence, create a new one, and set the current value
            -- For added fun, we have to execute in chunks due to the parser checking setval/currval arguments at parse time.
            EXECUTE query;
            EXECUTE $$ALTER TABLE auditor.$$ || current_audit_table || $$ ALTER COLUMN audit_id DROP DEFAULT; $$ ||
                $$CREATE SEQUENCE auditor.$$ || current_audit_table || $$_pkey_seq;$$;
            EXECUTE $$SELECT setval('auditor.$$ || current_audit_table || $$_pkey_seq', currval('auditor.$$ || current_audit_table || $$_audit_id_seq')); $$ ||
                $$DROP SEQUENCE auditor.$$ || current_audit_table || $$_audit_id_seq;$$;
            query:='';
        END IF;
    END IF;
    EXECUTE query;
END;
$_X$;


ALTER FUNCTION auditor.fix_columns() OWNER TO evergreen;

--
-- Name: get_audit_info(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.get_audit_info() RETURNS TABLE(eg_user integer, eg_ws integer)
    LANGUAGE plperlu
    AS $_X$
    return [{eg_user => $_SHARED{"eg_audit_user"}, eg_ws => $_SHARED{"eg_audit_ws"}}];
$_X$;


ALTER FUNCTION auditor.get_audit_info() OWNER TO evergreen;

--
-- Name: purge_audit_data(integer, integer, interval, interval, interval); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.purge_audit_data(keep_cur_entries integer, keep_old_entries integer, pivot_age interval, drop_age interval, run_duration interval) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    aid BIGINT;
    del_counter BIGINT DEFAULT 0;
    start_time TIMESTAMPTZ;
BEGIN

    start_time := CLOCK_TIMESTAMP();

    DELETE FROM auditor.asset_copy_history 
        WHERE audit_time < (NOW() - drop_age);

    IF CLOCK_TIMESTAMP() - start_time > run_duration THEN
        RAISE NOTICE 
            'Exiting auditor.purge_audit_data() on max duration %', 
            run_duration;
        RETURN;
    END IF;

    RAISE NOTICE 'Done with old entry deletes.  Starting current deletes.';

    -- loop over auditor rows that constitute the 16th or older
    -- row per copy and delete each.
    FOR aid IN 
        WITH ranked_entries_per_copy AS (
            SELECT audit_id,
                ROW_NUMBER() OVER (
                    PARTITION BY id
                    ORDER BY audit_time DESC, audit_id DESC
                ) AS position
            FROM auditor.asset_copy_history
        ) SELECT ranked.audit_id
            FROM ranked_entries_per_copy ranked 
            WHERE ranked.position > keep_cur_entries
    LOOP
        
        DELETE FROM auditor.asset_copy_history WHERE audit_id = aid;
        del_counter := del_counter + 1;

        IF (del_counter % 10000) = 0 THEN
            RAISE NOTICE 'Deleted % auditor rows', del_counter;
        END IF;

        IF CLOCK_TIMESTAMP() - start_time > run_duration THEN
            RAISE NOTICE 
                'Exiting auditor.purge_audit_data() on max duration %', 
                run_duration;
            RETURN;
        END IF;
    END LOOP;

    RAISE NOTICE 'Done with current entry maintenence; cleaning older entries';

    -- loop over auditor rows older than pivot_age that constitute 
    -- the 4th or older row per copy and delete them.
    FOR aid IN 
        WITH ranked_entries_per_copy AS (
            SELECT audit_id,
                ROW_NUMBER() OVER (
                    PARTITION BY id
                    ORDER BY audit_time DESC, audit_id DESC
                ) AS position
            FROM auditor.asset_copy_history
            WHERE audit_time < (NOW() - pivot_age)
        ) SELECT ranked.audit_id
            FROM ranked_entries_per_copy ranked 
            WHERE ranked.position > keep_old_entries
    LOOP
        
        DELETE FROM auditor.asset_copy_history WHERE audit_id = aid;
        del_counter := del_counter + 1;

        IF (del_counter % 10000) = 0 THEN
            RAISE NOTICE 'Deleted % auditor rows', del_counter;
        END IF;

        IF CLOCK_TIMESTAMP() - start_time > run_duration THEN
            RAISE NOTICE 
                'Exiting auditor.purge_audit_data() on max duration %', 
                run_duration;
            RETURN;
        END IF;
    END LOOP;
END;
$$;


ALTER FUNCTION auditor.purge_audit_data(keep_cur_entries integer, keep_old_entries integer, pivot_age interval, drop_age interval, run_duration interval) OWNER TO evergreen;

--
-- Name: set_audit_info(integer, integer); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.set_audit_info(integer, integer) RETURNS void
    LANGUAGE plperlu
    AS $_X$
    $_SHARED{"eg_audit_user"} = $_[0];
    $_SHARED{"eg_audit_ws"} = $_[1];
$_X$;


ALTER FUNCTION auditor.set_audit_info(integer, integer) OWNER TO evergreen;

--
-- Name: update_auditors(); Type: FUNCTION; Schema: auditor; Owner: evergreen
--

CREATE FUNCTION auditor.update_auditors() RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
    auditor_name TEXT;
    table_schema TEXT;
    table_name TEXT;
BEGIN
    -- Drop Lifecycle view(s) before potential column changes
    FOR auditor_name IN
        SELECT c.relname
            FROM pg_catalog.pg_class c
                JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            WHERE relkind = 'v' AND n.nspname = 'auditor' LOOP
        EXECUTE $$ DROP VIEW auditor.$$ || auditor_name || $$;$$;
    END LOOP;
    -- Fix all column discrepencies
    PERFORM auditor.fix_columns();
    -- Re-create trigger functions and lifecycle views
    FOR table_schema, table_name IN
        WITH audit_tables AS (
            SELECT c.oid AS audit_oid, c.relname AS audit_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            WHERE relkind='r' AND nspname = 'auditor'
        ),
        table_set AS (
            SELECT a.audit_oid, a.audit_table, c.oid AS main_oid, n.nspname as main_namespace, c.relname as main_table
            FROM pg_catalog.pg_class c
            JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
            JOIN audit_tables a ON a.audit_table = n.nspname || '_' || c.relname || '_history'
            WHERE relkind = 'r'
        )
        SELECT main_namespace, main_table FROM table_set LOOP
        
        PERFORM auditor.create_auditor_func(table_schema, table_name);
        PERFORM auditor.create_auditor_lifecycle(table_schema, table_name);
    END LOOP;
    RETURN TRUE;
END;
$_$;


ALTER FUNCTION auditor.update_auditors() OWNER TO evergreen;

--
-- Name: atag_authority_tags(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.atag_authority_tags(atag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_AGG(id) FROM authority.control_set_authority_field WHERE tag = $1
$_$;


ALTER FUNCTION authority.atag_authority_tags(atag text) OWNER TO evergreen;

--
-- Name: atag_authority_tags_refs(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.atag_authority_tags_refs(atag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_AGG(y) from (
        SELECT  unnest(ARRAY_CAT(
                    ARRAY[a.id],
                    (SELECT ARRAY_AGG(x.id) FROM authority.control_set_authority_field x WHERE x.main_entry = a.id)
                )) y
      FROM  authority.control_set_authority_field a
      WHERE a.tag = $1) x
$_$;


ALTER FUNCTION authority.atag_authority_tags_refs(atag text) OWNER TO evergreen;

--
-- Name: atag_browse_center(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.atag_browse_center(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.atag_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.atag_browse_center(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: atag_browse_center_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.atag_browse_center_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.atag_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.atag_browse_center_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: atag_browse_top(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.atag_browse_top(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.atag_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.atag_browse_top(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: atag_browse_top_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.atag_browse_top_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.atag_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.atag_browse_top_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: atag_search_heading(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.atag_search_heading(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.atag_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.atag_search_heading(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: atag_search_heading_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.atag_search_heading_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.atag_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.atag_search_heading_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: atag_search_rank(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.atag_search_rank(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.atag_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.atag_search_rank(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: atag_search_rank_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.atag_search_rank_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.atag_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.atag_search_rank_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: axis_authority_tags(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.axis_authority_tags(a text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_AGG(field) FROM authority.browse_axis_authority_field_map WHERE axis = $1;
$_$;


ALTER FUNCTION authority.axis_authority_tags(a text) OWNER TO evergreen;

--
-- Name: axis_authority_tags_refs(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.axis_authority_tags_refs(a text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_AGG(y) from (
       SELECT  unnest(ARRAY_CAT(
                 ARRAY[a.field],
                 (SELECT ARRAY_AGG(x.id) FROM authority.control_set_authority_field x WHERE x.main_entry = a.field)
             )) y
       FROM  authority.browse_axis_authority_field_map a
       WHERE axis = $1) x
$_$;


ALTER FUNCTION authority.axis_authority_tags_refs(a text) OWNER TO evergreen;

--
-- Name: axis_browse_center(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.axis_browse_center(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.axis_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.axis_browse_center(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: axis_browse_center_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.axis_browse_center_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.axis_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.axis_browse_center_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: axis_browse_top(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.axis_browse_top(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.axis_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.axis_browse_top(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: axis_browse_top_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.axis_browse_top_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.axis_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.axis_browse_top_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: axis_search_heading(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.axis_search_heading(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.axis_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.axis_search_heading(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: axis_search_heading_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.axis_search_heading_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.axis_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.axis_search_heading_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: axis_search_rank(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.axis_search_rank(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.axis_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.axis_search_rank(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: axis_search_rank_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.axis_search_rank_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.axis_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.axis_search_rank_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: btag_authority_tags(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.btag_authority_tags(btag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_AGG(authority_field) FROM authority.control_set_bib_field WHERE tag = $1
$_$;


ALTER FUNCTION authority.btag_authority_tags(btag text) OWNER TO evergreen;

--
-- Name: btag_authority_tags_refs(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.btag_authority_tags_refs(btag text) RETURNS integer[]
    LANGUAGE sql
    AS $_$
    SELECT ARRAY_AGG(y) from (
        SELECT  unnest(ARRAY_CAT(
                    ARRAY[a.authority_field],
                    (SELECT ARRAY_AGG(x.id) FROM authority.control_set_authority_field x WHERE x.main_entry = a.authority_field)
                )) y
      FROM  authority.control_set_bib_field a
      WHERE a.tag = $1) x
$_$;


ALTER FUNCTION authority.btag_authority_tags_refs(btag text) OWNER TO evergreen;

--
-- Name: btag_browse_center(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.btag_browse_center(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.btag_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.btag_browse_center(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: btag_browse_center_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.btag_browse_center_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 9, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_center(authority.btag_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.btag_browse_center_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: btag_browse_top(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.btag_browse_top(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.btag_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.btag_browse_top(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: btag_browse_top_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.btag_browse_top_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_browse_top(authority.btag_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.btag_browse_top_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: btag_search_heading(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.btag_search_heading(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.btag_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.btag_search_heading(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: btag_search_heading_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.btag_search_heading_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_heading(authority.btag_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.btag_search_heading_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: btag_search_rank(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.btag_search_rank(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.btag_authority_tags($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.btag_search_rank(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: btag_search_rank_refs(text, text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.btag_search_rank_refs(a text, q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT * FROM authority.simple_heading_search_rank(authority.btag_authority_tags_refs($1), $2, $3, $4, $5)
$_$;


ALTER FUNCTION authority.btag_search_rank_refs(a text, q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: authority_linking; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.authority_linking (
    id bigint NOT NULL,
    source bigint NOT NULL,
    target bigint NOT NULL,
    field integer NOT NULL
);


ALTER TABLE authority.authority_linking OWNER TO evergreen;

--
-- Name: calculate_authority_linking(bigint, integer, xml); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.calculate_authority_linking(rec_id bigint, rec_control_set integer, rec_marc_xml xml) RETURNS SETOF authority.authority_linking
    LANGUAGE plpgsql
    AS $_$
DECLARE
    acsaf       authority.control_set_authority_field%ROWTYPE;
    link        TEXT;
    aal         authority.authority_linking%ROWTYPE;
BEGIN
    IF rec_control_set IS NULL THEN
        -- No control_set on record?  Guess at one
        SELECT control_set INTO rec_control_set
            FROM authority.control_set_authority_field
            WHERE tag IN (
                SELECT UNNEST(
                    XPATH('//*[starts-with(@tag,"1")]/@tag',rec_marc_xml)::TEXT[]
                )
            ) LIMIT 1;

        IF NOT FOUND THEN
            RAISE WARNING 'Could not even guess at control set for authority record %', rec_id;
            RETURN;
        END IF;
    END IF;

    aal.source := rec_id;

    FOR acsaf IN
        SELECT * FROM authority.control_set_authority_field
        WHERE control_set = rec_control_set
            AND linking_subfield IS NOT NULL
            AND main_entry IS NOT NULL
    LOOP
        -- Loop over the trailing-number contents of all linking subfields
        FOR link IN
            SELECT  SUBSTRING( x::TEXT, '\d+$' )
              FROM  UNNEST(
                        XPATH(
                            '//*[@tag="'
                                || acsaf.tag
                                || '"]/*[@code="'
                                || acsaf.linking_subfield
                                || '"]/text()',
                            rec_marc_xml
                        )
                    ) x
        LOOP

            -- Ignore links that are null, malformed, circular, or point to
            -- non-existent authority records.
            IF link IS NOT NULL AND link::BIGINT <> rec_id THEN
                PERFORM * FROM authority.record_entry WHERE id = link::BIGINT;
                IF FOUND THEN
                    aal.target := link::BIGINT;
                    aal.field := acsaf.id;
                    RETURN NEXT aal;
                END IF;
            END IF;
        END LOOP;
    END LOOP;
END;
$_$;


ALTER FUNCTION authority.calculate_authority_linking(rec_id bigint, rec_control_set integer, rec_marc_xml xml) OWNER TO evergreen;

--
-- Name: extract_headings(bigint, integer[]); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.extract_headings(rid bigint, restrict integer[] DEFAULT NULL::integer[]) RETURNS SETOF authority.heading
    LANGUAGE plpgsql
    AS $$
DECLARE
    auth        authority.record_entry%ROWTYPE;
    output_row  authority.heading;
BEGIN
    -- Get the record
    SELECT INTO auth * FROM authority.record_entry WHERE id = rid;

    RETURN QUERY SELECT * FROM authority.extract_headings(auth.marc, restrict);
END;
$$;


ALTER FUNCTION authority.extract_headings(rid bigint, restrict integer[]) OWNER TO evergreen;

--
-- Name: extract_headings(text, integer[]); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.extract_headings(marc text, restrict integer[] DEFAULT NULL::integer[]) RETURNS SETOF authority.heading
    LANGUAGE plpgsql
    AS $$
DECLARE
    idx         authority.heading_field%ROWTYPE;
    xfrm        config.xml_transform%ROWTYPE;
    prev_xfrm   TEXT;
    transformed_xml TEXT;
    heading_node    TEXT;
    heading_node_list   TEXT[];
    component_node    TEXT;
    component_node_list   TEXT[];
    raw_text    TEXT;
    normalized_text    TEXT;
    normalizer  RECORD;
    curr_text   TEXT;
    joiner      TEXT;
    type_value  TEXT;
    base_thesaurus TEXT := NULL;
    output_row  authority.heading;
BEGIN

    -- Loop over the indexing entries
    FOR idx IN SELECT * FROM authority.heading_field WHERE restrict IS NULL OR id = ANY (restrict) ORDER BY format LOOP

        output_row.field   := idx.id;
        output_row.type    := idx.heading_type;
        output_row.purpose := idx.heading_purpose;

        joiner := COALESCE(idx.joiner, ' ');

        SELECT INTO xfrm * from config.xml_transform WHERE name = idx.format;

        -- See if we can skip the XSLT ... it's expensive
        IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
            -- Can't skip the transform
            IF xfrm.xslt <> '---' THEN
                transformed_xml := oils_xslt_process(marc, xfrm.xslt);
            ELSE
                transformed_xml := marc;
            END IF;

            prev_xfrm := xfrm.name;
        END IF;

        IF idx.thesaurus_xpath IS NOT NULL THEN
            base_thesaurus := ARRAY_TO_STRING(oils_xpath(idx.thesaurus_xpath, transformed_xml, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]), '');
        END IF;

        heading_node_list := oils_xpath( idx.heading_xpath, transformed_xml, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );

        FOR heading_node IN SELECT x FROM unnest(heading_node_list) AS x LOOP

            CONTINUE WHEN heading_node !~ E'^\\s*<';

            output_row.variant_type := NULL;
            output_row.related_type := NULL;
            output_row.thesaurus    := NULL;
            output_row.heading      := NULL;

            IF idx.heading_purpose = 'variant' AND idx.type_xpath IS NOT NULL THEN
                type_value := ARRAY_TO_STRING(oils_xpath(idx.type_xpath, heading_node, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]), '');
                BEGIN
                    output_row.variant_type := type_value;
                EXCEPTION WHEN invalid_text_representation THEN
                    RAISE NOTICE 'Do not recognize variant heading type %', type_value;
                END;
            END IF;
            IF idx.heading_purpose = 'related' AND idx.type_xpath IS NOT NULL THEN
                type_value := ARRAY_TO_STRING(oils_xpath(idx.type_xpath, heading_node, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]), '');
                BEGIN
                    output_row.related_type := type_value;
                EXCEPTION WHEN invalid_text_representation THEN
                    RAISE NOTICE 'Do not recognize related heading type %', type_value;
                END;
            END IF;
 
            IF idx.thesaurus_override_xpath IS NOT NULL THEN
                output_row.thesaurus := ARRAY_TO_STRING(oils_xpath(idx.thesaurus_override_xpath, heading_node, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]), '');
            END IF;
            IF output_row.thesaurus IS NULL THEN
                output_row.thesaurus := base_thesaurus;
            END IF;

            raw_text := NULL;

            -- now iterate over components of heading
            component_node_list := oils_xpath( idx.component_xpath, heading_node, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );
            FOR component_node IN SELECT x FROM unnest(component_node_list) AS x LOOP
            -- XXX much of this should be moved into oils_xpath_string...
                curr_text := ARRAY_TO_STRING(array_remove(array_remove(
                    oils_xpath( '//text()', -- get the content of all the nodes within the main selected node
                        REGEXP_REPLACE( component_node, E'\\s+', ' ', 'g' ) -- Translate adjacent whitespace to a single space
                    ), ' '), ''),  -- throw away morally empty (bankrupt?) strings
                    joiner
                );

                CONTINUE WHEN curr_text IS NULL OR curr_text = '';

                IF raw_text IS NOT NULL THEN
                    raw_text := raw_text || joiner;
                END IF;

                raw_text := COALESCE(raw_text,'') || curr_text;
            END LOOP;

            IF raw_text IS NOT NULL THEN
                output_row.heading := raw_text;
                normalized_text := raw_text;

                FOR normalizer IN
                    SELECT  n.func AS func,
                            n.param_count AS param_count,
                            m.params AS params
                    FROM  config.index_normalizer n
                            JOIN authority.heading_field_norm_map m ON (m.norm = n.id)
                    WHERE m.field = idx.id
                    ORDER BY m.pos LOOP
            
                        EXECUTE 'SELECT ' || normalizer.func || '(' ||
                            quote_literal( normalized_text ) ||
                            CASE
                                WHEN normalizer.param_count > 0
                                    THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                                    ELSE ''
                                END ||
                            ')' INTO normalized_text;
            
                END LOOP;
            
                output_row.normalized_heading := normalized_text;
            
                RETURN NEXT output_row;
            END IF;
        END LOOP;

    END LOOP;
END;
$$;


ALTER FUNCTION authority.extract_headings(marc text, restrict integer[]) OWNER TO evergreen;

--
-- Name: extract_thesaurus(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.extract_thesaurus(marcxml text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$
DECLARE
    thes_code TEXT;
BEGIN
    thes_code := vandelay.marc21_extract_fixed_field(marcxml,'Subj');
    IF thes_code IS NULL THEN
        thes_code := '|';
    ELSIF thes_code = 'z' THEN
        thes_code := COALESCE( oils_xpath_string('//*[@tag="040"]/*[@code="f"][1]', marcxml), 'z' );
    ELSE
        SELECT code INTO thes_code FROM authority.thesaurus WHERE short_code = thes_code;
        IF NOT FOUND THEN
            thes_code := '|'; -- default
        END IF;
    END IF;
    RETURN thes_code;
END;
$$;


ALTER FUNCTION authority.extract_thesaurus(marcxml text) OWNER TO evergreen;

--
-- Name: full_rec; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.full_rec (
    id bigint NOT NULL,
    record bigint NOT NULL,
    tag character(3) NOT NULL,
    ind1 text,
    ind2 text,
    subfield text,
    value text NOT NULL,
    index_vector tsvector NOT NULL,
    sort_value text
);


ALTER TABLE authority.full_rec OWNER TO evergreen;

--
-- Name: flatten_marc(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.flatten_marc(rid bigint) RETURNS SETOF authority.full_rec
    LANGUAGE plpgsql
    AS $$
DECLARE
    auth    authority.record_entry%ROWTYPE;
    output  authority.full_rec%ROWTYPE;
    field   RECORD;
BEGIN
    SELECT INTO auth * FROM authority.record_entry WHERE id = rid;

    FOR field IN SELECT * FROM vandelay.flatten_marc( auth.marc ) LOOP
        output.record := rid;
        output.ind1 := field.ind1;
        output.ind2 := field.ind2;
        output.tag := field.tag;
        output.subfield := field.subfield;
        output.value := field.value;
        output.sort_value := naco_normalize(field.value);

        RETURN NEXT output;
    END LOOP;
END;
$$;


ALTER FUNCTION authority.flatten_marc(rid bigint) OWNER TO evergreen;

--
-- Name: flatten_marc(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.flatten_marc(text) RETURNS SETOF authority.full_rec
    LANGUAGE plperlu
    AS $_$

use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use MARC::Charset;

MARC::Charset->assume_unicode(1);

my $xml = shift;
my $r = MARC::Record->new_from_xml( $xml );

return_next( { tag => 'LDR', value => $r->leader } );

for my $f ( $r->fields ) {
    if ($f->is_control_field) {
        return_next({ tag => $f->tag, value => $f->data });
    } else {
        for my $s ($f->subfields) {
            return_next({
                tag      => $f->tag,
                ind1     => $f->indicator(1),
                ind2     => $f->indicator(2),
                subfield => $s->[0],
                value    => $s->[1]
            });

        }
    }
}

return undef;

$_$;


ALTER FUNCTION authority.flatten_marc(text) OWNER TO evergreen;

--
-- Name: generate_overlay_template(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.generate_overlay_template(bigint) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT authority.generate_overlay_template( marc ) FROM authority.record_entry WHERE id = $1;
$_$;


ALTER FUNCTION authority.generate_overlay_template(bigint) OWNER TO evergreen;

--
-- Name: generate_overlay_template(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.generate_overlay_template(source_xml text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    cset                INT;
    main_entry          authority.control_set_authority_field%ROWTYPE;
    bib_field           authority.control_set_bib_field%ROWTYPE;
    auth_id             INT DEFAULT oils_xpath_string('//*[@tag="901"]/*[local-name()="subfield" and @code="c"]', source_xml)::INT;
    tmp_data            XML;
    replace_data        XML[] DEFAULT '{}'::XML[];
    replace_rules       TEXT[] DEFAULT '{}'::TEXT[];
    auth_field          XML[];
    auth_i1             TEXT;
    auth_i2             TEXT;
BEGIN
    IF auth_id IS NULL THEN
        RETURN NULL;
    END IF;

    -- Default to the LoC controll set
    SELECT control_set INTO cset FROM authority.record_entry WHERE id = auth_id;

    -- if none, make a best guess
    IF cset IS NULL THEN
        SELECT  control_set INTO cset
          FROM  authority.control_set_authority_field
          WHERE tag IN (
                    SELECT  UNNEST(XPATH('//*[local-name()="datafield" and starts-with(@tag,"1")]/@tag',marc::XML)::TEXT[])
                      FROM  authority.record_entry
                      WHERE id = auth_id
                )
          LIMIT 1;
    END IF;

    -- if STILL none, no-op change
    IF cset IS NULL THEN
        RETURN XMLELEMENT(
            name record,
            XMLATTRIBUTES('http://www.loc.gov/MARC21/slim' AS xmlns),
            XMLELEMENT( name leader, '00881nam a2200193   4500'),
            XMLELEMENT(
                name datafield,
                XMLATTRIBUTES( '905' AS tag, ' ' AS ind1, ' ' AS ind2),
                XMLELEMENT(
                    name subfield,
                    XMLATTRIBUTES('d' AS code),
                    '901c'
                )
            )
        )::TEXT;
    END IF;

    FOR main_entry IN SELECT * FROM authority.control_set_authority_field acsaf WHERE acsaf.control_set = cset AND acsaf.main_entry IS NULL LOOP
        auth_field := XPATH('//*[local-name()="datafield" and @tag="'||main_entry.tag||'"][1]',source_xml::XML);
        auth_i1 := (XPATH('//*[local-name()="datafield"]/@ind1',auth_field[1]))[1];
        auth_i2 := (XPATH('//*[local-name()="datafield"]/@ind2',auth_field[1]))[1];
        IF ARRAY_LENGTH(auth_field,1) > 0 THEN
            FOR bib_field IN SELECT * FROM authority.control_set_bib_field WHERE authority_field = main_entry.id LOOP
                SELECT XMLELEMENT( -- XMLAGG avoids magical <element> creation, but requires unnest subquery
                    name datafield,
                    XMLATTRIBUTES(bib_field.tag AS tag, auth_i1 AS ind1, auth_i2 AS ind2),
                    XMLAGG(UNNEST)
                ) INTO tmp_data FROM UNNEST(XPATH('//*[local-name()="subfield"]', auth_field[1]));
                replace_data := replace_data || tmp_data;
                replace_rules := replace_rules || ( bib_field.tag || main_entry.sf_list || E'[0~\\)' || auth_id || '$]' );
                tmp_data = NULL;
            END LOOP;
            EXIT;
        END IF;
    END LOOP;

    SELECT XMLAGG(UNNEST) INTO tmp_data FROM UNNEST(replace_data);

    RETURN XMLELEMENT(
        name record,
        XMLATTRIBUTES('http://www.loc.gov/MARC21/slim' AS xmlns),
        XMLELEMENT( name leader, '00881nam a2200193   4500'),
        tmp_data,
        XMLELEMENT(
            name datafield,
            XMLATTRIBUTES( '905' AS tag, ' ' AS ind1, ' ' AS ind2),
            XMLELEMENT(
                name subfield,
                XMLATTRIBUTES('r' AS code),
                ARRAY_TO_STRING(replace_rules,',')
            )
        )
    )::TEXT;
END;
$_$;


ALTER FUNCTION authority.generate_overlay_template(source_xml text) OWNER TO evergreen;

--
-- Name: generate_overlay_template(text, bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.generate_overlay_template(text, bigint) RETURNS text
    LANGUAGE plperlu
    AS $_X$

    use MARC::Record;
    use MARC::File::XML (BinaryEncoding => 'UTF-8');
    use MARC::Charset;

    MARC::Charset->assume_unicode(1);

    my $xml = shift;
    my $r = MARC::Record->new_from_xml( $xml );

    return undef unless ($r);

    my $id = shift() || $r->subfield( '901' => 'c' );
    $id =~ s/^\s*(?:\([^)]+\))?\s*(.+)\s*?$/$1/;
    return undef unless ($id); # We need an ID!

    my $tmpl = MARC::Record->new();
    $tmpl->encoding( 'UTF-8' );

    my @rule_fields;
    for my $field ( $r->field( '1..' ) ) { # Get main entry fields from the authority record

        my $tag = $field->tag;
        my $i1 = $field->indicator(1);
        my $i2 = $field->indicator(2);
        my $sf = join '', map { $_->[0] } $field->subfields;
        my @data = map { @$_ } $field->subfields;

        my @replace_them;

        # Map the authority field to bib fields it can control.
        if ($tag >= 100 and $tag <= 111) {       # names
            @replace_them = map { $tag + $_ } (0, 300, 500, 600, 700);
        } elsif ($tag eq '130') {                # uniform title
            @replace_them = qw/130 240 440 730 830/;
        } elsif ($tag >= 150 and $tag <= 155) {  # subjects
            @replace_them = ($tag + 500);
        } elsif ($tag >= 180 and $tag <= 185) {  # floating subdivisions
            @replace_them = qw/100 400 600 700 800 110 410 610 710 810 111 411 611 711 811 130 240 440 730 830 650 651 655/;
        } else {
            next;
        }

        # Dummy up the bib-side data
        $tmpl->append_fields(
            map {
                MARC::Field->new( $_, $i1, $i2, @data )
            } @replace_them
        );

        # Construct some 'replace' rules
        push @rule_fields, map { $_ . $sf . '[0~\)' .$id . '$]' } @replace_them;
    }

    # Insert the replace rules into the template
    $tmpl->append_fields(
        MARC::Field->new( '905' => ' ' => ' ' => 'r' => join(',', @rule_fields ) )
    );

    $xml = $tmpl->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;

    return $xml;

$_X$;


ALTER FUNCTION authority.generate_overlay_template(text, bigint) OWNER TO evergreen;

--
-- Name: get_5xx_heading(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.get_5xx_heading(w_subfield text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
--  Function takes a w subfield as input.  It returns the heading to be displayed for the
--  reference.  The headings are stored in authority.display_5xx_headings.
--  The current version only looks at the first position (0) of the w subfield.  It then looks
--  in authority.display_5xx_headings for a match and returns that heading.  If no match is found
--  it selects from authority.display_5xx_headings where w subfield position 0 is null, which is 
--  the default 5xx heading.  (See Also)
--
--  The table is built to be expandable for the future and this function could be modified to check
--  more positions.
DECLARE
     subfield_0	text;
     return_heading text;
BEGIN
     SELECT substring(w_subfield FROM '.') INTO subfield_0;

     SELECT heading INTO return_heading
     FROM authority.display_5xx_headings
     WHERE w_subfield_0 = subfield_0;

     IF return_heading IS NULL THEN
	SELECT heading INTO return_heading
	FROM authority.display_5xx_headings
	WHERE w_subfield_0 IS NULL;
     END IF;
	
     RETURN return_heading;
END;    
$$;


ALTER FUNCTION authority.get_5xx_heading(w_subfield text) OWNER TO evergreen;

--
-- Name: heading_changed(text, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.heading_changed(old_marc text, new_marc text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
  old_heading text;
  new_heading text;
BEGIN
     -- Grab the 1XX field of each authority marc.
     old_heading := substring(old_marc from '<datafield tag="1[0-9][0-9]".*?</datafield>');
     new_heading := substring(new_marc from '<datafield tag="1[0-9][0-9]".*?</datafield>');
     
     IF old_heading = new_heading THEN
         RETURN FALSE;
     ELSE
         RETURN TRUE;
     END IF;

  END $$;


ALTER FUNCTION authority.heading_changed(old_marc text, new_marc text) OWNER TO evergreen;

--
-- Name: indexing_ingest_or_delete(); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.indexing_ingest_or_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    ashs    authority.simple_heading%ROWTYPE;
    mbe_row metabib.browse_entry%ROWTYPE;
    mbe_id  BIGINT;
    ash_id  BIGINT;
BEGIN

    IF NEW.deleted IS TRUE THEN -- If this authority is deleted
        DELETE FROM authority.bib_linking WHERE authority = NEW.id; -- Avoid updating fields in bibs that are no longer visible
        DELETE FROM authority.full_rec WHERE record = NEW.id; -- Avoid validating fields against deleted authority records
        DELETE FROM authority.simple_heading WHERE record = NEW.id;
          -- Should remove matching $0 from controlled fields at the same time?

        -- XXX What do we about the actual linking subfields present in
        -- authority records that target this one when this happens?
        DELETE FROM authority.authority_linking
            WHERE source = NEW.id OR target = NEW.id;

        RETURN NEW; -- and we're done
    END IF;

    IF TG_OP = 'UPDATE' THEN -- re-ingest?
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.reingest.force_on_same_marc' AND enabled;

        IF NOT FOUND AND OLD.marc = NEW.marc THEN -- don't do anything if the MARC didn't change
            RETURN NEW;
        END IF;

        -- Unless there's a setting stopping us, propagate these updates to any linked bib records when the heading changes
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_authority_auto_update' AND enabled;

        IF NOT FOUND AND NEW.heading <> OLD.heading THEN
            PERFORM authority.propagate_changes(NEW.id);
        END IF;
    
        DELETE FROM authority.simple_heading WHERE record = NEW.id;
        DELETE FROM authority.authority_linking WHERE source = NEW.id;
    END IF;

    INSERT INTO authority.authority_linking (source, target, field)
        SELECT source, target, field FROM authority.calculate_authority_linking(
            NEW.id, NEW.control_set, NEW.marc::XML
        );

    FOR ashs IN SELECT * FROM authority.simple_heading_set(NEW.marc) LOOP

        INSERT INTO authority.simple_heading (record,atag,value,sort_value,thesaurus)
        VALUES (ashs.record, ashs.atag, ashs.value, ashs.sort_value, ashs.thesaurus);

        -- avoid creating browse entries for headings that are not linked
        -- to browse=true metabib fields.
        PERFORM 1 
        FROM authority.control_set_auth_field_metabib_field_map_refs map
        JOIN config.metabib_field cmf ON (cmf.id = map.metabib_field)
        WHERE map.authority_field = ashs.atag AND cmf.browse_field;

        CONTINUE WHEN NOT FOUND;

        ash_id := CURRVAL('authority.simple_heading_id_seq'::REGCLASS);

        SELECT INTO mbe_row * FROM metabib.browse_entry
        WHERE 
            MD5(value) = MD5(ashs.value) AND 
            MD5(sort_value) = MD5(ashs.sort_value);

        IF FOUND THEN
            mbe_id := mbe_row.id;
        ELSE
            INSERT INTO metabib.browse_entry
                ( value, sort_value, truncated_sort_value, metabib_fields_cache ) VALUES
                ( ashs.value, ashs.sort_value, 
                  SUBSTR(ashs.sort_value, 1, 2048),
                  '{}' 
                );

            mbe_id := CURRVAL('metabib.browse_entry_id_seq'::REGCLASS);
        END IF;

        INSERT INTO metabib.browse_entry_simple_heading_map (entry,simple_heading) VALUES (mbe_id,ash_id);

    END LOOP;

    -- Flatten and insert the afr data
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_authority_full_rec' AND enabled;
    IF NOT FOUND THEN
        PERFORM authority.reingest_authority_full_rec(NEW.id);
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_authority_rec_descriptor' AND enabled;
        IF NOT FOUND THEN
            PERFORM authority.reingest_authority_rec_descriptor(NEW.id);
        END IF;
    END IF;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION authority.indexing_ingest_or_delete() OWNER TO evergreen;

--
-- Name: map_thesaurus_to_control_set(); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.map_thesaurus_to_control_set() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.control_set IS NULL THEN
        SELECT control_set INTO NEW.control_set
        FROM authority.thesaurus
        WHERE code = authority.extract_thesaurus(NEW.marc);
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION authority.map_thesaurus_to_control_set() OWNER TO evergreen;

--
-- Name: merge_records(bigint, bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.merge_records(target_record bigint, source_record bigint) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    moved_objects INT := 0;
    bib_id        INT := 0;
    bib_rec       biblio.record_entry%ROWTYPE;
    auth_link     authority.bib_linking%ROWTYPE;
    ingest_same   boolean;
BEGIN

    -- Defining our terms:
    -- "target record" = the record that will survive the merge
    -- "source record" = the record that is sacrifing its existence and being
    --   replaced by the target record

    -- 1. Update all bib records with the ID from target_record in their $0
    FOR bib_rec IN SELECT bre.* FROM biblio.record_entry bre
      INNER JOIN authority.bib_linking abl ON abl.bib = bre.id
      WHERE abl.authority = source_record LOOP

        UPDATE biblio.record_entry
          SET marc = REGEXP_REPLACE(marc,
            E'(<subfield\\s+code="0"\\s*>[^<]*?\\))' || source_record || '<',
            E'\\1' || target_record || '<', 'g')
          WHERE id = bib_rec.id;

          moved_objects := moved_objects + 1;
    END LOOP;

    -- 2. Grab the current value of reingest on same MARC flag
    SELECT enabled INTO ingest_same
      FROM config.internal_flag
      WHERE name = 'ingest.reingest.force_on_same_marc'
    ;

    -- 3. Temporarily set reingest on same to TRUE
    UPDATE config.internal_flag
      SET enabled = TRUE
      WHERE name = 'ingest.reingest.force_on_same_marc'
    ;

    -- 4. Make a harmless update to target_record to trigger auto-update
    --    in linked bibliographic records
    UPDATE authority.record_entry
      SET deleted = FALSE
      WHERE id = target_record;

    -- 5. "Delete" source_record
    DELETE FROM authority.record_entry
      WHERE id = source_record;

    -- 6. Set "reingest on same MARC" flag back to initial value
    UPDATE config.internal_flag
      SET enabled = ingest_same
      WHERE name = 'ingest.reingest.force_on_same_marc'
    ;

    RETURN moved_objects;
END;
$_$;


ALTER FUNCTION authority.merge_records(target_record bigint, source_record bigint) OWNER TO evergreen;

--
-- Name: normalize_heading(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.normalize_heading(marcxml text) RETURNS text
    LANGUAGE sql STABLE STRICT
    AS $_$
    SELECT authority.normalize_heading($1, FALSE);
$_$;


ALTER FUNCTION authority.normalize_heading(marcxml text) OWNER TO evergreen;

--
-- Name: FUNCTION normalize_heading(marcxml text); Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON FUNCTION authority.normalize_heading(marcxml text) IS '
Extract the authority heading, thesaurus, and NACO-normalized values
from an authority record. The primary purpose is to build a unique
index to defend against duplicated authority records from the same
thesaurus.
';


--
-- Name: normalize_heading(text, boolean); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.normalize_heading(marcxml text, no_thesaurus boolean) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
    acsaf           authority.control_set_authority_field%ROWTYPE;
    tag_used        TEXT;
    nfi_used        TEXT;
    sf              TEXT;
    sf_node         TEXT;
    tag_node        TEXT;
    thes_code       TEXT;
    cset            INT;
    heading_text    TEXT;
    tmp_text        TEXT;
    first_sf        BOOL;
    auth_id         INT DEFAULT COALESCE(NULLIF(oils_xpath_string('//*[@tag="901"]/*[local-name()="subfield" and @code="c"]', marcxml), ''), '0')::INT;
BEGIN
    SELECT control_set INTO cset FROM authority.record_entry WHERE id = auth_id;

    IF cset IS NULL THEN
        SELECT  control_set INTO cset
          FROM  authority.control_set_authority_field
          WHERE tag IN (SELECT UNNEST(XPATH('//*[starts-with(@tag,"1")]/@tag',marcxml::XML)::TEXT[]))
          LIMIT 1;
    END IF;

    heading_text := '';
    FOR acsaf IN SELECT * FROM authority.control_set_authority_field WHERE control_set = cset AND main_entry IS NULL LOOP
        tag_used := acsaf.tag;
        nfi_used := acsaf.nfi;
        first_sf := TRUE;

        FOR tag_node IN SELECT unnest(oils_xpath('//*[@tag="'||tag_used||'"]',marcxml))
        LOOP
            FOR sf_node IN SELECT unnest(oils_xpath('//*[local-name() = "subfield" and contains("'||acsaf.sf_list||'",@code)]',tag_node))
            LOOP

                tmp_text := oils_xpath_string('.', sf_node);
                sf := oils_xpath_string('//*/@code', sf_node);

                IF first_sf AND tmp_text IS NOT NULL AND nfi_used IS NOT NULL THEN

                    tmp_text := SUBSTRING(
                        tmp_text FROM
                        COALESCE(
                            NULLIF(
                                REGEXP_REPLACE(
                                    oils_xpath_string('//*[local-name() = "datafield"]/@ind'||nfi_used, tag_node),
                                    $$\D+$$,
                                    '',
                                    'g'
                                ),
                                ''
                            )::INT,
                            0
                        ) + 1
                    );

                END IF;

                first_sf := FALSE;

                IF tmp_text IS NOT NULL AND tmp_text <> '' THEN
                    heading_text := heading_text || E'\u2021' || sf || ' ' || tmp_text;
                END IF;
            END LOOP;

            EXIT WHEN heading_text <> '';
        END LOOP;

        EXIT WHEN heading_text <> '';
    END LOOP;

    IF heading_text <> '' THEN
        IF no_thesaurus IS TRUE THEN
            heading_text := tag_used || ' ' || public.naco_normalize(heading_text);
        ELSE
            thes_code := authority.extract_thesaurus(marcxml);
            heading_text := tag_used || '_' || COALESCE(nfi_used,'-') || '_' || thes_code || ' ' || public.naco_normalize(heading_text);
        END IF;
    ELSE
        heading_text := 'NOHEADING_' || thes_code || ' ' || MD5(marcxml);
    END IF;

    RETURN heading_text;
END;
$_$;


ALTER FUNCTION authority.normalize_heading(marcxml text, no_thesaurus boolean) OWNER TO evergreen;

--
-- Name: normalize_heading_for_upsert(); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.normalize_heading_for_upsert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.heading := authority.normalize_heading( NEW.marc );
    NEW.simple_heading := authority.simple_normalize_heading( NEW.marc );
    RETURN NEW;
END;
$$;


ALTER FUNCTION authority.normalize_heading_for_upsert() OWNER TO evergreen;

--
-- Name: ongoing_generate_auth_ids_for_auth_to_auth_given_date(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.ongoing_generate_auth_ids_for_auth_to_auth_given_date(import_date text) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    base_ids          	BIGINT[];
    base_one		BIGINT;
    base_query	        TEXT;
    results_cursor	REFCURSOR;
    add_query		TEXT;
    auths               BIGINT[];
    linked_auths	BIGINT[];

BEGIN
    -- ver 1.0 - KMAIN-1113

    -- Generate a list of auth records that have been modified or created on the given day.
    base_query := 'SELECT COALESCE(ARRAY_AGG(id), ARRAY[]::BIGINT[]) FROM authority.record_entry WHERE edit_date BETWEEN ''' || import_date || ' 00:00:00-07'' AND ''' || import_date || ' 23:59:59-07'' AND NOT deleted';   

    OPEN results_cursor FOR EXECUTE base_query;
    FETCH results_cursor INTO base_ids;

    auths := base_ids;

    FOREACH base_one IN ARRAY base_ids
    LOOP
        -- Find the auth id's that should link with the given auth id
        SELECT * INTO linked_auths FROM  authority.unlinked_auths_to_given_auth_id(base_one);
        -- Combine newly found auth id's (linked_auths) to previously found ones (auths)
        SELECT INTO auths ARRAY( SELECT unnest(auths) AS e UNION SELECT unnest(linked_auths) AS e ORDER BY e);
    END LOOP;

    RETURN QUERY SELECT unnest(auths);
END;
$$;


ALTER FUNCTION authority.ongoing_generate_auth_ids_for_auth_to_auth_given_date(import_date text) OWNER TO evergreen;

--
-- Name: propagate_changes(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.propagate_changes(aid bigint) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT authority.propagate_changes( authority, bib ) FROM authority.bib_linking WHERE authority = $1;
$_$;


ALTER FUNCTION authority.propagate_changes(aid bigint) OWNER TO evergreen;

--
-- Name: propagate_changes(bigint, bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.propagate_changes(aid bigint, bid bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    bib_rec biblio.record_entry%ROWTYPE;
    new_marc TEXT;
BEGIN

    SELECT INTO bib_rec * FROM biblio.record_entry WHERE id = bid;

    new_marc := vandelay.merge_record_xml(
        bib_rec.marc, authority.generate_overlay_template(aid));

    IF new_marc = bib_rec.marc THEN
        -- Authority record change had no impact on this bib record.
        -- Nothing left to do.
        RETURN aid;
    END IF;

    PERFORM 1 FROM config.global_flag 
        WHERE name = 'ingest.disable_authority_auto_update_bib_meta' 
            AND enabled;

    IF NOT FOUND THEN 
        -- update the bib record editor and edit_date
        bib_rec.editor := (
            SELECT editor FROM authority.record_entry WHERE id = aid);
        bib_rec.edit_date = NOW();
    END IF;

    UPDATE biblio.record_entry SET
        marc = new_marc,
        editor = bib_rec.editor,
        edit_date = bib_rec.edit_date
    WHERE id = bid;

    RETURN aid;

END;
$$;


ALTER FUNCTION authority.propagate_changes(aid bigint, bid bigint) OWNER TO evergreen;

--
-- Name: reingest_authority_full_rec(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.reingest_authority_full_rec(auth_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM authority.full_rec WHERE record = auth_id;
    INSERT INTO authority.full_rec (record, tag, ind1, ind2, subfield, value, sort_value)
        SELECT record, tag, ind1, ind2, subfield, value, sort_value FROM authority.flatten_marc( auth_id );

    RETURN;
END;
$$;


ALTER FUNCTION authority.reingest_authority_full_rec(auth_id bigint) OWNER TO evergreen;

--
-- Name: reingest_authority_rec_descriptor(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.reingest_authority_rec_descriptor(auth_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM authority.rec_descriptor WHERE record = auth_id;
    INSERT INTO authority.rec_descriptor (record, record_status, encoding_level, thesaurus)
        SELECT  auth_id,
                vandelay.marc21_extract_fixed_field(marc,'RecStat'),
                vandelay.marc21_extract_fixed_field(marc,'ELvl'),
                authority.extract_thesaurus(marc)
          FROM  authority.record_entry
          WHERE id = auth_id;
    RETURN;
END;
$$;


ALTER FUNCTION authority.reingest_authority_rec_descriptor(auth_id bigint) OWNER TO evergreen;

--
-- Name: simple_heading_browse_center(integer[], text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.simple_heading_browse_center(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 9, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE plpgsql ROWS 10
    AS $$
DECLARE
    pivot_sort_value    TEXT;
    boffset             INT DEFAULT 0;
    aoffset             INT DEFAULT 0;
    blimit              INT DEFAULT 0;
    alimit              INT DEFAULT 0;
BEGIN

    pivot_sort_value := authority.simple_heading_find_pivot(atag_list,q,thesauruses);

    IF page = 0 THEN
        blimit := pagesize / 2;
        alimit := blimit;

        IF pagesize % 2 <> 0 THEN
            alimit := alimit + 1;
        END IF;
    ELSE
        blimit := pagesize;
        alimit := blimit;

        boffset := pagesize / 2;
        aoffset := boffset;

        IF pagesize % 2 <> 0 THEN
            boffset := boffset + 1;
        END IF;
    END IF;

    IF page <= 0 THEN
        -- "bottom" half of the browse results
        RETURN QUERY
            SELECT id FROM (
                SELECT  ash.id,
                        row_number() over ()
                FROM  authority.simple_heading ash
                WHERE ash.atag = ANY (atag_list)
                        AND CASE thesauruses
                            WHEN '' THEN TRUE
                            ELSE ash.thesaurus = ANY(regexp_split_to_array(thesauruses, ','))
                            END
                        AND ash.sort_value < pivot_sort_value
                ORDER BY ash.sort_value DESC
                LIMIT blimit
                OFFSET ABS(page) * pagesize - boffset
            ) x ORDER BY row_number DESC;
    END IF;

    IF page >= 0 THEN
        -- "bottom" half of the browse results
        RETURN QUERY
            SELECT  ash.id
            FROM  authority.simple_heading ash
            WHERE ash.atag = ANY (atag_list)
                    AND CASE thesauruses
                        WHEN '' THEN TRUE
                        ELSE ash.thesaurus = ANY(regexp_split_to_array(thesauruses, ','))
                        END
                    AND ash.sort_value >= pivot_sort_value
            ORDER BY ash.sort_value
            LIMIT alimit
            OFFSET ABS(page) * pagesize - aoffset;
    END IF;
END;
$$;


ALTER FUNCTION authority.simple_heading_browse_center(atag_list integer[], q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: simple_heading_browse_top(integer[], text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.simple_heading_browse_top(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE plpgsql ROWS 10
    AS $$
DECLARE
    pivot_sort_value    TEXT;
BEGIN

    pivot_sort_value := authority.simple_heading_find_pivot(atag_list,q,thesauruses);

    IF page < 0 THEN
         -- "bottom" half of the browse results
        RETURN QUERY
            SELECT id FROM (
                SELECT  ash.id,
                        row_number() over ()
                FROM  authority.simple_heading ash
                WHERE ash.atag = ANY (atag_list)
                        AND CASE thesauruses
                            WHEN '' THEN TRUE
                            ELSE ash.thesaurus = ANY(regexp_split_to_array(thesauruses, ','))
                            END
                        AND ash.sort_value < pivot_sort_value
                ORDER BY ash.sort_value DESC
                LIMIT pagesize
                OFFSET (ABS(page) - 1) * pagesize
            ) x ORDER BY row_number DESC;
    END IF;

    IF page >= 0 THEN
         -- "bottom" half of the browse results
        RETURN QUERY
            SELECT  ash.id
            FROM  authority.simple_heading ash
            WHERE ash.atag = ANY (atag_list)
                AND CASE thesauruses
                    WHEN '' THEN TRUE
                    ELSE ash.thesaurus = ANY(regexp_split_to_array(thesauruses, ','))
                    END
                    AND ash.sort_value >= pivot_sort_value
            ORDER BY ash.sort_value
            LIMIT pagesize
            OFFSET ABS(page) * pagesize ;
    END IF;
END;
$$;


ALTER FUNCTION authority.simple_heading_browse_top(atag_list integer[], q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: simple_heading_find_pivot(integer[], text, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.simple_heading_find_pivot(a integer[], q text, thesauruses text DEFAULT ''::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    sort_value_row  RECORD;
    value_row       RECORD;
    t_term          TEXT;
BEGIN

    t_term := public.naco_normalize(q);

    SELECT  CASE WHEN ash.sort_value LIKE t_term || '%' THEN 1 ELSE 0 END
                + CASE WHEN ash.value LIKE t_term || '%' THEN 1 ELSE 0 END AS rank,
            ash.sort_value
    INTO  sort_value_row
    FROM  authority.simple_heading ash
    WHERE ash.atag = ANY (a)
            AND ash.sort_value >= t_term
            AND CASE thesauruses
                WHEN '' THEN TRUE
                ELSE ash.thesaurus = ANY(regexp_split_to_array(thesauruses, ','))
                END
    ORDER BY rank DESC, ash.sort_value
    LIMIT 1;

    SELECT  CASE WHEN ash.sort_value LIKE t_term || '%' THEN 1 ELSE 0 END
                + CASE WHEN ash.value LIKE t_term || '%' THEN 1 ELSE 0 END AS rank,
            ash.sort_value
    INTO  value_row
    FROM  authority.simple_heading ash
    WHERE ash.atag = ANY (a)
            AND ash.value >= t_term
            AND CASE thesauruses
                WHEN '' THEN TRUE
                ELSE ash.thesaurus = ANY(regexp_split_to_array(thesauruses, ','))
                END
    ORDER BY rank DESC, ash.sort_value
    LIMIT 1;

    IF value_row.rank > sort_value_row.rank THEN
        RETURN value_row.sort_value;
    ELSE
        RETURN sort_value_row.sort_value;
    END IF;
END;
$$;


ALTER FUNCTION authority.simple_heading_find_pivot(a integer[], q text, thesauruses text) OWNER TO evergreen;

--
-- Name: simple_heading_plus_set(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.simple_heading_plus_set(marcxml text) RETURNS SETOF authority.simple_heading_plus
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    res             authority.simple_heading_plus%ROWTYPE;
    acsaf           authority.control_set_authority_field%ROWTYPE;
    tag_used        TEXT;
    nfi_used        TEXT;
    sf              TEXT;
    cset            INT;
    heading_text    TEXT;
    original_text   TEXT;
    joiner_text    TEXT;
    sort_text       TEXT;
    tmp_text        TEXT;
    tmp_xml         TEXT;
    first_sf        BOOL;
    auth_id         INT DEFAULT COALESCE(NULLIF(oils_xpath_string('//*[@tag="901"]/*[local-name()="subfield" and @code="c"]', marcxml), ''), '0')::INT;
BEGIN

    SELECT control_set INTO cset FROM authority.record_entry WHERE id = auth_id;

    IF cset IS NULL THEN
        SELECT  control_set INTO cset
          FROM  authority.control_set_authority_field
          WHERE tag IN ( SELECT  UNNEST(XPATH('//*[starts-with(@tag,"1")]/@tag',marcxml::XML)::TEXT[]))
          LIMIT 1;
    END IF;

    res.record := auth_id;

    FOR acsaf IN SELECT * FROM authority.control_set_authority_field WHERE control_set = cset LOOP

        res.atag := acsaf.id;
        tag_used := acsaf.tag;
        nfi_used := acsaf.nfi;
        joiner_text := COALESCE(acsaf.joiner, ' ');

        FOR tmp_xml IN SELECT UNNEST(XPATH('//*[@tag="'||tag_used||'"]', marcxml::XML)) LOOP

            heading_text := public.naco_normalize(COALESCE(
                oils_xpath_string('//subfield[contains("'||acsaf.sf_list||'",@code)]', tmp_xml::TEXT, joiner_text),
                ''));

            original_text = COALESCE(
                oils_xpath_string('//subfield[contains("'||acsaf.display_sf_list||'",@code)]', tmp_xml::TEXT),
                '');

            original_text = REGEXP_REPLACE(original_text, '^\s+|\s+$/', '','g');

            IF nfi_used IS NOT NULL THEN

                sort_text := SUBSTRING(
                    heading_text FROM
                    COALESCE(
                        NULLIF(
                            REGEXP_REPLACE(
                                oils_xpath_string('./@ind'||nfi_used, tmp_xml::TEXT),
                                $$\D+$$,
                                '',
                                'g'
                            ),
                            ''
                        )::INT,
                        0
                    ) + 1
                );

            ELSE
                sort_text := heading_text;
            END IF;

            IF heading_text IS NOT NULL AND heading_text <> '' THEN
                res.value := heading_text;
                res.sort_value := public.naco_normalize(sort_text);
                res.index_vector = to_tsvector('keyword'::regconfig, res.sort_value);
                res.original_text := original_text;
                RETURN NEXT res;
            END IF;

        END LOOP;

    END LOOP;

    RETURN;
END;
$_$;


ALTER FUNCTION authority.simple_heading_plus_set(marcxml text) OWNER TO evergreen;

--
-- Name: simple_heading_search_heading(integer[], text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.simple_heading_search_heading(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT  ash.id
      FROM  authority.simple_heading ash,
            public.naco_normalize($2) t(term),
            plainto_tsquery('keyword'::regconfig,$2) ptsq(term)
      WHERE ash.atag = ANY ($1)
            AND ash.index_vector @@ ptsq.term
            AND CASE $5
                WHEN '' THEN TRUE
                ELSE ash.thesaurus = ANY(regexp_split_to_array($5, ','))
                END
      ORDER BY ash.sort_value
      LIMIT $4
      OFFSET $4 * $3;
$_$;


ALTER FUNCTION authority.simple_heading_search_heading(atag_list integer[], q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: simple_heading_search_rank(integer[], text, integer, integer, text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.simple_heading_search_rank(atag_list integer[], q text, page integer DEFAULT 0, pagesize integer DEFAULT 10, thesauruses text DEFAULT ''::text) RETURNS SETOF bigint
    LANGUAGE sql ROWS 10
    AS $_$
    SELECT  ash.id
      FROM  authority.simple_heading ash,
            public.naco_normalize($2) t(term),
            plainto_tsquery('keyword'::regconfig,$2) ptsq(term)
      WHERE ash.atag = ANY ($1)
            AND ash.index_vector @@ ptsq.term
            AND CASE $5
                WHEN '' THEN TRUE
                ELSE ash.thesaurus = ANY(regexp_split_to_array($5, ','))
                END
      ORDER BY ts_rank_cd(ash.index_vector,ptsq.term,14)::numeric
                    + CASE WHEN ash.sort_value LIKE t.term || '%' THEN 2 ELSE 0 END
                    + CASE WHEN ash.value LIKE t.term || '%' THEN 1 ELSE 0 END DESC
      LIMIT $4
      OFFSET $4 * $3;
$_$;


ALTER FUNCTION authority.simple_heading_search_rank(atag_list integer[], q text, page integer, pagesize integer, thesauruses text) OWNER TO evergreen;

--
-- Name: simple_heading; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.simple_heading (
    id bigint NOT NULL,
    record bigint NOT NULL,
    atag integer NOT NULL,
    value text NOT NULL,
    sort_value text NOT NULL,
    index_vector tsvector NOT NULL,
    thesaurus text
);


ALTER TABLE authority.simple_heading OWNER TO evergreen;

--
-- Name: simple_heading_set(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.simple_heading_set(marcxml text) RETURNS SETOF authority.simple_heading
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
    res             authority.simple_heading%ROWTYPE;
    acsaf           authority.control_set_authority_field%ROWTYPE;
    heading_row     authority.heading%ROWTYPE;
    tag_used        TEXT;
    nfi_used        TEXT;
    sf              TEXT;
    cset            INT;
    heading_text    TEXT;
    joiner_text     TEXT;
    sort_text       TEXT;
    tmp_text        TEXT;
    tmp_xml         TEXT;
    first_sf        BOOL;
    auth_id         INT DEFAULT COALESCE(NULLIF(oils_xpath_string('//*[@tag="901"]/*[local-name()="subfield" and @code="c"]', marcxml), ''), '0')::INT;
BEGIN

    SELECT control_set INTO cset FROM authority.record_entry WHERE id = auth_id;

    IF cset IS NULL THEN
        SELECT  control_set INTO cset
          FROM  authority.control_set_authority_field
          WHERE tag IN ( SELECT  UNNEST(XPATH('//*[starts-with(@tag,"1")]/@tag',marcxml::XML)::TEXT[]))
          LIMIT 1;
    END IF;

    res.record := auth_id;
    res.thesaurus := authority.extract_thesaurus(marcxml);

    FOR acsaf IN SELECT * FROM authority.control_set_authority_field WHERE control_set = cset LOOP
        res.atag := acsaf.id;

        IF acsaf.heading_field IS NULL THEN
            tag_used := acsaf.tag;
            nfi_used := acsaf.nfi;
            joiner_text := COALESCE(acsaf.joiner, ' ');

            FOR tmp_xml IN SELECT UNNEST(XPATH('//*[@tag="'||tag_used||'"]', marcxml::XML)::TEXT[]) LOOP

                heading_text := COALESCE(
                    oils_xpath_string('//*[local-name()="subfield" and contains("'||acsaf.display_sf_list||'",@code)]', tmp_xml, joiner_text),
                    ''
                );

                IF nfi_used IS NOT NULL THEN

                    sort_text := SUBSTRING(
                        heading_text FROM
                        COALESCE(
                            NULLIF(
                                REGEXP_REPLACE(
                                    oils_xpath_string('//*[local-name()="datafield"]/@ind'||nfi_used, tmp_xml::TEXT),
                                    $$\D+$$,
                                    '',
                                    'g'
                                ),
                                ''
                            )::INT,
                            0
                        ) + 1
                    );

                ELSE
                    sort_text := heading_text;
                END IF;

                IF heading_text IS NOT NULL AND heading_text <> '' THEN
                    res.value := heading_text;
                    res.sort_value := public.naco_normalize(sort_text);
                    res.index_vector = to_tsvector('keyword'::regconfig, res.sort_value);
                    RETURN NEXT res;
                END IF;

            END LOOP;
        ELSE
            FOR heading_row IN SELECT * FROM authority.extract_headings(marcxml, ARRAY[acsaf.heading_field]) LOOP
                res.value := heading_row.heading;
                res.sort_value := heading_row.normalized_heading;
                res.index_vector = to_tsvector('keyword'::regconfig, res.sort_value);
                RETURN NEXT res;
            END LOOP;
        END IF;
    END LOOP;

    RETURN;
END;
$_$;


ALTER FUNCTION authority.simple_heading_set(marcxml text) OWNER TO evergreen;

--
-- Name: simple_normalize_heading(text); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.simple_normalize_heading(marcxml text) RETURNS text
    LANGUAGE sql STABLE STRICT
    AS $_$
    SELECT authority.normalize_heading($1, TRUE);
$_$;


ALTER FUNCTION authority.simple_normalize_heading(marcxml text) OWNER TO evergreen;

--
-- Name: unlinked_auths_to_given_auth_id(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.unlinked_auths_to_given_auth_id(auth_id bigint) RETURNS bigint[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    wheres          	TEXT[];
    single_where	TEXT;
    query	        TEXT;
    results_cursor	REFCURSOR;
    auths                BIGINT[];
    first		INT	:= 1;

BEGIN
    -- ver 1.0 - KMAIN-1105

    SELECT INTO wheres COALESCE(ARRAY_AGG('subfield = ''' || subfield || ''' AND value = ''' || value || ''''), ARRAY[]::TEXT[])
        FROM authority.full_rec WHERE record = auth_id AND tag LIKE '1__';

    query := 'SELECT COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[]) FROM (';

    FOREACH single_where IN ARRAY wheres
    LOOP
        IF first < 1 THEN
            -- not first subquery
            query := query || ' INTERSECT (SELECT record FROM authority.full_rec WHERE ' || single_where || ' AND tag NOT LIKE ''1__'')';
        ELSE
            -- first subquery
            query := query || '(SELECT record FROM authority.full_rec WHERE ' || single_where || ' AND tag NOT LIKE ''1__'')';
            first := 0;
        END IF;
    END LOOP;

    query := query || ') AS X';

    OPEN results_cursor FOR EXECUTE query;

    FETCH results_cursor INTO auths;

    RETURN auths;
END;
$$;


ALTER FUNCTION authority.unlinked_auths_to_given_auth_id(auth_id bigint) OWNER TO evergreen;

--
-- Name: unlinked_bibs_to_given_auth_id(bigint); Type: FUNCTION; Schema: authority; Owner: evergreen
--

CREATE FUNCTION authority.unlinked_bibs_to_given_auth_id(auth_id bigint) RETURNS bigint[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    wheres          	TEXT[];
    single_where	TEXT;
    query	        TEXT;
    results_cursor	REFCURSOR;
    bibs                BIGINT[];
    first		INT	:= 1;

BEGIN
    -- ver 2.0 - KMAIN-1090: This version compares the authority.full_rec to metabib.real_full_rec.

    SELECT INTO wheres COALESCE(ARRAY_AGG('subfield = ''' || subfield || ''' AND value = ''' || value || ''''), ARRAY[]::TEXT[])
        FROM authority.full_rec WHERE record = auth_id AND tag ILIKE '1__';

    query := 'SELECT COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[]) FROM (';

    FOREACH single_where IN ARRAY wheres
    LOOP
        IF first < 1 THEN
            -- not first subquery
            query := query || ' INTERSECT (SELECT record FROM metabib.real_full_rec WHERE ' || single_where || ')';
        ELSE
            -- first subquery
            query := query || '(SELECT record FROM metabib.real_full_rec WHERE ' || single_where || ')';
            first := 0;
        END IF;
    END LOOP;

    query := query || ') AS X';

    OPEN results_cursor FOR EXECUTE query;

    FETCH results_cursor INTO bibs;

    RETURN bibs;
END;
$$;


ALTER FUNCTION authority.unlinked_bibs_to_given_auth_id(auth_id bigint) OWNER TO evergreen;

--
-- Name: calculate_bib_visibility_attribute_set(bigint, integer, boolean); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.calculate_bib_visibility_attribute_set(bib_id bigint, new_source integer DEFAULT NULL::integer, force_source boolean DEFAULT false) RETURNS integer[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    bib_row     biblio.record_entry%ROWTYPE;
    cn_row      asset.call_number%ROWTYPE;
    attr_set    INT[] := '{}'::INT[];
BEGIN
    SELECT * INTO bib_row FROM biblio.record_entry WHERE id = bib_id;

    IF force_source THEN
        IF new_source IS NOT NULL THEN
            attr_set := attr_set || search.calculate_visibility_attribute(new_source, 'bib_source');
        END IF;
    ELSIF bib_row.source IS NOT NULL THEN
        attr_set := attr_set || search.calculate_visibility_attribute(bib_row.source, 'bib_source');
    END IF;

    FOR cn_row IN
        SELECT  *
          FROM  asset.call_number
          WHERE record = bib_id
                AND label = '##URI##'
                AND NOT deleted
    LOOP
        attr_set := attr_set || search.calculate_visibility_attribute(cn_row.owning_lib, 'luri_org');
    END LOOP;

    RETURN attr_set;
END;
$$;


ALTER FUNCTION biblio.calculate_bib_visibility_attribute_set(bib_id bigint, new_source integer, force_source boolean) OWNER TO evergreen;

--
-- Name: check_marcxml_well_formed(); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.check_marcxml_well_formed() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    IF xml_is_well_formed(NEW.marc) THEN
        RETURN NEW;
    ELSE
        RAISE EXCEPTION 'Attempted to % MARCXML that is not well formed', TG_OP;
    END IF;
    
END;
$$;


ALTER FUNCTION biblio.check_marcxml_well_formed() OWNER TO evergreen;

--
-- Name: extract_fingerprint(text); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.extract_fingerprint(marc text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
	idx		config.biblio_fingerprint%ROWTYPE;
	xfrm		config.xml_transform%ROWTYPE;
	prev_xfrm	TEXT;
	transformed_xml	TEXT;
	xml_node	TEXT;
	xml_node_list	TEXT[];
	raw_text	TEXT;
    output_text TEXT := '';
BEGIN

    IF marc IS NULL OR marc = '' THEN
        RETURN NULL;
    END IF;

	-- Loop over the indexing entries
	FOR idx IN SELECT * FROM config.biblio_fingerprint ORDER BY format, id LOOP

		SELECT INTO xfrm * from config.xml_transform WHERE name = idx.format;

		-- See if we can skip the XSLT ... it's expensive
		IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
			-- Can't skip the transform
			IF xfrm.xslt <> '---' THEN
				transformed_xml := oils_xslt_process(marc,xfrm.xslt);
			ELSE
				transformed_xml := marc;
			END IF;

			prev_xfrm := xfrm.name;
		END IF;

		raw_text := COALESCE(
            naco_normalize(
                ARRAY_TO_STRING(
                    oils_xpath(
                        '//text()',
                        (oils_xpath(
                            idx.xpath,
                            transformed_xml,
                            ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] 
                        ))[1]
                    ),
                    ''
                )
            ),
            ''
        );

        raw_text := REGEXP_REPLACE(raw_text, E'\\[.+?\\]', E'');
        raw_text := REGEXP_REPLACE(raw_text, E'\\mthe\\M|\\man?d?d\\M', E'', 'g'); -- arg! the pain!

        IF idx.first_word IS TRUE THEN
            raw_text := REGEXP_REPLACE(raw_text, E'^(\\w+).*?$', E'\\1');
        END IF;

		output_text := output_text || idx.name || ':' ||
					   REGEXP_REPLACE(raw_text, E'\\s+', '', 'g') || ' ';

	END LOOP;

    RETURN BTRIM(output_text);

END;
$_$;


ALTER FUNCTION biblio.extract_fingerprint(marc text) OWNER TO evergreen;

--
-- Name: extract_languages(bigint); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.extract_languages(bigint) RETURNS tsvector
    LANGUAGE plpgsql
    AS $_$

DECLARE
    alt_lang    text;
    lang        text;
    subfields   text;
BEGIN
    lang := biblio.marc21_extract_fixed_field($1, 'Lang');

--  read MARC 041 subfields from actor.org_unit_setting.opac_additional_language_subfields
--  trim any '"' chars, split into array of subfields

    SELECT value INTO subfields FROM actor.org_unit_setting where name like 'opac.additional_language_subfields';
--
--  query MARC 041 specified subfields for additional search languages
--
    FOR alt_lang IN (SELECT value FROM biblio.flatten_marc($1) where tag='041' and POSITION(subfield IN subfields) > 0)
    LOOP
        lang := lang || ' ' || alt_lang;
    END LOOP;

    return lang::tsvector;
END;
$_$;


ALTER FUNCTION biblio.extract_languages(bigint) OWNER TO evergreen;

--
-- Name: extract_located_uris(bigint, text, integer); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.extract_located_uris(bib_id bigint, marcxml text, editor_id integer) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    uris            TEXT[];
    uri_xml         TEXT;
    uri_label       TEXT;
    uri_href        TEXT;
    uri_use         TEXT;
    uri_owner_list  TEXT[];
    uri_owner       TEXT;
    uri_owner_id    INT;
    uri_id          INT;
    uri_cn_id       INT;
    uri_map_id      INT;
    current_uri     INT;
    current_map     INT;
    uri_map_count   INT;
    current_uri_map_list    INT[];
    current_map_owner_list  INT[];

BEGIN

    uris := oils_xpath('//*[@tag="856" and (@ind1="4" or @ind1="1") and (@ind2="0" or @ind2="1")]',marcxml);
    IF ARRAY_UPPER(uris,1) > 0 THEN
        FOR i IN 1 .. ARRAY_UPPER(uris, 1) LOOP
            -- First we pull info out of the 856
            uri_xml     := uris[i];

            uri_href    := (oils_xpath('//*[@code="u"]/text()',uri_xml))[1];
            uri_label   := (oils_xpath('//*[@code="y"]/text()|//*[@code="3"]/text()',uri_xml))[1];
            uri_use     := (oils_xpath('//*[@code="z"]/text()|//*[@code="2"]/text()|//*[@code="n"]/text()',uri_xml))[1];

            IF uri_label IS NULL THEN
                uri_label := uri_href;
            END IF;
            CONTINUE WHEN uri_href IS NULL;

            -- Get the distinct list of libraries wanting to use 
            SELECT  ARRAY_AGG(
                        DISTINCT REGEXP_REPLACE(
                            x,
                            $re$^.*?\((\w+)\).*$$re$,
                            E'\\1'
                        )
                    ) INTO uri_owner_list
              FROM  UNNEST(
                        oils_xpath(
                            '//*[@code="9"]/text()|//*[@code="w"]/text()|//*[@code="n"]/text()',
                            uri_xml
                        )
                    )x;

            IF ARRAY_UPPER(uri_owner_list,1) > 0 THEN

                -- look for a matching uri
                IF uri_use IS NULL THEN
                    SELECT id INTO uri_id
                        FROM asset.uri
                        WHERE label = uri_label AND href = uri_href AND use_restriction IS NULL AND active
                        ORDER BY id LIMIT 1;
                    IF NOT FOUND THEN -- create one
                        INSERT INTO asset.uri (label, href, use_restriction) VALUES (uri_label, uri_href, uri_use);
                        SELECT id INTO uri_id
                            FROM asset.uri
                            WHERE label = uri_label AND href = uri_href AND use_restriction IS NULL AND active;
                    END IF;
                ELSE
                    SELECT id INTO uri_id
                        FROM asset.uri
                        WHERE label = uri_label AND href = uri_href AND use_restriction = uri_use AND active
                        ORDER BY id LIMIT 1;
                    IF NOT FOUND THEN -- create one
                        INSERT INTO asset.uri (label, href, use_restriction) VALUES (uri_label, uri_href, uri_use);
                        SELECT id INTO uri_id
                            FROM asset.uri
                            WHERE label = uri_label AND href = uri_href AND use_restriction = uri_use AND active;
                    END IF;
                END IF;

                FOR j IN 1 .. ARRAY_UPPER(uri_owner_list, 1) LOOP
                    uri_owner := uri_owner_list[j];

                    SELECT id INTO uri_owner_id FROM actor.org_unit WHERE shortname = BTRIM(REPLACE(uri_owner,chr(160),''));
                    CONTINUE WHEN NOT FOUND;

                    -- we need a call number to link through
                    SELECT id INTO uri_cn_id FROM asset.call_number WHERE owning_lib = uri_owner_id AND record = bib_id AND label = '##URI##' AND NOT deleted;
                    IF NOT FOUND THEN
                        INSERT INTO asset.call_number (owning_lib, record, create_date, edit_date, creator, editor, label)
                            VALUES (uri_owner_id, bib_id, 'now', 'now', editor_id, editor_id, '##URI##');
                        SELECT id INTO uri_cn_id FROM asset.call_number WHERE owning_lib = uri_owner_id AND record = bib_id AND label = '##URI##' AND NOT deleted;
                    END IF;

                    -- now, link them if they're not already
                    SELECT id INTO uri_map_id FROM asset.uri_call_number_map WHERE call_number = uri_cn_id AND uri = uri_id;
                    IF NOT FOUND THEN
                        INSERT INTO asset.uri_call_number_map (call_number, uri) VALUES (uri_cn_id, uri_id);
                        SELECT id INTO uri_map_id FROM asset.uri_call_number_map WHERE call_number = uri_cn_id AND uri = uri_id;
                    END IF;

                    current_uri_map_list := current_uri_map_list || uri_map_id;
                    current_map_owner_list := current_map_owner_list || uri_cn_id;

                END LOOP;

            END IF;

        END LOOP;
    END IF;

    -- Clear any orphaned URIs, URI mappings and call
    -- numbers for this bib that weren't mapped above.
    FOR current_map IN
        SELECT  m.id
          FROM  asset.uri_call_number_map m
                LEFT JOIN asset.call_number cn ON (cn.id = m.call_number)
          WHERE cn.record = bib_id
                AND cn.label = '##URI##'
                AND (NOT (m.id = ANY (current_uri_map_list))
                     OR current_uri_map_list is NULL)
    LOOP
        SELECT uri INTO current_uri FROM asset.uri_call_number_map WHERE id = current_map;
        DELETE FROM asset.uri_call_number_map WHERE id = current_map;

        SELECT COUNT(*) INTO uri_map_count FROM asset.uri_call_number_map WHERE uri = current_uri;
        IF uri_map_count = 0 THEN
            DELETE FROM asset.uri WHERE id = current_uri;
        END IF;
    END LOOP;

    UPDATE asset.call_number
    SET deleted = TRUE, edit_date = now(), editor = editor_id
    WHERE id IN (
        SELECT  id
          FROM  asset.call_number
          WHERE record = bib_id
                AND label = '##URI##'
                AND NOT deleted
                AND (NOT (id = ANY (current_map_owner_list))
                     OR current_map_owner_list is NULL)
    );

    RETURN;
END;
$_$;


ALTER FUNCTION biblio.extract_located_uris(bib_id bigint, marcxml text, editor_id integer) OWNER TO evergreen;

--
-- Name: extract_metabib_field_entry(bigint, text, text[], integer[]); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.extract_metabib_field_entry(rid bigint, default_joiner text, field_types text[], only_fields integer[]) RETURNS SETOF metabib.field_entry_template
    LANGUAGE plpgsql
    AS $_$
DECLARE
    bib     biblio.record_entry%ROWTYPE;
    idx     config.metabib_field%ROWTYPE;
    xfrm        config.xml_transform%ROWTYPE;
    prev_xfrm   TEXT;
    transformed_xml TEXT;
    xml_node    TEXT;
    xml_node_list   TEXT[];
    facet_text  TEXT;
    display_text TEXT;
    browse_text TEXT;
    sort_value  TEXT;
    raw_text    TEXT;
    curr_text   TEXT;
    joiner      TEXT := default_joiner; -- XXX will index defs supply a joiner?
    authority_text TEXT;
    authority_link BIGINT;
    output_row  metabib.field_entry_template%ROWTYPE;
    process_idx BOOL;
BEGIN

    -- Start out with no field-use bools set
    output_row.browse_nocase = FALSE;
    output_row.browse_field = FALSE;
    output_row.facet_field = FALSE;
    output_row.display_field = FALSE;
    output_row.search_field = FALSE;

    -- Get the record
    SELECT INTO bib * FROM biblio.record_entry WHERE id = rid;

    -- Loop over the indexing entries
    FOR idx IN SELECT * FROM config.metabib_field WHERE id = ANY (only_fields) ORDER BY format LOOP
        CONTINUE WHEN idx.xpath IS NULL OR idx.xpath = ''; -- pure virtual field

        process_idx := FALSE;
        IF idx.display_field AND 'display' = ANY (field_types) THEN process_idx = TRUE; END IF;
        IF idx.browse_field AND 'browse' = ANY (field_types) THEN process_idx = TRUE; END IF;
        IF idx.search_field AND 'search' = ANY (field_types) THEN process_idx = TRUE; END IF;
        IF idx.facet_field AND 'facet' = ANY (field_types) THEN process_idx = TRUE; END IF;
        CONTINUE WHEN process_idx = FALSE;

        joiner := COALESCE(idx.joiner, default_joiner);

        SELECT INTO xfrm * from config.xml_transform WHERE name = idx.format;

        -- See if we can skip the XSLT ... it's expensive
        IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
            -- Can't skip the transform
            IF xfrm.xslt <> '---' THEN
                transformed_xml := oils_xslt_process(bib.marc,xfrm.xslt);
            ELSE
                transformed_xml := bib.marc;
            END IF;

            prev_xfrm := xfrm.name;
        END IF;

        xml_node_list := oils_xpath( idx.xpath, transformed_xml, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );

        raw_text := NULL;
        FOR xml_node IN SELECT x FROM unnest(xml_node_list) AS x LOOP
            CONTINUE WHEN xml_node !~ E'^\\s*<';

            -- XXX much of this should be moved into oils_xpath_string...
            curr_text := ARRAY_TO_STRING(array_remove(array_remove(
                oils_xpath( '//text()', -- get the content of all the nodes within the main selected node
                    REGEXP_REPLACE( xml_node, E'\\s+', ' ', 'g' ) -- Translate adjacent whitespace to a single space
                ), ' '), ''),  -- throw away morally empty (bankrupt?) strings
                joiner
            );

            CONTINUE WHEN curr_text IS NULL OR curr_text = '';

            IF raw_text IS NOT NULL THEN
                raw_text := raw_text || joiner;
            END IF;

            raw_text := COALESCE(raw_text,'') || curr_text;

            -- autosuggest/metabib.browse_entry
            IF idx.browse_field THEN
                output_row.browse_nocase = idx.browse_nocase;

                IF idx.browse_xpath IS NOT NULL AND idx.browse_xpath <> '' THEN
                    browse_text := oils_xpath_string( idx.browse_xpath, xml_node, joiner, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );
                ELSE
                    browse_text := curr_text;
                END IF;

                IF idx.browse_sort_xpath IS NOT NULL AND
                    idx.browse_sort_xpath <> '' THEN

                    sort_value := oils_xpath_string(
                        idx.browse_sort_xpath, xml_node, joiner,
                        ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]
                    );
                ELSE
                    sort_value := browse_text;
                END IF;

                output_row.field_class = idx.field_class;
                output_row.field = idx.id;
                output_row.source = rid;
                output_row.value = BTRIM(REGEXP_REPLACE(browse_text, E'\\s+', ' ', 'g'));

                -- output_row.value = BTRIM(REGEXP_REPLACE(browse_text, E'\\s+', ' ', 'g'));
                -- outer regexp_replace keeps all '.' expect the last one.
                -- inner regexp_replace removes all connecting whitespace and replaces it with a single space
                output_row.value = BTRIM(REGEXP_REPLACE(REGEXP_REPLACE(browse_text, E'\\s+', ' ', 'g'), E'\\.$', '', 'g'));
                -- /KCLS

                -- KCLS call number browse uses dewey sort
                IF idx.field_class = 'identifier' AND idx.name = 'bibcn' THEN
                    output_row.sort_value := asset.label_normalizer_dewey(sort_value);
                ELSE
                    output_row.sort_value := public.naco_normalize(sort_value);
                END IF;

                output_row.authority := NULL;

                IF idx.authority_xpath IS NOT NULL AND idx.authority_xpath <> '' THEN
                    authority_text := oils_xpath_string(
                        idx.authority_xpath, xml_node, joiner,
                        ARRAY[
                            ARRAY[xfrm.prefix, xfrm.namespace_uri],
                            ARRAY['xlink','http://www.w3.org/1999/xlink']
                        ]
                    );

                    IF authority_text ~ '^\d+$' THEN
                        authority_link := authority_text::BIGINT;
                        PERFORM * FROM authority.record_entry WHERE id = authority_link;
                        IF FOUND THEN
                            output_row.authority := authority_link;
                        END IF;
                    END IF;

                END IF;

                output_row.browse_field = TRUE;
                -- Returning browse rows with search_field = true for search+browse
                -- configs allows us to retain granularity of being able to search
                -- browse fields with "starts with" type operators (for example, for
                -- titles of songs in music albums)
                IF idx.search_field THEN
                    output_row.search_field = TRUE;
                END IF;
                RETURN NEXT output_row;
                output_row.browse_nocase = FALSE;
                output_row.browse_field = FALSE;
                output_row.search_field = FALSE;
                output_row.sort_value := NULL;
            END IF;

            -- insert raw node text for faceting
            IF idx.facet_field THEN

                IF idx.facet_xpath IS NOT NULL AND idx.facet_xpath <> '' THEN
                    facet_text := oils_xpath_string( idx.facet_xpath, xml_node, joiner, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );
                ELSE
                    facet_text := curr_text;
                END IF;

                output_row.field_class = idx.field_class;
                output_row.field = -1 * idx.id;
                output_row.source = rid;
                output_row.value = BTRIM(REGEXP_REPLACE(facet_text, E'\\s+', ' ', 'g'));

                output_row.facet_field = TRUE;
                RETURN NEXT output_row;
                output_row.facet_field = FALSE;
            END IF;

            -- insert raw node text for display
            IF idx.display_field THEN

                IF idx.display_xpath IS NOT NULL AND idx.display_xpath <> '' THEN
                    display_text := oils_xpath_string( idx.display_xpath, xml_node, joiner, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]] );
                ELSE
                    display_text := curr_text;
                END IF;

                output_row.field_class = idx.field_class;
                output_row.field = -1 * idx.id;
                output_row.source = rid;
                output_row.value = BTRIM(REGEXP_REPLACE(display_text, E'\\s+', ' ', 'g'));

                output_row.display_field = TRUE;
                RETURN NEXT output_row;
                output_row.display_field = FALSE;
            END IF;

        END LOOP;

        CONTINUE WHEN raw_text IS NULL OR raw_text = '';

        -- insert combined node text for searching
        IF idx.search_field THEN
            output_row.field_class = idx.field_class;
            -- KCLS
            -- TODO: move these mods into configs / search normalizers
            IF idx.field_class = 'identifier' AND idx.name = 'bibcn' THEN
                output_row.field_class = 'call_number';
                output_row.browse_field = TRUE;
                output_row.sort_value = public.naco_normalize_keep_decimal(raw_text,'');
                output_row.value = raw_text;
            ELSE
                output_row.field_class = idx.field_class;
                output_row.value = BTRIM(REGEXP_REPLACE(raw_text, E'\\s+', ' ', 'g'));
            END IF;
            -- /KCLS
            output_row.field = idx.id;
            output_row.source = rid;
            -- KCLS -- value is set above
            -- output_row.value = BTRIM(REGEXP_REPLACE(raw_text, E'\\s+', ' ', 'g'));
            -- /KCLS

            output_row.search_field = TRUE;
            RETURN NEXT output_row;
            output_row.search_field = FALSE;
        END IF;

    END LOOP;

END;
$_$;


ALTER FUNCTION biblio.extract_metabib_field_entry(rid bigint, default_joiner text, field_types text[], only_fields integer[]) OWNER TO evergreen;

--
-- Name: extract_quality(text, text, text); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.extract_quality(marc text, best_lang text, best_type text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    qual        INT;
    ldr         TEXT;
    tval        TEXT;
    tval_rec    RECORD;
    bval        TEXT;
    bval_rec    RECORD;
    type_map    RECORD;
    ff_pos      RECORD;
    ff_tag_data TEXT;
BEGIN

    IF marc IS NULL OR marc = '' THEN
        RETURN NULL;
    END IF;

    -- First, the count of tags
    qual := ARRAY_UPPER(oils_xpath('//*[local-name()="datafield"]', marc), 1);

    -- now go through a bunch of pain to get the record type
    IF best_type IS NOT NULL THEN
        ldr := (oils_xpath('//*[local-name()="leader"]/text()', marc))[1];

        IF ldr IS NOT NULL THEN
            SELECT * INTO tval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'Type' LIMIT 1; -- They're all the same
            SELECT * INTO bval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'BLvl' LIMIT 1; -- They're all the same


            tval := SUBSTRING( ldr, tval_rec.start_pos + 1, tval_rec.length );
            bval := SUBSTRING( ldr, bval_rec.start_pos + 1, bval_rec.length );

            -- RAISE NOTICE 'type %, blvl %, ldr %', tval, bval, ldr;

            SELECT * INTO type_map FROM config.marc21_rec_type_map WHERE type_val LIKE '%' || tval || '%' AND blvl_val LIKE '%' || bval || '%';

            IF type_map.code IS NOT NULL THEN
                IF best_type = type_map.code THEN
                    qual := qual + qual / 2;
                END IF;

                FOR ff_pos IN SELECT * FROM config.marc21_ff_pos_map WHERE fixed_field = 'Lang' AND rec_type = type_map.code ORDER BY tag DESC LOOP
                    ff_tag_data := SUBSTRING((oils_xpath('//*[@tag="' || ff_pos.tag || '"]/text()',marc))[1], ff_pos.start_pos + 1, ff_pos.length);
                    IF ff_tag_data = best_lang THEN
                            qual := qual + 100;
                    END IF;
                END LOOP;
            END IF;
        END IF;
    END IF;

    -- Now look for some quality metrics
    -- DCL record?
    IF ARRAY_UPPER(oils_xpath('//*[@tag="040"]/*[@code="a" and contains(.,"DLC")]', marc), 1) = 1 THEN
        qual := qual + 10;
    END IF;

    -- From OCLC?
    IF (oils_xpath('//*[@tag="003"]/text()', marc))[1] ~* E'oclo?c' THEN
        qual := qual + 10;
    END IF;

    RETURN qual;

END;
$$;


ALTER FUNCTION biblio.extract_quality(marc text, best_lang text, best_type text) OWNER TO evergreen;

--
-- Name: fingerprint_trigger(); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.fingerprint_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    -- For TG_ARGV, first param is language (like 'eng'), second is record type (like 'BKS')

    IF NEW.deleted IS TRUE THEN -- we don't much care, then, do we?
        RETURN NEW;
    END IF;

    NEW.fingerprint := biblio.extract_fingerprint(NEW.marc);
    NEW.quality := biblio.extract_quality(NEW.marc, TG_ARGV[0], TG_ARGV[1]);

    RETURN NEW;

END;
$$;


ALTER FUNCTION biblio.fingerprint_trigger() OWNER TO evergreen;

--
-- Name: full_rec_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.full_rec_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.full_rec_id_seq OWNER TO evergreen;

--
-- Name: real_full_rec; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.real_full_rec (
    id bigint DEFAULT nextval('metabib.full_rec_id_seq'::regclass) NOT NULL,
    record bigint NOT NULL,
    tag character(3) NOT NULL,
    ind1 text,
    ind2 text,
    subfield text,
    value text NOT NULL,
    index_vector tsvector NOT NULL
)
WITH (autovacuum_enabled='true');


ALTER TABLE metabib.real_full_rec OWNER TO evergreen;

--
-- Name: full_rec; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW metabib.full_rec AS
 SELECT real_full_rec.id,
    real_full_rec.record,
    real_full_rec.tag,
    real_full_rec.ind1,
    real_full_rec.ind2,
    real_full_rec.subfield,
    "substring"(real_full_rec.value, 1, 1024) AS value,
    real_full_rec.index_vector
   FROM metabib.real_full_rec;


ALTER TABLE metabib.full_rec OWNER TO evergreen;

--
-- Name: flatten_marc(bigint); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.flatten_marc(rid bigint) RETURNS SETOF metabib.full_rec
    LANGUAGE plpgsql
    AS $$
DECLARE
    bib biblio.record_entry%ROWTYPE;
    output  metabib.full_rec%ROWTYPE;
    field   RECORD;
BEGIN
    SELECT INTO bib * FROM biblio.record_entry WHERE id = rid;

    FOR field IN SELECT * FROM vandelay.flatten_marc( bib.marc ) LOOP
        output.record := rid;
        output.ind1 := field.ind1;
        output.ind2 := field.ind2;
        output.tag := field.tag;
        output.subfield := field.subfield;
        output.value := field.value;

        RETURN NEXT output;
    END LOOP;
END;
$$;


ALTER FUNCTION biblio.flatten_marc(rid bigint) OWNER TO evergreen;

--
-- Name: indexing_ingest_or_delete(); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.indexing_ingest_or_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    tmp_bool BOOL;
BEGIN

    IF NEW.deleted THEN -- If this bib is deleted

        PERFORM * FROM config.internal_flag WHERE
            name = 'ingest.metarecord_mapping.preserve_on_delete' AND enabled;

        tmp_bool := FOUND; -- Just in case this is changed by some other statement

        PERFORM metabib.remap_metarecord_for_bib( NEW.id, NEW.fingerprint, TRUE, tmp_bool );

        IF NOT tmp_bool THEN
            -- One needs to keep these around to support searches
            -- with the #deleted modifier, so one should turn on the named
            -- internal flag for that functionality.
            DELETE FROM metabib.record_attr_vector_list WHERE source = NEW.id;
        END IF;

        DELETE FROM authority.bib_linking WHERE bib = NEW.id; -- Avoid updating fields in bibs that are no longer visible
        DELETE FROM biblio.peer_bib_copy_map WHERE peer_record = NEW.id; -- Separate any multi-homed items
        DELETE FROM metabib.browse_entry_def_map WHERE source = NEW.id; -- Don't auto-suggest deleted bibs
        RETURN NEW; -- and we're done
    END IF;

    IF TG_OP = 'UPDATE' AND OLD.deleted IS FALSE THEN -- re-ingest?
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.reingest.force_on_same_marc' AND enabled;

        IF NOT FOUND AND OLD.marc = NEW.marc THEN -- don't do anything if the MARC didn't change
            RETURN NEW;
        END IF;
    END IF;

    -- Record authority linking
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_authority_linking' AND enabled;
    IF NOT FOUND THEN
        PERFORM biblio.map_authority_linking( NEW.id, NEW.marc );
    END IF;

    -- Flatten and insert the mfr data
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_metabib_full_rec' AND enabled;
    IF NOT FOUND THEN
        PERFORM metabib.reingest_metabib_full_rec(NEW.id);

        -- Now we pull out attribute data, which is dependent on the mfr for all but XPath-based fields
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_metabib_rec_descriptor' AND enabled;
        IF NOT FOUND THEN
            PERFORM metabib.reingest_record_attributes(NEW.id, NULL, NEW.marc, TG_OP = 'INSERT' OR OLD.deleted);
        END IF;
    END IF;

    -- Gather and insert the field entry data
    PERFORM metabib.reingest_metabib_field_entries(NEW.id);

    -- Located URI magic
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.disable_located_uri' AND enabled;
    IF NOT FOUND THEN PERFORM biblio.extract_located_uris( NEW.id, NEW.marc, NEW.editor ); END IF;

    -- (re)map metarecord-bib linking
    IF TG_OP = 'INSERT' THEN -- if not deleted and performing an insert, check for the flag
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.metarecord_mapping.skip_on_insert' AND enabled;
        IF NOT FOUND THEN
            PERFORM metabib.remap_metarecord_for_bib( NEW.id, NEW.fingerprint );
        END IF;
    ELSE -- we're doing an update, and we're not deleted, remap
        PERFORM * FROM config.internal_flag WHERE name = 'ingest.metarecord_mapping.skip_on_update' AND enabled;
        IF NOT FOUND THEN
            PERFORM metabib.remap_metarecord_for_bib( NEW.id, NEW.fingerprint );
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION biblio.indexing_ingest_or_delete() OWNER TO evergreen;

--
-- Name: map_authority_linking(bigint, text); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.map_authority_linking(bibid bigint, marc text) RETURNS bigint
    LANGUAGE sql
    AS $_$
    DELETE FROM authority.bib_linking WHERE bib = $1;
    INSERT INTO authority.bib_linking (bib, authority)
        SELECT  y.bib,
                y.authority
          FROM (    SELECT  DISTINCT $1 AS bib,
                            BTRIM(remove_paren_substring(txt))::BIGINT AS authority
                      FROM  unnest(oils_xpath('//*[@code="0"]/text()',$2)) x(txt)
                      WHERE BTRIM(remove_paren_substring(txt)) ~ $re$^\d+$$re$
                ) y JOIN authority.record_entry r ON r.id = y.authority;
    SELECT $1;
$_$;


ALTER FUNCTION biblio.map_authority_linking(bibid bigint, marc text) OWNER TO evergreen;

--
-- Name: marc21_extract_all_fixed_fields(bigint); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.marc21_extract_all_fixed_fields(rid bigint) RETURNS SETOF biblio.record_ff_map
    LANGUAGE sql
    AS $_$
    SELECT $1 AS record, ff_name, ff_value FROM vandelay.marc21_extract_all_fixed_fields( (SELECT marc FROM biblio.record_entry WHERE id = $1), TRUE );
$_$;


ALTER FUNCTION biblio.marc21_extract_all_fixed_fields(rid bigint) OWNER TO evergreen;

--
-- Name: marc21_extract_fixed_field(bigint, text); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.marc21_extract_fixed_field(rid bigint, ff text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.marc21_extract_fixed_field( (SELECT marc FROM biblio.record_entry WHERE id = $1), $2, TRUE );
$_$;


ALTER FUNCTION biblio.marc21_extract_fixed_field(rid bigint, ff text) OWNER TO evergreen;

--
-- Name: marc21_extract_fixed_field_list(bigint, text); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.marc21_extract_fixed_field_list(rid bigint, ff text) RETURNS text[]
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.marc21_extract_fixed_field_list( (SELECT marc FROM biblio.record_entry WHERE id = $1), $2, TRUE );
$_$;


ALTER FUNCTION biblio.marc21_extract_fixed_field_list(rid bigint, ff text) OWNER TO evergreen;

--
-- Name: marc21_physical_characteristics(bigint); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.marc21_physical_characteristics(rid bigint) RETURNS SETOF biblio.marc21_physical_characteristics
    LANGUAGE sql
    AS $_$
    SELECT id, $1 AS record, ptype, subfield, value FROM vandelay.marc21_physical_characteristics( (SELECT marc FROM biblio.record_entry WHERE id = $1) );
$_$;


ALTER FUNCTION biblio.marc21_physical_characteristics(rid bigint) OWNER TO evergreen;

--
-- Name: marc21_rec_type_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.marc21_rec_type_map (
    code text NOT NULL,
    type_val text NOT NULL,
    blvl_val text NOT NULL
);


ALTER TABLE config.marc21_rec_type_map OWNER TO evergreen;

--
-- Name: marc21_record_type(bigint); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.marc21_record_type(rid bigint) RETURNS config.marc21_rec_type_map
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.marc21_record_type( (SELECT marc FROM biblio.record_entry WHERE id = $1) );
$_$;


ALTER FUNCTION biblio.marc21_record_type(rid bigint) OWNER TO evergreen;

--
-- Name: next_autogen_tcn_value(); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.next_autogen_tcn_value() RETURNS text
    LANGUAGE plpgsql
    AS $$
	BEGIN RETURN 'AUTOGENERATED-' || nextval('biblio.autogen_tcn_value_seq'::TEXT); END;
$$;


ALTER FUNCTION biblio.next_autogen_tcn_value() OWNER TO evergreen;

--
-- Name: normalize_biblio_monograph_part_sortkey(); Type: FUNCTION; Schema: biblio; Owner: evergreen
--

CREATE FUNCTION biblio.normalize_biblio_monograph_part_sortkey() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.label_sortkey := REGEXP_REPLACE(
        evergreen.lpad_number_substrings(
            naco_normalize(NEW.label),
            '0',
            10
        ),
        E'\\s+',
        '',
        'g'
    );
    RETURN NEW;
END;
$$;


ALTER FUNCTION biblio.normalize_biblio_monograph_part_sortkey() OWNER TO evergreen;

--
-- Name: ranked_volumes_ex(bigint, integer, integer, evergreen.hstore, evergreen.hstore, integer); Type: FUNCTION; Schema: cmd; Owner: postgres
--

CREATE FUNCTION cmd.ranked_volumes_ex(bibid bigint, ouid integer, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, pref_lib integer DEFAULT NULL::integer) RETURNS TABLE(id bigint, name text, label_sortkey text, rank bigint)
    LANGUAGE sql STABLE
    AS $_$
    SELECT ua.id, ua.name, ua.label_sortkey, MIN(ua.rank) AS rank FROM (
        SELECT acn.id, aou.name, acn.label_sortkey,
            RANK() OVER w
        FROM asset.call_number acn
            JOIN asset.copy acp ON (acn.id = acp.call_number)
            JOIN actor.org_unit_descendants( $2, COALESCE(
                $3, (
                    SELECT depth
                    FROM actor.org_unit_type aout
                        INNER JOIN actor.org_unit ou ON ou_type = aout.id
                    WHERE ou.id = $2
                ), $6)
            ) AS aou ON (acp.circ_lib = aou.id)
        WHERE acn.record = $1
            AND acn.deleted IS FALSE
            AND acp.deleted IS FALSE
        GROUP BY acn.id, acp.status, aou.name, acn.label_sortkey, aou.id
        WINDOW w AS (
            ORDER BY evergreen.rank_ou(aou.id, $2, $6), evergreen.rank_cp_status(acp.status)
        )
    ) AS ua
    GROUP BY ua.id, ua.name, ua.label_sortkey
    ORDER BY rank, ua.name, ua.label_sortkey
    LIMIT ($4 -> 'acn')::INT
    OFFSET ($5 -> 'acn')::INT;
$_$;


ALTER FUNCTION cmd.ranked_volumes_ex(bibid bigint, ouid integer, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, pref_lib integer) OWNER TO postgres;

--
-- Name: attempt_price(text); Type: FUNCTION; Schema: collectionhq; Owner: evergreen
--

CREATE FUNCTION collectionhq.attempt_price(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
  DECLARE
    attempt_value ALIAS FOR $1;
    output TEXT;
  BEGIN
    FOR output IN
      EXECUTE 'SELECT (REGEXP_REPLACE(' || quote_literal(attempt_value) || E', E\'[^0-9\.]\', \'\', \'g\')::NUMERIC(8,2) * 100)::INTEGER AS a;'
    LOOP
      RETURN output;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      FOR output IN
        EXECUTE E'SELECT \'\' AS a;'
      LOOP
        RETURN output;
      END LOOP;
  END;
$_$;


ALTER FUNCTION collectionhq.attempt_price(text) OWNER TO evergreen;

--
-- Name: attempt_year(text); Type: FUNCTION; Schema: collectionhq; Owner: evergreen
--

CREATE FUNCTION collectionhq.attempt_year(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
  DECLARE
    attempt_value ALIAS FOR $1;
    output TEXT;
  BEGIN
    FOR output IN
      EXECUTE 'SELECT SUBSTRING(REGEXP_REPLACE(' || quote_literal(attempt_value) || E', E\'[^0-9]\', \'\', \'g\') FROM 1 FOR 4) AS a;'
    LOOP
      RETURN output;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      FOR output IN
        EXECUTE E'SELECT \'\' AS a;'
      LOOP
        RETURN output;
      END LOOP;
  END;
$_$;


ALTER FUNCTION collectionhq.attempt_year(text) OWNER TO evergreen;

--
-- Name: quote(text); Type: FUNCTION; Schema: collectionhq; Owner: evergreen
--

CREATE FUNCTION collectionhq.quote(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
  DECLARE
    value ALIAS FOR $1;
    output TEXT;
  BEGIN
    IF value IS NOT NULL AND value <> '' THEN
      RETURN '##' || value || '##';
    ELSE
      RETURN '';
    END IF;
  END;
$_$;


ALTER FUNCTION collectionhq.quote(text) OWNER TO evergreen;

--
-- Name: write_bib_rows_to_stdout(text, integer); Type: FUNCTION; Schema: collectionhq; Owner: evergreen
--

CREATE FUNCTION collectionhq.write_bib_rows_to_stdout(text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Usage: SELECT collectionHQ.write_bib_rows_to_stdout('LIBRARYCODE', org_unit_id);

  DECLARE
    library_service_code ALIAS FOR $1;
    org_unit_id ALIAS FOR $2;
    isbn TEXT := '';
    title TEXT := '';
    author TEXT := '';
    edition_num TEXT := '';
    publication_date TEXT := '';
    publisher TEXT := '';
    price TEXT := '';
    lms_item_type TEXT := '';
    class_num TEXT := '';
    extract_date TEXT := '';
    output TEXT := '';
    lms_bib_id BIGINT;
    num_rows INTEGER := 0;

  BEGIN
    
    SELECT REPLACE(NOW()::DATE::TEXT, '-', '') INTO extract_date;
    FOR lms_bib_id IN
      SELECT DISTINCT bre.id FROM biblio.record_entry bre JOIN asset.call_number acn ON (acn.record = bre.id) WHERE acn.owning_lib IN (SELECT id FROM actor.org_unit_descendants(org_unit_id)) AND NOT acn.deleted AND NOT bre.deleted
    LOOP

      SELECT r.isbn[1],
             SUBSTRING(r.title FROM 1 FOR 100),
             SUBSTRING(r.author FROM 1 FOR 50)
      INTO isbn, title, author
      FROM reporter.materialized_simple_record r
      WHERE id = lms_bib_id;
      SELECT 
        SUBSTRING(naco_normalize((XPATH('//marc:datafield[@tag="250"][1]/marc:subfield[@code="a"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT, 'a') FROM 1 FOR 20),
        collectionHQ.attempt_year((XPATH('//marc:datafield[@tag="260"][1]/marc:subfield[@code="c"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT),
        SUBSTRING(naco_normalize((XPATH('//marc:datafield[@tag="260"][1]/marc:subfield[@code="b"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT, 'b') FROM 1 FOR 100),
        collectionHQ.attempt_price((XPATH('//marc:datafield[@tag="020"][1]/marc:subfield[@code="c"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT),
        SUBSTRING(naco_normalize((XPATH('//marc:datafield[@tag="082"][1]/marc:subfield[@code="a"][1]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT, 'a') FROM 1 FOR 20)
      INTO edition_num, publication_date, publisher, price, class_num
      FROM biblio.record_entry
      WHERE id = lms_bib_id;

      SELECT circ_modifier INTO lms_item_type FROM asset.copy c, asset.call_number cn WHERE cn.record = lms_bib_id AND cn.id = c.call_number AND NOT cn.deleted AND NOT c.deleted LIMIT 1;
  
      output := 
        '##BIB##,'
        || lms_bib_id || ','
        || COALESCE(collectionHQ.quote(library_service_code), '') || ','
        || COALESCE(collectionHQ.quote(isbn), '') || ','
        || COALESCE(collectionHQ.quote(title), '') || ','
        || COALESCE(collectionHQ.quote(author), '') || ','
        || COALESCE(collectionHQ.quote(edition_num), '') || ','
        || COALESCE(collectionHQ.quote(publication_date), '') || ','
        || COALESCE(collectionHQ.quote(publisher), '') || ','
        || COALESCE(price, '') || ','
        || COALESCE(collectionHQ.quote(lms_item_type), '') || ','
        || COALESCE(collectionHQ.quote(class_num), '') || ','
        || COALESCE(collectionHQ.quote(extract_date), '');
  
       RAISE INFO '%', output;

       num_rows := num_rows + 1;
       IF (num_rows::numeric % 1000.0 = 0.0) THEN RAISE INFO '% rows written', num_rows; END IF;

    END LOOP;

    RAISE INFO '% rows written in total.', num_rows;
    RETURN '';

  END;

$_$;


ALTER FUNCTION collectionhq.write_bib_rows_to_stdout(text, integer) OWNER TO evergreen;

--
-- Name: write_item_rows_to_stdout(text, integer); Type: FUNCTION; Schema: collectionhq; Owner: postgres
--

CREATE FUNCTION collectionhq.write_item_rows_to_stdout(text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
 
DECLARE
 item BIGINT;
 authority_code ALIAS FOR $1;
 org_unit_id ALIAS for $2;
 lms_bib_id BIGINT;
 library_code TEXT;
 bar_code TEXT;
 last_use_date TEXT;
 cumulative_use_total TEXT;
 cumulative_use_current TEXT;
 status TEXT;
 date_added TEXT;
 price TEXT;
 purchase_code TEXT;
 rotating_stock TEXT;
 lib_supsel_tag TEXT;
 gen_supsel_tag TEXT;
 notes TEXT;
 extract_date TEXT;
 collection_code TEXT;
 collection_code_level_2 TEXT;
 filter_level_1 TEXT;
 filter_level_2 TEXT;
 filter_level_3 TEXT;
 filter_level_4 TEXT;
 isbn TEXT := '';
 output TEXT := '';
 arrived TIMESTAMPTZ;
 num_rows INTEGER := 0;

BEGIN

 SELECT REPLACE(NOW()::DATE::TEXT, '-', '') INTO extract_date;
 FOR item, arrived, cumulative_use_total IN
   SELECT cp.id, dest_recv_time, COALESCE(sum(DISTINCT c.circ_count), 0::bigint) + COALESCE(count(DISTINCT circ.id), 0::bigint) + COALESCE(count(DISTINCT acirc.id), 0::bigint) AS circ_count
   FROM asset.copy cp
   LEFT JOIN extend_reporter.legacy_circ_count c USING (id)
   LEFT JOIN (SELECT max(dest_recv_time) as dest_recv_time, target_copy, dest from action.transit_copy group by target_copy, dest) atc ON (cp.id = atc.target_copy AND cp.circ_lib = atc.dest)
   LEFT JOIN action.circulation circ ON circ.target_copy = cp.id
   LEFT JOIN action.aged_circulation acirc ON acirc.target_copy = cp.id
   WHERE NOT cp.deleted AND cp.circ_lib IN (SELECT id FROM actor.org_unit_descendants(org_unit_id)) GROUP BY cp.id, dest_recv_time ORDER BY cp.id
 LOOP

   SELECT cn.record, cn.label
   INTO lms_bib_id, filter_level_1
   FROM asset.call_number cn, asset.copy c 
   WHERE c.call_number = cn.id AND c.id =  item;
   SELECT r.isbn[1] INTO isbn
   FROM reporter.materialized_simple_record r
   WHERE id = lms_bib_id;
   SELECT collectionHQ.attempt_price(ac.price::TEXT), barcode, ac.status,
          REPLACE(create_date::DATE::TEXT, '-', ''),
          CASE WHEN floating IS NULL THEN NULL ELSE 'Y' END
   INTO price, bar_code, status, date_added, rotating_stock
   FROM asset.copy ac 
   WHERE id = item;
   IF price IS NULL OR price = '' THEN
     SELECT collectionHQ.attempt_price((XPATH('//marc:datafield[@tag="020"][1]/marc:subfield[@code="c"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT)
     INTO price
     FROM biblio.record_entry
     WHERE id = lms_bib_id;
   END IF;
   SELECT ou.shortname INTO library_code FROM actor.org_unit ou, asset.copy c WHERE ou.id = c.circ_lib AND c.id = item;
   /* SELECT REPLACE(xact_start::DATE::TEXT, '-', '') INTO last_use_date FROM action.circulation WHERE target_copy = item ORDER BY xact_start DESC LIMIT 1; */
   SELECT REPLACE(xact_start::DATE::TEXT, '-', '') INTO last_use_date FROM ( SELECT action.aged_circulation.xact_start FROM action.aged_circulation where target_copy = item UNION SELECT action.circulation.xact_start FROM action.circulation where target_copy = item) as lu  order by xact_start DESC limit 1;

   
   IF arrived IS NOT NULL THEN
     SELECT COUNT(*) INTO cumulative_use_current FROM action.circulation WHERE target_copy = item AND xact_start > arrived;
   ELSE
   cumulative_use_current := '0'; 
   END IF;
   SELECT SUBSTRING(value FROM 1 FOR 100) INTO notes FROM asset.copy_note WHERE owning_copy = item AND title ILIKE '%collectionHQ%' ORDER BY id LIMIT 1;
   SELECT l.name INTO collection_code FROM asset.copy c, asset.copy_location l WHERE c.location = l.id AND c.id = item;

   purchase_code := ''; -- FIXME do we want something else here?
   lib_supsel_tag := ''; -- FIXME do we want something else here?
   gen_supsel_tag := ''; -- FIXME do we want something else here?
   collection_code_level_2 := ''; -- FIXME do we want something else here?
   filter_level_2 := ''; -- FIXME do we want something else here?
   filter_level_3 := ''; -- FIXME do we want something else here?
   filter_level_4 := ''; -- FIXME do we want something else here?

   output := '##HOLD##,'
     || lms_bib_id || ','
     || COALESCE(collectionHQ.quote(authority_code), '') || ','
     || COALESCE(collectionHQ.quote(library_code), '') || ','
     || COALESCE(collectionHQ.quote(bar_code), '') || ','
     || COALESCE(collectionHQ.quote(last_use_date), '') || ','
     || COALESCE(cumulative_use_total, '') || ','
     || COALESCE(cumulative_use_current, '') || ','
     || COALESCE(collectionHQ.quote(status), '') || ','
     || COALESCE(collectionHQ.quote(date_added), '') || ','
     || COALESCE(price, '') || ','
     || COALESCE(collectionHQ.quote(purchase_code), '') || ','
     || COALESCE(collectionHQ.quote(rotating_stock), '') || ','
     || COALESCE(collectionHQ.quote(lib_supsel_tag), '') || ','
     || COALESCE(collectionHQ.quote(gen_supsel_tag), '') || ','
     || COALESCE(collectionHQ.quote(notes), '') || ','
     || COALESCE(collectionHQ.quote(extract_date), '') || ','
     || COALESCE(collectionHQ.quote(collection_code), '') || ','
     || COALESCE(collectionHQ.quote(collection_code_level_2), '') || ','
     || COALESCE(collectionHQ.quote(filter_level_1), '') || ','
     || COALESCE(collectionHQ.quote(filter_level_2), '') || ','
     || COALESCE(collectionHQ.quote(filter_level_3), '') || ','
     || COALESCE(collectionHQ.quote(filter_level_4), '') || ','
     || COALESCE(collectionHQ.quote(isbn), '');

    RAISE INFO '%', output;

    num_rows := num_rows + 1;
    IF (num_rows::numeric % 1000.0 = 0.0) THEN RAISE INFO '% rows written', num_rows; END IF;

 END LOOP;

 RAISE INFO '% rows written in total.', num_rows;

 RETURN '';
END;

$_$;


ALTER FUNCTION collectionhq.write_item_rows_to_stdout(text, integer) OWNER TO postgres;

--
-- Name: write_item_rows_to_stdout_new(text, integer); Type: FUNCTION; Schema: collectionhq; Owner: postgres
--

CREATE FUNCTION collectionhq.write_item_rows_to_stdout_new(text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Usage: SELECT collectionHQ.write_item_rows_to_stdout ('LIBRARYCODE',org_unit_id);

  DECLARE
    item BIGINT;
    authority_code ALIAS FOR $1;
    org_unit_id ALIAS for $2;
    lms_bib_id BIGINT;
    library_code TEXT;
    bar_code TEXT;
    last_use_date TEXT;
    cumulative_use_total TEXT;
    cumulative_use_current TEXT;
    status TEXT;
    date_added TEXT;
    price TEXT;
    purchase_code TEXT;
    rotating_stock TEXT;
    lib_supsel_tag TEXT;
    gen_supsel_tag TEXT;
    notes TEXT;
    extract_date TEXT;
    collection_code TEXT;
    collection_code_level_2 TEXT;
    filter_level_1 TEXT;
    filter_level_2 TEXT;
    filter_level_3 TEXT;
    filter_level_4 TEXT;
    isbn TEXT := '';
    output TEXT := '';
    arrived TIMESTAMPTZ;
    num_rows INTEGER := 0;

  BEGIN

    SELECT REPLACE(NOW()::DATE::TEXT, '-', '') INTO extract_date;
    FOR item, arrived, cumulative_use_total IN
      SELECT cp.id, dest_recv_time, COALESCE(sum(c.circ_count), 0::bigint) + COALESCE(count(circ.id), 0::bigint) + COALESCE(count(acirc.id), 0::bigint) AS circ_count
      FROM asset.copy cp
      LEFT JOIN extend_reporter.legacy_circ_count c USING (id)
      LEFT JOIN (SELECT max(dest_recv_time) as dest_recv_time, target_copy, dest from action.transit_copy group by target_copy, dest) atc ON (cp.id = atc.target_copy AND cp.circ_lib = atc.dest)
      LEFT JOIN action.circulation circ ON circ.target_copy = cp.id
      LEFT JOIN action.aged_circulation acirc ON acirc.target_copy = cp.id
      WHERE NOT cp.deleted AND cp.circ_lib IN (SELECT id FROM actor.org_unit_descendants(org_unit_id)) GROUP BY cp.id, dest_recv_time ORDER BY cp.id
    LOOP

      SELECT cn.record, cn.label
      INTO lms_bib_id, filter_level_1
      FROM asset.call_number cn, asset.copy c 
      WHERE c.call_number = cn.id AND c.id =  item;
      SELECT r.isbn[1] INTO isbn
      FROM reporter.materialized_simple_record r
      WHERE id = lms_bib_id;
      SELECT collectionHQ.attempt_price(ac.price::TEXT), barcode, ac.status,
             REPLACE(create_date::DATE::TEXT, '-', ''),
             CASE floating WHEN TRUE THEN 'Y' ELSE NULL END
      INTO price, bar_code, status, date_added, rotating_stock
      FROM asset.copy ac 
      WHERE id = item;
      IF price IS NULL OR price = '' THEN
        SELECT collectionHQ.attempt_price((XPATH('//marc:datafield[@tag="020"][1]/marc:subfield[@code="c"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT)
        INTO price
        FROM biblio.record_entry
        WHERE id = lms_bib_id;
      END IF;
      SELECT ou.shortname INTO library_code FROM actor.org_unit ou, asset.copy c WHERE ou.id = c.circ_lib AND c.id = item;
      SELECT REPLACE(xact_start::DATE::TEXT, '-', '') INTO last_use_date FROM action.circulation WHERE target_copy = item ORDER BY xact_start DESC LIMIT 1;
      
      IF arrived IS NOT NULL THEN
        SELECT COUNT(*) INTO cumulative_use_current FROM action.circulation WHERE target_copy = item AND xact_start > arrived;
      ELSE
      cumulative_use_current := '0'; 
      END IF;
      SELECT SUBSTRING(value FROM 1 FOR 100) INTO notes FROM asset.copy_note WHERE owning_copy = item AND title ILIKE '%collectionHQ%' ORDER BY id LIMIT 1;
      SELECT l.name INTO collection_code FROM asset.copy c, asset.copy_location l WHERE c.location = l.id AND c.id = item;
  
      purchase_code := ''; -- FIXME do we want something else here?
      lib_supsel_tag := ''; -- FIXME do we want something else here?
      gen_supsel_tag := ''; -- FIXME do we want something else here?
      collection_code_level_2 := ''; -- FIXME do we want something else here?
      filter_level_2 := ''; -- FIXME do we want something else here?
      filter_level_3 := ''; -- FIXME do we want something else here?
      filter_level_4 := ''; -- FIXME do we want something else here?
  
      output := '##HOLD##,'
        || lms_bib_id || ','
        || COALESCE(collectionHQ.quote(authority_code), '') || ','
        || COALESCE(collectionHQ.quote(library_code), '') || ','
        || COALESCE(collectionHQ.quote(bar_code), '') || ','
        || COALESCE(collectionHQ.quote(last_use_date), '') || ','
        || COALESCE(cumulative_use_total, '') || ','
        || COALESCE(cumulative_use_current, '') || ','
        || COALESCE(collectionHQ.quote(status), '') || ','
        || COALESCE(collectionHQ.quote(date_added), '') || ','
        || COALESCE(price, '') || ','
        || COALESCE(collectionHQ.quote(purchase_code), '') || ','
        || COALESCE(collectionHQ.quote(rotating_stock), '') || ','
        || COALESCE(collectionHQ.quote(lib_supsel_tag), '') || ','
        || COALESCE(collectionHQ.quote(gen_supsel_tag), '') || ','
        || COALESCE(collectionHQ.quote(notes), '') || ','
        || COALESCE(collectionHQ.quote(extract_date), '') || ','
        || COALESCE(collectionHQ.quote(collection_code), '') || ','
        || COALESCE(collectionHQ.quote(collection_code_level_2), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_1), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_2), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_3), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_4), '') || ','
        || COALESCE(collectionHQ.quote(isbn), '');
  
       RAISE INFO '%', output;

       num_rows := num_rows + 1;
       IF (num_rows::numeric % 1000.0 = 0.0) THEN RAISE INFO '% rows written', num_rows; END IF;

    END LOOP;

    RAISE INFO '% rows written in total.', num_rows;

  END;

$_$;


ALTER FUNCTION collectionhq.write_item_rows_to_stdout_new(text, integer) OWNER TO postgres;

--
-- Name: write_item_rows_to_stdout_old(text, integer); Type: FUNCTION; Schema: collectionhq; Owner: postgres
--

CREATE FUNCTION collectionhq.write_item_rows_to_stdout_old(text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Usage: SELECT collectionHQ.write_item_rows_to_stdout ('LIBRARYCODE',org_unit_id);

  DECLARE
    item BIGINT;
    authority_code ALIAS FOR $1;
    org_unit_id ALIAS for $2;
    lms_bib_id BIGINT;
    library_code TEXT;
    bar_code TEXT;
    last_use_date TEXT;
    cumulative_use_total TEXT;
    cumulative_use_current TEXT;
    status TEXT;
    date_added TEXT;
    price TEXT;
    purchase_code TEXT;
    rotating_stock TEXT;
    lib_supsel_tag TEXT;
    gen_supsel_tag TEXT;
    notes TEXT;
    extract_date TEXT;
    collection_code TEXT;
    collection_code_level_2 TEXT;
    filter_level_1 TEXT;
    filter_level_2 TEXT;
    filter_level_3 TEXT;
    filter_level_4 TEXT;
    isbn TEXT := '';
    output TEXT := '';
    arrived TIMESTAMPTZ;
    num_rows INTEGER := 0;

    start1 timestamp;
    start2 timestamp;
    start3 timestamp;
    start4 timestamp;
    start5 timestamp;
    start6 timestamp;
    start7 timestamp;
    start8 timestamp;
    start9 timestamp;
    start10 timestamp;
    start11 timestamp;

    total1 interval := 0;
    total2 interval := 0;
    total3 interval := 0;
    total4 interval := 0;
    total5 interval := 0;
    total6 interval := 0;
    total7 interval := 0;
    total8 interval := 0;
    total9 interval := 0;
    total10 interval := 0;
    total11 interval := 0;

  BEGIN

    SELECT REPLACE(NOW()::DATE::TEXT, '-', '') INTO extract_date;

    FOR item IN
      SELECT id FROM asset.copy WHERE NOT deleted AND circ_lib IN (SELECT id FROM actor.org_unit_descendants(org_unit_id)) ORDER BY id
    LOOP
      
      start1 = clock_timestamp();

      SELECT cn.record, cn.label
      INTO lms_bib_id, filter_level_1
      FROM asset.call_number cn, asset.copy c 
      WHERE c.call_number = cn.id AND c.id =  item;
      SELECT r.isbn[1] INTO isbn
      FROM reporter.materialized_simple_record r
      WHERE id = lms_bib_id;

      start2 = clock_timestamp();

      SELECT collectionHQ.attempt_price(ac.price::TEXT), barcode, ac.status,
             REPLACE(create_date::DATE::TEXT, '-', ''),
             CASE floating WHEN TRUE THEN 'Y' ELSE NULL END
      INTO price, bar_code, status, date_added, rotating_stock
      FROM asset.copy ac 
      WHERE id = item;

      start3 = clock_timestamp();

      IF price IS NULL OR price = '' THEN
        SELECT collectionHQ.attempt_price((XPATH('//marc:datafield[@tag="020"][1]/marc:subfield[@code="c"]/text()', marc::XML, ARRAY[ARRAY['marc', 'http://www.loc.gov/MARC21/slim']]))[1]::TEXT)
        INTO price
        FROM biblio.record_entry
        WHERE id = lms_bib_id;
      END IF;

      start4 = clock_timestamp();

      SELECT ou.shortname INTO library_code FROM actor.org_unit ou, asset.copy c WHERE ou.id = c.circ_lib AND c.id = item;

      start5 = clock_timestamp();
      
      SELECT REPLACE(xact_start::DATE::TEXT, '-', '') INTO last_use_date FROM action.circulation WHERE target_copy = item ORDER BY xact_start DESC LIMIT 1;

      start6 = clock_timestamp();

      SELECT circ_count INTO cumulative_use_total FROM extend_reporter.full_circ_count WHERE id = item;
      IF cumulative_use_total IS NULL THEN
        cumulative_use_total := '0';
      END IF;


      SELECT MAX(dest_recv_time) INTO arrived
      FROM action.transit_copy atc
      JOIN asset.copy ac ON (ac.id = atc.target_copy AND ac.circ_lib = atc.dest)
      WHERE ac.id = item;

      start7 = clock_timestamp();

      IF arrived IS NOT NULL THEN
        SELECT COUNT(*) INTO cumulative_use_current FROM action.circulation WHERE target_copy = item AND xact_start > arrived;
      ELSE
      cumulative_use_current := '0'; 
      END IF;

      start8 = clock_timestamp();

      SELECT SUBSTRING(value FROM 1 FOR 100) INTO notes FROM asset.copy_note WHERE owning_copy = item AND title ILIKE '%collectionHQ%' ORDER BY id LIMIT 1;

      start9 = clock_timestamp();

      SELECT l.name INTO collection_code FROM asset.copy c, asset.copy_location l WHERE c.location = l.id AND c.id = item;

      start10 = clock_timestamp();
  
      purchase_code := ''; -- FIXME do we want something else here?
      lib_supsel_tag := ''; -- FIXME do we want something else here?
      gen_supsel_tag := ''; -- FIXME do we want something else here?
      collection_code_level_2 := ''; -- FIXME do we want something else here?
      filter_level_2 := ''; -- FIXME do we want something else here?
      filter_level_3 := ''; -- FIXME do we want something else here?
      filter_level_4 := ''; -- FIXME do we want something else here?
  
      output := '##HOLD##,'
        || lms_bib_id || ','
        || COALESCE(collectionHQ.quote(authority_code), '') || ','
        || COALESCE(collectionHQ.quote(library_code), '') || ','
        || COALESCE(collectionHQ.quote(bar_code), '') || ','
        || COALESCE(collectionHQ.quote(last_use_date), '') || ','
        || COALESCE(cumulative_use_total, '') || ','
        || COALESCE(cumulative_use_current, '') || ','
        || COALESCE(collectionHQ.quote(status), '') || ','
        || COALESCE(collectionHQ.quote(date_added), '') || ','
        || COALESCE(price, '') || ','
        || COALESCE(collectionHQ.quote(purchase_code), '') || ','
        || COALESCE(collectionHQ.quote(rotating_stock), '') || ','
        || COALESCE(collectionHQ.quote(lib_supsel_tag), '') || ','
        || COALESCE(collectionHQ.quote(gen_supsel_tag), '') || ','
        || COALESCE(collectionHQ.quote(notes), '') || ','
        || COALESCE(collectionHQ.quote(extract_date), '') || ','
        || COALESCE(collectionHQ.quote(collection_code), '') || ','
        || COALESCE(collectionHQ.quote(collection_code_level_2), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_1), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_2), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_3), '') || ','
        || COALESCE(collectionHQ.quote(filter_level_4), '') || ','
        || COALESCE(collectionHQ.quote(isbn), '');

        start11 = clock_timestamp();
  
       RAISE INFO '%', output;

       total1 = total1 + start2 - start1;
       total2 = total2 + start3 - start2;
       total3 = total3 + start4 - start3;
       total4 = total4 + start5 - start4;
       total5 = total5 + start6 - start5;
       total6 = total6 + start7 - start6;
       total7 = total7 + start8 - start7;
       total8 = total8 + start9 - start8;
       total9 = total9 + start10 - start9;
       total10 = total10 + start11 - start10;
       total11 = total11 + start11 - start1;

       num_rows := num_rows + 1;
       IF (num_rows::numeric % 1000.0 = 0.0) THEN 
          RAISE INFO '% rows written', num_rows;
          RAISE INFO 'total time % num rows %', total11, num_rows;
       END IF;
       EXIT WHEN (num_rows = 300000);

    END LOOP;

    RAISE INFO '% rows written in total.', num_rows;

    RAISE INFO 'time: 1: % 2: % 3: % 4: % 5: % 6: % 7: % 8: % 9: % 10: %', total1, total2, total3, total4, total5, total6, total7, total8, total9, total10;
    RAISE INFO 'total time % num rows %', total11, num_rows;
    RETURN 'x';

  END;

$_$;


ALTER FUNCTION collectionhq.write_item_rows_to_stdout_old(text, integer) OWNER TO postgres;

--
-- Name: create_or_update_code_unknown(); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION config.create_or_update_code_unknown() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
UPDATE config.coded_value_map
SET code = 'x' WHERE code = ' ' AND ctype = 'audience';
RETURN NULL;
END;
$$;


ALTER FUNCTION config.create_or_update_code_unknown() OWNER TO evergreen;

--
-- Name: interval_to_seconds(interval); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION config.interval_to_seconds(interval_val interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN EXTRACT( EPOCH FROM interval_val );
END;
$$;


ALTER FUNCTION config.interval_to_seconds(interval_val interval) OWNER TO evergreen;

--
-- Name: interval_to_seconds(text); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION config.interval_to_seconds(interval_string text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN config.interval_to_seconds( interval_string::INTERVAL );
END;
$$;


ALTER FUNCTION config.interval_to_seconds(interval_string text) OWNER TO evergreen;

--
-- Name: marc_field; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.marc_field (
    id integer NOT NULL,
    marc_format integer NOT NULL,
    marc_record_type config.marc_record_type NOT NULL,
    tag character(3) NOT NULL,
    name text,
    description text,
    fixed_field boolean,
    repeatable boolean,
    mandatory boolean,
    hidden boolean,
    owner integer,
    CONSTRAINT config_standard_marc_tags_are_fully_specified CHECK (((owner IS NOT NULL) OR ((owner IS NULL) AND (repeatable IS NOT NULL) AND (mandatory IS NOT NULL) AND (hidden IS NOT NULL))))
);


ALTER TABLE config.marc_field OWNER TO evergreen;

--
-- Name: TABLE marc_field; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.marc_field IS '
This table stores a list of MARC fields recognized by the Evergreen
instance.  Note that we''re not aiming for completely generic ISO2709
support: we''re assuming things like three characters for a tag,
one-character subfield labels, two indicators per variable data field,
and the like, all of which are technically specializations of ISO2709.

Of particular significance is the owner column; if it''s set to a null
value, the field definition is assumed to come from a national
standards body; if it''s set to a non-null value, the field definition
is an OU-level addition to or override of the standard.
';


--
-- Name: ou_marc_fields(integer, config.marc_record_type, integer); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION config.ou_marc_fields(marc_format integer, marc_record_type config.marc_record_type, ou integer) RETURNS SETOF config.marc_field
    LANGUAGE sql
    AS $_$
    SELECT id, marc_format, marc_record_type, tag, name, description, fixed_field, repeatable, mandatory, hidden, owner
    FROM (
        SELECT id, marc_format, marc_record_type, tag, name, description,
              fixed_field, repeatable, mandatory, hidden, owner, depth,
              MAX(depth) OVER (PARTITION BY marc_format, marc_record_type, tag) AS winner
        FROM config.marc_field_for_ou
        WHERE (owner IS NULL
               OR owner IN (SELECT id FROM actor.org_unit_ancestors($3)))
        AND   marc_format = $1
        AND   marc_record_type = $2
    ) AS s
    WHERE depth = winner
    AND not hidden;
$_$;


ALTER FUNCTION config.ou_marc_fields(marc_format integer, marc_record_type config.marc_record_type, ou integer) OWNER TO evergreen;

--
-- Name: marc_subfield; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.marc_subfield (
    id integer NOT NULL,
    marc_format integer NOT NULL,
    marc_record_type config.marc_record_type NOT NULL,
    tag character(3) NOT NULL,
    code character(1) NOT NULL,
    description text,
    repeatable boolean,
    mandatory boolean,
    hidden boolean,
    value_ctype text,
    owner integer,
    CONSTRAINT config_standard_marc_subfields_are_fully_specified CHECK (((owner IS NOT NULL) OR ((owner IS NULL) AND (repeatable IS NOT NULL) AND (mandatory IS NOT NULL) AND (hidden IS NOT NULL))))
);


ALTER TABLE config.marc_subfield OWNER TO evergreen;

--
-- Name: TABLE marc_subfield; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.marc_subfield IS '
This table stores the list of subfields recognized by this Evergreen
instance.  As with config.marc_field, of particular significance is the
owner column; if it''s set to a null value, the subfield definition is
assumed to come from a national standards body; if it''s set to a non-null
value, the subfield definition is an OU-level addition to or override
of the standard.
';


--
-- Name: ou_marc_subfields(integer, config.marc_record_type, integer); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION config.ou_marc_subfields(marc_format integer, marc_record_type config.marc_record_type, ou integer) RETURNS SETOF config.marc_subfield
    LANGUAGE sql
    AS $_$
    SELECT id, marc_format, marc_record_type, tag, code, description, repeatable, mandatory,
           hidden, value_ctype, owner
    FROM (
        SELECT id, marc_format, marc_record_type, tag, code, description,
              repeatable, mandatory, hidden, value_ctype, owner, depth,
              MAX(depth) OVER (PARTITION BY marc_format, marc_record_type, tag, code) AS winner
        FROM config.marc_subfield_for_ou
        WHERE (owner IS NULL
               OR owner IN (SELECT id FROM actor.org_unit_ancestors($3)))
        AND   marc_format = $1
        AND   marc_record_type = $2
    ) AS s
    WHERE depth = winner
    AND not hidden;
$_$;


ALTER FUNCTION config.ou_marc_subfields(marc_format integer, marc_record_type config.marc_record_type, ou integer) OWNER TO evergreen;

--
-- Name: setting_is_user_or_ws(); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION config.setting_is_user_or_ws() RETURNS trigger
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN

    IF TG_TABLE_NAME = 'usr_setting_type' THEN
        PERFORM TRUE FROM config.workstation_setting_type cwst
            WHERE cwst.name = NEW.name;
        IF NOT FOUND THEN
            RETURN NULL;
        END IF;
    END IF;

    IF TG_TABLE_NAME = 'workstation_setting_type' THEN
        PERFORM TRUE FROM config.usr_setting_type cust
            WHERE cust.name = NEW.name;
        IF NOT FOUND THEN
            RETURN NULL;
        END IF;
    END IF;

    RAISE EXCEPTION 
        '% Cannot be used as both a user setting and a workstation setting.', 
        NEW.name;
END;
$$;


ALTER FUNCTION config.setting_is_user_or_ws() OWNER TO evergreen;

--
-- Name: update_coded_value_map(text, text, text, text, boolean, text, boolean, boolean); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION config.update_coded_value_map(in_ctype text, in_code text, in_value text, in_description text DEFAULT NULL::text, in_opac_visible boolean DEFAULT NULL::boolean, in_search_label text DEFAULT NULL::text, in_is_simple boolean DEFAULT NULL::boolean, add_only boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    current_row config.coded_value_map%ROWTYPE;
BEGIN
    -- Look for a current value
    SELECT INTO current_row * FROM config.coded_value_map WHERE ctype = in_ctype AND code = in_code;
    -- If we have one..
    IF FOUND AND NOT add_only THEN
        -- Update anything we were handed
        current_row.value := COALESCE(current_row.value, in_value);
        current_row.description := COALESCE(current_row.description, in_description);
        current_row.opac_visible := COALESCE(current_row.opac_visible, in_opac_visible);
        current_row.search_label := COALESCE(current_row.search_label, in_search_label);
        current_row.is_simple := COALESCE(current_row.is_simple, in_is_simple);
        UPDATE config.coded_value_map
            SET
                value = current_row.value,
                description = current_row.description,
                opac_visible = current_row.opac_visible,
                search_label = current_row.search_label,
                is_simple = current_row.is_simple
            WHERE id = current_row.id;
    ELSE
        INSERT INTO config.coded_value_map(ctype, code, value, description, opac_visible, search_label, is_simple) VALUES
            (in_ctype, in_code, in_value, in_description, COALESCE(in_opac_visible, TRUE), in_search_label, COALESCE(in_is_simple, FALSE));
    END IF;
END;
$$;


ALTER FUNCTION config.update_coded_value_map(in_ctype text, in_code text, in_value text, in_description text, in_opac_visible boolean, in_search_label text, in_is_simple boolean, add_only boolean) OWNER TO evergreen;

--
-- Name: update_hard_due_dates(); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION config.update_hard_due_dates() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    temp_value  config.hard_due_date_values%ROWTYPE;
    updated     INT := 0;
BEGIN
    FOR temp_value IN
      SELECT  DISTINCT ON (hard_due_date) *
        FROM  config.hard_due_date_values
        WHERE active_date <= NOW() -- We've passed (or are at) the rollover time
        ORDER BY hard_due_date, active_date DESC -- Latest (nearest to us) active time
   LOOP
        UPDATE  config.hard_due_date
          SET   ceiling_date = temp_value.ceiling_date
          WHERE id = temp_value.hard_due_date
                AND ceiling_date <> temp_value.ceiling_date -- Time is equal if we've already updated the chdd
                AND temp_value.ceiling_date >= NOW(); -- Don't update ceiling dates to the past

        IF FOUND THEN
            updated := updated + 1;
        END IF;
    END LOOP;

    RETURN updated;
END;
$$;


ALTER FUNCTION config.update_hard_due_dates() OWNER TO evergreen;

--
-- Name: z3950_source_credentials_apply(text, integer, text, text); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION config.z3950_source_credentials_apply(src text, org integer, uname text, passwd text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM 1 FROM config.z3950_source_credentials
        WHERE owner = org AND source = src;

    IF FOUND THEN
        IF COALESCE(uname, '') = '' AND COALESCE(passwd, '') = '' THEN
            DELETE FROM config.z3950_source_credentials 
                WHERE owner = org AND source = src;
        ELSE 
            UPDATE config.z3950_source_credentials 
                SET username = uname, password = passwd
                WHERE owner = org AND source = src;
        END IF;
    ELSE
        IF COALESCE(uname, '') <> '' OR COALESCE(passwd, '') <> '' THEN
            INSERT INTO config.z3950_source_credentials
                (source, owner, username, password) 
                VALUES (src, org, uname, passwd);
        END IF;
    END IF;
END;
$$;


ALTER FUNCTION config.z3950_source_credentials_apply(src text, org integer, uname text, passwd text) OWNER TO evergreen;

--
-- Name: z3950_source_credentials; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.z3950_source_credentials (
    id integer NOT NULL,
    owner integer NOT NULL,
    source text NOT NULL,
    username text,
    password text
);


ALTER TABLE config.z3950_source_credentials OWNER TO evergreen;

--
-- Name: z3950_source_credentials_lookup(text, integer); Type: FUNCTION; Schema: config; Owner: evergreen
--

CREATE FUNCTION config.z3950_source_credentials_lookup(source text, owner integer) RETURNS config.z3950_source_credentials
    LANGUAGE sql STABLE
    AS $_$

    SELECT creds.* 
    FROM config.z3950_source_credentials creds
        JOIN actor.org_unit aou ON (aou.id = creds.owner)
        JOIN actor.org_unit_type aout ON (aout.id = aou.ou_type)
    WHERE creds.source = $1 AND creds.owner IN ( 
        SELECT id FROM actor.org_unit_ancestors($2) 
    )
    ORDER BY aout.depth DESC LIMIT 1;

$_$;


ALTER FUNCTION config.z3950_source_credentials_lookup(source text, owner integer) OWNER TO evergreen;

--
-- Name: clear_all_expired_circ_history_items(); Type: FUNCTION; Schema: container; Owner: evergreen
--

CREATE FUNCTION container.clear_all_expired_circ_history_items() RETURNS void
    LANGUAGE plpgsql
    AS $$
--
-- Delete expired circulation bucket items for all users that have
-- a setting for patron.max_reading_list_interval.
--
DECLARE
    today        TIMESTAMP WITH TIME ZONE;
    threshold    TIMESTAMP WITH TIME ZONE;
	usr_setting  RECORD;
BEGIN
	SELECT date_trunc( 'day', now() ) INTO today;
	--
	FOR usr_setting in
		SELECT
			usr,
			value
		FROM
			actor.usr_setting
		WHERE
			name = 'patron.max_reading_list_interval'
	LOOP
		--
		-- Make sure the setting is a valid interval
		--
		BEGIN
			threshold := today - CAST( translate( usr_setting.value, '"', '' ) AS INTERVAL );
		EXCEPTION
			WHEN OTHERS THEN
				RAISE NOTICE 'Invalid setting patron.max_reading_list_interval for user %: ''%''',
					usr_setting.usr, usr_setting.value;
				CONTINUE;
		END;
		--
		--RAISE NOTICE 'User % threshold %', usr_setting.usr, threshold;
		--
    	DELETE FROM container.copy_bucket_item
    	WHERE
        	bucket IN
        	(
        	    SELECT
        	        id
        	    FROM
        	        container.copy_bucket
        	    WHERE
        	        owner = usr_setting.usr
        	        AND btype = 'circ_history'
        	)
        	AND create_time < threshold;
	END LOOP;
	--
END;
$$;


ALTER FUNCTION container.clear_all_expired_circ_history_items() OWNER TO evergreen;

--
-- Name: FUNCTION clear_all_expired_circ_history_items(); Type: COMMENT; Schema: container; Owner: evergreen
--

COMMENT ON FUNCTION container.clear_all_expired_circ_history_items() IS '
/*
 * Delete expired circulation bucket items for all users that have
 * a setting for patron.max_reading_list_interval.
*/
';


--
-- Name: clear_expired_circ_history_items(integer); Type: FUNCTION; Schema: container; Owner: evergreen
--

CREATE FUNCTION container.clear_expired_circ_history_items(ac_usr integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
--
-- Delete old circulation bucket items for a specified user.
-- "Old" means older than the interval specified by a
-- user-level setting, if it is so specified.
--
DECLARE
    threshold TIMESTAMP WITH TIME ZONE;
BEGIN
	-- Sanity check
	IF ac_usr IS NULL THEN
		RETURN;
	END IF;
	-- Determine the threshold date that defines "old".  Subtract the
	-- interval from the system date, then truncate to midnight.
	SELECT
		date_trunc( 
			'day',
			now() - CAST( translate( value, '"', '' ) AS INTERVAL )
		)
	INTO
		threshold
	FROM
		actor.usr_setting
	WHERE
		usr = ac_usr
		AND name = 'patron.max_reading_list_interval';
	--
	IF threshold is null THEN
		-- No interval defined; don't delete anything
		-- RAISE NOTICE 'No interval defined for user %', ac_usr;
		return;
	END IF;
	--
	-- RAISE NOTICE 'Date threshold: %', threshold;
	--
	-- Threshold found; do the delete
	delete from container.copy_bucket_item
	where
		bucket in
		(
			select
				id
			from
				container.copy_bucket
			where
				owner = ac_usr
				and btype = 'circ_history'
		)
		and create_time < threshold;
	--
	RETURN;
END;
$$;


ALTER FUNCTION container.clear_expired_circ_history_items(ac_usr integer) OWNER TO evergreen;

--
-- Name: FUNCTION clear_expired_circ_history_items(ac_usr integer); Type: COMMENT; Schema: container; Owner: evergreen
--

COMMENT ON FUNCTION container.clear_expired_circ_history_items(ac_usr integer) IS '
/*
 * Delete old circulation bucket items for a specified user.
 * "Old" means older than the interval specified by a
 * user-level setting, if it is so specified.
*/
';


--
-- Name: bib_mod_since(timestamp with time zone); Type: FUNCTION; Schema: elastic; Owner: evergreen
--

CREATE FUNCTION elastic.bib_mod_since(since timestamp with time zone) RETURNS TABLE(id bigint)
    LANGUAGE sql STABLE
    AS $$
    /**
     * Last update date for each bib, which is taken from most recent
     * edit for either the bib, a linked call number, or a linked copy.
     * If no call numbers are linked, uses the bib edit date only.
     * Includes deleted data since it can impact indexing.
     */

    SELECT bre.id FROM biblio.record_entry bre 
        WHERE bre.edit_date > since OR bre.merge_date > since

    UNION

    SELECT bre.id
        FROM biblio.record_entry bre 
        JOIN asset.call_number acn ON acn.record = bre.id
        WHERE acn.edit_date > since

    UNION

    SELECT bre.id
        FROM biblio.record_entry bre 
        JOIN asset.call_number acn ON acn.record = bre.id
        JOIN asset.copy acp ON acp.call_number = acn.id
        WHERE acp.edit_date > since

$$;


ALTER FUNCTION elastic.bib_mod_since(since timestamp with time zone) OWNER TO evergreen;

--
-- Name: show_encode_version(); Type: FUNCTION; Schema: esi; Owner: evergreen
--

CREATE FUNCTION esi.show_encode_version() RETURNS text
    LANGUAGE plperlu
    AS $_$
  use Encode;
  return $Encode::VERSION;
$_$;


ALTER FUNCTION esi.show_encode_version() OWNER TO evergreen;

--
-- Name: throttle_hold_queue_position_queries(integer, interval); Type: FUNCTION; Schema: esi; Owner: evergreen
--

CREATE FUNCTION esi.throttle_hold_queue_position_queries(max_queries integer DEFAULT 20, max_duration interval DEFAULT '00:00:02'::interval) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    num_running INTEGER;
BEGIN
    -- terminate any that are running longer than the allowed
    -- duration
    PERFORM pg_cancel_backend(pid)
    FROM pg_stat_activity
    WHERE query ~* $$^SELECT  count\("ahr".id \) AS "count" FROM action.hold_request AS "ahr"  WHERE \( \( \( \( "ahr".target IN \(SELECT  "acp".id AS "id" FROM asset.copy AS "acp"  INNER JOIN asset.call_number AS "acn" ON \( "acn".id = "acp".call_number \)   INNER JOIN biblio.record_entry AS "bre" ON \( "bre".id = "acn".record AND  "bre".id =$$
    AND state <> 'idle'
    AND NOW() - query_start > max_duration;

    -- and terminate them all if there are too many
    SELECT COUNT(*)
    INTO num_running
    FROM pg_stat_activity
    WHERE query ~* $$^SELECT  count\("ahr".id \) AS "count" FROM action.hold_request AS "ahr"  WHERE \( \( \( \( "ahr".target IN \(SELECT  "acp".id AS "id" FROM asset.copy AS "acp"  INNER JOIN asset.call_number AS "acn" ON \( "acn".id = "acp".call_number \)   INNER JOIN biblio.record_entry AS "bre" ON \( "bre".id = "acn".record AND  "bre".id =$$;
    IF num_running > max_queries THEN
        RAISE WARNING 'Terminating hold queue position calculations: % were running',  num_running;
        PERFORM pg_cancel_backend(pid)
        FROM pg_stat_activity
        WHERE query ~* $$^SELECT  count\("ahr".id \) AS "count" FROM action.hold_request AS "ahr"  WHERE \( \( \( \( "ahr".target IN \(SELECT  "acp".id AS "id" FROM asset.copy AS "acp"  INNER JOIN asset.call_number AS "acn" ON \( "acn".id = "acp".call_number \)   INNER JOIN biblio.record_entry AS "bre" ON \( "bre".id = "acn".record AND  "bre".id =$$
    	AND state <> 'idle';
    END IF;   
END;
$_$;


ALTER FUNCTION esi.throttle_hold_queue_position_queries(max_queries integer, max_duration interval) OWNER TO evergreen;

--
-- Name: array_overlap_check(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.array_overlap_check() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    fld     TEXT;
    cnt     INT;
BEGIN
    fld := TG_ARGV[0];
    EXECUTE 'SELECT COUNT(*) FROM '|| TG_TABLE_SCHEMA ||'.'|| TG_TABLE_NAME ||' WHERE '|| fld ||' && ($1).'|| fld INTO cnt USING NEW;
    IF cnt > 0 THEN
        RAISE EXCEPTION 'Cannot insert duplicate array into field % of table %', fld, TG_TABLE_SCHEMA ||'.'|| TG_TABLE_NAME;
    END IF;
    RETURN NEW;
END;
$_$;


ALTER FUNCTION evergreen.array_overlap_check() OWNER TO evergreen;

--
-- Name: asset_copy_alert_copy_inh_fkey(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.asset_copy_alert_copy_inh_fkey() RETURNS trigger
    LANGUAGE plpgsql COST 50
    AS $_$
BEGIN
        PERFORM 1 FROM asset.copy WHERE id = NEW.copy;
        IF NOT FOUND THEN
                RAISE foreign_key_violation USING MESSAGE = FORMAT(
                        $$Referenced asset.copy id not found, copy:%s$$, NEW.copy
                );
        END IF;
        RETURN NEW;
END;
$_$;


ALTER FUNCTION evergreen.asset_copy_alert_copy_inh_fkey() OWNER TO evergreen;

--
-- Name: asset_copy_inventory_copy_inh_fkey(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.asset_copy_inventory_copy_inh_fkey() RETURNS trigger
    LANGUAGE plpgsql COST 50
    AS $_$
BEGIN
        PERFORM 1 FROM asset.copy WHERE id = NEW.copy;
        IF NOT FOUND THEN
                RAISE foreign_key_violation USING MESSAGE = FORMAT(
                        $$Referenced asset.copy id not found, copy:%s$$, NEW.copy
                );
        END IF;
        RETURN NEW;
END;
$_$;


ALTER FUNCTION evergreen.asset_copy_inventory_copy_inh_fkey() OWNER TO evergreen;

--
-- Name: asset_copy_note_owning_copy_inh_fkey(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.asset_copy_note_owning_copy_inh_fkey() RETURNS trigger
    LANGUAGE plpgsql COST 50
    AS $_$
			BEGIN
				PERFORM 1 FROM asset.copy WHERE id = NEW.owning_copy;
				IF NOT FOUND THEN
					RAISE foreign_key_violation USING MESSAGE = FORMAT(
						$$Referenced asset.copy id not found, owning_copy:%s$$, NEW.owning_copy
					);
				END IF;
				RETURN NEW;
			END;
			$_$;


ALTER FUNCTION evergreen.asset_copy_note_owning_copy_inh_fkey() OWNER TO evergreen;

--
-- Name: asset_copy_tag_copy_map_copy_inh_fkey(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.asset_copy_tag_copy_map_copy_inh_fkey() RETURNS trigger
    LANGUAGE plpgsql COST 50
    AS $_$
			BEGIN
				PERFORM 1 FROM asset.copy WHERE id = NEW.copy;
				IF NOT FOUND THEN
					RAISE foreign_key_violation USING MESSAGE = FORMAT(
						$$Referenced asset.copy id not found, copy:%s$$, NEW.copy
					);
				END IF;
				RETURN NEW;
			END;
			$_$;


ALTER FUNCTION evergreen.asset_copy_tag_copy_map_copy_inh_fkey() OWNER TO evergreen;

--
-- Name: can_float(integer, integer, integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.can_float(copy_floating_group integer, from_ou integer, to_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    float_member config.floating_group_member%ROWTYPE;
    shared_ou_depth INT;
    to_ou_depth INT;
BEGIN
    -- Grab the shared OU depth. If this is less than the stop depth later we ignore the entry.
    SELECT INTO shared_ou_depth max(depth) FROM actor.org_unit_common_ancestors( from_ou, to_ou ) aou JOIN actor.org_unit_type aout ON aou.ou_type = aout.id;
    -- Grab the to ou depth. If this is greater than max depth we ignore the entry.
    SELECT INTO to_ou_depth depth FROM actor.org_unit aou JOIN actor.org_unit_type aout ON aou.ou_type = aout.id WHERE aou.id = to_ou;
    -- Grab float members that apply. We don't care what we get beyond wanting excluded ones first.
    SELECT INTO float_member *
        FROM
            config.floating_group_member cfgm
            JOIN actor.org_unit aou ON cfgm.org_unit = aou.id
            JOIN actor.org_unit_type aout ON aou.ou_type = aout.id
        WHERE
            cfgm.floating_group = copy_floating_group
            AND to_ou IN (SELECT id FROM actor.org_unit_descendants(aou.id))
            AND cfgm.stop_depth <= shared_ou_depth
            AND (cfgm.max_depth IS NULL OR to_ou_depth <= max_depth)
        ORDER BY
            exclude DESC;
    -- If we found something then we want to return the opposite of the exclude flag
    IF FOUND THEN
        RETURN NOT float_member.exclude;
    END IF;
    -- Otherwise no floating.
    RETURN false;
END;
$$;


ALTER FUNCTION evergreen.can_float(copy_floating_group integer, from_ou integer, to_ou integer) OWNER TO evergreen;

--
-- Name: change_db_setting(text, text[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.change_db_setting(setting_name text, settings text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
EXECUTE 'ALTER DATABASE ' || quote_ident(current_database()) || ' SET ' || quote_ident(setting_name) || ' = ' || array_to_string(settings, ',');
END;

$$;


ALTER FUNCTION evergreen.change_db_setting(setting_name text, settings text[]) OWNER TO evergreen;

--
-- Name: change_password(integer, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.change_password(user_id integer, new_pw text, pw_type text DEFAULT 'main'::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_salt TEXT;
BEGIN
    SELECT actor.create_salt(pw_type) INTO new_salt;

    IF pw_type = 'main' THEN
        -- Only 'main' passwords are required to have
        -- the extra layer of MD5 hashing.
        PERFORM actor.set_passwd(
            user_id, pw_type, md5(new_salt || md5(new_pw)), new_salt
        );

    ELSE
        PERFORM actor.set_passwd(user_id, pw_type, new_pw, new_salt);
    END IF;
END;
$$;


ALTER FUNCTION evergreen.change_password(user_id integer, new_pw text, pw_type text) OWNER TO evergreen;

--
-- Name: cmd_ahr_query(integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.cmd_ahr_query(integer) RETURNS TABLE(id integer, cut_in_line boolean, request_time timestamp with time zone)
    LANGUAGE sql
    AS $_$
WITH holds(holdid) AS 
( SELECT acm.hold FROM action.hold_copy_map acm 
  JOIN action.hold_copy_map acm2 USING(target_copy) 
  WHERE acm2.hold=$1) 
  SELECT id, cut_in_line, request_time FROM action.hold_request WHERE id IN (SELECT holdid FROM holds) ORDER BY coalesce(cut_in_line, false ) DESC, request_time; 
$_$;


ALTER FUNCTION evergreen.cmd_ahr_query(integer) OWNER TO evergreen;

--
-- Name: coded_value_map_normalizer(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.coded_value_map_normalizer(input text, ctype text) RETURNS text
    LANGUAGE sql
    AS $_$
        SELECT COALESCE(value,$1) 
            FROM config.coded_value_map 
            WHERE ctype = $2 AND code = $1;
$_$;


ALTER FUNCTION evergreen.coded_value_map_normalizer(input text, ctype text) OWNER TO evergreen;

--
-- Name: container_copy_bucket_item_target_copy_inh_fkey(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.container_copy_bucket_item_target_copy_inh_fkey() RETURNS trigger
    LANGUAGE plpgsql COST 50
    AS $_$
			BEGIN
				PERFORM 1 FROM asset.copy WHERE id = NEW.target_copy;
				IF NOT FOUND THEN
					RAISE foreign_key_violation USING MESSAGE = FORMAT(
						$$Referenced asset.copy id not found, target_copy:%s$$, NEW.target_copy
					);
				END IF;
				RETURN NEW;
			END;
			$_$;


ALTER FUNCTION evergreen.container_copy_bucket_item_target_copy_inh_fkey() OWNER TO evergreen;

--
-- Name: could_be_serial_holding_code(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.could_be_serial_holding_code(text) RETURNS boolean
    LANGUAGE plperlu
    AS $_$
    use JSON::XS;
    use MARC::Field;

    eval {
        my $holding_code = (new JSON::XS)->decode(shift);
        new MARC::Field('999', @$holding_code);
    };  
    return $@ ? 0 : 1;
$_$;


ALTER FUNCTION evergreen.could_be_serial_holding_code(text) OWNER TO evergreen;

--
-- Name: display_field_force_nfc(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.display_field_force_nfc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.value := force_unicode_normal_form(NEW.value,'NFC');
    RETURN NEW;
END;
$$;


ALTER FUNCTION evergreen.display_field_force_nfc() OWNER TO evergreen;

--
-- Name: escape_for_html(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.escape_for_html(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT LEAKPROOF COST 10
    AS $_$
    SELECT  regexp_replace(
                regexp_replace(
                    regexp_replace(
                        $1,
                        '&',
                        '&amp;',
                        'g'
                    ),
                    '<',
                    '&lt;',
                    'g'
                ),
                '>',
                '&gt;',
                'g'
            );
$_$;


ALTER FUNCTION evergreen.escape_for_html(text) OWNER TO evergreen;

--
-- Name: extract_marc_field(text, bigint, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.extract_marc_field(text, bigint, text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT extract_marc_field($1,$2,$3,'');
$_$;


ALTER FUNCTION evergreen.extract_marc_field(text, bigint, text) OWNER TO evergreen;

--
-- Name: extract_marc_field(text, bigint, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.extract_marc_field(text, bigint, text, text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    query TEXT;
    output TEXT;
BEGIN
    query := $q$
        SELECT  regexp_replace(
                    oils_xpath_string(
                        $q$ || quote_literal($3) || $q$,
                        marc,
                        ' '
                    ),
                    $q$ || quote_literal($4) || $q$,
                    '',
                    'g')
          FROM  $q$ || $1 || $q$
          WHERE id = $q$ || $2;

    EXECUTE query INTO output;

    -- RAISE NOTICE 'query: %, output; %', query, output;

    RETURN output;
END;
$_$;


ALTER FUNCTION evergreen.extract_marc_field(text, bigint, text, text) OWNER TO evergreen;

--
-- Name: extract_marc_field_set(text, bigint, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.extract_marc_field_set(text, bigint, text, text) RETURNS SETOF text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    query TEXT;
    output TEXT;
BEGIN
    FOR output IN
        SELECT x.t FROM (
            SELECT id,t
                FROM  oils_xpath_table(
                    'id', 'marc', $1, $3, 'id = ' || $2)
                AS t(id int, t text))x
        LOOP
        IF $4 IS NOT NULL THEN
            SELECT INTO output (SELECT regexp_replace(output, $4, '', 'g'));
        END IF;
        RETURN NEXT output;
    END LOOP;
    RETURN;
END;
$_$;


ALTER FUNCTION evergreen.extract_marc_field_set(text, bigint, text, text) OWNER TO evergreen;

--
-- Name: facet_force_nfc(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.facet_force_nfc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.value := evergreen.force_unicode_normal_form(NEW.value,'NFC');
    RETURN NEW;
END;
$$;


ALTER FUNCTION evergreen.facet_force_nfc() OWNER TO evergreen;

--
-- Name: fake_fkey_tgr(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.fake_fkey_tgr() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    copy_id BIGINT;
BEGIN
    EXECUTE 'SELECT ($1).' || quote_ident(TG_ARGV[0]) INTO copy_id USING NEW;
    IF copy_id IS NOT NULL THEN
        PERFORM * FROM asset.copy WHERE id = copy_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Key (%.%=%) does not exist in asset.copy', TG_TABLE_SCHEMA, TG_TABLE_NAME, copy_id;
        END IF;
    END IF;
    RETURN NULL;
END;
$_$;


ALTER FUNCTION evergreen.fake_fkey_tgr() OWNER TO evergreen;

--
-- Name: find_next_open_time(integer, timestamp with time zone, boolean, time without time zone, integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.find_next_open_time(circ_lib integer, initial timestamp with time zone, hourly boolean DEFAULT false, initial_time time without time zone DEFAULT NULL::time without time zone, dow_count integer DEFAULT 0) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
DECLARE
    day_number      INT;
    plus_days       INT;
    final_time      TEXT;
    time_adjusted   BOOL;
    hoo_open        TIME WITHOUT TIME ZONE;
    hoo_close       TIME WITHOUT TIME ZONE;
    adjacent        actor.org_unit_closed%ROWTYPE;
    breakout        INT := 0;
BEGIN

    IF dow_count > 6 THEN
        RETURN initial;
    END IF;

    IF initial_time IS NULL THEN
        initial_time := initial::TIME;
    END IF;

    final_time := (initial + '1 second'::INTERVAL)::TEXT;
    LOOP
        breakout := breakout + 1;

        time_adjusted := FALSE;

        IF dow_count > 0 THEN -- we're recursing, so check for HOO closing
            day_number := EXTRACT(ISODOW FROM final_time::TIMESTAMPTZ) - 1;
            plus_days := 0;
            FOR i IN 1..7 LOOP
                EXECUTE 'SELECT dow_' || day_number || '_open, dow_' || day_number || '_close FROM actor.hours_of_operation WHERE id = $1'
                    INTO hoo_open, hoo_close
                    USING circ_lib;

                -- RAISE NOTICE 'initial time: %; dow: %; close: %',initial_time,day_number,hoo_close;

                IF hoo_close = '00:00:00' THEN -- bah ... I guess we'll check the next day
                    day_number := (day_number + 1) % 7;
                    plus_days := plus_days + 1;
                    time_adjusted := TRUE;
                    CONTINUE;
                END IF;

                IF hoo_close IS NULL THEN -- no hours of operation ... assume no closing?
                    hoo_close := '23:59:59';
                END IF;

                EXIT;
            END LOOP;

            final_time := DATE(final_time::TIMESTAMPTZ + (plus_days || ' days')::INTERVAL)::TEXT;
            IF hoo_close <> '00:00:00' AND hourly THEN -- Not a day-granular circ
                final_time := final_time||' '|| hoo_close;
            ELSE
                final_time := final_time||' 23:59:59';
            END IF;
        END IF;

        -- Loop through other closings
        LOOP 
            SELECT * INTO adjacent FROM actor.org_unit_closed WHERE org_unit = circ_lib AND final_time::TIMESTAMPTZ between close_start AND close_end;
            EXIT WHEN adjacent.id IS NULL;
            time_adjusted := TRUE;
            -- RAISE NOTICE 'recursing for closings with final_time: %',final_time;
            final_time := evergreen.find_next_open_time(circ_lib, adjacent.close_end::TIMESTAMPTZ, hourly, initial_time, dow_count + 1)::TEXT;
        END LOOP;

        EXIT WHEN breakout > 100;
        EXIT WHEN NOT time_adjusted;

    END LOOP;

    RETURN final_time;
END;
$_$;


ALTER FUNCTION evergreen.find_next_open_time(circ_lib integer, initial timestamp with time zone, hourly boolean, initial_time time without time zone, dow_count integer) OWNER TO evergreen;

--
-- Name: force_unicode_normal_form(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.force_unicode_normal_form(string text, form text) RETURNS text
    LANGUAGE plperlu
    AS $_X$
use Unicode::Normalize 'normalize';
return normalize($_[1],$_[0]); # reverse the params
$_X$;


ALTER FUNCTION evergreen.force_unicode_normal_form(string text, form text) OWNER TO evergreen;

--
-- Name: gen_refundable_payment_number(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.gen_refundable_payment_number() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM TRUE FROM money.credit_card_payment WHERE id = NEW.payment;
    IF FOUND THEN
        -- credit card payments do not get a special receipt number.
        NEW.receipt_number := 0;
    ELSE
        SELECT INTO NEW.receipt_number COALESCE(MAX(receipt_number), 0) + 1
        FROM money.refundable_payment WHERE payment_ou = NEW.payment_ou;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION evergreen.gen_refundable_payment_number() OWNER TO evergreen;

--
-- Name: generic_map_normalizer(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.generic_map_normalizer(text, text) RETURNS text
    LANGUAGE plperlu
    AS $_X$
my $string = shift;
my %map;

my $default = $string;

$_ = shift;
while (/^\s*?(.*?)\s*?=>\s*?(\S+)\s*/) {
    if ($1 eq '') {
        $default = $2;
    } else {
        $map{$2} = [split(/\s*,\s*/, $1)];
    }
    $_ = $';	
}

for my $key ( keys %map ) {
    return $key if (grep { $_ eq $string } @{ $map{$key} });
}

return $default;

$_X$;


ALTER FUNCTION evergreen.generic_map_normalizer(text, text) OWNER TO evergreen;

--
-- Name: get_barcodes(integer, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.get_barcodes(select_ou integer, type text, in_barcode text) RETURNS SETOF evergreen.barcode_set
    LANGUAGE plpgsql
    AS $$
DECLARE
    cur_barcode TEXT;
    barcode_len INT;
    completion_len  INT;
    asset_barcodes  TEXT[];
    actor_barcodes  TEXT[];
    do_asset    BOOL = false;
    do_serial   BOOL = false;
    do_booking  BOOL = false;
    do_actor    BOOL = false;
    completion_set  config.barcode_completion%ROWTYPE;
BEGIN

    IF position('asset' in type) > 0 THEN
        do_asset = true;
    END IF;
    IF position('serial' in type) > 0 THEN
        do_serial = true;
    END IF;
    IF position('booking' in type) > 0 THEN
        do_booking = true;
    END IF;
    IF do_asset OR do_serial OR do_booking THEN
        asset_barcodes = asset_barcodes || in_barcode;
    END IF;
    IF position('actor' in type) > 0 THEN
        do_actor = true;
        actor_barcodes = actor_barcodes || in_barcode;
    END IF;

    barcode_len := length(in_barcode);

    FOR completion_set IN
      SELECT * FROM config.barcode_completion
        WHERE active
        AND org_unit IN (SELECT aou.id FROM actor.org_unit_ancestors(select_ou) aou)
        LOOP
        IF completion_set.prefix IS NULL THEN
            completion_set.prefix := '';
        END IF;
        IF completion_set.suffix IS NULL THEN
            completion_set.suffix := '';
        END IF;
        IF completion_set.length = 0 OR completion_set.padding IS NULL OR length(completion_set.padding) = 0 THEN
            cur_barcode = completion_set.prefix || in_barcode || completion_set.suffix;
        ELSE
            completion_len = completion_set.length - length(completion_set.prefix) - length(completion_set.suffix);
            IF completion_len >= barcode_len THEN
                IF completion_set.padding_end THEN
                    cur_barcode = rpad(in_barcode, completion_len, completion_set.padding);
                ELSE
                    cur_barcode = lpad(in_barcode, completion_len, completion_set.padding);
                END IF;
                cur_barcode = completion_set.prefix || cur_barcode || completion_set.suffix;
            END IF;
        END IF;
        IF completion_set.actor THEN
            actor_barcodes = actor_barcodes || cur_barcode;
        END IF;
        IF completion_set.asset THEN
            asset_barcodes = asset_barcodes || cur_barcode;
        END IF;
    END LOOP;

    IF do_asset AND do_serial THEN
        RETURN QUERY SELECT 'asset'::TEXT, id, barcode FROM ONLY asset.copy WHERE barcode = ANY(asset_barcodes) AND deleted = false;
        RETURN QUERY SELECT 'serial'::TEXT, id, barcode FROM serial.unit WHERE barcode = ANY(asset_barcodes) AND deleted = false;
    ELSIF do_asset THEN
        RETURN QUERY SELECT 'asset'::TEXT, id, barcode FROM asset.copy WHERE barcode = ANY(asset_barcodes) AND deleted = false;
    ELSIF do_serial THEN
        RETURN QUERY SELECT 'serial'::TEXT, id, barcode FROM serial.unit WHERE barcode = ANY(asset_barcodes) AND deleted = false;
    END IF;
    IF do_booking THEN
        RETURN QUERY SELECT 'booking'::TEXT, id::BIGINT, barcode FROM booking.resource WHERE barcode = ANY(asset_barcodes);
    END IF;
    IF do_actor THEN
        RETURN QUERY SELECT 'actor'::TEXT, c.usr::BIGINT, c.barcode FROM actor.card c JOIN actor.usr u ON c.usr = u.id WHERE c.barcode = ANY(actor_barcodes) AND c.active AND NOT u.deleted ORDER BY usr;
    END IF;
    RETURN;
END;
$$;


ALTER FUNCTION evergreen.get_barcodes(select_ou integer, type text, in_barcode text) OWNER TO evergreen;

--
-- Name: FUNCTION get_barcodes(select_ou integer, type text, in_barcode text); Type: COMMENT; Schema: evergreen; Owner: evergreen
--

COMMENT ON FUNCTION evergreen.get_barcodes(select_ou integer, type text, in_barcode text) IS '
Given user input, find an appropriate barcode in the proper class.

Will add prefix/suffix information to do so, and return all results.
';


--
-- Name: get_locale_name(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.get_locale_name(locale text, OUT name text, OUT description text) RETURNS record
    LANGUAGE plpgsql STABLE COST 1
    AS $$
DECLARE
    eg_locale TEXT;
BEGIN
    eg_locale := LOWER(SUBSTRING(locale FROM 1 FOR 2)) || '-' || UPPER(SUBSTRING(locale FROM 4 FOR 2));
        
    SELECT i18nc.string INTO name
    FROM config.i18n_locale i18nl
       INNER JOIN config.i18n_core i18nc ON i18nl.code = i18nc.translation
    WHERE i18nc.identity_value = eg_locale
       AND code = eg_locale
       AND i18nc.fq_field = 'i18n_l.name';

    IF name IS NULL THEN
       SELECT i18nl.name INTO name
       FROM config.i18n_locale i18nl
       WHERE code = eg_locale;
    END IF;

    SELECT i18nc.string INTO description
    FROM config.i18n_locale i18nl
       INNER JOIN config.i18n_core i18nc ON i18nl.code = i18nc.translation
    WHERE i18nc.identity_value = eg_locale
       AND code = eg_locale
       AND i18nc.fq_field = 'i18n_l.description';

    IF description IS NULL THEN
       SELECT i18nl.description INTO description
       FROM config.i18n_locale i18nl
       WHERE code = eg_locale;
    END IF;
END;
$$;


ALTER FUNCTION evergreen.get_locale_name(locale text, OUT name text, OUT description text) OWNER TO evergreen;

--
-- Name: insert_on_deploy(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.insert_on_deploy() RETURNS boolean
    LANGUAGE sql
    AS $$
    SELECT EXISTS(SELECT id FROM actor.org_unit LIMIT 1);
$$;


ALTER FUNCTION evergreen.insert_on_deploy() OWNER TO evergreen;

--
-- Name: levenshtein_damerau_edistance(text, text, integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.levenshtein_damerau_edistance(a text, b text, integer) RETURNS numeric
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
use Text::Levenshtein::Damerau::XS qw/xs_edistance/;
return xs_edistance(@_);
$$;


ALTER FUNCTION evergreen.levenshtein_damerau_edistance(a text, b text, integer) OWNER TO evergreen;

--
-- Name: limit_oustl(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.limit_oustl() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    BEGIN
        -- Only keeps the most recent five settings changes.
        DELETE FROM config.org_unit_setting_type_log WHERE field_name = NEW.field_name AND org = NEW.org AND date_applied NOT IN 
        (SELECT date_applied FROM config.org_unit_setting_type_log WHERE field_name = NEW.field_name AND org = NEW.org ORDER BY date_applied DESC LIMIT 4);
        
        IF (TG_OP = 'UPDATE') THEN
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            RETURN NEW;
        END IF;
        RETURN NULL;
    END;
$$;


ALTER FUNCTION evergreen.limit_oustl() OWNER TO evergreen;

--
-- Name: located_uris(bigint[], integer, integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.located_uris(bibid bigint[], ouid integer, pref_lib integer DEFAULT NULL::integer) RETURNS TABLE(id bigint, name text, label_sortkey text, rank integer)
    LANGUAGE sql STABLE
    AS $_$
    WITH all_orgs AS (SELECT COALESCE( enabled, FALSE ) AS flag FROM config.global_flag WHERE name = 'opac.located_uri.act_as_copy')
    SELECT DISTINCT ON (id) * FROM (
    SELECT acn.id, COALESCE(aou.name,aoud.name), acn.label_sortkey, evergreen.rank_ou(aou.id, $2, $3) AS pref_ou
      FROM asset.call_number acn
           INNER JOIN asset.uri_call_number_map auricnm ON acn.id = auricnm.call_number
           INNER JOIN asset.uri auri ON auri.id = auricnm.uri
           LEFT JOIN actor.org_unit_ancestors( COALESCE($3, $2) ) aou ON (acn.owning_lib = aou.id)
           LEFT JOIN actor.org_unit_descendants( COALESCE($3, $2) ) aoud ON (acn.owning_lib = aoud.id),
           all_orgs
      WHERE acn.record = ANY ($1)
          AND acn.deleted IS FALSE
          AND auri.active IS TRUE
          AND ((NOT all_orgs.flag AND aou.id IS NOT NULL) OR (all_orgs.flag AND COALESCE(aou.id,aoud.id) IS NOT NULL))
    UNION
    SELECT acn.id, COALESCE(aou.name,aoud.name) AS name, acn.label_sortkey, evergreen.rank_ou(aou.id, $2, $3) AS pref_ou
      FROM asset.call_number acn
           INNER JOIN asset.uri_call_number_map auricnm ON acn.id = auricnm.call_number
           INNER JOIN asset.uri auri ON auri.id = auricnm.uri
           LEFT JOIN actor.org_unit_ancestors( $2 ) aou ON (acn.owning_lib = aou.id)
           LEFT JOIN actor.org_unit_descendants( $2 ) aoud ON (acn.owning_lib = aoud.id),
           all_orgs
      WHERE acn.record = ANY ($1)
          AND acn.deleted IS FALSE
          AND auri.active IS TRUE
          AND ((NOT all_orgs.flag AND aou.id IS NOT NULL) OR (all_orgs.flag AND COALESCE(aou.id,aoud.id) IS NOT NULL)))x
    ORDER BY id, pref_ou DESC;
$_$;


ALTER FUNCTION evergreen.located_uris(bibid bigint[], ouid integer, pref_lib integer) OWNER TO evergreen;

--
-- Name: located_uris(bigint, integer, integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.located_uris(bibid bigint, ouid integer, pref_lib integer DEFAULT NULL::integer) RETURNS TABLE(id bigint, name text, label_sortkey text, rank integer)
    LANGUAGE sql STABLE
    AS $_$ SELECT * FROM evergreen.located_uris(ARRAY[$1],$2,$3) $_$;


ALTER FUNCTION evergreen.located_uris(bibid bigint, ouid integer, pref_lib integer) OWNER TO evergreen;

--
-- Name: uri; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.uri (
    id integer NOT NULL,
    href text NOT NULL,
    label text,
    use_restriction text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE asset.uri OWNER TO evergreen;

--
-- Name: located_uris_as_uris(bigint, integer, integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.located_uris_as_uris(bibid bigint, ouid integer, pref_lib integer DEFAULT NULL::integer) RETURNS SETOF asset.uri
    LANGUAGE sql STABLE
    AS $_$
    /* Maps a bib directly to its scoped asset.uri's */

    SELECT uri.* 
    FROM evergreen.located_uris($1, $2, $3) located_uri
    JOIN asset.uri_call_number_map map ON (map.call_number = located_uri.id)
    JOIN asset.uri uri ON (uri.id = map.uri)

$_$;


ALTER FUNCTION evergreen.located_uris_as_uris(bibid bigint, ouid integer, pref_lib integer) OWNER TO evergreen;

--
-- Name: lowercase(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.lowercase(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
    return lc(shift);
$$;


ALTER FUNCTION evergreen.lowercase(text) OWNER TO evergreen;

--
-- Name: lpad_number_substrings(text, text, integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.lpad_number_substrings(text, text, integer) RETURNS text
    LANGUAGE plperlu
    AS $_$
    my $string = shift;            # Source string
    my $pad = shift;               # string to fill. Typically '0'. This should be a single character.
    my $len = shift;               # length of resultant padded field

    $string =~ s/([0-9]+)/$pad x ($len - length($1)) . $1/eg;

    return $string;
$_$;


ALTER FUNCTION evergreen.lpad_number_substrings(text, text, integer) OWNER TO evergreen;

--
-- Name: maintain_901(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.maintain_901() RETURNS trigger
    LANGUAGE plperlu
    AS $_X$
use strict;
use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use MARC::Charset;
use Encode;
use Unicode::Normalize;

MARC::Charset->assume_unicode(1);

my $schema = $_TD->{table_schema};
my $marc = MARC::Record->new_from_xml($_TD->{new}{marc});

my @old901s = $marc->field('901');
$marc->delete_fields(@old901s);

if ($schema eq 'biblio') {
    my $tcn_value = $_TD->{new}{tcn_value};

    # Set TCN value to record ID?
    my $id_as_tcn = spi_exec_query("
        SELECT enabled
        FROM config.global_flag
        WHERE name = 'cat.bib.use_id_for_tcn'
    ");
    if (($id_as_tcn->{processed}) && $id_as_tcn->{rows}[0]->{enabled} eq 't') {
        $tcn_value = $_TD->{new}{id}; 
        $_TD->{new}{tcn_value} = $tcn_value;
    }

    my $new_901 = MARC::Field->new("901", " ", " ",
        "a" => $tcn_value,
        "b" => $_TD->{new}{tcn_source},
        "c" => $_TD->{new}{id},
        "t" => $schema
    );

    if ($_TD->{new}{owner}) {
        $new_901->add_subfields("o" => $_TD->{new}{owner});
    }

    if ($_TD->{new}{share_depth}) {
        $new_901->add_subfields("d" => $_TD->{new}{share_depth});
    }

    if ($_TD->{new}{source}) {
        my $plan = spi_prepare('
            SELECT source
            FROM config.bib_source
            WHERE id = $1
        ', 'INTEGER');
        my $source_name =
            spi_exec_prepared($plan, {limit => 1}, $_TD->{new}{source})->{rows}[0]{source};
        spi_freeplan($plan);
        $new_901->add_subfields("s" => $source_name) if $source_name;
    }

    $marc->append_fields($new_901);
} elsif ($schema eq 'authority') {
    my $new_901 = MARC::Field->new("901", " ", " ",
        "c" => $_TD->{new}{id},
        "t" => $schema,
    );
    $marc->append_fields($new_901);
} elsif ($schema eq 'serial') {
    my $new_901 = MARC::Field->new("901", " ", " ",
        "c" => $_TD->{new}{id},
        "t" => $schema,
        "o" => $_TD->{new}{owning_lib},
    );

    if ($_TD->{new}{record}) {
        $new_901->add_subfields("r" => $_TD->{new}{record});
    }

    $marc->append_fields($new_901);
} else {
    my $new_901 = MARC::Field->new("901", " ", " ",
        "c" => $_TD->{new}{id},
        "t" => $schema,
    );
    $marc->append_fields($new_901);
}

my $xml = $marc->as_xml_record();
$xml =~ s/\n//sgo;
$xml =~ s/^<\?xml.+\?\s*>//go;
$xml =~ s/>\s+</></go;
$xml =~ s/\p{Cc}//go;

# Embed a version of OpenILS::Application::AppUtils->entityize()
# to avoid having to set PERL5LIB for PostgreSQL as well

$xml = NFC($xml);

# Convert raw ampersands to entities
$xml =~ s/&(?!\S+;)/&amp;/gso;

# Convert Unicode characters to entities
$xml =~ s/([\x{0080}-\x{fffd}])/sprintf('&#x%X;',ord($1))/sgoe;

$xml =~ s/[\x00-\x1f]//go;
$_TD->{new}{marc} = $xml;

return "MODIFY";
$_X$;


ALTER FUNCTION evergreen.maintain_901() OWNER TO evergreen;

--
-- Name: maintain_control_numbers(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.maintain_control_numbers() RETURNS trigger
    LANGUAGE plperlu
    AS $_X$
use strict;
use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use MARC::Charset;
use Encode;
use Unicode::Normalize;

MARC::Charset->assume_unicode(1);

my $record = MARC::Record->new_from_xml($_TD->{new}{marc});
my $schema = $_TD->{table_schema};
my $rec_id = $_TD->{new}{id};

# Short-circuit if maintaining control numbers per MARC21 spec is not enabled
my $enable = spi_exec_query("SELECT enabled FROM config.global_flag WHERE name = 'cat.maintain_control_numbers'");
if (!($enable->{processed}) or $enable->{rows}[0]->{enabled} eq 'f') {
    return;
}

# Get the control number identifier from an OU setting based on $_TD->{new}{owner}
my $ou_cni = 'EVRGRN';

my $owner;
if ($schema eq 'serial') {
    $owner = $_TD->{new}{owning_lib};
} else {
    # are.owner and bre.owner can be null, so fall back to the consortial setting
    $owner = $_TD->{new}{owner} || 1;
}

my $ous_rv = spi_exec_query("SELECT value FROM actor.org_unit_ancestor_setting('cat.marc_control_number_identifier', $owner)");
if ($ous_rv->{processed}) {
    $ou_cni = $ous_rv->{rows}[0]->{value};
    $ou_cni =~ s/"//g; # Stupid VIM syntax highlighting"
} else {
    # Fall back to the shortname of the OU if there was no OU setting
    $ous_rv = spi_exec_query("SELECT shortname FROM actor.org_unit WHERE id = $owner");
    if ($ous_rv->{processed}) {
        $ou_cni = $ous_rv->{rows}[0]->{shortname};
    }
}

my ($create, $munge) = (0, 0);

my @scns = $record->field('035');

foreach my $id_field ('001', '003') {
    my $spec_value;
    my @controls = $record->field($id_field);

    if ($id_field eq '001') {
        $spec_value = $rec_id;
    } else {
        $spec_value = $ou_cni;
    }

    # Create the 001/003 if none exist
    if (scalar(@controls) == 1) {
        # Only one field; check to see if we need to munge it
        unless (grep $_->data() eq $spec_value, @controls) {
            $munge = 1;
        }
    } else {
        # Delete the other fields, as with more than 1 001/003 we do not know which 003/001 to match
        foreach my $control (@controls) {
            $record->delete_field($control);
        }
        $record->insert_fields_ordered(MARC::Field->new($id_field, $spec_value));
        $create = 1;
    }
}

my $cn = $record->field('001')->data();
# Special handling of OCLC numbers, often found in records that lack 003
if ($cn =~ /^o(c[nm]|n)\d/) {
    $cn =~ s/^o(c[nm]|n)0*(\d+)/$2/;
    $record->field('003')->data('OCoLC');
    $create = 0;
}

# Now, if we need to munge the 001, we will first push the existing 001/003
# into the 035; but if the record did not have one (and one only) 001 and 003
# to begin with, skip this process
if ($munge and not $create) {

    my $scn = "(" . $record->field('003')->data() . ")" . $cn;

    # Do not create duplicate 035 fields
    unless (grep $_->subfield('a') eq $scn, @scns) {
        $record->insert_fields_ordered(MARC::Field->new('035', '', '', 'a' => $scn));
    }
}

# Set the 001/003 and update the MARC
if ($create or $munge) {
    $record->field('001')->data($rec_id);
    $record->field('003')->data($ou_cni);

    my $xml = $record->as_xml_record();
    $xml =~ s/\n//sgo;
    $xml =~ s/^<\?xml.+\?\s*>//go;
    $xml =~ s/>\s+</></go;
    $xml =~ s/\p{Cc}//go;

    # Embed a version of OpenILS::Application::AppUtils->entityize()
    # to avoid having to set PERL5LIB for PostgreSQL as well

    $xml = NFC($xml);

    # Convert raw ampersands to entities
    $xml =~ s/&(?!\S+;)/&amp;/gso;

    # Convert Unicode characters to entities
    $xml =~ s/([\x{0080}-\x{fffd}])/sprintf('&#x%X;',ord($1))/sgoe;

    $xml =~ s/[\x00-\x1f]//go;
    $_TD->{new}{marc} = $xml;

    return "MODIFY";
}

return;
$_X$;


ALTER FUNCTION evergreen.maintain_control_numbers() OWNER TO evergreen;

--
-- Name: marc_tag_to_string(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.marc_tag_to_string(tag text, marcxml text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    final TEXT DEFAULT '';
    datafield XML;
    subfield XML;
BEGIN
    FOR datafield IN SELECT UNNEST(XPATH(
            '//*[starts-with(@tag,"'||tag||'")]', marcxml::XML)) LOOP

        -- delineate marc tags
        IF final <> '' THEN final := final || ' | '; END IF;

        -- add the tag
        final := final || (SELECT ARRAY_TO_STRING(
            XPATH('//*/@tag[1]', datafield ), ''));

        -- add indicator 1 and 2, defaulting to _
        final := final || ' '
            || (SELECT REGEXP_REPLACE(ARRAY_TO_STRING(
                XPATH('//*/@ind1[1]', datafield), ''), '^\s?$', '_'))
            || (SELECT REGEXP_REPLACE(ARRAY_TO_STRING(
                XPATH('//*/@ind2[1]', datafield), ''), '^\s?$', '_'));

        -- append each code and subfield value
        FOR subfield IN SELECT UNNEST(XPATH(
                '//*[@code]', datafield)) LOOP
            final := final || ' $' || (
                SELECT evergreen.xml_famous5_to_text( -- unescape XML
                    ARRAY_TO_STRING(XPATH(
                    '//*/@code[1]|//*/text()[1]', subfield), ' ')));
        END LOOP;

    END LOOP;
    RETURN final;
END;
$_$;


ALTER FUNCTION evergreen.marc_tag_to_string(tag text, marcxml text) OWNER TO evergreen;

--
-- Name: marc_to(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.marc_to(marc text, xfrm text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT evergreen.xml_pretty_print(xslt_process($1,xslt)::XML)::TEXT FROM config.xml_transform WHERE name = $2;
$_$;


ALTER FUNCTION evergreen.marc_to(marc text, xfrm text) OWNER TO evergreen;

--
-- Name: oils_i18n_code_tracking(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_i18n_code_tracking() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM oils_i18n_update_apply( OLD.code::TEXT, NEW.code::TEXT, TG_ARGV[0]::TEXT );
    RETURN NEW;
END;
$$;


ALTER FUNCTION evergreen.oils_i18n_code_tracking() OWNER TO evergreen;

--
-- Name: oils_i18n_gettext(integer, text, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_i18n_gettext(integer, text, text, text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT $2;
$_$;


ALTER FUNCTION evergreen.oils_i18n_gettext(integer, text, text, text) OWNER TO evergreen;

--
-- Name: oils_i18n_gettext(text, text, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_i18n_gettext(text, text, text, text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT $2;
$_$;


ALTER FUNCTION evergreen.oils_i18n_gettext(text, text, text, text) OWNER TO evergreen;

--
-- Name: oils_i18n_id_tracking(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_i18n_id_tracking() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM oils_i18n_update_apply( OLD.id::TEXT, NEW.id::TEXT, TG_ARGV[0]::TEXT );
    RETURN NEW;
END;
$$;


ALTER FUNCTION evergreen.oils_i18n_id_tracking() OWNER TO evergreen;

--
-- Name: oils_i18n_update_apply(text, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_i18n_update_apply(old_ident text, new_ident text, hint text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
BEGIN

    EXECUTE $$
        UPDATE  config.i18n_core
          SET   identity_value = $$ || quote_literal( new_ident ) || $$ 
          WHERE fq_field LIKE '$$ || hint || $$.%' 
                AND identity_value = $$ || quote_literal( old_ident ) || $$;$$;

    RETURN;

END;
$_$;


ALTER FUNCTION evergreen.oils_i18n_update_apply(old_ident text, new_ident text, hint text) OWNER TO evergreen;

--
-- Name: oils_i18n_xlate(text, text, text, text, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_i18n_xlate(keytable text, keyclass text, keycol text, identcol text, keyvalue text, raw_locale text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    locale      TEXT := REGEXP_REPLACE( REGEXP_REPLACE( raw_locale, E'[;, ].+$', '' ), E'_', '-', 'g' );
    language    TEXT := REGEXP_REPLACE( locale, E'-.+$', '' );
    result      config.i18n_core%ROWTYPE;
    fallback    TEXT;
    keyfield    TEXT := keyclass || '.' || keycol;
BEGIN

    -- Try the full locale
    SELECT  * INTO result
      FROM  config.i18n_core
      WHERE fq_field = keyfield
            AND identity_value = keyvalue
            AND translation = locale;

    -- Try just the language
    IF NOT FOUND THEN
        SELECT  * INTO result
          FROM  config.i18n_core
          WHERE fq_field = keyfield
                AND identity_value = keyvalue
                AND translation = language;
    END IF;

    -- Fall back to the string we passed in in the first place
    IF NOT FOUND THEN
	EXECUTE
            'SELECT ' ||
                keycol ||
            ' FROM ' || keytable ||
            ' WHERE ' || identcol || ' = ' || quote_literal(keyvalue)
                INTO fallback;
        RETURN fallback;
    END IF;

    RETURN result.string;
END;
$_$;


ALTER FUNCTION evergreen.oils_i18n_xlate(keytable text, keyclass text, keycol text, identcol text, keyvalue text, raw_locale text) OWNER TO evergreen;

--
-- Name: oils_json_to_text(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_json_to_text(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    use JSON::XS;                    
    my $json = shift();
    my $txt;
    eval { $txt = JSON::XS->new->allow_nonref->decode( $json ) };   
    return undef if ($@);
    return $txt
$_$;


ALTER FUNCTION evergreen.oils_json_to_text(text) OWNER TO evergreen;

--
-- Name: oils_text_as_bytea(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_text_as_bytea(text) RETURNS bytea
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT CAST(REGEXP_REPLACE(UPPER($1), $$\\$$, $$\\\\$$, 'g') AS BYTEA);
$_$;


ALTER FUNCTION evergreen.oils_text_as_bytea(text) OWNER TO evergreen;

--
-- Name: oils_xpath(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_xpath(text, text) RETURNS text[]
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT  ARRAY_AGG(
                CASE WHEN strpos(x,'<') = 1 THEN -- It's an element node
                    x
                ELSE -- it's text-ish
                    evergreen.xml_famous5_to_text(x)
                END
            )
      FROM  UNNEST(XPATH( $1, $2::XML)::TEXT[]) x;
$_$;


ALTER FUNCTION evergreen.oils_xpath(text, text) OWNER TO evergreen;

--
-- Name: oils_xpath(text, text, text[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_xpath(text, text, text[]) RETURNS text[]
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT  ARRAY_AGG(
                CASE WHEN strpos(x,'<') = 1 THEN -- It's an element node
                    x
                ELSE -- it's text-ish
                    evergreen.xml_famous5_to_text(x)
                END
            )
      FROM  UNNEST(XPATH( $1, $2::XML, $3 )::TEXT[]) x;
$_$;


ALTER FUNCTION evergreen.oils_xpath(text, text, text[]) OWNER TO evergreen;

--
-- Name: oils_xpath_string(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_xpath_string(text, text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT oils_xpath_string( $1, $2, '{}'::TEXT[] );
$_$;


ALTER FUNCTION evergreen.oils_xpath_string(text, text) OWNER TO evergreen;

--
-- Name: oils_xpath_string(text, text, anyarray); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_xpath_string(text, text, anyarray) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT oils_xpath_string( $1, $2, '', $3 );
$_$;


ALTER FUNCTION evergreen.oils_xpath_string(text, text, anyarray) OWNER TO evergreen;

--
-- Name: oils_xpath_string(text, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_xpath_string(text, text, text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT oils_xpath_string( $1, $2, $3, '{}'::TEXT[] );
$_$;


ALTER FUNCTION evergreen.oils_xpath_string(text, text, text) OWNER TO evergreen;

--
-- Name: oils_xpath_string(text, text, text, anyarray); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_xpath_string(text, text, text, anyarray) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT  ARRAY_TO_STRING(
                oils_xpath(
                    $1 ||
                        CASE WHEN $1 ~ $re$/[^/[]*@[^]]+$$re$ OR $1 ~ $re$text\(\)$$re$ THEN '' ELSE '//text()' END,
                    $2,
                    $4
                ),
                $3
            );
$_$;


ALTER FUNCTION evergreen.oils_xpath_string(text, text, text, anyarray) OWNER TO evergreen;

--
-- Name: oils_xpath_table(text, text, text, text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_xpath_table(key text, document_field text, relation_name text, xpaths text, criteria text) RETURNS SETOF record
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    xpath_list  TEXT[];
    select_list TEXT[];
    where_list  TEXT[];
    q           TEXT;
    out_record  RECORD;
    empty_test  RECORD;
BEGIN
    xpath_list := STRING_TO_ARRAY( xpaths, '|' );

    select_list := ARRAY_APPEND( select_list, key || '::INT AS key' );

    FOR i IN 1 .. ARRAY_UPPER(xpath_list,1) LOOP
        IF xpath_list[i] = 'null()' THEN
            select_list := ARRAY_APPEND( select_list, 'NULL::TEXT AS c_' || i );
        ELSE
            select_list := ARRAY_APPEND(
                select_list,
                $sel$
                unnest(
                    COALESCE(
                        NULLIF(
                            oils_xpath(
                                $sel$ ||
                                    quote_literal(
                                        CASE
                                            WHEN xpath_list[i] ~ $re$/[^/[]*@[^/]+$$re$ OR xpath_list[i] ~ $re$text\(\)$$re$ THEN xpath_list[i]
                                            ELSE xpath_list[i] || '//text()'
                                        END
                                    ) ||
                                $sel$,
                                $sel$ || document_field || $sel$
                            ),
                           '{}'::TEXT[]
                        ),
                        '{NULL}'::TEXT[]
                    )
                ) AS c_$sel$ || i
            );
            where_list := ARRAY_APPEND(
                where_list,
                'c_' || i || ' IS NOT NULL'
            );
        END IF;
    END LOOP;

    q := $q$
SELECT * FROM (
    SELECT $q$ || ARRAY_TO_STRING( select_list, ', ' ) || $q$ FROM $q$ || relation_name || $q$ WHERE ($q$ || criteria || $q$)
)x WHERE $q$ || ARRAY_TO_STRING( where_list, ' OR ' );
    -- RAISE NOTICE 'query: %', q;

    FOR out_record IN EXECUTE q LOOP
        RETURN NEXT out_record;
    END LOOP;

    RETURN;
END;
$_$;


ALTER FUNCTION evergreen.oils_xpath_table(key text, document_field text, relation_name text, xpaths text, criteria text) OWNER TO evergreen;

--
-- Name: oils_xpath_tag_to_table(text, text, text[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_xpath_tag_to_table(marc text, tag text, xpaths text[]) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$

-- This function currently populates columns with the FIRST matching value
-- of each XPATH.  It would be reasonable to add a 'return_arrays' option
-- where each column is an array of all matching values for each path, but
-- that remains as a TODO

DECLARE
    field RECORD;
    output RECORD;
    select_list TEXT[];
    from_list TEXT[];
    q TEXT;
BEGIN
    -- setup query select
    FOR i IN 1 .. ARRAY_UPPER(xpaths,1) LOOP
        IF xpaths[i] = 'null()' THEN
            select_list := ARRAY_APPEND(select_list, 'NULL::TEXT AS c_' || i );
        ELSE
            select_list := ARRAY_APPEND(select_list, '(oils_xpath(' ||
                quote_literal(
                    CASE
                        WHEN xpaths[i] ~ $re$/[^/[]*@[^/]+$$re$ -- attribute
                            OR xpaths[i] ~ $re$text\(\)$$re$
                        THEN xpaths[i]
                        ELSE xpaths[i] || '//text()'
                    END
                ) || ', field_marc))[1] AS cl_' || i);
                -- hardcoded to first value for each path
        END IF;
    END LOOP;

    -- run query over tag set
    q := 'SELECT ' || ARRAY_TO_STRING(select_list, ',')
        || ' FROM UNNEST(oils_xpath(' || quote_literal('//*[@tag="' || tag
        || '"]') || ', ' || quote_literal(marc) || ')) AS field_marc;';
    --RAISE NOTICE '%', q;

    RETURN QUERY EXECUTE q;
END;

$_$;


ALTER FUNCTION evergreen.oils_xpath_tag_to_table(marc text, tag text, xpaths text[]) OWNER TO evergreen;

--
-- Name: oils_xslt_process(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.oils_xslt_process(text, text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_X$
  use strict;

  use XML::LibXSLT;
  use XML::LibXML;

  my $doc = shift;
  my $xslt = shift;

  # The following approach uses the older XML::LibXML 1.69 / XML::LibXSLT 1.68
  # methods of parsing XML documents and stylesheets, in the hopes of broader
  # compatibility with distributions
  my $parser = $_SHARED{'_xslt_process'}{parsers}{xml} || XML::LibXML->new();

  # Cache the XML parser, if we do not already have one
  $_SHARED{'_xslt_process'}{parsers}{xml} = $parser
    unless ($_SHARED{'_xslt_process'}{parsers}{xml});

  my $xslt_parser = $_SHARED{'_xslt_process'}{parsers}{xslt} || XML::LibXSLT->new();

  # Cache the XSLT processor, if we do not already have one
  $_SHARED{'_xslt_process'}{parsers}{xslt} = $xslt_parser
    unless ($_SHARED{'_xslt_process'}{parsers}{xslt});

  my $stylesheet = $_SHARED{'_xslt_process'}{stylesheets}{$xslt} ||
    $xslt_parser->parse_stylesheet( $parser->parse_string($xslt) );

  $_SHARED{'_xslt_process'}{stylesheets}{$xslt} = $stylesheet
    unless ($_SHARED{'_xslt_process'}{stylesheets}{$xslt});

  return $stylesheet->output_as_chars(
    $stylesheet->transform(
      $parser->parse_string($doc)
    )
  );

$_X$;


ALTER FUNCTION evergreen.oils_xslt_process(text, text) OWNER TO evergreen;

--
-- Name: org_top(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.org_top() RETURNS actor.org_unit
    LANGUAGE sql STABLE
    AS $$
    SELECT * FROM actor.org_unit WHERE parent_ou IS NULL LIMIT 1;
$$;


ALTER FUNCTION evergreen.org_top() OWNER TO evergreen;

--
-- Name: ous_change_log(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.ous_change_log() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
    original TEXT;
    BEGIN
        -- Check for which setting is being updated, and log it.
        SELECT INTO original value FROM actor.org_unit_setting WHERE name = NEW.name AND org_unit = NEW.org_unit;
                
        INSERT INTO config.org_unit_setting_type_log (org,original_value,new_value,field_name) VALUES (NEW.org_unit, original, NEW.value, NEW.name);
        
        RETURN NEW;
    END;
$$;


ALTER FUNCTION evergreen.ous_change_log() OWNER TO evergreen;

--
-- Name: ous_delete_log(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.ous_delete_log() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
    original TEXT;
    BEGIN
        -- Check for which setting is being updated, and log it.
        SELECT INTO original value FROM actor.org_unit_setting WHERE name = OLD.name AND org_unit = OLD.org_unit;
                
        INSERT INTO config.org_unit_setting_type_log (org,original_value,new_value,field_name) VALUES (OLD.org_unit, original, 'null', OLD.name);
        
        RETURN OLD;
    END;
$$;


ALTER FUNCTION evergreen.ous_delete_log() OWNER TO evergreen;

--
-- Name: perl_oils_xpath(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.perl_oils_xpath(text, text) RETURNS text[]
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT perl_oils_xpath( $1, $2, '{}'::TEXT[]);$_$;


ALTER FUNCTION evergreen.perl_oils_xpath(text, text) OWNER TO evergreen;

--
-- Name: perl_oils_xpath(text, text, text[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.perl_oils_xpath(xpath text, xml text, ns text[]) RETURNS text[]
    LANGUAGE plperlu
    AS $_X$
  use strict;
  use XML::LibXML;

  my $xpath = shift;
  my $doc = shift;
  my $ns_string = shift || '';

  my %ns_list = $ns_string =~ m/\{([^{,]+),([^}]+)\}/g;

  # The following approach uses the older XML::LibXML 1.69 / XML::LibXSLT 1.68
  # methods of parsing XML documents and stylesheets, in the hopes of broader
  # compatibility with distributions
  my $parser = eval { $_SHARED{'_xslt_process'}{parsers}{xml} || XML::LibXML->new() };

  return undef if ($@);

  # Cache the XML parser, if we do not already have one
  $_SHARED{'_xslt_process'}{parsers}{xml} = $parser
    unless ($_SHARED{'_xslt_process'}{parsers}{xml});

  # parse the doc
  my $dom = eval { $parser->parse_string($doc) };

  return undef if ($@);

  # Register the requested namespaces
  $dom->documentElement->setNamespace( $ns_list{$_} => $_ ) for ( keys %ns_list );
  my $xpc = XML::LibXML::XPathContext->new;
  $xpc->registerNs( $ns_list{$_} => $_ ) for ( keys %ns_list );

  # Gather and return nodes
  my @nodes = $dom->findnodes($xpath);

  return [ map { $_->toStringC14N } @nodes ];
$_X$;


ALTER FUNCTION evergreen.perl_oils_xpath(xpath text, xml text, ns text[]) OWNER TO evergreen;

--
-- Name: pg_statistics(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.pg_statistics(tab text, col text) RETURNS TABLE(element text, frequency integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- This query will die on PG < 9.2, but the function can be created. We just won't use it where we can't.
    RETURN QUERY
        SELECT  e,
                f
          FROM  (SELECT ROW_NUMBER() OVER (),
                        (f * 100)::INT AS f
                  FROM  (SELECT UNNEST(most_common_elem_freqs) AS f
                          FROM  pg_stats
                          WHERE tablename = tab
                                AND attname = col
                        )x
                ) AS f
                JOIN (SELECT ROW_NUMBER() OVER (),
                             e
                       FROM (SELECT UNNEST(most_common_elems::text::text[]) AS e
                              FROM  pg_stats 
                              WHERE tablename = tab
                                    AND attname = col
                            )y
                ) AS elems USING (row_number);
END;
$$;


ALTER FUNCTION evergreen.pg_statistics(tab text, col text) OWNER TO evergreen;

--
-- Name: protect_reserved_rows_from_delete(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.protect_reserved_rows_from_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF OLD.id < TG_ARGV[0]::INT THEN
    RAISE EXCEPTION 'Cannot delete row with reserved ID %', OLD.id; 
END IF;
RETURN OLD;
END
$$;


ALTER FUNCTION evergreen.protect_reserved_rows_from_delete() OWNER TO evergreen;

--
-- Name: query_int_wrapper(integer[], text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.query_int_wrapper(integer[], text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
BEGIN
    RETURN $1 @@ $2::query_int;
END;
$_$;


ALTER FUNCTION evergreen.query_int_wrapper(integer[], text) OWNER TO evergreen;

--
-- Name: qwerty_keyboard_distance(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.qwerty_keyboard_distance(a text, b text) RETURNS numeric
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
use String::KeyboardDistance qw(:all);
return qwerty_keyboard_distance(@_);
$$;


ALTER FUNCTION evergreen.qwerty_keyboard_distance(a text, b text) OWNER TO evergreen;

--
-- Name: qwerty_keyboard_distance_match(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.qwerty_keyboard_distance_match(a text, b text) RETURNS numeric
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
use String::KeyboardDistance qw(:all);
return qwerty_keyboard_distance_match(@_);
$$;


ALTER FUNCTION evergreen.qwerty_keyboard_distance_match(a text, b text) OWNER TO evergreen;

--
-- Name: rank_cp(asset.copy); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.rank_cp(copy asset.copy) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    rank INT;
BEGIN
    WITH totally_available AS (
        SELECT id, 0 AS avail_rank
        FROM config.copy_status
        WHERE opac_visible IS TRUE
            AND copy_active IS TRUE
            AND id != 1 -- "Checked out"
    ), almost_available AS (
        SELECT id, 10 AS avail_rank
        FROM config.copy_status
        WHERE holdable IS TRUE
            AND opac_visible IS TRUE
            AND copy_active IS FALSE
            OR id = 1 -- "Checked out"
    )
    SELECT COALESCE(
        CASE WHEN NOT copy.opac_visible THEN 100 END,
        (SELECT avail_rank FROM totally_available WHERE copy.status IN (id)),
        CASE WHEN copy.holdable THEN
            (SELECT avail_rank FROM almost_available WHERE copy.status IN (id))
        END,
        100
    ) INTO rank;

    RETURN rank;
END;
$$;


ALTER FUNCTION evergreen.rank_cp(copy asset.copy) OWNER TO evergreen;

--
-- Name: rank_cp(bigint); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.rank_cp(copy_id bigint) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    copy asset.copy%ROWTYPE;
BEGIN
    SELECT * INTO copy FROM asset.copy WHERE id = copy_id;
    RETURN evergreen.rank_cp(copy);
END;
$$;


ALTER FUNCTION evergreen.rank_cp(copy_id bigint) OWNER TO evergreen;

--
-- Name: rank_ou(integer, integer, integer); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.rank_ou(lib integer, search_lib integer, pref_lib integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE sql STABLE
    AS $_$
    SELECT COALESCE(

        -- lib matches search_lib
        (SELECT CASE WHEN $1 = $2 THEN -20000 END),

        -- lib matches pref_lib
        (SELECT CASE WHEN $1 = $3 THEN -10000 END),


        -- pref_lib is a child of search_lib and lib is a child of pref lib.  
        (SELECT distance - 5000
            FROM actor.org_unit_descendants_distance($3) 
            WHERE id = $1 AND $3 IN (
                SELECT id FROM actor.org_unit_descendants($2))),

        -- lib is a child of search_lib
        (SELECT distance FROM actor.org_unit_descendants_distance($2) WHERE id = $1),

        -- all others pay cash
        1000
    );
$_$;


ALTER FUNCTION evergreen.rank_ou(lib integer, search_lib integer, pref_lib integer) OWNER TO evergreen;

--
-- Name: rank_ou(integer, integer, integer, double precision, double precision); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.rank_ou(lib integer, search_lib integer, pref_lib integer, plat double precision, plon double precision) RETURNS integer
    LANGUAGE sql STABLE
    AS $_$
    SELECT COALESCE(

        -- lib matches search_lib
        (SELECT CASE WHEN $1 = $2 THEN -20000 END),

        -- lib matches pref_lib
        (SELECT CASE WHEN $1 = $3 THEN -10000 END),


        -- pref_lib is a child of search_lib and lib is a child of pref lib.
        -- For example, searching CONS, pref lib is SYS1,
        -- copies at BR1 and BR2 sort to the front.
        (SELECT distance - 5000
            FROM actor.org_unit_descendants_distance($3)
            WHERE id = $1 AND $3 IN (
                SELECT id FROM actor.org_unit_descendants($2))),

        -- lib is a child of search_lib
        (SELECT distance FROM actor.org_unit_descendants_distance($2) WHERE id = $1),

        -- all others pay cash
        1000
    ) + ((SELECT CASE WHEN addr.latitude IS NULL THEN 0 ELSE -20038 END) + (earth_distance( -- shortest GC distance is returned, only half the circumfrence is needed
            ll_to_earth(
                COALESCE(addr.latitude,plat), -- if the org has no coords, we just
                COALESCE(addr.longitude,plon) -- force 0 distance and let the above tie-break
            ),ll_to_earth(plat,plon)
        ) / 1000)::INT ) -- earth_distance is in meters, convert to kilometers and subtract from largest distance
    FROM actor.org_unit org
         LEFT JOIN actor.org_address addr ON (org.billing_address = addr.id)
    WHERE org.id = $1;
$_$;


ALTER FUNCTION evergreen.rank_ou(lib integer, search_lib integer, pref_lib integer, plat double precision, plon double precision) OWNER TO evergreen;

--
-- Name: ranked_volumes(bigint[], integer, integer, evergreen.hstore, evergreen.hstore, integer, text[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.ranked_volumes(bibid bigint[], ouid integer, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, pref_lib integer DEFAULT NULL::integer, includes text[] DEFAULT NULL::text[]) RETURNS TABLE(id bigint, name text, label_sortkey text, rank bigint)
    LANGUAGE sql STABLE ROWS 10
    AS $_$
    WITH RECURSIVE ou_depth AS (
        SELECT COALESCE(
            $3,
            (
                SELECT depth
                FROM actor.org_unit_type aout
                    INNER JOIN actor.org_unit ou ON ou_type = aout.id
                WHERE ou.id = $2
            )
        ) AS depth
    ), descendant_depth AS (
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
        FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN anscestor_depth ad ON (ad.id = ou.id),
                ou_depth
        WHERE ad.depth = ou_depth.depth
            UNION ALL
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
        FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN descendant_depth ot ON (ot.id = ou.parent_ou)
    ), anscestor_depth AS (
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
        FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
        WHERE ou.id = $2
            UNION ALL
        SELECT  ou.id,
                ou.parent_ou,
                out.depth
        FROM  actor.org_unit ou
                JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                JOIN anscestor_depth ot ON (ot.parent_ou = ou.id)
    ), descendants as (
        SELECT ou.* FROM actor.org_unit ou JOIN descendant_depth USING (id)
    )

    SELECT ua.id, ua.name, ua.label_sortkey, MIN(ua.rank) AS rank FROM (
        SELECT acn.id, owning_lib.name, acn.label_sortkey,
            evergreen.rank_cp(acp),
            RANK() OVER w
        FROM asset.call_number acn
            JOIN asset.copy acp ON (acn.id = acp.call_number)
            JOIN descendants AS aou ON (acp.circ_lib = aou.id)
            JOIN actor.org_unit AS owning_lib ON (acn.owning_lib = owning_lib.id)
        WHERE acn.record = ANY ($1)
            AND acn.deleted IS FALSE
            AND acp.deleted IS FALSE
            AND CASE WHEN ('exclude_invisible_acn' = ANY($7)) THEN
                EXISTS (
                    WITH basevm AS (SELECT c_attrs FROM  asset.patron_default_visibility_mask()),
                         circvm AS (SELECT search.calculate_visibility_attribute_test('circ_lib', ARRAY[acp.circ_lib]) AS mask)
                    SELECT  1
                      FROM  basevm, circvm, asset.copy_vis_attr_cache acvac
                      WHERE acvac.vis_attr_vector @@ (basevm.c_attrs || '&' || circvm.mask)::query_int
                            AND acvac.target_copy = acp.id
                            AND acvac.record = acn.record
                ) ELSE TRUE END
        GROUP BY acn.id, evergreen.rank_cp(acp), owning_lib.name, acn.label_sortkey, aou.id
        WINDOW w AS (
            ORDER BY
                COALESCE(
                    CASE WHEN aou.id = $2 THEN -20000 END,
                    CASE WHEN aou.id = $6 THEN -10000 END,
                    (SELECT distance - 5000
                        FROM actor.org_unit_descendants_distance($6) as x
                        WHERE x.id = aou.id AND $6 IN (
                            SELECT q.id FROM actor.org_unit_descendants($2) as q)),
                    (SELECT e.distance FROM actor.org_unit_descendants_distance($2) as e WHERE e.id = aou.id),
                    1000
                ),
                evergreen.rank_cp(acp)
        )
    ) AS ua
    GROUP BY ua.id, ua.name, ua.label_sortkey
    ORDER BY rank, ua.name, ua.label_sortkey
    LIMIT ($4 -> 'acn')::INT
    OFFSET ($5 -> 'acn')::INT;
$_$;


ALTER FUNCTION evergreen.ranked_volumes(bibid bigint[], ouid integer, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, pref_lib integer, includes text[]) OWNER TO evergreen;

--
-- Name: ranked_volumes(bigint, integer, integer, evergreen.hstore, evergreen.hstore, integer, text[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.ranked_volumes(bibid bigint, ouid integer, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, pref_lib integer DEFAULT NULL::integer, includes text[] DEFAULT NULL::text[]) RETURNS TABLE(id bigint, name text, label_sortkey text, rank bigint)
    LANGUAGE sql STABLE
    AS $_$ SELECT * FROM evergreen.ranked_volumes(ARRAY[$1],$2,$3,$4,$5,$6,$7) $_$;


ALTER FUNCTION evergreen.ranked_volumes(bibid bigint, ouid integer, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, pref_lib integer, includes text[]) OWNER TO evergreen;

--
-- Name: regexp_split_to_array(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.regexp_split_to_array(text, text) RETURNS text[]
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_X$
    return encode_array_literal([split $_[1], $_[0]]);
$_X$;


ALTER FUNCTION evergreen.regexp_split_to_array(text, text) OWNER TO evergreen;

--
-- Name: reingest_metabib_field_entries(bigint, boolean, boolean, boolean); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.reingest_metabib_field_entries(bib_id bigint, skip_facet boolean DEFAULT false, skip_browse boolean DEFAULT false, skip_search boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    fclass          RECORD;
    ind_data        metabib.field_entry_template%ROWTYPE;
    mbe_row         metabib.browse_entry%ROWTYPE;
    mbe_id          BIGINT;
    b_skip_facet    BOOL;
    b_skip_browse   BOOL;
    b_skip_search   BOOL;
    value_prepped   TEXT;
    field_class     TEXT;
BEGIN
    --ver1.6 modified by kmain-1119
    SELECT COALESCE(NULLIF(skip_facet, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_facet_indexing' AND enabled)) INTO b_skip_facet;
    SELECT COALESCE(NULLIF(skip_browse, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_browse_indexing' AND enabled)) INTO b_skip_browse;
    SELECT COALESCE(NULLIF(skip_search, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_search_indexing' AND enabled)) INTO b_skip_search;

    PERFORM * FROM config.internal_flag WHERE name = 'ingest.assume_inserts_only' AND enabled;
    IF NOT FOUND THEN
        IF NOT b_skip_search THEN
            FOR fclass IN SELECT * FROM config.metabib_class LOOP
                -- RAISE NOTICE 'Emptying out %', fclass.name;
                EXECUTE $$DELETE FROM metabib.$$ || fclass.name || $$_field_entry WHERE source = $$ || bib_id;
            END LOOP;
        END IF;
        IF NOT b_skip_facet THEN
            DELETE FROM metabib.facet_entry WHERE source = bib_id;
        END IF;
        IF NOT b_skip_browse THEN
            DELETE FROM metabib.browse_author_entry_def_map WHERE source = bib_id;
            DELETE FROM metabib.browse_title_entry_def_map WHERE source = bib_id;
            DELETE FROM metabib.browse_subject_entry_def_map WHERE source = bib_id;
            DELETE FROM metabib.browse_series_entry_def_map WHERE source = bib_id;
            DELETE FROM metabib.browse_call_number_entry_def_map WHERE source = bib_id;
        END IF;
    END IF;

    FOR ind_data IN SELECT * FROM biblio.extract_metabib_field_entry( bib_id ) LOOP

        --ind_data.field_class -- author, title, subject, etc

        IF ind_data.field < 0 THEN
            ind_data.field = -1 * ind_data.field;
        END IF;

        IF ind_data.facet_field AND NOT b_skip_facet THEN
            INSERT INTO metabib.facet_entry (field, source, value)
                VALUES (ind_data.field, ind_data.source, ind_data.value);
        END IF;

        IF ind_data.browse_field AND NOT b_skip_browse THEN
            -- A caveat about this SELECT: this should take care of replacing
            -- old mbe rows when data changes, but not if normalization (by
            -- which I mean specifically the output of
            -- evergreen.oils_tsearch2()) changes.  It may or may not be
            -- expensive to add a comparison of index_vector to index_vector
            -- to the WHERE clause below.

            value_prepped := metabib.browse_normalize(ind_data.value, ind_data.field);
            IF char_length(value_prepped) > 0 THEN
                CASE ind_data.field_class

                  WHEN 'author' THEN

                    SELECT INTO mbe_row * FROM metabib.browse_author_entry
                        WHERE sort_value = ind_data.sort_value
                        ORDER BY id;

                    IF FOUND THEN
                        mbe_id := mbe_row.id;
                    ELSE
                        INSERT INTO metabib.browse_author_entry
                            ( value, sort_value, truncated_sort_value ) VALUES
                            ( value_prepped, ind_data.sort_value, substr(ind_data.sort_value, 1, 2700) );

                        mbe_id := CURRVAL('metabib.browse_author_entry_id_seq'::REGCLASS);
                    END IF;

                    INSERT INTO metabib.browse_author_entry_def_map (entry, def, source, authority)
                        VALUES (mbe_id, ind_data.field, ind_data.source, ind_data.authority);

                  WHEN 'title' THEN

                    SELECT INTO mbe_row * FROM metabib.browse_title_entry
                        WHERE sort_value = ind_data.sort_value
                        ORDER BY id;

                    IF FOUND THEN
                        mbe_id := mbe_row.id;
                    ELSE
                        INSERT INTO metabib.browse_title_entry
                            ( value, sort_value, truncated_sort_value ) VALUES
                            ( value_prepped, ind_data.sort_value, substr(ind_data.sort_value, 1, 2700) );

                        mbe_id := CURRVAL('metabib.browse_title_entry_id_seq'::REGCLASS);
                    END IF;

                    INSERT INTO metabib.browse_title_entry_def_map (entry, def, source, authority)
                        VALUES (mbe_id, ind_data.field, ind_data.source, ind_data.authority);

                  WHEN 'subject' THEN

                    SELECT INTO mbe_row * FROM metabib.browse_subject_entry
                        WHERE sort_value = ind_data.sort_value
                        ORDER BY id;

                    IF FOUND THEN
                        mbe_id := mbe_row.id;
                    ELSE
                        INSERT INTO metabib.browse_subject_entry
                            ( value, sort_value, truncated_sort_value ) VALUES
                            ( value_prepped, ind_data.sort_value, substr(ind_data.sort_value, 1, 2700) );

                        mbe_id := CURRVAL('metabib.browse_subject_entry_id_seq'::REGCLASS);
                    END IF;

                    INSERT INTO metabib.browse_subject_entry_def_map (entry, def, source, authority)
                        VALUES (mbe_id, ind_data.field, ind_data.source, ind_data.authority);

                  WHEN 'series' THEN

                    SELECT INTO mbe_row * FROM metabib.browse_series_entry
                        WHERE sort_value = ind_data.sort_value
                        ORDER BY id;

                    IF FOUND THEN
                        mbe_id := mbe_row.id;
                    ELSE
                        INSERT INTO metabib.browse_series_entry
                            ( value, sort_value, truncated_sort_value ) VALUES
                            ( value_prepped, ind_data.sort_value, substr(ind_data.sort_value, 1, 2700) );

                        mbe_id := CURRVAL('metabib.browse_series_entry_id_seq'::REGCLASS);
                    END IF;

                    INSERT INTO metabib.browse_series_entry_def_map (entry, def, source, authority)
                        VALUES (mbe_id, ind_data.field, ind_data.source, ind_data.authority);

                  WHEN 'call_number' THEN

                    SELECT INTO mbe_row * FROM metabib.browse_call_number_entry
                        WHERE sort_value = ind_data.sort_value
                        ORDER BY id;

                    IF FOUND THEN
                        mbe_id := mbe_row.id;
                    ELSE
                        INSERT INTO metabib.browse_call_number_entry
                            ( value, sort_value, truncated_sort_value ) VALUES
                            ( value_prepped, ind_data.sort_value, substr(ind_data.sort_value, 1, 2700) );

                        mbe_id := CURRVAL('metabib.browse_call_number_entry_id_seq'::REGCLASS);
                    END IF;

                    INSERT INTO metabib.browse_call_number_entry_def_map (entry, def, source, authority)
                        VALUES (mbe_id, ind_data.field, ind_data.source, ind_data.authority);
                  ELSE
                END CASE;
            END IF;
        END IF;

        IF ind_data.search_field AND NOT b_skip_search THEN
            -- Avoid inserting duplicate rows
            EXECUTE 'SELECT 1 FROM metabib.' || ind_data.field_class ||
                '_field_entry WHERE field = $1 AND source = $2 AND value = $3'
                INTO mbe_id USING ind_data.field, ind_data.source, ind_data.value;
                -- RAISE NOTICE 'Search for an already matching row returned %', mbe_id;
            IF mbe_id IS NULL THEN
                EXECUTE $$
                INSERT INTO metabib.$$ || ind_data.field_class || $$_field_entry (field, source, value)
                    VALUES ($$ ||
                        quote_literal(ind_data.field) || $$, $$ ||
                        quote_literal(ind_data.source) || $$, $$ ||
                        quote_literal(ind_data.value) ||
                    $$);$$;
            END IF;
        END IF;

    END LOOP;

    IF NOT b_skip_search THEN
        PERFORM metabib.update_combined_index_vectors(bib_id);
    END IF;

    RETURN;
END;
$_X$;


ALTER FUNCTION evergreen.reingest_metabib_field_entries(bib_id bigint, skip_facet boolean, skip_browse boolean, skip_search boolean) OWNER TO evergreen;

--
-- Name: rel_bump(text[], text, text[], numeric[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.rel_bump(terms text[], value text, bumps text[], mults numeric[]) RETURNS numeric
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
use strict;
my ($terms,$value,$bumps,$mults) = @_;

my $retval = 1;

for (my $id = 0; $id < @$bumps; $id++) {
        if ($bumps->[$id] eq 'first_word') {
                $retval *= $mults->[$id] if ($value =~ /^$terms->[0]/);
        } elsif ($bumps->[$id] eq 'full_match') {
                my $fullmatch = join(' ', @$terms);
                $retval *= $mults->[$id] if ($value =~ /^$fullmatch$/);
        } elsif ($bumps->[$id] eq 'word_order') {
                my $wordorder = join('.*', @$terms);
                $retval *= $mults->[$id] if ($value =~ /$wordorder/);
        }
}
return $retval;
$_$;


ALTER FUNCTION evergreen.rel_bump(terms text[], value text, bumps text[], mults numeric[]) OWNER TO evergreen;

--
-- Name: tableoid2name(oid); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.tableoid2name(oid) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	BEGIN
		RETURN $1::regclass;
	END;
$_$;


ALTER FUNCTION evergreen.tableoid2name(oid) OWNER TO evergreen;

--
-- Name: text_array_merge_unique(text[], text[]); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.text_array_merge_unique(text[], text[]) RETURNS text[]
    LANGUAGE sql
    AS $_$
    SELECT NULLIF(ARRAY(
        SELECT * FROM UNNEST($1) x
            UNION
        SELECT * FROM UNNEST($2) y
    ),'{}');
$_$;


ALTER FUNCTION evergreen.text_array_merge_unique(text[], text[]) OWNER TO evergreen;

--
-- Name: unaccent_and_squash(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.unaccent_and_squash(arg text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
        BEGIN
        RETURN evergreen.lowercase(public.unaccent('public.unaccent', regexp_replace(arg, '[\s[:punct:]]','','g')));
        END;
$$;


ALTER FUNCTION evergreen.unaccent_and_squash(arg text) OWNER TO evergreen;

--
-- Name: upgrade_deps_block_check(text, text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.upgrade_deps_block_check(my_db_patch text, my_applied_to text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE 
    deprecates TEXT;
    supersedes TEXT;
BEGIN
    IF NOT evergreen.upgrade_verify_no_dep_conflicts( my_db_patch ) THEN
        SELECT  STRING_AGG(patch, ', ') INTO deprecates FROM evergreen.upgrade_list_applied_deprecates(my_db_patch);
        SELECT  STRING_AGG(patch, ', ') INTO supersedes FROM evergreen.upgrade_list_applied_supersedes(my_db_patch);
        RAISE EXCEPTION '
Upgrade script % can not be applied:
  applied deprecated scripts %
  applied superseded scripts %
  deprecated by %
  superseded by %',
            my_db_patch,
            (SELECT ARRAY_AGG(patch) FROM evergreen.upgrade_list_applied_deprecates(my_db_patch)),
            (SELECT ARRAY_AGG(patch) FROM evergreen.upgrade_list_applied_supersedes(my_db_patch)),
            evergreen.upgrade_list_applied_deprecated(my_db_patch),
            evergreen.upgrade_list_applied_superseded(my_db_patch);
    END IF;

    INSERT INTO config.upgrade_log (version, applied_to) VALUES (my_db_patch, my_applied_to);
    RETURN TRUE;
END;
$$;


ALTER FUNCTION evergreen.upgrade_deps_block_check(my_db_patch text, my_applied_to text) OWNER TO evergreen;

--
-- Name: upgrade_list_applied_deprecated(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.upgrade_list_applied_deprecated(my_db_patch text) RETURNS SETOF text
    LANGUAGE sql
    AS $_$
    SELECT  db_patch
      FROM  config.db_patch_dependencies
      WHERE ARRAY[$1]::TEXT[] && deprecates
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_deprecated(my_db_patch text) OWNER TO evergreen;

--
-- Name: upgrade_list_applied_deprecates(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.upgrade_list_applied_deprecates(my_db_patch text) RETURNS SETOF evergreen.patch
    LANGUAGE sql
    AS $_$
    SELECT  DISTINCT l.version
      FROM  config.upgrade_log l
            JOIN config.db_patch_dependencies d ON (l.version = ANY(d.deprecates))
      WHERE d.db_patch = $1
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_deprecates(my_db_patch text) OWNER TO evergreen;

--
-- Name: upgrade_list_applied_superseded(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.upgrade_list_applied_superseded(my_db_patch text) RETURNS SETOF text
    LANGUAGE sql
    AS $_$
    SELECT  db_patch
      FROM  config.db_patch_dependencies
      WHERE ARRAY[$1]::TEXT[] && supersedes
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_superseded(my_db_patch text) OWNER TO evergreen;

--
-- Name: upgrade_list_applied_supersedes(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.upgrade_list_applied_supersedes(my_db_patch text) RETURNS SETOF evergreen.patch
    LANGUAGE sql
    AS $_$
    SELECT  DISTINCT l.version
      FROM  config.upgrade_log l
            JOIN config.db_patch_dependencies d ON (l.version = ANY(d.supersedes))
      WHERE d.db_patch = $1
$_$;


ALTER FUNCTION evergreen.upgrade_list_applied_supersedes(my_db_patch text) OWNER TO evergreen;

--
-- Name: upgrade_verify_no_dep_conflicts(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.upgrade_verify_no_dep_conflicts(my_db_patch text) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT  COUNT(*) = 0
      FROM  (SELECT * FROM evergreen.upgrade_list_applied_deprecates( $1 )
                UNION
             SELECT * FROM evergreen.upgrade_list_applied_supersedes( $1 )
                UNION
             SELECT * FROM evergreen.upgrade_list_applied_deprecated( $1 )
                UNION
             SELECT * FROM evergreen.upgrade_list_applied_superseded( $1 ))x
$_$;


ALTER FUNCTION evergreen.upgrade_verify_no_dep_conflicts(my_db_patch text) OWNER TO evergreen;

--
-- Name: uppercase(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.uppercase(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
    return uc(shift);
$$;


ALTER FUNCTION evergreen.uppercase(text) OWNER TO evergreen;

--
-- Name: vandelay_import_item_imported_as_inh_fkey(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.vandelay_import_item_imported_as_inh_fkey() RETURNS trigger
    LANGUAGE plpgsql COST 50
    AS $_$
BEGIN   
        IF NEW.imported_as IS NULL THEN
                RETURN NEW;
        END IF;
        PERFORM 1 FROM asset.copy WHERE id = NEW.imported_as;
        IF NOT FOUND THEN
                RAISE foreign_key_violation USING MESSAGE = FORMAT(
                        $$Referenced asset.copy id not found, imported_as:%s$$, NEW.imported_as
                );
        END IF;
        RETURN NEW;
END;
$_$;


ALTER FUNCTION evergreen.vandelay_import_item_imported_as_inh_fkey() OWNER TO evergreen;

--
-- Name: xml_escape(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.xml_escape(str text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT REPLACE(REPLACE(REPLACE($1,
       '&', '&amp;'),
       '<', '&lt;'),
       '>', '&gt;');
$_$;


ALTER FUNCTION evergreen.xml_escape(str text) OWNER TO evergreen;

--
-- Name: xml_famous5_to_text(text); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.xml_famous5_to_text(text) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
 SELECT REPLACE(
            REPLACE(
                REPLACE(
                    REPLACE(
                        REPLACE( $1, '&lt;', '<'),
                        '&gt;',
                        '>'
                    ),
                    '&apos;',
                    $$'$$
                ), -- ' ... vim
                '&quot;',
                '"'
            ),
            '&amp;',
            '&'
        );
$_$;


ALTER FUNCTION evergreen.xml_famous5_to_text(text) OWNER TO evergreen;

--
-- Name: xml_pretty_print(xml); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.xml_pretty_print(input xml) RETURNS xml
    LANGUAGE sql
    AS $_$
SELECT xslt_process($1::text,
$$<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    version="1.0">
   <xsl:output method="xml" omit-xml-declaration="yes" indent="yes"/>
   <xsl:strip-space elements="*"/>
   <xsl:template match="@*|node()">
     <xsl:copy>
       <xsl:apply-templates select="@*|node()"/>
     </xsl:copy>
   </xsl:template>
 </xsl:stylesheet>
$$::text)::XML
$_$;


ALTER FUNCTION evergreen.xml_pretty_print(input xml) OWNER TO evergreen;

--
-- Name: FUNCTION xml_pretty_print(input xml); Type: COMMENT; Schema: evergreen; Owner: evergreen
--

COMMENT ON FUNCTION evergreen.xml_pretty_print(input xml) IS 'Simple pretty printer for XML, as written by Andrew Dunstan at http://goo.gl/zBHIk';


--
-- Name: z3950_attr_name_is_valid(); Type: FUNCTION; Schema: evergreen; Owner: evergreen
--

CREATE FUNCTION evergreen.z3950_attr_name_is_valid() RETURNS trigger
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN

  PERFORM * FROM config.z3950_attr WHERE name = NEW.z3950_attr_type;

  IF FOUND THEN
    RETURN NULL;
  END IF;

  RAISE EXCEPTION '% is not a valid Z39.50 attribute type', NEW.z3950_attr_type;

END;
$$;


ALTER FUNCTION evergreen.z3950_attr_name_is_valid() OWNER TO evergreen;

--
-- Name: FUNCTION z3950_attr_name_is_valid(); Type: COMMENT; Schema: evergreen; Owner: evergreen
--

COMMENT ON FUNCTION evergreen.z3950_attr_name_is_valid() IS '
Used by a config.z3950_index_field_map constraint trigger
to verify z3950_attr_type maps.
';


--
-- Name: autosuggest_prepare_tsquery(text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.autosuggest_prepare_tsquery(orig text) RETURNS text[]
    LANGUAGE plpgsql
    AS $_$
DECLARE
    orig_ended_in_space     BOOLEAN;
    result                  RECORD;
    plain                   TEXT;
    normalized              TEXT;
BEGIN
    orig_ended_in_space := orig ~ E'\\s$';

    orig := ARRAY_TO_STRING(
        evergreen.regexp_split_to_array(orig, E'\\W+'), ' '
    );

    normalized := public.naco_normalize(orig); -- also trim()s
    plain := trim(orig);

    IF NOT orig_ended_in_space THEN
        plain := plain || ':*';
        normalized := normalized || ':*';
    END IF;

    plain := ARRAY_TO_STRING(
        evergreen.regexp_split_to_array(plain, E'\\s+'), ' & '
    );
    normalized := ARRAY_TO_STRING(
        evergreen.regexp_split_to_array(normalized, E'\\s+'), ' & '
    );

    RETURN ARRAY[normalized, plain];
END;
$_$;


ALTER FUNCTION metabib.autosuggest_prepare_tsquery(orig text) OWNER TO evergreen;

--
-- Name: browse(integer[], text, integer, integer, boolean, bigint, integer, text, text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.browse(search_field integer[], browse_term text, context_org integer DEFAULT NULL::integer, context_loc_group integer DEFAULT NULL::integer, staff boolean DEFAULT false, pivot_id bigint DEFAULT NULL::bigint, result_limit integer DEFAULT 10, ccvm_ctype text DEFAULT NULL::text, ccvm_code text DEFAULT NULL::text) RETURNS SETOF metabib.flat_browse_entry_appearance
    LANGUAGE plpgsql ROWS 10
    AS $_$
DECLARE
    core_query              TEXT;
    back_query              TEXT;
    forward_query           TEXT;
    pivot_sort_value        TEXT;
    pivot_sort_fallback     TEXT;
    context_locations       INT[];
    browse_superpage_size   INT;
    results_skipped         INT := 0;
    back_limit              INT;
    back_to_pivot           INT;
    forward_limit           INT;
    forward_to_pivot        INT;
    ccvm_filter_join        TEXT := '';
BEGIN
    -- First, find the pivot if we were given a browse term but not a pivot.
    IF pivot_id IS NULL THEN
        pivot_id := metabib.browse_pivot(search_field, browse_term);
    END IF;

    SELECT INTO pivot_sort_value truncated_sort_value 
        FROM metabib.browse_entry WHERE id = pivot_id;

    -- Bail if we couldn't find a pivot.
    IF pivot_sort_value IS NULL THEN
        RETURN;
    END IF;

    -- Transform the context_loc_group argument (if any) (logc at the
    -- TPAC layer) into a form we'll be able to use.
    IF context_loc_group IS NOT NULL THEN
        SELECT INTO context_locations ARRAY_AGG(location)
            FROM asset.copy_location_group_map
            WHERE lgroup = context_loc_group;
    END IF;

    -- Get the configured size of browse superpages.
    SELECT INTO browse_superpage_size COALESCE(value::INT,100)     -- NULL ok
        FROM config.global_flag
        WHERE enabled AND name = 'opac.browse.holdings_visibility_test_limit';

    -- First we're going to search backward from the pivot, then we're going
    -- to search forward.  In each direction, we need two limits.  At the
    -- lesser of the two limits, we delineate the edge of the result set
    -- we're going to return.  At the greater of the two limits, we find the
    -- pivot value that would represent an offset from the current pivot
    -- at a distance of one "page" in either direction, where a "page" is a
    -- result set of the size specified in the "result_limit" argument.
    --
    -- The two limits in each direction make four derived values in total,
    -- and we calculate them now.
    back_limit := CEIL(result_limit::FLOAT / 2);
    back_to_pivot := result_limit;
    forward_limit := result_limit / 2;
    forward_to_pivot := result_limit - 1;

    IF ccvm_ctype IS NOT NULL THEN
        ccvm_filter_join := $x$
            AND EXISTS (
                SELECT TRUE FROM metabib.browse_entry_def_map mbedm
                JOIN metabib.record_attr_vector_list vec ON (vec.source = mbedm.source)
                JOIN config.coded_value_map ccvm ON (
                    ccvm.ctype = $x$ || QUOTE_LITERAL(ccvm_ctype) || $x$ 
                    AND ccvm.id = ANY (vec.vlist)
                    AND ccvm.code = $x$ || QUOTE_LITERAL(ccvm_code) || $x$
                )
                WHERE mbedm.entry = mbe.id
            )
        $x$;
    END IF;

    -- This is the meat of the SQL query that finds browse entries.  We'll
    -- pass this to a function which uses it with a cursor, so that individual
    -- rows may be fetched in a loop until some condition is satisfied, without
    -- waiting for a result set of fixed size to be collected all at once.
    core_query := '
SELECT  mbe.id,
        mbe.value,
        mbe.sort_value
  FROM  metabib.browse_entry mbe
  WHERE mbe.metabib_fields_cache && ' || quote_literal(search_field) ||
      ccvm_filter_join ||
      ' AND ';

    -- This is the variant of the query for browsing backward.
    back_query := core_query ||
        ' mbe.truncated_sort_value <= ' || quote_literal(pivot_sort_value) ||
    ' ORDER BY mbe.truncated_sort_value DESC ';

    -- This variant browses forward.
    forward_query := core_query ||
        ' mbe.truncated_sort_value > ' || quote_literal(pivot_sort_value) ||
    ' ORDER BY mbe.truncated_sort_value ';

    -- We now call the function which applies a cursor to the provided
    -- queries, stopping at the appropriate limits and also giving us
    -- the next page's pivot.
    RETURN QUERY
        SELECT * FROM metabib.staged_browse(
            back_query, search_field, context_org, context_locations,
            staff, browse_superpage_size, TRUE, back_limit, back_to_pivot,
            ccvm_ctype, ccvm_code
        ) UNION
        SELECT * FROM metabib.staged_browse(
            forward_query, search_field, context_org, context_locations,
            staff, browse_superpage_size, FALSE, forward_limit, forward_to_pivot,
            ccvm_ctype, ccvm_code
        ) ORDER BY row_number DESC;
END;
$_$;


ALTER FUNCTION metabib.browse(search_field integer[], browse_term text, context_org integer, context_loc_group integer, staff boolean, pivot_id bigint, result_limit integer, ccvm_ctype text, ccvm_code text) OWNER TO evergreen;

--
-- Name: browse(text, text, integer, integer, boolean, bigint, integer, text, text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.browse(search_class text, browse_term text, context_org integer DEFAULT NULL::integer, context_loc_group integer DEFAULT NULL::integer, staff boolean DEFAULT false, pivot_id bigint DEFAULT NULL::bigint, result_limit integer DEFAULT 10, ccvm_ctype text DEFAULT NULL::text, ccvm_code text DEFAULT NULL::text) RETURNS SETOF metabib.flat_browse_entry_appearance
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY SELECT * FROM metabib.browse(
        (SELECT COALESCE(ARRAY_AGG(id), ARRAY[]::INT[])
            FROM config.metabib_field WHERE field_class = search_class),
        browse_term,
        context_org,
        context_loc_group,
        staff,
        pivot_id,
        result_limit,
        ccvm_ctype,
        ccvm_code
    );
END;
$$;


ALTER FUNCTION metabib.browse(search_class text, browse_term text, context_org integer, context_loc_group integer, staff boolean, pivot_id bigint, result_limit integer, ccvm_ctype text, ccvm_code text) OWNER TO evergreen;

--
-- Name: browse_authority_is_unauthorized(bigint, integer[]); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.browse_authority_is_unauthorized(mbe_id bigint, fields integer[]) RETURNS TABLE(auth_tag character, atag integer, record bigint)
    LANGUAGE sql
    AS $_$
    SELECT 
        acsaf.tag AS auth_tag,
        ash.atag AS atag,
        ash.record AS auth_record
    FROM metabib.browse_entry_simple_heading_map mbeshm
    JOIN authority.simple_heading ash ON (mbeshm.simple_heading = ash.id)
    JOIN authority.control_set_authority_field acsaf
        ON (acsaf.id = ash.atag AND acsaf.tag LIKE '4__')
    JOIN authority.control_set_auth_field_metabib_field_map_refs refs_map
        ON (acsaf.id = refs_map.authority_field)
    JOIN config.metabib_field cmf ON 
        (cmf.id = refs_map.metabib_field AND cmf.id = ANY($2))
    WHERE mbeshm.entry = $1
    LIMIT 1
$_$;


ALTER FUNCTION metabib.browse_authority_is_unauthorized(mbe_id bigint, fields integer[]) OWNER TO evergreen;

--
-- Name: browse_authority_is_unauthorized(bigint, text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.browse_authority_is_unauthorized(mbe_id bigint, field_class text) RETURNS TABLE(auth_tag character, atag integer, record bigint)
    LANGUAGE sql
    AS $_$
    SELECT metabib.browse_authority_is_unauthorized(
        mbe_id, (SELECT ARRAY_AGG(id) 
            FROM config.metabib_field WHERE field_class = $2)
    );
$_$;


ALTER FUNCTION metabib.browse_authority_is_unauthorized(mbe_id bigint, field_class text) OWNER TO evergreen;

--
-- Name: browse_authority_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.browse_authority_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    -- So far this function is not called.  When its usage is known, depending on
    -- how it is called/used we can use that information to modify it to use the new
    -- broken apart tables for both metabib.browse_entry and metabib.browse_entry_simple_heading_map
    --ver1.1  updated with kmain-806 - added note
    SELECT  mbe.id
      FROM  metabib.browse_entry mbe
    --        JOIN metabib.browse_entry_simple_heading_map mbeshm ON ( mbeshm.entry = mbe.id )
    --        JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
    --        JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
    --            ash.atag = map.authority_field
    --            AND map.metabib_field = ANY($1)
    --        )
      WHERE mbe.sort_value >= public.naco_normalize($2)
      ORDER BY mbe.sort_value, mbe.value LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_authority_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_authority_refs_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.browse_authority_refs_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    SELECT  mbe.id
      FROM  metabib.browse_entry mbe
            JOIN metabib.browse_entry_simple_heading_map mbeshm ON ( mbeshm.entry = mbe.id )
            JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
            JOIN authority.control_set_auth_field_metabib_field_map_refs_only map ON (
                ash.atag = map.authority_field
                AND map.metabib_field = ANY($1)
            )
      WHERE mbe.sort_value >= public.naco_normalize($2)
      ORDER BY mbe.sort_value, mbe.value LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_authority_refs_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_bib_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.browse_bib_pivot(integer[], text) RETURNS bigint
    LANGUAGE sql STABLE
    AS $_$
    SELECT  mbe.id
      FROM  metabib.browse_entry mbe
            JOIN metabib.browse_entry_def_map mbedm ON (
                mbedm.entry = mbe.id
                AND mbedm.def = ANY($1)
            )
      WHERE mbe.sort_value >= public.naco_normalize($2)
      ORDER BY mbe.sort_value, mbe.value LIMIT 1;
$_$;


ALTER FUNCTION metabib.browse_bib_pivot(integer[], text) OWNER TO evergreen;

--
-- Name: browse_normalize(text, integer); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.browse_normalize(facet_text text, mapped_field integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    normalizer  RECORD;
BEGIN

    FOR normalizer IN
        SELECT  n.func AS func,
                n.param_count AS param_count,
                m.params AS params
          FROM  config.index_normalizer n
                JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
          WHERE m.field = mapped_field AND m.pos < 0
          ORDER BY m.pos LOOP

            EXECUTE 'SELECT ' || normalizer.func || '(' ||
                quote_literal( facet_text ) ||
                CASE
                    WHEN normalizer.param_count > 0
                        THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'') --'
                        ELSE ''
                    END ||
                ')' INTO facet_text;

    END LOOP;

    RETURN facet_text;
END;

$$;


ALTER FUNCTION metabib.browse_normalize(facet_text text, mapped_field integer) OWNER TO evergreen;

--
-- Name: browse_pivot(integer[], text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.browse_pivot(search_field integer[], browse_term text) RETURNS bigint
    LANGUAGE plpgsql STABLE
    AS $_$
-- handles 'search_field' conflict.  using this means I don't
-- have to drop/recreate the function and those that rely on it 
-- just to change the 'search_field' param name.
#variable_conflict use_variable
DECLARE
    sort_value TEXT;
BEGIN
    SELECT INTO sort_value
        CASE WHEN cmf.field_class = 'identifier' THEN 
            public.naco_normalize_keep_decimal($2, '')
        ELSE 
            public.naco_normalize($2)
        END
    FROM config.metabib_field cmf
    WHERE cmf.id = search_field[1];

    RETURN mbe.id FROM metabib.browse_entry mbe
    WHERE mbe.metabib_fields_cache && $1
    AND mbe.truncated_sort_value >= sort_value
    ORDER BY mbe.sort_value LIMIT 1;
END;
$_$;


ALTER FUNCTION metabib.browse_pivot(search_field integer[], browse_term text) OWNER TO evergreen;

--
-- Name: compile_composite_attr(integer); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.compile_composite_attr(cattr_id integer) RETURNS public.query_int
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT metabib.compile_composite_attr(definition) FROM config.composite_attr_entry_definition WHERE coded_value = $1;
$_$;


ALTER FUNCTION metabib.compile_composite_attr(cattr_id integer) OWNER TO evergreen;

--
-- Name: compile_composite_attr(text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.compile_composite_attr(cattr_def text) RETURNS public.query_int
    LANGUAGE plperlu IMMUTABLE
    AS $_X$

    use JSON::XS;

    my $json = shift;
    my $def = decode_json($json);

    die("Composite attribute definition not supplied") unless $def;

    my $_cache = (exists $_SHARED{metabib_compile_composite_attr_cache}) ? 1 : 0;

    return $_SHARED{metabib_compile_composite_attr_cache}{$json}
        if ($_cache && $_SHARED{metabib_compile_composite_attr_cache}{$json});

    sub recurse {
        my $d = shift;
        my $j = '&';
        my @list;

        if (ref $d eq 'HASH') { # node or AND
            if (exists $d->{_attr}) { # it is a node
                my $plan = spi_prepare('SELECT * FROM metabib.full_attr_id_map WHERE attr = $1 AND value = $2', qw/TEXT TEXT/);
                my $id = spi_exec_prepared(
                    $plan, {limit => 1}, $d->{_attr}, $d->{_val}
                )->{rows}[0]{id};
                spi_freeplan($plan);
                return $id;
            } elsif (exists $d->{_not} && scalar(keys(%$d)) == 1) { # it is a NOT
                return '!' . recurse($$d{_not});
            } else { # an AND list
                @list = map { recurse($$d{$_}) } sort keys %$d;
            }
        } elsif (ref $d eq 'ARRAY') {
            $j = '|';
            @list = map { recurse($_) } @$d;
        }

        @list = grep { defined && $_ ne '' } @list;

        return '(' . join($j,@list) . ')' if @list;
        return '';
    }

    my $val = recurse($def) || undef;
    $_SHARED{metabib_compile_composite_attr_cache}{$json} = $val if $_cache;
    return $val;

$_X$;


ALTER FUNCTION metabib.compile_composite_attr(cattr_def text) OWNER TO evergreen;

--
-- Name: compile_composite_attr_cache_disable(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.compile_composite_attr_cache_disable() RETURNS boolean
    LANGUAGE plperlu
    AS $_X$
    delete $_SHARED{metabib_compile_composite_attr_cache};
    return ! exists $_SHARED{metabib_compile_composite_attr_cache};
$_X$;


ALTER FUNCTION metabib.compile_composite_attr_cache_disable() OWNER TO evergreen;

--
-- Name: compile_composite_attr_cache_init(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.compile_composite_attr_cache_init() RETURNS boolean
    LANGUAGE plperlu
    AS $_X$
    $_SHARED{metabib_compile_composite_attr_cache} = {}
        if ! exists $_SHARED{metabib_compile_composite_attr_cache};
    return exists $_SHARED{metabib_compile_composite_attr_cache};
$_X$;


ALTER FUNCTION metabib.compile_composite_attr_cache_init() OWNER TO evergreen;

--
-- Name: compile_composite_attr_cache_invalidate(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.compile_composite_attr_cache_invalidate() RETURNS boolean
    LANGUAGE sql
    AS $$
    SELECT metabib.compile_composite_attr_cache_disable() AND metabib.compile_composite_attr_cache_init();
$$;


ALTER FUNCTION metabib.compile_composite_attr_cache_invalidate() OWNER TO evergreen;

--
-- Name: composite_attr_def_cache_inval_tgr(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.composite_attr_def_cache_inval_tgr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM metabib.compile_composite_attr_cache_invalidate();
    RETURN NULL;
END;
$$;


ALTER FUNCTION metabib.composite_attr_def_cache_inval_tgr() OWNER TO evergreen;

--
-- Name: display_field_normalize_trigger(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.display_field_normalize_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    normalizer  RECORD;
    display_field_text  TEXT;
BEGIN
    display_field_text := NEW.value;

    FOR normalizer IN
        SELECT  n.func AS func,
                n.param_count AS param_count,
                m.params AS params
          FROM  config.index_normalizer n
                JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
          WHERE m.field = NEW.field AND m.pos < 0
          ORDER BY m.pos LOOP

            EXECUTE 'SELECT ' || normalizer.func || '(' ||
                quote_literal( display_field_text ) ||
                CASE
                    WHEN normalizer.param_count > 0
                        THEN ',' || REPLACE(REPLACE(BTRIM(
                            normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                        ELSE ''
                    END ||
                ')' INTO display_field_text;

    END LOOP;

    NEW.value = display_field_text;

    RETURN NEW;
END;
$$;


ALTER FUNCTION metabib.display_field_normalize_trigger() OWNER TO evergreen;

--
-- Name: facet_normalize_trigger(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.facet_normalize_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    normalizer  RECORD;
    facet_text  TEXT;
BEGIN
    facet_text := NEW.value;

    FOR normalizer IN
        SELECT  n.func AS func,
                n.param_count AS param_count,
                m.params AS params
          FROM  config.index_normalizer n
                JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
          WHERE m.field = NEW.field AND m.pos < 0
          ORDER BY m.pos LOOP

            EXECUTE 'SELECT ' || normalizer.func || '(' ||
                quote_literal( facet_text ) ||
                CASE
                    WHEN normalizer.param_count > 0
                        THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                        ELSE ''
                    END ||
                ')' INTO facet_text;

    END LOOP;

    NEW.value = facet_text;

    RETURN NEW;
END;
$$;


ALTER FUNCTION metabib.facet_normalize_trigger() OWNER TO evergreen;

--
-- Name: get_browse_entry_marc_record(bigint, text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.get_browse_entry_marc_record(browse_entry bigint, search_class text) RETURNS text
    LANGUAGE sql STABLE
    AS $$
    SELECT are.marc
    FROM metabib.browse_entry mbe
    JOIN metabib.browse_entry_simple_heading_map mbeshm 
        ON (mbeshm.entry = mbe.id)
    JOIN authority.simple_heading ash ON (ash.id = mbeshm.simple_heading)
    JOIN authority.control_set_authority_field acsaf ON (acsaf.id = ash.atag)
    JOIN authority.record_entry are ON (are.id = ash.record)
    JOIN authority.control_set_auth_field_metabib_field_map_refs map 
        ON (map.authority_field = ash.atag)
    JOIN config.metabib_field cmf ON (cmf.id = map.metabib_field)
    WHERE   mbe.id = browse_entry
        AND acsaf.main_entry IS NULL
        AND NOT are.deleted
        AND cmf.field_class = search_class
    ORDER BY
        -- favor 'lcsh' headings over other thesauri,
        -- falling back to record size as a tie-breaker
        CASE
            WHEN ash.thesaurus = 'lcsh' THEN 1000000
            ELSE LENGTH(are.marc)
        END
    DESC
    LIMIT 1;
$$;


ALTER FUNCTION metabib.get_browse_entry_marc_record(browse_entry bigint, search_class text) OWNER TO evergreen;

--
-- Name: maintain_browse_metabib_fields_cache(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.maintain_browse_metabib_fields_cache() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    entry_id BIGINT;
BEGIN

    SELECT INTO entry_id
        CASE WHEN TG_OP = 'DELETE' THEN OLD.entry ELSE NEW.entry END;
    
    -- distinct list of config.metabib_field IDs which link 
    -- to a given metabib.browse_entry via bib or auth maps.
    UPDATE metabib.browse_entry
    SET metabib_fields_cache = ARRAY(
        SELECT DISTINCT(x.def_id) FROM (
            SELECT mbedm.def AS def_id
                FROM metabib.browse_entry_def_map mbedm
                WHERE mbedm.entry = entry_id
            UNION
            SELECT map.metabib_field AS def_id
                FROM metabib.browse_entry_simple_heading_map mbeshm
                JOIN authority.simple_heading ash ON (mbeshm.simple_heading = ash.id)
                JOIN authority.control_set_auth_field_metabib_field_map_refs map
                    ON (ash.atag = map.authority_field)
                WHERE mbeshm.entry = entry_id
        )x
    )
    WHERE id = entry_id;

    IF TG_OP = 'DELETE' THEN
        -- remove browse entries that link to neither a bib nor auth field
        PERFORM TRUE FROM metabib.browse_entry
        WHERE id = entry_id AND ARRAY_LENGTH(metabib_fields_cache, 1) > 0;

        IF NOT FOUND THEN
            DELETE FROM metabib.browse_entry WHERE id = entry_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION metabib.maintain_browse_metabib_fields_cache() OWNER TO evergreen;

--
-- Name: normalized_field_entry_view(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.normalized_field_entry_view() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

DECLARE
	norm_table		text	:= 	TG_TABLE_SCHEMA || '.normalized_' || TG_TABLE_NAME;
	temp_id			bigint;
BEGIN

IF(TG_OP = 'UPDATE') THEN

EXECUTE 'SELECT id FROM '||norm_table||' WHERE id = '||NEW.id||';' INTO temp_id;

	IF(temp_id IS NOT NULL) THEN
		EXECUTE 'UPDATE '||norm_table||' 
		SET value = '''||search_normalize(NEW.value)||''', ind = get_ind('||NEW.source||','||NEW.field||'), source = '||NEW.source||' WHERE id = '||NEW.id||';';
	ELSE
		EXECUTE 'INSERT INTO '||norm_table||' VALUES ( '||NEW.id||','||NEW.source||', '''||search_normalize(NEW.value)||''', get_ind('||NEW.source||', '||NEW.field||') );';
	END IF;
ELSIF(TG_OP = 'INSERT') THEN

	EXECUTE 'INSERT INTO '||norm_table||' VALUES ( '||NEW.id||','||NEW.source||', '''||search_normalize(NEW.value)||''', get_ind('||NEW.source||', '||NEW.field||') );';

END IF;

RETURN NULL;

END;
$$;


ALTER FUNCTION metabib.normalized_field_entry_view() OWNER TO evergreen;

--
-- Name: reingest_metabib_field_entries(bigint, boolean, boolean, boolean, boolean, integer[]); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.reingest_metabib_field_entries(bib_id bigint, skip_facet boolean DEFAULT false, skip_display boolean DEFAULT false, skip_browse boolean DEFAULT false, skip_search boolean DEFAULT false, only_fields integer[] DEFAULT '{}'::integer[]) RETURNS void
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    fclass          RECORD;
    ind_data        metabib.field_entry_template%ROWTYPE;
    mbe_row         metabib.browse_entry%ROWTYPE;
    mbe_id          BIGINT;
    b_skip_facet    BOOL;
    b_skip_display    BOOL;
    b_skip_browse   BOOL;
    b_skip_search   BOOL;
    value_prepped   TEXT;
    field_list      INT[] := only_fields;
    field_types     TEXT[] := '{}'::TEXT[];
BEGIN

    IF field_list = '{}'::INT[] THEN
        SELECT ARRAY_AGG(id) INTO field_list FROM config.metabib_field;
    END IF;

    SELECT COALESCE(NULLIF(skip_facet, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_facet_indexing' AND enabled)) INTO b_skip_facet;
    SELECT COALESCE(NULLIF(skip_display, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_display_indexing' AND enabled)) INTO b_skip_display;
    SELECT COALESCE(NULLIF(skip_browse, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_browse_indexing' AND enabled)) INTO b_skip_browse;
    SELECT COALESCE(NULLIF(skip_search, FALSE), EXISTS (SELECT enabled FROM config.internal_flag WHERE name =  'ingest.skip_search_indexing' AND enabled)) INTO b_skip_search;

    IF NOT b_skip_facet THEN field_types := field_types || '{facet}'; END IF;
    IF NOT b_skip_display THEN field_types := field_types || '{display}'; END IF;
    IF NOT b_skip_browse THEN field_types := field_types || '{browse}'; END IF;
    IF NOT b_skip_search THEN field_types := field_types || '{search}'; END IF;

    PERFORM * FROM config.internal_flag WHERE name = 'ingest.assume_inserts_only' AND enabled;
    IF NOT FOUND THEN
        IF NOT b_skip_search THEN
            FOR fclass IN SELECT * FROM config.metabib_class LOOP
                -- RAISE NOTICE 'Emptying out %', fclass.name;
                EXECUTE $$DELETE FROM metabib.$$ || fclass.name || $$_field_entry WHERE source = $$ || bib_id;
            END LOOP;
        END IF;
        IF NOT b_skip_facet THEN
            DELETE FROM metabib.facet_entry WHERE source = bib_id;
        END IF;
        IF NOT b_skip_display THEN
            DELETE FROM metabib.display_entry WHERE source = bib_id;
        END IF;
        IF NOT b_skip_browse THEN
            DELETE FROM metabib.browse_entry_def_map WHERE source = bib_id;
        END IF;
    END IF;

    FOR ind_data IN SELECT * FROM biblio.extract_metabib_field_entry( bib_id, ' ', field_types, field_list ) LOOP

        -- don't store what has been normalized away
        CONTINUE WHEN ind_data.value IS NULL;

        IF ind_data.field < 0 THEN
            ind_data.field = -1 * ind_data.field;
        END IF;

        IF ind_data.facet_field AND NOT b_skip_facet THEN
            INSERT INTO metabib.facet_entry (field, source, value)
                VALUES (ind_data.field, ind_data.source, ind_data.value);
        END IF;

        IF ind_data.display_field AND NOT b_skip_display THEN
            INSERT INTO metabib.display_entry (field, source, value)
                VALUES (ind_data.field, ind_data.source, ind_data.value);
        END IF;


        IF ind_data.browse_field AND NOT b_skip_browse THEN
            -- A caveat about this SELECT: this should take care of replacing
            -- old mbe rows when data changes, but not if normalization (by
            -- which I mean specifically the output of
            -- evergreen.oils_tsearch2()) changes.  It may or may not be
            -- expensive to add a comparison of index_vector to index_vector
            -- to the WHERE clause below.

            CONTINUE WHEN ind_data.sort_value IS NULL;


            value_prepped := metabib.browse_normalize(ind_data.value, ind_data.field);

            IF ind_data.browse_nocase THEN
                value_prepped := evergreen.lowercase(value_prepped);
            END IF;

            SELECT INTO mbe_row * FROM metabib.browse_entry
                WHERE
                    MD5(value) = MD5(value_prepped) AND
                    MD5(sort_value) = MD5(ind_data.sort_value);

            IF FOUND THEN
                mbe_id := mbe_row.id;
            ELSE
                INSERT INTO metabib.browse_entry
                    ( value, sort_value, truncated_sort_value, metabib_fields_cache)
                    VALUES (
                        value_prepped,
                        ind_data.sort_value,
                        SUBSTR(ind_data.sort_value, 1, 2048),
                        '{}'
                    );
                mbe_id := CURRVAL('metabib.browse_entry_id_seq'::REGCLASS);
            END IF;

            INSERT INTO metabib.browse_entry_def_map (entry, def, source, authority)
                VALUES (mbe_id, ind_data.field, ind_data.source, ind_data.authority);
        END IF;

        IF ind_data.search_field AND NOT b_skip_search THEN
            -- Avoid inserting duplicate rows
            EXECUTE 'SELECT 1 FROM metabib.' || ind_data.field_class ||
                '_field_entry WHERE field = $1 AND source = $2 AND value = $3'
                INTO mbe_id USING ind_data.field, ind_data.source, ind_data.value;
                -- RAISE NOTICE 'Search for an already matching row returned %', mbe_id;
            IF mbe_id IS NULL THEN
                EXECUTE $$
                INSERT INTO metabib.$$ || ind_data.field_class || $$_field_entry (field, source, value)
                    VALUES ($$ ||
                        quote_literal(ind_data.field) || $$, $$ ||
                        quote_literal(ind_data.source) || $$, $$ ||
                        quote_literal(ind_data.value) ||
                    $$);$$;
            END IF;
        END IF;

    END LOOP;

    IF NOT b_skip_search THEN
        PERFORM metabib.update_combined_index_vectors(bib_id);
    END IF;

    RETURN;
END;

$_X$;


ALTER FUNCTION metabib.reingest_metabib_field_entries(bib_id bigint, skip_facet boolean, skip_display boolean, skip_browse boolean, skip_search boolean, only_fields integer[]) OWNER TO evergreen;

--
-- Name: reingest_metabib_full_rec(bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.reingest_metabib_full_rec(bib_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM * FROM config.internal_flag WHERE name = 'ingest.assume_inserts_only' AND enabled;
    IF NOT FOUND THEN
        DELETE FROM metabib.real_full_rec WHERE record = bib_id;
    END IF;
    INSERT INTO metabib.real_full_rec (record, tag, ind1, ind2, subfield, value)
        SELECT record, tag, ind1, ind2, subfield, value FROM biblio.flatten_marc( bib_id );

    RETURN;
END;
$$;


ALTER FUNCTION metabib.reingest_metabib_full_rec(bib_id bigint) OWNER TO evergreen;

--
-- Name: reingest_record_attributes(bigint, text[], text, boolean); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.reingest_record_attributes(rid bigint, pattr_list text[] DEFAULT NULL::text[], prmarc text DEFAULT NULL::text, rdeleted boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    transformed_xml TEXT;
    rmarc           TEXT := prmarc;
    tmp_val         TEXT;
    prev_xfrm       TEXT;
    normalizer      RECORD;
    xfrm            config.xml_transform%ROWTYPE;
    attr_vector     INT[] := '{}'::INT[];
    attr_vector_tmp INT[];
    attr_list       TEXT[] := pattr_list;
    attr_value      TEXT[];
    norm_attr_value TEXT[];
    tmp_xml         TEXT;
    tmp_array       TEXT[];
    attr_def        config.record_attr_definition%ROWTYPE;
    ccvm_row        config.coded_value_map%ROWTYPE;
    jump_past       BOOL;
BEGIN

    IF attr_list IS NULL OR rdeleted THEN -- need to do the full dance on INSERT or undelete
        SELECT ARRAY_AGG(name) INTO attr_list FROM config.record_attr_definition
        WHERE (
            tag IS NOT NULL OR
            fixed_field IS NOT NULL OR
            xpath IS NOT NULL OR
            phys_char_sf IS NOT NULL OR
            composite
        ) AND (
            filter OR sorter
        );
    END IF;

    IF rmarc IS NULL THEN
        SELECT marc INTO rmarc FROM biblio.record_entry WHERE id = rid;
    END IF;

    FOR attr_def IN SELECT * FROM config.record_attr_definition WHERE NOT composite AND name = ANY( attr_list ) ORDER BY format LOOP

        jump_past := FALSE; -- This gets set when we are non-multi and have found something
        attr_value := '{}'::TEXT[];
        norm_attr_value := '{}'::TEXT[];
        attr_vector_tmp := '{}'::INT[];

        SELECT * INTO ccvm_row FROM config.coded_value_map c WHERE c.ctype = attr_def.name LIMIT 1; 

        IF attr_def.tag IS NOT NULL THEN -- tag (and optional subfield list) selection
            SELECT  ARRAY_AGG(value) INTO attr_value
              FROM  (SELECT * FROM metabib.full_rec ORDER BY tag, subfield) AS x
              WHERE record = rid
                    AND tag LIKE attr_def.tag
                    AND CASE
                        WHEN attr_def.sf_list IS NOT NULL 
                            THEN POSITION(subfield IN attr_def.sf_list) > 0
                        ELSE TRUE
                    END
              GROUP BY tag
              ORDER BY tag;

            IF NOT attr_def.multi THEN
                attr_value := ARRAY[ARRAY_TO_STRING(attr_value, COALESCE(attr_def.joiner,' '))];
                jump_past := TRUE;
            END IF;
        END IF;

        IF NOT jump_past AND attr_def.fixed_field IS NOT NULL THEN -- a named fixed field, see config.marc21_ff_pos_map.fixed_field
            attr_value := attr_value || vandelay.marc21_extract_fixed_field_list(rmarc, attr_def.fixed_field);

            IF NOT attr_def.multi THEN
                attr_value := ARRAY[attr_value[1]];
                jump_past := TRUE;
            END IF;
        END IF;

        IF NOT jump_past AND attr_def.xpath IS NOT NULL THEN -- and xpath expression

            SELECT INTO xfrm * FROM config.xml_transform WHERE name = attr_def.format;
        
            -- See if we can skip the XSLT ... it's expensive
            IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
                -- Can't skip the transform
                IF xfrm.xslt <> '---' THEN
                    transformed_xml := oils_xslt_process(rmarc,xfrm.xslt);
                ELSE
                    transformed_xml := rmarc;
                END IF;
    
                prev_xfrm := xfrm.name;
            END IF;

            IF xfrm.name IS NULL THEN
                -- just grab the marcxml (empty) transform
                SELECT INTO xfrm * FROM config.xml_transform WHERE xslt = '---' LIMIT 1;
                prev_xfrm := xfrm.name;
            END IF;

            FOR tmp_xml IN SELECT UNNEST(oils_xpath(attr_def.xpath, transformed_xml, ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]])) LOOP
                tmp_val := oils_xpath_string(
                                '//*',
                                tmp_xml,
                                COALESCE(attr_def.joiner,' '),
                                ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]
                            );
                IF tmp_val IS NOT NULL AND BTRIM(tmp_val) <> '' THEN
                    attr_value := attr_value || tmp_val;
                    EXIT WHEN NOT attr_def.multi;
                END IF;
            END LOOP;
        END IF;

        IF NOT jump_past AND attr_def.phys_char_sf IS NOT NULL THEN -- a named Physical Characteristic, see config.marc21_physical_characteristic_*_map
            SELECT  ARRAY_AGG(m.value) INTO tmp_array
              FROM  vandelay.marc21_physical_characteristics(rmarc) v
                    LEFT JOIN config.marc21_physical_characteristic_value_map m ON (m.id = v.value)
              WHERE v.subfield = attr_def.phys_char_sf AND (m.value IS NOT NULL AND BTRIM(m.value) <> '')
                    AND ( ccvm_row.id IS NULL OR ( ccvm_row.id IS NOT NULL AND v.id IS NOT NULL) );

            attr_value := attr_value || tmp_array;

            IF NOT attr_def.multi THEN
                attr_value := ARRAY[attr_value[1]];
            END IF;

        END IF;

                -- apply index normalizers to attr_value
        FOR tmp_val IN SELECT value FROM UNNEST(attr_value) x(value) LOOP
            FOR normalizer IN
                SELECT  n.func AS func,
                        n.param_count AS param_count,
                        m.params AS params
                  FROM  config.index_normalizer n
                        JOIN config.record_attr_index_norm_map m ON (m.norm = n.id)
                  WHERE attr = attr_def.name
                  ORDER BY m.pos LOOP
                    EXECUTE 'SELECT ' || normalizer.func || '(' ||
                    COALESCE( quote_literal( tmp_val ), 'NULL' ) ||
                        CASE
                            WHEN normalizer.param_count > 0
                                THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                                ELSE ''
                            END ||
                    ')' INTO tmp_val;

            END LOOP;
            IF tmp_val IS NOT NULL AND tmp_val <> '' THEN
                -- note that a string that contains only blanks
                -- is a valid value for some attributes
                norm_attr_value := norm_attr_value || tmp_val;
            END IF;
        END LOOP;
        
        IF attr_def.filter THEN
            -- Create unknown uncontrolled values and find the IDs of the values
            IF ccvm_row.id IS NULL THEN
                FOR tmp_val IN SELECT value FROM UNNEST(norm_attr_value) x(value) LOOP
                    IF tmp_val IS NOT NULL AND BTRIM(tmp_val) <> '' THEN
                        BEGIN -- use subtransaction to isolate unique constraint violations
                            INSERT INTO metabib.uncontrolled_record_attr_value ( attr, value ) VALUES ( attr_def.name, tmp_val );
                        EXCEPTION WHEN unique_violation THEN END;
                    END IF;
                END LOOP;

                SELECT ARRAY_AGG(id) INTO attr_vector_tmp FROM metabib.uncontrolled_record_attr_value WHERE attr = attr_def.name AND value = ANY( norm_attr_value );
            ELSE
                SELECT ARRAY_AGG(id) INTO attr_vector_tmp FROM config.coded_value_map WHERE ctype = attr_def.name AND code = ANY( norm_attr_value );
            END IF;

            -- Add the new value to the vector
            attr_vector := attr_vector || attr_vector_tmp;
        END IF;

        IF attr_def.sorter THEN
            DELETE FROM metabib.record_sorter WHERE source = rid AND attr = attr_def.name;
            IF norm_attr_value[1] IS NOT NULL THEN
                INSERT INTO metabib.record_sorter (source, attr, value) VALUES (rid, attr_def.name, norm_attr_value[1]);
            END IF;
        END IF;

    END LOOP;

/* We may need to rewrite the vlist to contain
   the intersection of new values for requested
   attrs and old values for ignored attrs. To
   do this, we take the old attr vlist and
   subtract any values that are valid for the
   requested attrs, and then add back the new
   set of attr values. */

    IF ARRAY_LENGTH(pattr_list, 1) > 0 THEN 
        SELECT vlist INTO attr_vector_tmp FROM metabib.record_attr_vector_list WHERE source = rid;
        SELECT attr_vector_tmp - ARRAY_AGG(id::INT) INTO attr_vector_tmp FROM metabib.full_attr_id_map WHERE attr = ANY (pattr_list);
        attr_vector := attr_vector || attr_vector_tmp;
    END IF;

    -- On to composite attributes, now that the record attrs have been pulled.  Processed in name order, so later composite
    -- attributes can depend on earlier ones.
    PERFORM metabib.compile_composite_attr_cache_init();
    FOR attr_def IN SELECT * FROM config.record_attr_definition WHERE composite AND name = ANY( attr_list ) ORDER BY name LOOP

        FOR ccvm_row IN SELECT * FROM config.coded_value_map c WHERE c.ctype = attr_def.name ORDER BY value LOOP

            tmp_val := metabib.compile_composite_attr( ccvm_row.id );
            CONTINUE WHEN tmp_val IS NULL OR tmp_val = ''; -- nothing to do

            IF attr_def.filter THEN
                IF attr_vector @@ tmp_val::query_int THEN
                    attr_vector = attr_vector + intset(ccvm_row.id);
                    EXIT WHEN NOT attr_def.multi;
                END IF;
            END IF;

            IF attr_def.sorter THEN
                IF attr_vector @@ tmp_val THEN
                    DELETE FROM metabib.record_sorter WHERE source = rid AND attr = attr_def.name;
                    INSERT INTO metabib.record_sorter (source, attr, value) VALUES (rid, attr_def.name, ccvm_row.code);
                END IF;
            END IF;

        END LOOP;

    END LOOP;

    IF ARRAY_LENGTH(attr_vector, 1) > 0 THEN
        IF rdeleted THEN -- initial insert OR revivication
            DELETE FROM metabib.record_attr_vector_list WHERE source = rid;
            INSERT INTO metabib.record_attr_vector_list (source, vlist) VALUES (rid, attr_vector);
        ELSE
            UPDATE metabib.record_attr_vector_list SET vlist = attr_vector WHERE source = rid;
        END IF;
    END IF;

END;

$$;


ALTER FUNCTION metabib.reingest_record_attributes(rid bigint, pattr_list text[], prmarc text, rdeleted boolean) OWNER TO evergreen;

--
-- Name: remap_metarecord_for_bib(bigint, text, boolean, boolean); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.remap_metarecord_for_bib(bib_id bigint, fp text, bib_is_deleted boolean DEFAULT false, retain_deleted boolean DEFAULT false) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    new_mapping     BOOL := TRUE;
    source_count    INT;
    old_mr          BIGINT;
    tmp_mr          metabib.metarecord%ROWTYPE;
    deleted_mrs     BIGINT[];
BEGIN

    -- We need to make sure we're not a deleted master record of an MR
    IF bib_is_deleted THEN
        IF NOT retain_deleted THEN -- Go away for any MR that we're master of, unless retained
            DELETE FROM metabib.metarecord_source_map WHERE source = bib_id;
        END IF;

        FOR old_mr IN SELECT id FROM metabib.metarecord WHERE master_record = bib_id LOOP

            -- Now, are there any more sources on this MR?
            SELECT COUNT(*) INTO source_count FROM metabib.metarecord_source_map WHERE metarecord = old_mr;

            IF source_count = 0 AND NOT retain_deleted THEN -- No other records
                deleted_mrs := ARRAY_APPEND(deleted_mrs, old_mr); -- Just in case...
                DELETE FROM metabib.metarecord WHERE id = old_mr;

            ELSE -- indeed there are. Update it with a null cache and recalcualated master record
                UPDATE  metabib.metarecord
                  SET   mods = NULL,
                        master_record = (SELECT id FROM biblio.record_entry WHERE fingerprint = fp AND NOT deleted ORDER BY quality DESC, id ASC LIMIT 1)
                  WHERE id = old_mr;
            END IF;
        END LOOP;

    ELSE -- insert or update

        FOR tmp_mr IN SELECT m.* FROM metabib.metarecord m JOIN metabib.metarecord_source_map s ON (s.metarecord = m.id) WHERE s.source = bib_id LOOP

            -- Find the first fingerprint-matching
            IF old_mr IS NULL AND fp = tmp_mr.fingerprint THEN
                old_mr := tmp_mr.id;
                new_mapping := FALSE;

            ELSE -- Our fingerprint changed ... maybe remove the old MR
                DELETE FROM metabib.metarecord_source_map WHERE metarecord = tmp_mr.id AND source = bib_id; -- remove the old source mapping
                SELECT COUNT(*) INTO source_count FROM metabib.metarecord_source_map WHERE metarecord = tmp_mr.id;
                IF source_count = 0 THEN -- No other records
                    deleted_mrs := ARRAY_APPEND(deleted_mrs, tmp_mr.id);
                    DELETE FROM metabib.metarecord WHERE id = tmp_mr.id;
                END IF;
            END IF;

        END LOOP;

        -- we found no suitable, preexisting MR based on old source maps
        IF old_mr IS NULL THEN
            SELECT id INTO old_mr FROM metabib.metarecord WHERE fingerprint = fp; -- is there one for our current fingerprint?

            IF old_mr IS NULL THEN -- nope, create one and grab its id
                INSERT INTO metabib.metarecord ( fingerprint, master_record ) VALUES ( fp, bib_id );
                SELECT id INTO old_mr FROM metabib.metarecord WHERE fingerprint = fp;

            ELSE -- indeed there is. update it with a null cache and recalcualated master record
                UPDATE  metabib.metarecord
                  SET   mods = NULL,
                        master_record = (SELECT id FROM biblio.record_entry WHERE fingerprint = fp AND NOT deleted ORDER BY quality DESC, id ASC LIMIT 1)
                  WHERE id = old_mr;
            END IF;

        ELSE -- there was one we already attached to, update its mods cache and master_record
            UPDATE  metabib.metarecord
              SET   mods = NULL,
                    master_record = (SELECT id FROM biblio.record_entry WHERE fingerprint = fp AND NOT deleted ORDER BY quality DESC, id ASC LIMIT 1)
              WHERE id = old_mr;
        END IF;

        IF new_mapping THEN
            INSERT INTO metabib.metarecord_source_map (metarecord, source) VALUES (old_mr, bib_id); -- new source mapping
        END IF;

    END IF;

    IF ARRAY_UPPER(deleted_mrs,1) > 0 THEN
        UPDATE action.hold_request SET target = old_mr WHERE target IN ( SELECT unnest(deleted_mrs) ) AND hold_type = 'M'; -- if we had to delete any MRs above, make sure their holds are moved
    END IF;

    RETURN old_mr;

END;
$$;


ALTER FUNCTION metabib.remap_metarecord_for_bib(bib_id bigint, fp text, bib_is_deleted boolean, retain_deleted boolean) OWNER TO evergreen;

--
-- Name: remove_duplicate_browse_entries(); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.remove_duplicate_browse_entries() RETURNS text[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    bib_ids         BIGINT[];
    bib_one         BIGINT;
    auth_ids        BIGINT[];
    auth_one		BIGINT;
    be_ids          BIGINT[];
    be_one          BIGINT;

    result_message  TEXT[];
    dup_count       BIGINT;

BEGIN
    -- ver 1.0 - KMAIN-1119

    ---------------------------------- AUTHOR - Duplicates in metabib.browse_author_entry ----------------------------------
    -- Generate an array of bib id's that point to a duplicate browse_entry
    SELECT INTO bib_ids COALESCE(ARRAY_AGG(DISTINCT mbedm.source), ARRAY[]::BIGINT[])
        FROM metabib.browse_author_entry AS mbe
        JOIN metabib.browse_author_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_author_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the bib id's from array created previously
    FOREACH bib_one IN ARRAY bib_ids
    LOOP
        PERFORM metabib.reingest_metabib_field_entries(bib_one, true, false, true);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_author_entry AS mbe
        LEFT OUTER JOIN metabib.browse_author_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_author_entry AS mbe
        LEFT OUTER JOIN metabib.browse_author_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_author_entry WHERE id = be_one;
    END LOOP;

    -- Generate a list of auth id's that point to a duplicate browse_entry
    SELECT INTO auth_ids COALESCE(ARRAY_AGG(DISTINCT ash.record), ARRAY[]::BIGINT[])
	FROM metabib.browse_author_entry AS mbe
	JOIN metabib.browse_author_entry_simple_heading_map AS mbeshm
	ON mbe.id = mbeshm.entry
	JOIN authority.simple_heading AS ash
	ON ash.id = mbeshm.simple_heading
	WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_author_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the auth id's from array created previously
    FOREACH auth_one IN ARRAY auth_ids
    LOOP
        PERFORM metabib.triggered_reingest_for_auth_id(auth_one);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
        FROM (
        SELECT mbe.id FROM metabib.browse_author_entry AS mbe
        LEFT OUTER JOIN metabib.browse_author_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_author_entry AS mbe
        LEFT OUTER JOIN metabib.browse_author_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_author_entry WHERE id = be_one;
    END LOOP;

    SELECT INTO dup_count COUNT(kyle.sort_value)
    FROM (SELECT COUNT(id), sort_value FROM metabib.browse_author_entry
        GROUP BY sort_value
        HAVING COUNT(id) > 1) as kyle;

    result_message := array_append(result_message, 'browse_author_entry duplicates = ' || dup_count);


    ---------------------------------- SERIES - Duplicates in metabib.browse_series_entry ----------------------------------
    -- Generate an array of bib id's that point to a duplicate browse_entry
    SELECT INTO bib_ids COALESCE(ARRAY_AGG(DISTINCT mbedm.source), ARRAY[]::BIGINT[])
        FROM metabib.browse_series_entry AS mbe
        JOIN metabib.browse_series_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_series_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the bib id's from array created previously
    FOREACH bib_one IN ARRAY bib_ids
    LOOP
        PERFORM metabib.reingest_metabib_field_entries(bib_one, true, false, true);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_series_entry AS mbe
        LEFT OUTER JOIN metabib.browse_series_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_series_entry AS mbe
        LEFT OUTER JOIN metabib.browse_series_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_series_entry WHERE id = be_one;
    END LOOP;

    -- Generate a list of auth id's that point to a duplicate browse_entry
    SELECT INTO auth_ids COALESCE(ARRAY_AGG(DISTINCT ash.record), ARRAY[]::BIGINT[])
	FROM metabib.browse_series_entry AS mbe
	JOIN metabib.browse_series_entry_simple_heading_map AS mbeshm
	ON mbe.id = mbeshm.entry
	JOIN authority.simple_heading AS ash
	ON ash.id = mbeshm.simple_heading
	WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_series_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the auth id's from array created previously
    FOREACH auth_one IN ARRAY auth_ids
    LOOP
        PERFORM metabib.triggered_reingest_for_auth_id(auth_one);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_series_entry AS mbe
        LEFT OUTER JOIN metabib.browse_series_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_series_entry AS mbe
        LEFT OUTER JOIN metabib.browse_series_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_series_entry WHERE id = be_one;
    END LOOP;

    SELECT INTO dup_count COUNT(kyle.sort_value)
    FROM (SELECT COUNT(id), sort_value FROM metabib.browse_series_entry
        GROUP BY sort_value
        HAVING COUNT(id) > 1) as kyle;

    result_message := array_append(result_message, 'browse_series_entry duplicates = ' || dup_count);


    ---------------------------------- SUBJECT - Duplicates in metabib.browse_subject_entry ----------------------------------
    -- Generate an array of bib id's that point to a duplicate browse_entry
    SELECT INTO bib_ids COALESCE(ARRAY_AGG(DISTINCT mbedm.source), ARRAY[]::BIGINT[])
        FROM metabib.browse_subject_entry AS mbe
        JOIN metabib.browse_subject_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_subject_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the bib id's from array created previously
    FOREACH bib_one IN ARRAY bib_ids
    LOOP
        PERFORM metabib.reingest_metabib_field_entries(bib_one, true, false, true);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_subject_entry AS mbe
        LEFT OUTER JOIN metabib.browse_subject_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_subject_entry AS mbe
        LEFT OUTER JOIN metabib.browse_subject_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_subject_entry WHERE id = be_one;
    END LOOP;

    -- Generate a list of auth id's that point to a duplicate browse_entry
    SELECT INTO auth_ids COALESCE(ARRAY_AGG(DISTINCT ash.record), ARRAY[]::BIGINT[])
	FROM metabib.browse_subject_entry AS mbe
	JOIN metabib.browse_subject_entry_simple_heading_map AS mbeshm
	ON mbe.id = mbeshm.entry
	JOIN authority.simple_heading AS ash
	ON ash.id = mbeshm.simple_heading
	WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_subject_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the auth id's from array created previously
    FOREACH auth_one IN ARRAY auth_ids
    LOOP
        PERFORM metabib.triggered_reingest_for_auth_id(auth_one);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_subject_entry AS mbe
        LEFT OUTER JOIN metabib.browse_subject_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_subject_entry AS mbe
        LEFT OUTER JOIN metabib.browse_subject_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_subject_entry WHERE id = be_one;
    END LOOP;

    SELECT INTO dup_count COUNT(kyle.sort_value)
    FROM (SELECT COUNT(id), sort_value FROM metabib.browse_subject_entry
        GROUP BY sort_value
        HAVING COUNT(id) > 1) as kyle;

    result_message := array_append(result_message, 'browse_subject_entry duplicates = ' || dup_count);


    ---------------------------------- TITLE - Duplicates in metabib.browse_title_entry ----------------------------------
    -- Generate an array of bib id's that point to a duplicate browse_entry
    SELECT INTO bib_ids COALESCE(ARRAY_AGG(DISTINCT mbedm.source), ARRAY[]::BIGINT[])
        FROM metabib.browse_title_entry AS mbe
        JOIN metabib.browse_title_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_title_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the bib id's from array created previously
    FOREACH bib_one IN ARRAY bib_ids
    LOOP
        PERFORM metabib.reingest_metabib_field_entries(bib_one, true, false, true);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_title_entry AS mbe
        LEFT OUTER JOIN metabib.browse_title_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_title_entry AS mbe
        LEFT OUTER JOIN metabib.browse_title_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_title_entry WHERE id = be_one;
    END LOOP;

    -- Generate a list of auth id's that point to a duplicate browse_entry
    SELECT INTO auth_ids COALESCE(ARRAY_AGG(DISTINCT ash.record), ARRAY[]::BIGINT[])
	FROM metabib.browse_title_entry AS mbe
	JOIN metabib.browse_title_entry_simple_heading_map AS mbeshm
	ON mbe.id = mbeshm.entry
	JOIN authority.simple_heading AS ash
	ON ash.id = mbeshm.simple_heading
	WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_title_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the auth id's from array created previously
    FOREACH auth_one IN ARRAY auth_ids
    LOOP
        PERFORM metabib.triggered_reingest_for_auth_id(auth_one);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_title_entry AS mbe
        LEFT OUTER JOIN metabib.browse_title_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
        INTERSECT
        SELECT mbe.id FROM metabib.browse_title_entry AS mbe
        LEFT OUTER JOIN metabib.browse_title_entry_simple_heading_map AS mbeshm
        ON mbe.id = mbeshm.entry
        WHERE mbeshm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_title_entry WHERE id = be_one;
    END LOOP;

    SELECT INTO dup_count COUNT(kyle.sort_value)
    FROM (SELECT COUNT(id), sort_value FROM metabib.browse_title_entry
        GROUP BY sort_value
        HAVING COUNT(id) > 1) as kyle;

    result_message := array_append(result_message, 'browse_title_entry duplicates = ' || dup_count);


    ---------------------------------- CALL NUMBER - Duplicates in metabib.browse_call_number_entry ----------------------------------
    -- Generate an array of bib id's that point to a duplicate browse_entry
    SELECT INTO bib_ids COALESCE(ARRAY_AGG(DISTINCT mbedm.source), ARRAY[]::BIGINT[])
        FROM metabib.browse_call_number_entry AS mbe
        JOIN metabib.browse_call_number_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbe.sort_value IN (
            SELECT mbe.sort_value 
            FROM metabib.browse_call_number_entry AS mbe
            GROUP BY mbe.sort_value HAVING COUNT (mbe.id) > 1);

    -- Reingest the bib id's from array created previously
    FOREACH bib_one IN ARRAY bib_ids
    LOOP
        PERFORM metabib.reingest_metabib_field_entries(bib_one, true, false, true);
    END LOOP;

    -- Remove browse_entries that are duplicate and nothing linked to them
    -- Generate an array of browse_entry id's to be deleted
    SELECT INTO be_ids COALESCE(ARRAY_AGG(dbe.id), ARRAY[]::BIGINT[])
    FROM (
        SELECT mbe.id FROM metabib.browse_call_number_entry AS mbe
        LEFT OUTER JOIN metabib.browse_call_number_entry_def_map AS mbedm
        ON mbe.id = mbedm.entry
        WHERE mbedm.id IS NULL
    ) AS dbe;

    -- Delete duplicate browse_entry id's that don't link
    FOREACH be_one IN ARRAY be_ids
    LOOP
        DELETE FROM metabib.browse_call_number_entry WHERE id = be_one;
    END LOOP;

    SELECT INTO dup_count COUNT(kyle.sort_value)
    FROM (SELECT COUNT(id), sort_value FROM metabib.browse_call_number_entry
        GROUP BY sort_value
        HAVING COUNT(id) > 1) as kyle;

    result_message := array_append(result_message, 'browse_call_number_entry duplicates = ' || dup_count);


    RETURN result_message;

END;
$$;


ALTER FUNCTION metabib.remove_duplicate_browse_entries() OWNER TO evergreen;

--
-- Name: search_class_to_registered_components(text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.search_class_to_registered_components(search_class text) RETURNS SETOF record
    LANGUAGE plpgsql ROWS 1
    AS $$
DECLARE
    search_parts        TEXT[];
    field_name          TEXT;
    search_part_count   INTEGER;
    rec                 RECORD;
    registered_class    config.metabib_class%ROWTYPE;
    registered_alias    config.metabib_search_alias%ROWTYPE;
    registered_field    config.metabib_field%ROWTYPE;
BEGIN
    search_parts := REGEXP_SPLIT_TO_ARRAY(search_class, E'\\|');

    search_part_count := ARRAY_LENGTH(search_parts, 1);
    IF search_part_count = 0 THEN
        RETURN;
    ELSE
        SELECT INTO registered_class
            * FROM config.metabib_class WHERE name = search_parts[1];
        IF FOUND THEN
            IF search_part_count < 2 THEN   -- all fields
                rec := (registered_class.name, NULL::INTEGER);
                RETURN NEXT rec;
                RETURN; -- done
            END IF;
            FOR field_name IN SELECT *
                FROM UNNEST(search_parts[2:search_part_count]) LOOP
                SELECT INTO registered_field
                    * FROM config.metabib_field
                    WHERE name = field_name AND
                        field_class = registered_class.name;
                IF FOUND THEN
                    rec := (registered_class.name, registered_field.id);
                    RETURN NEXT rec;
                END IF;
            END LOOP;
        ELSE
            -- maybe we have an alias?
            SELECT INTO registered_alias
                * FROM config.metabib_search_alias WHERE alias=search_parts[1];
            IF NOT FOUND THEN
                RETURN;
            ELSE
                IF search_part_count < 2 THEN   -- return w/e the alias says
                    rec := (
                        registered_alias.field_class, registered_alias.field
                    );
                    RETURN NEXT rec;
                    RETURN; -- done
                ELSE
                    FOR field_name IN SELECT *
                        FROM UNNEST(search_parts[2:search_part_count]) LOOP
                        SELECT INTO registered_field
                            * FROM config.metabib_field
                            WHERE name = field_name AND
                                field_class = registered_alias.field_class;
                        IF FOUND THEN
                            rec := (
                                registered_alias.field_class,
                                registered_field.id
                            );
                            RETURN NEXT rec;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        END IF;
    END IF;
END;
$$;


ALTER FUNCTION metabib.search_class_to_registered_components(search_class text) OWNER TO evergreen;

--
-- Name: set_export_date(bigint, date); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.set_export_date(bib_id bigint, input_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
	PERFORM * FROM metabib.bib_export_data WHERE bib = bib_id;
	IF FOUND THEN 
		UPDATE metabib.bib_export_data SET export_date = input_date
		WHERE bib = bib_id;
	ELSE 
		INSERT INTO metabib.bib_export_data (bib, export_date)
		VALUES (bib_id, input_date);
	END IF;
END;
$$;


ALTER FUNCTION metabib.set_export_date(bib_id bigint, input_date date) OWNER TO evergreen;

--
-- Name: set_import_date(bigint, date); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.set_import_date(bib_id bigint, input_date date) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
	PERFORM * FROM metabib.bib_export_data WHERE bib = bib_id;
	IF FOUND THEN 
		UPDATE metabib.bib_export_data SET import_date = input_date
		WHERE bib = bib_id;
	ELSE 
		INSERT INTO metabib.bib_export_data (bib, import_date)
		VALUES (bib_id, input_date);
	END IF;
END;
$$;


ALTER FUNCTION metabib.set_import_date(bib_id bigint, input_date date) OWNER TO evergreen;

--
-- Name: staged_browse(text, integer[], integer, integer[], boolean, integer, boolean, integer, integer, text, text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.staged_browse(query text, fields integer[], context_org integer, context_locations integer[], staff boolean, browse_superpage_size integer, count_up_from_zero boolean, result_limit integer, next_pivot_pos integer, ccvm_ctype text DEFAULT NULL::text, ccvm_code text DEFAULT NULL::text) RETURNS SETOF metabib.flat_browse_entry_appearance
    LANGUAGE plpgsql ROWS 10
    AS $_$
DECLARE
    curs                    REFCURSOR;
    rec                     RECORD;
    qpfts_query             TEXT;
    aqpfts_query            TEXT;
    afields                 INT[];
    bfields                 INT[];
    result_row              metabib.flat_browse_entry_appearance%ROWTYPE;
    results_skipped         INT := 0;
    row_counter             INT := 0;
    row_number              INT;
    slice_start             INT;
    slice_end               INT;
    full_end                INT;
    all_records             BIGINT[];
    all_brecords             BIGINT[];
    all_arecords            BIGINT[];
    superpage_of_records    BIGINT[];
    superpage_size          INT;
    c_tests                 TEXT := '';
    b_tests                 TEXT := '';
    c_orgs                  INT[];
    unauthorized_entry      RECORD;
BEGIN
    IF count_up_from_zero THEN
        row_number := 0;
    ELSE
        row_number := -1;
    END IF;

    /* JBAS-2485 Skip Holdings Checks
    IF STAFF THEN
        -- include ransendant bibs in staff browse
        SELECT asset.bib_source_default() || '|' INTO b_tests;
    ELSE
        SELECT x.c_attrs, x.b_attrs INTO c_tests, b_tests FROM asset.patron_default_visibility_mask() x;
    END IF;

    -- b_tests supplies its own query_int operator, c_tests does not
    IF c_tests <> '' THEN c_tests := c_tests || '&'; END IF;

    SELECT ARRAY_AGG(id) INTO c_orgs FROM actor.org_unit_descendants(context_org);

    c_tests := c_tests || search.calculate_visibility_attribute_test('circ_lib',c_orgs)
               || '&' || search.calculate_visibility_attribute_test('owning_lib',c_orgs);

    PERFORM 1 FROM config.internal_flag WHERE enabled AND name = 'opac.located_uri.act_as_copy';
    IF FOUND THEN
        b_tests := b_tests || search.calculate_visibility_attribute_test(
            'luri_org',
            (SELECT ARRAY_AGG(id) FROM actor.org_unit_full_path(context_org) x)
        );
    ELSE
        b_tests := b_tests || search.calculate_visibility_attribute_test(
            'luri_org',
            (SELECT ARRAY_AGG(id) FROM actor.org_unit_ancestors(context_org) x)
        );
    END IF;

    IF context_locations THEN
        IF c_tests <> '' THEN c_tests := c_tests || '&'; END IF;
        c_tests := c_tests || search.calculate_visibility_attribute_test('location',context_locations);
    END IF;
    */

    OPEN curs NO SCROLL FOR EXECUTE query;

    LOOP
        FETCH curs INTO rec;
        IF NOT FOUND THEN
            IF result_row.pivot_point IS NOT NULL THEN
                RETURN NEXT result_row;
            END IF;
            RETURN;
        END IF;

        SELECT INTO unauthorized_entry *
        FROM metabib.browse_authority_is_unauthorized(rec.id, fields);

        -- Gather aggregate data based on the MBE row we're looking at now, authority axis
        IF (unauthorized_entry.record IS NOT NULL) THEN
            --unauthorized term belongs to an auth linked to a bib?
            SELECT INTO all_arecords, result_row.sees, afields
                    ARRAY_AGG(DISTINCT abl.bib),
                    STRING_AGG(DISTINCT abl.authority::TEXT, $$,$$),
                    ARRAY_AGG(DISTINCT map.metabib_field)
            FROM authority.bib_linking abl
            INNER JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
                    map.authority_field = unauthorized_entry.atag
                    AND map.metabib_field = ANY(fields)
            )
            WHERE abl.authority = unauthorized_entry.record;
        ELSE
            --do usual procedure
            SELECT INTO all_arecords, result_row.sees, afields
                    ARRAY_AGG(DISTINCT abl.bib), -- bibs to check for visibility
                    STRING_AGG(DISTINCT aal.source::TEXT, $$,$$), -- authority record ids
                    ARRAY_AGG(DISTINCT map.metabib_field) -- authority-tag-linked CMF rows

            FROM  metabib.browse_entry_simple_heading_map mbeshm
                    JOIN authority.simple_heading ash ON ( mbeshm.simple_heading = ash.id )
                    JOIN authority.authority_linking aal ON ( ash.record = aal.source )
                    JOIN authority.bib_linking abl ON ( aal.target = abl.authority )
                    JOIN authority.control_set_auth_field_metabib_field_map_refs map ON (
                        ash.atag = map.authority_field
                        AND map.metabib_field = ANY(fields)
                    )
                    JOIN authority.control_set_authority_field acsaf ON (
                        map.authority_field = acsaf.id
                    )
                    JOIN authority.heading_field ahf ON (ahf.id = acsaf.heading_field)
              WHERE mbeshm.entry = rec.id
              -- KCLS JBAS-2285
              -- For reasons that are not yet entirely clear to me,
              -- KCLS does not want the 'variant' limitation here.
              --AND   ahf.heading_purpose = 'variant'
              ;

        END IF;

        -- Gather aggregate data based on the MBE row we're looking at now, bib axis
        SELECT INTO all_brecords, result_row.authorities, bfields
                ARRAY_AGG(DISTINCT source),
                STRING_AGG(DISTINCT authority::TEXT, $$,$$),
                ARRAY_AGG(DISTINCT def)
          FROM  metabib.browse_entry_def_map
          WHERE entry = rec.id
                AND def = ANY(fields);

        SELECT INTO result_row.fields STRING_AGG(DISTINCT x::TEXT, $$,$$) FROM UNNEST(afields || bfields) x;

        result_row.sources := 0;
        result_row.asources := 0;

        /** Remove refs to linked bib records that do not 
            match the requested ccvm filter */
        IF ccvm_ctype IS NOT NULL THEN

            -- bib-linked bibs
            IF ARRAY_UPPER(all_brecords, 1) IS NOT NULL THEN
                SELECT INTO all_brecords ARRAY_AGG(DISTINCT vec.source)
                FROM metabib.record_attr_vector_list vec
                JOIN config.coded_value_map ccvm
                    ON (
                        ccvm.ctype = ccvm_ctype
                        AND ccvm.code = ccvm_code
                        AND ccvm.id = ANY (vec.vlist)
                    )
                WHERE vec.source = ANY(all_brecords);
            END IF;

            -- auth-linked bibs
            IF ARRAY_UPPER(all_arecords, 1) IS NOT NULL THEN
                SELECT INTO all_arecords ARRAY_AGG(DISTINCT vec.source)
                FROM metabib.record_attr_vector_list vec
                JOIN config.coded_value_map ccvm
                    ON (
                        ccvm.ctype = ccvm_ctype
                        AND ccvm.code = ccvm_code
                        AND ccvm.id = ANY (vec.vlist)
                    )
                WHERE vec.source = ANY(all_arecords);
            END IF;
        END IF;

        -- Bib-linked vis checking
        IF ARRAY_UPPER(all_brecords,1) IS NOT NULL THEN

            /* JBAS-2485 Skip Holdings Checks
            SELECT  INTO result_row.sources COUNT(DISTINCT b.id)
              FROM  biblio.record_entry b
                    LEFT JOIN asset.copy_vis_attr_cache acvac ON (acvac.record = b.id)
              WHERE b.id = ANY(all_brecords[1:browse_superpage_size])
                    AND (
                        acvac.vis_attr_vector @@ c_tests::query_int
                        OR b.vis_attr_vector @@ b_tests::query_int
                    );
            */

            SELECT  INTO result_row.sources COUNT(DISTINCT b.id)
              FROM  biblio.record_entry b
              WHERE b.id = ANY(all_brecords[1:browse_superpage_size]);

            result_row.accurate := TRUE;

        END IF;

        -- Authority-linked vis checking
        IF ARRAY_UPPER(all_arecords,1) IS NOT NULL THEN

            /* JBAS-2485 Skip Holdings Checks
            SELECT  INTO result_row.asources COUNT(DISTINCT b.id)
              FROM  biblio.record_entry b
                    LEFT JOIN asset.copy_vis_attr_cache acvac ON (acvac.record = b.id)
              WHERE b.id = ANY(all_arecords[1:browse_superpage_size])
                    AND (
                        acvac.vis_attr_vector @@ c_tests::query_int
                        OR b.vis_attr_vector @@ b_tests::query_int
                    );
            */

            SELECT  INTO result_row.asources COUNT(DISTINCT b.id)
              FROM  biblio.record_entry b
              WHERE b.id = ANY(all_arecords[1:browse_superpage_size]);

            result_row.aaccurate := TRUE;

        END IF;

        IF result_row.sources > 0 OR result_row.asources > 0 THEN

            -- The function that calls this function needs row_number in order
            -- to correctly order results from two different runs of this
            -- functions.
            result_row.row_number := row_number;

            -- Now, if row_counter is still less than limit, return a row.  If
            -- not, but it is less than next_pivot_pos, continue on without
            -- returning actual result rows until we find
            -- that next pivot, and return it.

            IF row_counter < result_limit THEN
                result_row.browse_entry := rec.id;
                result_row.value := rec.value;

                RETURN NEXT result_row;
            ELSE
                result_row.browse_entry := NULL;
                result_row.authorities := NULL;
                result_row.fields := NULL;
                result_row.value := NULL;
                result_row.sources := NULL;
                result_row.sees := NULL;
                result_row.accurate := NULL;
                result_row.aaccurate := NULL;
                result_row.pivot_point := rec.id;

                IF row_counter >= next_pivot_pos THEN
                    RETURN NEXT result_row;
                    RETURN;
                END IF;
            END IF;

            IF count_up_from_zero THEN
                row_number := row_number + 1;
            ELSE
                row_number := row_number - 1;
            END IF;

            -- row_counter is different from row_number.
            -- It simply counts up from zero so that we know when
            -- we've reached our limit.
            row_counter := row_counter + 1;
        END IF;
    END LOOP;
END;
$_$;


ALTER FUNCTION metabib.staged_browse(query text, fields integer[], context_org integer, context_locations integer[], staff boolean, browse_superpage_size integer, count_up_from_zero boolean, result_limit integer, next_pivot_pos integer, ccvm_ctype text, ccvm_code text) OWNER TO evergreen;

--
-- Name: suggest_browse_entries(text, text, text, integer, integer, integer); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.suggest_browse_entries(raw_query_text text, search_class text, headline_opts text, visibility_org integer, query_limit integer, normalization integer) RETURNS TABLE(value text, field integer, buoyant_and_class_match boolean, field_match boolean, field_weight integer, rank real, buoyant boolean, match text)
    LANGUAGE plpgsql ROWS 10
    AS $_$
DECLARE
    prepared_query_texts    TEXT[];
    query                   TSQUERY;
    plain_query             TSQUERY;
    opac_visibility_join    TEXT;
    search_class_join       TEXT;
    r_fields                RECORD;
    b_tests                 TEXT := '';
BEGIN
    prepared_query_texts := metabib.autosuggest_prepare_tsquery(raw_query_text);

    query := TO_TSQUERY('keyword', prepared_query_texts[1]);
    plain_query := TO_TSQUERY('keyword', prepared_query_texts[2]);

    visibility_org := NULLIF(visibility_org,-1);
    IF visibility_org IS NOT NULL THEN
        PERFORM FROM actor.org_unit WHERE id = visibility_org AND parent_ou IS NULL;
        IF FOUND THEN
            opac_visibility_join := '';
        ELSE
            PERFORM 1 FROM config.internal_flag WHERE enabled AND name = 'opac.located_uri.act_as_copy';
            IF FOUND THEN
                b_tests := search.calculate_visibility_attribute_test(
                    'luri_org',
                    (SELECT ARRAY_AGG(id) FROM actor.org_unit_full_path(visibility_org))
                );
            ELSE
                b_tests := search.calculate_visibility_attribute_test(
                    'luri_org',
                    (SELECT ARRAY_AGG(id) FROM actor.org_unit_ancestors(visibility_org))
                );
            END IF;
            opac_visibility_join := '
    LEFT JOIN asset.copy_vis_attr_cache acvac ON (acvac.record = x.source)
    LEFT JOIN biblio.record_entry b ON (b.id = x.source)
    JOIN vm ON (acvac.vis_attr_vector @@
            (vm.c_attrs || $$&$$ ||
                search.calculate_visibility_attribute_test(
                    $$circ_lib$$,
                    (SELECT ARRAY_AGG(id) FROM actor.org_unit_descendants($4))
                )
            )::query_int
         ) OR (b.vis_attr_vector @@ $$' || b_tests || '$$::query_int)
';
        END IF;
    ELSE
        opac_visibility_join := '';
    END IF;

    -- The following determines whether we only provide suggestsons matching
    -- the user's selected search_class, or whether we show other suggestions
    -- too. The reason for MIN() is that for search_classes like
    -- 'title|proper|uniform' you would otherwise get multiple rows.  The
    -- implication is that if title as a class doesn't have restrict,
    -- nor does the proper field, but the uniform field does, you're going
    -- to get 'false' for your overall evaluation of 'should we restrict?'
    -- To invert that, change from MIN() to MAX().

    SELECT
        INTO r_fields
            MIN(cmc.restrict::INT) AS restrict_class,
            MIN(cmf.restrict::INT) AS restrict_field
        FROM metabib.search_class_to_registered_components(search_class)
            AS _registered (field_class TEXT, field INT)
        JOIN
            config.metabib_class cmc ON (cmc.name = _registered.field_class)
        LEFT JOIN
            config.metabib_field cmf ON (cmf.id = _registered.field);

    -- evaluate 'should we restrict?'
    IF r_fields.restrict_field::BOOL OR r_fields.restrict_class::BOOL THEN
        search_class_join := '
    JOIN
        metabib.search_class_to_registered_components($2)
        AS _registered (field_class TEXT, field INT) ON (
            (_registered.field IS NULL AND
                _registered.field_class = cmf.field_class) OR
            (_registered.field = cmf.id)
        )
    ';
    ELSE
        search_class_join := '
    LEFT JOIN
        metabib.search_class_to_registered_components($2)
        AS _registered (field_class TEXT, field INT) ON (
            _registered.field_class = cmc.name
        )
    ';
    END IF;

    RETURN QUERY EXECUTE '
WITH vm AS ( SELECT * FROM asset.patron_default_visibility_mask() ),
     mbe AS (SELECT * FROM metabib.browse_entry WHERE index_vector @@ $1 LIMIT 10000)
SELECT  DISTINCT
        x.value,
        x.id,
        x.push,
        x.restrict,
        x.weight,
        x.ts_rank_cd,
        x.buoyant,
        TS_HEADLINE(value, $7, $3)
  FROM  (SELECT DISTINCT
                mbe.value,
                cmf.id,
                cmc.buoyant AND _registered.field_class IS NOT NULL AS push,
                _registered.field = cmf.id AS restrict,
                cmf.weight,
                TS_RANK_CD(mbe.index_vector, $1, $6),
                cmc.buoyant,
                mbedm.source
          FROM  metabib.browse_entry_def_map mbedm
                JOIN mbe ON (mbe.id = mbedm.entry)
                JOIN config.metabib_field cmf ON (cmf.id = mbedm.def)
                JOIN config.metabib_class cmc ON (cmf.field_class = cmc.name)
                '  || search_class_join || '
          ORDER BY 3 DESC, 4 DESC NULLS LAST, 5 DESC, 6 DESC, 7 DESC, 1 ASC
          LIMIT 1000) AS x
        ' || opac_visibility_join || '
  ORDER BY 3 DESC, 4 DESC NULLS LAST, 5 DESC, 6 DESC, 7 DESC, 1 ASC
  LIMIT $5
'   -- sic, repeat the order by clause in the outer select too
    USING
        query, search_class, headline_opts,
        visibility_org, query_limit, normalization, plain_query
        ;

    -- sort order:
    --  buoyant AND chosen class = match class
    --  chosen field = match field
    --  field weight
    --  rank
    --  buoyancy
    --  value itself

END;
$_$;


ALTER FUNCTION metabib.suggest_browse_entries(raw_query_text text, search_class text, headline_opts text, visibility_org integer, query_limit integer, normalization integer) OWNER TO evergreen;

--
-- Name: triggered_reingest_for_auth_id(bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.triggered_reingest_for_auth_id(auth_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN
   
   UPDATE config.internal_flag SET enabled = TRUE WHERE name = 'ingest.reingest.force_on_same_marc';

   UPDATE authority.record_entry SET id = id WHERE id = auth_id;

   UPDATE config.internal_flag SET enabled = FALSE WHERE name = 'ingest.reingest.force_on_same_marc';

END;
$$;


ALTER FUNCTION metabib.triggered_reingest_for_auth_id(auth_id bigint) OWNER TO evergreen;

--
-- Name: triggered_reingest_for_bib_id(bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.triggered_reingest_for_bib_id(bib_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
   reingest_count	BIGINT;
BEGIN
   
   UPDATE config.internal_flag SET enabled = TRUE WHERE name = 'ingest.reingest.force_on_same_marc';

   reingest_count = 0;
   
   UPDATE biblio.record_entry SET id = id WHERE id = bib_id;
   reingest_count = reingest_count + 1;

   UPDATE config.internal_flag SET enabled = FALSE WHERE name = 'ingest.reingest.force_on_same_marc';

   RETURN reingest_count;
END;
$$;


ALTER FUNCTION metabib.triggered_reingest_for_bib_id(bib_id bigint) OWNER TO evergreen;

--
-- Name: triggered_reingest_for_bib_set(bigint, bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.triggered_reingest_for_bib_set(start_id bigint, stop_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
   record_id		BIGINT;
   reingest_count	BIGINT;
BEGIN
   
   UPDATE config.internal_flag SET enabled = TRUE WHERE name = 'ingest.reingest.force_on_same_marc';

   reingest_count = 0;
   FOR record_id IN (SELECT id FROM biblio.record_entry WHERE id >= start_id AND id <= stop_id AND NOT deleted ORDER BY id) LOOP

       UPDATE biblio.record_entry SET id = id WHERE id = record_id;
       reingest_count = reingest_count + 1;

   END LOOP;

   UPDATE config.internal_flag SET enabled = FALSE WHERE name = 'ingest.reingest.force_on_same_marc';

   RETURN reingest_count;
END;
$$;


ALTER FUNCTION metabib.triggered_reingest_for_bib_set(start_id bigint, stop_id bigint) OWNER TO evergreen;

--
-- Name: trim_trailing_punctuation(text); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.trim_trailing_punctuation(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    result    TEXT;
    last_char TEXT;
BEGIN
    result := $1;
    last_char = substring(result from '.$');

    IF last_char = ',' THEN
        result := substring(result from '^(.*),$');

    ELSIF last_char = '.' THEN
        IF substring(result from ' \w\.$') IS NULL THEN
            result := substring(result from '^(.*)\.$');
        END IF;
    END IF;

    RETURN result;

END;
$_$;


ALTER FUNCTION metabib.trim_trailing_punctuation(text) OWNER TO evergreen;

--
-- Name: update_combined_index_vectors(bigint); Type: FUNCTION; Schema: metabib; Owner: evergreen
--

CREATE FUNCTION metabib.update_combined_index_vectors(bib_id bigint) RETURNS void
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    rdata       TSVECTOR;
    vclass      TEXT;
    vfield      INT;
    rfields     INT[];
BEGIN
    DELETE FROM metabib.combined_keyword_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_keyword_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.keyword_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_keyword_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.keyword_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_title_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_title_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.title_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_title_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.title_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_author_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_author_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.author_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_author_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.author_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_subject_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_subject_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.subject_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_subject_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.subject_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_series_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_series_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.series_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_series_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.series_field_entry WHERE source = bib_id;

    DELETE FROM metabib.combined_identifier_field_entry WHERE record = bib_id;
    INSERT INTO metabib.combined_identifier_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, field, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.identifier_field_entry WHERE source = bib_id GROUP BY field;
    INSERT INTO metabib.combined_identifier_field_entry(record, metabib_field, index_vector)
        SELECT bib_id, NULL, strip(COALESCE(string_agg(index_vector::TEXT,' '),'')::tsvector)
        FROM metabib.identifier_field_entry WHERE source = bib_id;

    -- For each virtual def, gather the data from the combined real field
    -- entries and append it to the virtual combined entry.
    FOR vfield, rfields IN SELECT virtual, ARRAY_AGG(real)  FROM config.metabib_field_virtual_map GROUP BY virtual LOOP
        SELECT  field_class INTO vclass
          FROM  config.metabib_field
          WHERE id = vfield;

        SELECT  string_agg(index_vector::TEXT,' ')::tsvector INTO rdata
          FROM  metabib.combined_all_field_entry
          WHERE record = bib_id
                AND metabib_field = ANY (rfields);

        BEGIN -- I cannot wait for INSERT ON CONFLICT ... 9.5, though
            EXECUTE $$
                INSERT INTO metabib.combined_$$ || vclass || $$_field_entry
                    (record, metabib_field, index_vector) VALUES ($1, $2, $3)
            $$ USING bib_id, vfield, rdata;
        EXCEPTION WHEN unique_violation THEN
            EXECUTE $$
                UPDATE  metabib.combined_$$ || vclass || $$_field_entry
                  SET   index_vector = index_vector || $3
                  WHERE record = $1
                        AND metabib_field = $2
            $$ USING bib_id, vfield, rdata;
        WHEN OTHERS THEN
            -- ignore and move on
        END;
    END LOOP;
END;
$_X$;


ALTER FUNCTION metabib.update_combined_index_vectors(bib_id bigint) OWNER TO evergreen;

--
-- Name: add_codabar_checkdigit(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.add_codabar_checkdigit(text) RETURNS text
    LANGUAGE plperl STABLE STRICT
    AS $_X$
    my $barcode = shift;

    return $barcode if $barcode !~ /^\d{13,14}$/;
    $barcode = substr($barcode, 0, 13); # ignore 14th digit
    my @digits = split //, $barcode;
    my $total = 0;
    $total += $digits[$_] foreach (1, 3, 5, 7, 9, 11);
    $total += (2 * $digits[$_] >= 10) ? (2 * $digits[$_] - 9) : (2 * $digits[$_]) foreach (0, 2, 4, 6, 8, 10, 12);
    my $remainder = $total % 10;
    my $checkdigit = ($remainder == 0) ? $remainder : 10 - $remainder;
    return $barcode . $checkdigit; 
$_X$;


ALTER FUNCTION migration_tools.add_codabar_checkdigit(text) OWNER TO evergreen;

--
-- Name: address_parse_out_citystatezip(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.address_parse_out_citystatezip(text) RETURNS text[]
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        city_state_zip TEXT := $1;
        city TEXT := '';
        state TEXT := '';
        zip TEXT := '';
    BEGIN
        zip := CASE WHEN city_state_zip ~ E'\\d\\d\\d\\d\\d' THEN REGEXP_REPLACE( city_state_zip, E'^.*(\\d\\d\\d\\d\\d-?\\d*).*$', E'\\1' ) ELSE '' END;
        city_state_zip := REGEXP_REPLACE( city_state_zip, E'^(.*)\\d\\d\\d\\d\\d-?\\d*(.*)$', E'\\1\\2');
        IF city_state_zip ~ ',' THEN
            state := REGEXP_REPLACE( city_state_zip, E'^(.*),(.*)$', E'\\2');
            city := REGEXP_REPLACE( city_state_zip, E'^(.*),(.*)$', E'\\1');
        ELSE
            IF city_state_zip ~ E'\\s+[A-Z][A-Z]\\s*' THEN
                state := REGEXP_REPLACE( city_state_zip, E'^.*,?\\s+([A-Z][A-Z])\\s*.*$', E'\\1' );
                city := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s+[A-Z][A-Z](\\s*.*)$', E'\\1\\2' );
            ELSE
                IF city_state_zip ~ E'^\\S+$'  THEN
                    city := city_state_zip;
                    state := 'N/A';
                ELSE
                    state := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s*(\\S+)\\s*$', E'\\2');
                    city := REGEXP_REPLACE( city_state_zip, E'^(.*?),?\\s*(\\S+)\\s*$', E'\\1');
                END IF;
            END IF;
        END IF;
        RETURN ARRAY[ TRIM(BOTH ' ' FROM city), TRIM(BOTH ' ' FROM state), TRIM(BOTH ' ' FROM zip) ];
    END;
$_$;


ALTER FUNCTION migration_tools.address_parse_out_citystatezip(text) OWNER TO evergreen;

--
-- Name: apply_circ_matrix(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.apply_circ_matrix(tablename text) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- Usage:
--
--   First make sure the circ matrix is loaded and the circulations
--   have been staged to the extent possible (but at the very least
--   circ_lib, target_copy, usr, and *_renewal).  User profiles and
--   circ modifiers must also be in place.
--
--   SELECT migration_tools.apply_circ_matrix('m_pioneer.action_circulation');
--

DECLARE
  circ_lib             INT;
  target_copy          INT;
  usr                  INT;
  is_renewal           BOOLEAN;
  this_duration_rule   INT;
  this_fine_rule       INT;
  this_max_fine_rule   INT;
  rcd                  config.rule_circ_duration%ROWTYPE;
  rrf                  config.rule_recurring_fine%ROWTYPE;
  rmf                  config.rule_max_fine%ROWTYPE;
  circ                 INT;
  n                    INT := 0;
  n_circs              INT;
  
BEGIN

  EXECUTE 'SELECT COUNT(*) FROM ' || tablename || ';' INTO n_circs;

  FOR circ IN EXECUTE ('SELECT id FROM ' || tablename) LOOP

    -- Fetch the correct rules for this circulation
    EXECUTE ('
      SELECT
        circ_lib,
        target_copy,
        usr,
        CASE
          WHEN phone_renewal OR desk_renewal OR opac_renewal THEN TRUE
          ELSE FALSE
        END
      FROM ' || tablename || ' WHERE id = ' || circ || ';')
      INTO circ_lib, target_copy, usr, is_renewal ;
    SELECT
      INTO this_duration_rule,
           this_fine_rule,
           this_max_fine_rule
      duration_rule,
      recurring_fine_rule,
      max_fine_rule
      FROM action.find_circ_matrix_matchpoint(
        circ_lib,
        target_copy,
        usr,
        is_renewal
        );
    SELECT INTO rcd * FROM config.rule_circ_duration
      WHERE id = this_duration_rule;
    SELECT INTO rrf * FROM config.rule_recurring_fine
      WHERE id = this_fine_rule;
    SELECT INTO rmf * FROM config.rule_max_fine
      WHERE id = this_max_fine_rule;

    -- Apply the rules to this circulation
    EXECUTE ('UPDATE ' || tablename || ' c
    SET
      duration_rule = rcd.name,
      recurring_fine_rule = rrf.name,
      max_fine_rule = rmf.name,
      duration = rcd.normal,
      recurring_fine = rrf.normal,
      max_fine =
        CASE rmf.is_percent
          WHEN TRUE THEN (rmf.amount / 100.0) * ac.price
          ELSE rmf.amount
        END,
      renewal_remaining = rcd.max_renewals
    FROM
      config.rule_circ_duration rcd,
      config.rule_recurring_fine rrf,
      config.rule_max_fine rmf,
                        asset.copy ac
    WHERE
      rcd.id = ' || this_duration_rule || ' AND
      rrf.id = ' || this_fine_rule || ' AND
      rmf.id = ' || this_max_fine_rule || ' AND
                        ac.id = c.target_copy AND
      c.id = ' || circ || ';');

    -- Keep track of where we are in the process
    n := n + 1;
    IF (n % 100 = 0) THEN
      RAISE INFO '%', n || ' of ' || n_circs
        || ' (' || (100*n/n_circs) || '%) circs updated.';
    END IF;

  END LOOP;

  RETURN;
END;

$$;


ALTER FUNCTION migration_tools.apply_circ_matrix(tablename text) OWNER TO evergreen;

--
-- Name: apply_circ_matrix_after_20(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.apply_circ_matrix_after_20(tablename text) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- Usage:
--
--   First make sure the circ matrix is loaded and the circulations
--   have been staged to the extent possible (but at the very least
--   circ_lib, target_copy, usr, and *_renewal).  User profiles and
--   circ modifiers must also be in place.
--
--   SELECT migration_tools.apply_circ_matrix('m_pioneer.action_circulation');
--

DECLARE
  circ_lib             INT;
  target_copy          INT;
  usr                  INT;
  is_renewal           BOOLEAN;
  this_duration_rule   INT;
  this_fine_rule       INT;
  this_max_fine_rule   INT;
  rcd                  config.rule_circ_duration%ROWTYPE;
  rrf                  config.rule_recurring_fine%ROWTYPE;
  rmf                  config.rule_max_fine%ROWTYPE;
  circ                 INT;
  n                    INT := 0;
  n_circs              INT;
  
BEGIN

  EXECUTE 'SELECT COUNT(*) FROM ' || tablename || ';' INTO n_circs;

  FOR circ IN EXECUTE ('SELECT id FROM ' || tablename) LOOP

    -- Fetch the correct rules for this circulation
    EXECUTE ('
      SELECT
        circ_lib,
        target_copy,
        usr,
        CASE
          WHEN phone_renewal OR desk_renewal OR opac_renewal THEN TRUE
          ELSE FALSE
        END
      FROM ' || tablename || ' WHERE id = ' || circ || ';')
      INTO circ_lib, target_copy, usr, is_renewal ;
    SELECT
      INTO this_duration_rule,
           this_fine_rule,
           this_max_fine_rule
      (matchpoint).duration_rule,
      (matchpoint).recurring_fine_rule,
      (matchpoint).max_fine_rule
      FROM action.find_circ_matrix_matchpoint(
        circ_lib,
        target_copy,
        usr,
        is_renewal
        );
    SELECT INTO rcd * FROM config.rule_circ_duration
      WHERE id = this_duration_rule;
    SELECT INTO rrf * FROM config.rule_recurring_fine
      WHERE id = this_fine_rule;
    SELECT INTO rmf * FROM config.rule_max_fine
      WHERE id = this_max_fine_rule;

    -- Apply the rules to this circulation
    EXECUTE ('UPDATE ' || tablename || ' c
    SET
      duration_rule = rcd.name,
      recurring_fine_rule = rrf.name,
      max_fine_rule = rmf.name,
      duration = rcd.normal,
      recurring_fine = rrf.normal,
      max_fine =
        CASE rmf.is_percent
          WHEN TRUE THEN (rmf.amount / 100.0) * ac.price
          ELSE rmf.amount
        END,
      renewal_remaining = rcd.max_renewals
    FROM
      config.rule_circ_duration rcd,
      config.rule_recurring_fine rrf,
      config.rule_max_fine rmf,
                        asset.copy ac
    WHERE
      rcd.id = ' || this_duration_rule || ' AND
      rrf.id = ' || this_fine_rule || ' AND
      rmf.id = ' || this_max_fine_rule || ' AND
                        ac.id = c.target_copy AND
      c.id = ' || circ || ';');

    -- Keep track of where we are in the process
    n := n + 1;
    IF (n % 100 = 0) THEN
      RAISE INFO '%', n || ' of ' || n_circs
        || ' (' || (100*n/n_circs) || '%) circs updated.';
    END IF;

  END LOOP;

  RETURN;
END;

$$;


ALTER FUNCTION migration_tools.apply_circ_matrix_after_20(tablename text) OWNER TO evergreen;

--
-- Name: apply_circ_matrix_before_20(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.apply_circ_matrix_before_20(tablename text) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- Usage:
--
--   First make sure the circ matrix is loaded and the circulations
--   have been staged to the extent possible (but at the very least
--   circ_lib, target_copy, usr, and *_renewal).  User profiles and
--   circ modifiers must also be in place.
--
--   SELECT migration_tools.apply_circ_matrix('m_pioneer.action_circulation');
--

DECLARE
  circ_lib             INT;
  target_copy          INT;
  usr                  INT;
  is_renewal           BOOLEAN;
  this_duration_rule   INT;
  this_fine_rule       INT;
  this_max_fine_rule   INT;
  rcd                  config.rule_circ_duration%ROWTYPE;
  rrf                  config.rule_recurring_fine%ROWTYPE;
  rmf                  config.rule_max_fine%ROWTYPE;
  circ                 INT;
  n                    INT := 0;
  n_circs              INT;
  
BEGIN

  EXECUTE 'SELECT COUNT(*) FROM ' || tablename || ';' INTO n_circs;

  FOR circ IN EXECUTE ('SELECT id FROM ' || tablename) LOOP

    -- Fetch the correct rules for this circulation
    EXECUTE ('
      SELECT
        circ_lib,
        target_copy,
        usr,
        CASE
          WHEN phone_renewal OR desk_renewal OR opac_renewal THEN TRUE
          ELSE FALSE
        END
      FROM ' || tablename || ' WHERE id = ' || circ || ';')
      INTO circ_lib, target_copy, usr, is_renewal ;
    SELECT
      INTO this_duration_rule,
           this_fine_rule,
           this_max_fine_rule
      duration_rule,
      recuring_fine_rule,
      max_fine_rule
      FROM action.find_circ_matrix_matchpoint(
        circ_lib,
        target_copy,
        usr,
        is_renewal
        );
    SELECT INTO rcd * FROM config.rule_circ_duration
      WHERE id = this_duration_rule;
    SELECT INTO rrf * FROM config.rule_recurring_fine
      WHERE id = this_fine_rule;
    SELECT INTO rmf * FROM config.rule_max_fine
      WHERE id = this_max_fine_rule;

    -- Apply the rules to this circulation
    EXECUTE ('UPDATE ' || tablename || ' c
    SET
      duration_rule = rcd.name,
      recuring_fine_rule = rrf.name,
      max_fine_rule = rmf.name,
      duration = rcd.normal,
      recuring_fine = rrf.normal,
      max_fine =
        CASE rmf.is_percent
          WHEN TRUE THEN (rmf.amount / 100.0) * ac.price
          ELSE rmf.amount
        END,
      renewal_remaining = rcd.max_renewals
    FROM
      config.rule_circ_duration rcd,
      config.rule_recuring_fine rrf,
      config.rule_max_fine rmf,
                        asset.copy ac
    WHERE
      rcd.id = ' || this_duration_rule || ' AND
      rrf.id = ' || this_fine_rule || ' AND
      rmf.id = ' || this_max_fine_rule || ' AND
                        ac.id = c.target_copy AND
      c.id = ' || circ || ';');

    -- Keep track of where we are in the process
    n := n + 1;
    IF (n % 100 = 0) THEN
      RAISE INFO '%', n || ' of ' || n_circs
        || ' (' || (100*n/n_circs) || '%) circs updated.';
    END IF;

  END LOOP;

  RETURN;
END;

$$;


ALTER FUNCTION migration_tools.apply_circ_matrix_before_20(tablename text) OWNER TO evergreen;

--
-- Name: assign_standing_penalties(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.assign_standing_penalties() RETURNS void
    LANGUAGE plpgsql
    AS $$

-- USAGE: Once circulation data has been loaded, and group penalty thresholds have been set up, run this.
--        This will assign standing penalties as needed.

DECLARE
  org_unit  INT;
  usr       INT;

BEGIN

  FOR org_unit IN EXECUTE ('SELECT DISTINCT org_unit FROM permission.grp_penalty_threshold;') LOOP

    FOR usr IN EXECUTE ('SELECT id FROM actor.usr WHERE NOT deleted;') LOOP
  
      EXECUTE('SELECT actor.calculate_system_penalties(' || usr || ', ' || org_unit || ');');

    END LOOP;

  END LOOP;

  RETURN;

END;

$$;


ALTER FUNCTION migration_tools.assign_standing_penalties() OWNER TO evergreen;

--
-- Name: attempt_cast(text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.attempt_cast(text, text, text) RETURNS record
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        attempt_value ALIAS FOR $1;
        datatype ALIAS FOR $2;
        fail_value ALIAS FOR $3;
        output RECORD;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ' || quote_literal(attempt_value) || '::' || datatype || ' AS a;'
        LOOP
            RETURN output;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            FOR output IN
                EXECUTE 'SELECT ' || quote_literal(fail_value) || '::' || datatype || ' AS a;'
            LOOP
                RETURN output;
            END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.attempt_cast(text, text, text) OWNER TO evergreen;

--
-- Name: attempt_date(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.attempt_date(text, text) RETURNS date
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        attempt_value ALIAS FOR $1;
        fail_value ALIAS FOR $2;
        output DATE;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ' || quote_literal(attempt_value) || '::date AS a;'
        LOOP
            RETURN output;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            FOR output IN
                EXECUTE 'SELECT ' || quote_literal(fail_value) || '::date AS a;'
            LOOP
                RETURN output;
            END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.attempt_date(text, text) OWNER TO evergreen;

--
-- Name: attempt_money(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.attempt_money(text, text) RETURNS numeric
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        attempt_value ALIAS FOR $1;
        fail_value ALIAS FOR $2;
        output NUMERIC(8,2);
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ' || quote_literal(attempt_value) || '::NUMERIC(8,2) AS a;'
        LOOP
            RETURN output;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            FOR output IN
                EXECUTE 'SELECT ' || quote_literal(fail_value) || '::NUMERIC(8,2) AS a;'
            LOOP
                RETURN output;
            END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.attempt_money(text, text) OWNER TO evergreen;

--
-- Name: attempt_phone(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.attempt_phone(text, text) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
  DECLARE
    phone TEXT := $1;
    areacode TEXT := $2;
    temp TEXT := '';
    output TEXT := '';
    n_digits INTEGER := 0;
  BEGIN
    temp := phone;
    temp := REGEXP_REPLACE(temp, '^1*[^0-9]*(?=[0-9])', '');
    temp := REGEXP_REPLACE(temp, '[^0-9]*([0-9]{3})[^0-9]*([0-9]{3})[^0-9]*([0-9]{4})', E'\\1-\\2-\\3');
    n_digits := LENGTH(REGEXP_REPLACE(REGEXP_REPLACE(temp, '(.*)?[a-zA-Z].*', E'\\1') , '[^0-9]', '', 'g'));
    IF n_digits = 7 AND areacode <> '' THEN
      temp := REGEXP_REPLACE(temp, '[^0-9]*([0-9]{3})[^0-9]*([0-9]{4})', E'\\1-\\2');
      output := (areacode || '-' || temp);
    ELSE
      output := temp;
    END IF;
    RETURN output;
  END;

$_$;


ALTER FUNCTION migration_tools.attempt_phone(text, text) OWNER TO evergreen;

--
-- Name: attempt_timestamptz(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.attempt_timestamptz(text, text) RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        attempt_value ALIAS FOR $1;
        fail_value ALIAS FOR $2;
        output TIMESTAMPTZ;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ' || quote_literal(attempt_value) || '::TIMESTAMPTZ AS a;'
        LOOP
            RETURN output;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            FOR output IN
                EXECUTE 'SELECT ' || quote_literal(fail_value) || '::TIMESTAMPTZ AS a;'
            LOOP
                RETURN output;
            END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.attempt_timestamptz(text, text) OWNER TO evergreen;

--
-- Name: base_circ_field_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.base_circ_field_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''base_circ_field_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.base_circ_field_map(text) OWNER TO evergreen;

--
-- Name: base_copy_location_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.base_copy_location_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''base_copy_location_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.base_copy_location_map(text) OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.base_item_dynamic_field_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''base_item_dynamic_field_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.base_item_dynamic_field_map(text) OWNER TO evergreen;

--
-- Name: base_profile_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.base_profile_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''base_profile_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.base_profile_map(text) OWNER TO evergreen;

--
-- Name: build(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.build(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        production_tables TEXT[];
    BEGIN
        --RAISE INFO 'In migration_tools.build(%)', migration_schema;
        SELECT migration_tools.production_tables(migration_schema) INTO STRICT production_tables;
        PERFORM migration_tools.build_base_staging_tables(migration_schema,production_tables);
        PERFORM migration_tools.exec( $1, 'CREATE UNIQUE INDEX ' || migration_schema || '_patron_barcode_key ON ' || migration_schema || '.actor_card ( barcode );' );
        PERFORM migration_tools.exec( $1, 'CREATE UNIQUE INDEX ' || migration_schema || '_patron_usrname_key ON ' || migration_schema || '.actor_usr ( usrname );' );
        PERFORM migration_tools.exec( $1, 'CREATE UNIQUE INDEX ' || migration_schema || '_copy_barcode_key ON ' || migration_schema || '.asset_copy ( barcode );' );
        PERFORM migration_tools.exec( $1, 'CREATE UNIQUE INDEX ' || migration_schema || '_copy_id_key ON ' || migration_schema || '.asset_copy ( id );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_callnum_record_idx ON ' || migration_schema || '.asset_call_number ( record );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_callnum_upper_label_id_lib_idx ON ' || migration_schema || '.asset_call_number ( UPPER(label),id,owning_lib );' );
        PERFORM migration_tools.exec( $1, 'CREATE UNIQUE INDEX ' || migration_schema || '_callnum_label_once_per_lib ON ' || migration_schema || '.asset_call_number ( record,owning_lib,label );' );
    END;
$_$;


ALTER FUNCTION migration_tools.build(text) OWNER TO evergreen;

--
-- Name: build_base_staging_tables(text, text[]); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.build_base_staging_tables(text, text[]) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        production_tables ALIAS FOR $2;
    BEGIN
        --RAISE INFO 'In migration_tools.build_base_staging_tables(%,%)', migration_schema, production_tables;
        FOR i IN array_lower(production_tables,1) .. array_upper(production_tables,1) LOOP
            PERFORM migration_tools.build_specific_base_staging_table(migration_schema,production_tables[i]);
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.build_base_staging_tables(text, text[]) OWNER TO evergreen;

--
-- Name: build_specific_base_staging_table(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.build_specific_base_staging_table(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        production_table ALIAS FOR $2;
        base_staging_table TEXT;
        columns RECORD;
    BEGIN
        base_staging_table = REPLACE( production_table, '.', '_' );
        --RAISE INFO 'In migration_tools.build_specific_base_staging_table(%,%) -> %', migration_schema, production_table, base_staging_table;
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.' || base_staging_table || ' ( LIKE ' || production_table || ' INCLUDING DEFAULTS EXCLUDING CONSTRAINTS );' );
        PERFORM migration_tools.exec( $1, '
            INSERT INTO ' || migration_schema || '.fields_requiring_mapping
                SELECT table_schema, table_name, column_name, data_type
                FROM information_schema.columns 
                WHERE table_schema = ''' || migration_schema || ''' AND table_name = ''' || base_staging_table || ''' AND is_nullable = ''NO'' AND column_default IS NULL;
        ' );
        FOR columns IN 
            SELECT table_schema, table_name, column_name, data_type
            FROM information_schema.columns 
            WHERE table_schema = migration_schema AND table_name = base_staging_table AND is_nullable = 'NO' AND column_default IS NULL
        LOOP
            PERFORM migration_tools.exec( $1, 'ALTER TABLE ' || columns.table_schema || '.' || columns.table_name || ' ALTER COLUMN ' || columns.column_name || ' DROP NOT NULL;' );
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.build_specific_base_staging_table(text, text) OWNER TO evergreen;

--
-- Name: change_call_number(bigint, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.change_call_number(copy_id bigint, new_label text) RETURNS void
    LANGUAGE plpgsql
    AS $$

DECLARE
  old_volume   BIGINT;
  new_volume   BIGINT;
  bib          BIGINT;
  owner        INTEGER;
  old_label    TEXT;
  remainder    BIGINT;

BEGIN

  -- Bail out if asked to change the label to ##URI##
  IF new_label = '##URI##' THEN
    RETURN;
  END IF;

  -- Gather information
  SELECT call_number INTO old_volume FROM asset.copy WHERE id = copy_id;
  SELECT record INTO bib FROM asset.call_number WHERE id = old_volume;
  SELECT owning_lib, label INTO owner, old_label FROM asset.call_number WHERE id = old_volume;

  -- Bail out if the label already is ##URI##
  IF old_label = '##URI##' THEN
    RETURN;
  END IF;

  -- Bail out if the call number label is already correct
  IF new_volume = old_volume THEN
    RETURN;
  END IF;

  -- Check whether we already have a destination volume available
  SELECT id INTO new_volume FROM asset.call_number 
    WHERE 
      record = bib AND
      owning_lib = owner AND
      label = new_label AND
      NOT deleted;

  -- Create destination volume if needed
  IF NOT FOUND THEN
    INSERT INTO asset.call_number (creator, editor, record, owning_lib, label) 
      VALUES (1, 1, bib, owner, new_label);
    SELECT id INTO new_volume FROM asset.call_number
      WHERE 
        record = bib AND
        owning_lib = owner AND
        label = new_label AND
        NOT deleted;
  END IF;

  -- Move copy to destination
  UPDATE asset.copy SET call_number = new_volume WHERE id = copy_id;

  -- Delete source volume if it is now empty
  SELECT id INTO remainder FROM asset.copy WHERE call_number = old_volume AND NOT deleted;
  IF NOT FOUND THEN
    DELETE FROM asset.call_number WHERE id = old_volume;
  END IF;

END;

$$;


ALTER FUNCTION migration_tools.change_call_number(copy_id bigint, new_label text) OWNER TO evergreen;

--
-- Name: change_owning_lib(bigint, integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.change_owning_lib(copy_id bigint, new_owning_lib integer) RETURNS void
    LANGUAGE plpgsql
    AS $$

DECLARE
  old_volume     BIGINT;
  new_volume     BIGINT;
  bib            BIGINT;
  old_owning_lib INTEGER;
	old_label      TEXT;
  remainder      BIGINT;

BEGIN

  -- Gather information
  SELECT call_number INTO old_volume FROM asset.copy WHERE id = copy_id;
  SELECT record INTO bib FROM asset.call_number WHERE id = old_volume;
  SELECT owning_lib, label INTO old_owning_lib, old_label FROM asset.call_number WHERE id = old_volume;

	-- Bail out if the new_owning_lib is not the ID of an org_unit
	IF new_owning_lib NOT IN (SELECT id FROM actor.org_unit) THEN
		RAISE WARNING 
			'% is not a valid actor.org_unit ID; no change made.', 
				new_owning_lib;
		RETURN;
	END IF;

  -- Bail out discreetly if the owning_lib is already correct
  IF new_owning_lib = old_owning_lib THEN
    RETURN;
  END IF;

  -- Check whether we already have a destination volume available
  SELECT id INTO new_volume FROM asset.call_number 
    WHERE 
      record = bib AND
      owning_lib = new_owning_lib AND
      label = old_label AND
      NOT deleted;

  -- Create destination volume if needed
  IF NOT FOUND THEN
    INSERT INTO asset.call_number (creator, editor, record, owning_lib, label) 
      VALUES (1, 1, bib, new_owning_lib, old_label);
    SELECT id INTO new_volume FROM asset.call_number
      WHERE 
        record = bib AND
        owning_lib = new_owning_lib AND
        label = old_label AND
        NOT deleted;
  END IF;

  -- Move copy to destination
  UPDATE asset.copy SET call_number = new_volume WHERE id = copy_id;

  -- Delete source volume if it is now empty
  SELECT id INTO remainder FROM asset.copy WHERE call_number = old_volume AND NOT deleted;
  IF NOT FOUND THEN
    DELETE FROM asset.call_number WHERE id = old_volume;
  END IF;

END;

$$;


ALTER FUNCTION migration_tools.change_owning_lib(copy_id bigint, new_owning_lib integer) OWNER TO evergreen;

--
-- Name: change_owning_lib(bigint, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.change_owning_lib(copy_id bigint, new_owner text) RETURNS void
    LANGUAGE plpgsql
    AS $_$

-- You can use shortnames with this function, which looks up the org unit ID and passes it to change_owning_lib(BIGINT,INTEGER).

DECLARE
	new_owning_lib	INTEGER;

BEGIN

	-- Parse the new_owner as an org unit ID or shortname
	IF new_owner IN (SELECT shortname FROM actor.org_unit) THEN
		SELECT id INTO new_owning_lib FROM actor.org_unit WHERE shortname = new_owner;
		PERFORM migration_tools.change_owning_lib(copy_id, new_owning_lib);
	ELSIF new_owner ~ E'^[0-9]+$' THEN
		IF new_owner::INTEGER IN (SELECT id FROM actor.org_unit) THEN
			RAISE INFO 
				'%',
				E'You don\'t need to put the actor.org_unit ID in quotes; '
					|| E'if you put it in quotes, I\'m going to try to parse it as a shortname first.';
			new_owning_lib := new_owner::INTEGER;
		PERFORM migration_tools.change_owning_lib(copy_id, new_owning_lib);
		END IF;
	ELSE
		RAISE WARNING 
			'% is not a valid actor.org_unit shortname or ID; no change made.', 
			new_owning_lib;
		RETURN;
	END IF;

END;

$_$;


ALTER FUNCTION migration_tools.change_owning_lib(copy_id bigint, new_owner text) OWNER TO evergreen;

--
-- Name: check_ou_depth(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.check_ou_depth() RETURNS void
    LANGUAGE plpgsql
    AS $$

DECLARE
  ou  INT;
	org_unit_depth INT;
	ou_parent INT;
	parent_depth INT;
  errors_found BOOLEAN;
	ou_shortname TEXT;
	parent_shortname TEXT;
	ou_type_name TEXT;
	parent_type TEXT;
	type_id INT;
	type_depth INT;
	type_parent INT;
	type_parent_depth INT;
	proper_parent TEXT;

BEGIN

	errors_found := FALSE;

-- Checking actor.org_unit_type

	FOR type_id IN EXECUTE ('SELECT id FROM actor.org_unit_type ORDER BY id;') LOOP

		SELECT depth FROM actor.org_unit_type WHERE id = type_id INTO type_depth;
		SELECT parent FROM actor.org_unit_type WHERE id = type_id INTO type_parent;

		IF type_parent IS NOT NULL THEN

			SELECT depth FROM actor.org_unit_type WHERE id = type_parent INTO type_parent_depth;

			IF type_depth - type_parent_depth <> 1 THEN
				SELECT name FROM actor.org_unit_type WHERE id = type_id INTO ou_type_name;
				SELECT name FROM actor.org_unit_type WHERE id = type_parent INTO parent_type;
				RAISE INFO 'The % org unit type has a depth of %, but its parent org unit type, %, has a depth of %.',
					ou_type_name, type_depth, parent_type, type_parent_depth;
				errors_found := TRUE;

			END IF;

		END IF;

	END LOOP;

-- Checking actor.org_unit

  FOR ou IN EXECUTE ('SELECT id FROM actor.org_unit ORDER BY shortname;') LOOP

		SELECT parent_ou FROM actor.org_unit WHERE id = ou INTO ou_parent;
		SELECT t.depth FROM actor.org_unit_type t, actor.org_unit o WHERE o.ou_type = t.id and o.id = ou INTO org_unit_depth;
		SELECT t.depth FROM actor.org_unit_type t, actor.org_unit o WHERE o.ou_type = t.id and o.id = ou_parent INTO parent_depth;
		SELECT shortname FROM actor.org_unit WHERE id = ou INTO ou_shortname;
		SELECT shortname FROM actor.org_unit WHERE id = ou_parent INTO parent_shortname;
		SELECT t.name FROM actor.org_unit_type t, actor.org_unit o WHERE o.ou_type = t.id and o.id = ou INTO ou_type_name;
		SELECT t.name FROM actor.org_unit_type t, actor.org_unit o WHERE o.ou_type = t.id and o.id = ou_parent INTO parent_type;

		IF ou_parent IS NOT NULL THEN

			IF	(org_unit_depth - parent_depth <> 1) OR (
				(SELECT parent FROM actor.org_unit_type WHERE name = ou_type_name) <> (SELECT id FROM actor.org_unit_type WHERE name = parent_type)
			) THEN
				RAISE INFO '% (org unit %) is a % (depth %) but its parent, % (org unit %), is a % (depth %).', 
					ou_shortname, ou, ou_type_name, org_unit_depth, parent_shortname, ou_parent, parent_type, parent_depth;
				errors_found := TRUE;
			END IF;

		END IF;

  END LOOP;

	IF NOT errors_found THEN
		RAISE INFO 'No errors found.';
	END IF;

  RETURN;

END;

$$;


ALTER FUNCTION migration_tools.check_ou_depth() OWNER TO evergreen;

--
-- Name: country_code(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.country_code(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value FROM ' || migration_schema || '.config WHERE key = ''country_code'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.country_code(text) OWNER TO evergreen;

--
-- Name: create_cards(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.create_cards(schemaname text) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- USAGE: Make sure the patrons are staged in schemaname.actor_usr_legacy and have 'usrname' assigned.
--        Then SELECT migration_tools.create_cards('m_foo');

DECLARE
	u                    TEXT := schemaname || '.actor_usr_legacy';
	c                    TEXT := schemaname || '.actor_card';
  
BEGIN

	EXECUTE ('DELETE FROM ' || c || ';');
	EXECUTE ('INSERT INTO ' || c || ' (usr, barcode) SELECT id, usrname FROM ' || u || ';');
	EXECUTE ('UPDATE ' || u || ' u SET card = c.id FROM ' || c || ' c WHERE c.usr = u.id;');

  RETURN;

END;

$$;


ALTER FUNCTION migration_tools.create_cards(schemaname text) OWNER TO evergreen;

--
-- Name: debug_exec(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.debug_exec(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        sql ALIAS FOR $2;
        nrows INTEGER;
    BEGIN
        EXECUTE 'UPDATE ' || migration_schema || '.sql_current SET sql = ' || quote_literal(sql) || ';';
        RAISE INFO 'debug_exec sql = %', sql;
        EXECUTE sql;
        GET DIAGNOSTICS nrows = ROW_COUNT;
        PERFORM migration_tools.log(migration_schema,sql,nrows);
    EXCEPTION
        WHEN OTHERS THEN 
            RAISE EXCEPTION '!!!!!!!!!!! state = %, msg = %, sql = %', SQLSTATE, SQLERRM, sql;
    END;
$_$;


ALTER FUNCTION migration_tools.debug_exec(text, text) OWNER TO evergreen;

--
-- Name: exec(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.exec(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        sql ALIAS FOR $2;
        nrows INTEGER;
    BEGIN
        EXECUTE 'UPDATE ' || migration_schema || '.sql_current SET sql = ' || quote_literal(sql) || ';';
        --RAISE INFO '%', sql;
        EXECUTE sql;
        GET DIAGNOSTICS nrows = ROW_COUNT;
        PERFORM migration_tools.log(migration_schema,sql,nrows);
    EXCEPTION
        WHEN OTHERS THEN 
            RAISE EXCEPTION '!!!!!!!!!!! state = %, msg = %, sql = %', SQLSTATE, SQLERRM, sql;
    END;
$_$;


ALTER FUNCTION migration_tools.exec(text, text) OWNER TO evergreen;

--
-- Name: expand_barcode(text, text, integer, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.expand_barcode(text, text, integer, text, text) RETURNS text
    LANGUAGE plperl STABLE
    AS $_$
    my ($barcode, $prefix, $maxlen, $pad, $suffix) = @_;

    # default case
    return unless defined $barcode;

    $prefix     = '' unless defined $prefix;
    $maxlen ||= 14;
    $pad        = '0' unless defined $pad;
    $suffix     = '' unless defined $suffix;

    # bail out if adding prefix and suffix would bring new barcode over max length
    return $barcode if (length($prefix) + length($barcode) + length($suffix)) > $maxlen;

    my $new_barcode = $barcode;
    if ($pad ne '') {
        my $pad_length = $maxlen - length($prefix) - length($suffix);
        if (length($barcode) < $pad_length) {
            # assuming we always want padding on the left
            # also assuming that it is possible to have the pad string be longer than 1 character
            $new_barcode = substr($pad x ($pad_length - length($barcode)), 0, $pad_length - length($barcode)) . $new_barcode;
        }
    }

    # bail out if adding prefix and suffix would bring new barcode over max length
    return $barcode if (length($prefix) + length($new_barcode) + length($suffix)) > $maxlen;

    return "$prefix$new_barcode$suffix";
$_$;


ALTER FUNCTION migration_tools.expand_barcode(text, text, integer, text, text) OWNER TO evergreen;

--
-- Name: init(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.init(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        sql TEXT;
    BEGIN
        EXECUTE 'DROP TABLE IF EXISTS ' || migration_schema || '.sql_current;';
        EXECUTE 'CREATE TABLE ' || migration_schema || '.sql_current ( sql TEXT);';
        EXECUTE 'INSERT INTO ' || migration_schema || '.sql_current ( sql ) VALUES ( '''' );';
        BEGIN
            SELECT 'CREATE TABLE ' || migration_schema || '.sql_log ( time TIMESTAMP NOT NULL DEFAULT NOW(), row_count INTEGER, sql TEXT );' INTO STRICT sql;
            EXECUTE sql;
        EXCEPTION
            WHEN OTHERS THEN 
                RAISE INFO '!!!!!!!!!!! state = %, msg = %, sql = %', SQLSTATE, SQLERRM, sql;
        END;
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.config;' );
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.config ( key TEXT UNIQUE, value TEXT);' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''production_tables'', ''asset.call_number,asset.copy_location,asset.copy,asset.stat_cat,asset.stat_cat_entry,asset.stat_cat_entry_copy_map,asset.copy_note,actor.usr,actor.card,actor.usr_address,actor.stat_cat,actor.stat_cat_entry,actor.stat_cat_entry_usr_map,actor.usr_note,action.circulation,action.hold_request,action.hold_notification,money.grocery,money.billing,money.cash_payment,money.forgive_payment'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''country_code'', ''USA'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.fields_requiring_mapping;' );
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.fields_requiring_mapping( table_schema TEXT, table_name TEXT, column_name TEXT, data_type TEXT);' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.base_profile_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.base_profile_map ( 
            id SERIAL,
            perm_grp_id INTEGER,
            transcribed_perm_group TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''base_profile_map'', ''base_profile_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.base_item_dynamic_field_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.base_item_dynamic_field_map ( 
            id SERIAL,
            evergreen_field TEXT,
            evergreen_value TEXT,
            evergreen_datatype TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_dynamic_lf1_idx ON ' || migration_schema || '.base_item_dynamic_field_map (legacy_field1,legacy_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_dynamic_lf2_idx ON ' || migration_schema || '.base_item_dynamic_field_map (legacy_field2,legacy_value2);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_dynamic_lf3_idx ON ' || migration_schema || '.base_item_dynamic_field_map (legacy_field3,legacy_value3);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''base_item_dynamic_field_map'', ''base_item_dynamic_field_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.base_copy_location_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.base_copy_location_map ( 
            id SERIAL,
            location INTEGER,
            holdable BOOLEAN NOT NULL DEFAULT TRUE,
            hold_verify BOOLEAN NOT NULL DEFAULT FALSE,
            opac_visible BOOLEAN NOT NULL DEFAULT TRUE,
            circulate BOOLEAN NOT NULL DEFAULT TRUE,
            transcribed_location TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_base_copy_location_lf1_idx ON ' || migration_schema || '.base_copy_location_map (legacy_field1,legacy_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_base_copy_location_lf2_idx ON ' || migration_schema || '.base_copy_location_map (legacy_field2,legacy_value2);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_base_copy_location_lf3_idx ON ' || migration_schema || '.base_copy_location_map (legacy_field3,legacy_value3);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_base_copy_location_loc_idx ON ' || migration_schema || '.base_copy_location_map (transcribed_location);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''base_copy_location_map'', ''base_copy_location_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.base_circ_field_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.base_circ_field_map ( 
            id SERIAL,
            circulate BOOLEAN,
            loan_period TEXT,
            max_renewals TEXT,
            max_out TEXT,
            fine_amount TEXT,
            fine_interval TEXT,
            max_fine TEXT,
            item_field1 TEXT,
            item_value1 TEXT,
            item_field2 TEXT,
            item_value2 TEXT,
            patron_field1 TEXT,
            patron_value1 TEXT,
            patron_field2 TEXT,
            patron_value2 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_circ_dynamic_lf1_idx ON ' || migration_schema || '.base_circ_field_map (item_field1,item_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_circ_dynamic_lf2_idx ON ' || migration_schema || '.base_circ_field_map (item_field2,item_value2);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_circ_dynamic_lf3_idx ON ' || migration_schema || '.base_circ_field_map (patron_field1,patron_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_circ_dynamic_lf4_idx ON ' || migration_schema || '.base_circ_field_map (patron_field2,patron_value2);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''base_circ_field_map'', ''base_circ_field_map'' );' );

        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_init'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_init'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.init(text) OWNER TO evergreen;

--
-- Name: insert_856_9(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.insert_856_9(text, text) RETURNS text
    LANGUAGE plperlu STABLE
    AS $_$

  ## USAGE: UPDATE biblio.record_entry SET marc = migration_tools.insert_856_9(marc, 'ABC') WHERE [...];

  my ($marcxml, $shortname) = @_;

  use MARC::Record;
  use MARC::File::XML;

  my $xml = $marcxml;

  eval {
    my $marc = MARC::Record->new_from_xml($marcxml, 'UTF-8');

    foreach my $field ( $marc->field('856') ) {
      if ( scalar(grep( /(contentreserve|netlibrary|overdrive)\.com/i, $field->subfield('u'))) > 0 &&
           ! ( $field->as_string('9') =~ m/$shortname/ ) ) {
        $field->add_subfields( '9' => $shortname );
				$field->update( ind2 => '0');
      }
    }

    $xml = $marc->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;
  };

  return $xml;

$_$;


ALTER FUNCTION migration_tools.insert_856_9(text, text) OWNER TO evergreen;

--
-- Name: insert_base_into_production(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.insert_base_into_production(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        production_tables TEXT[];
    BEGIN
        --RAISE INFO 'In migration_tools.insert_into_production(%)', migration_schema;
        SELECT migration_tools.production_tables(migration_schema) INTO STRICT production_tables;
        FOR i IN array_lower(production_tables,1) .. array_upper(production_tables,1) LOOP
            PERFORM migration_tools.insert_into_production(migration_schema,production_tables[i]);
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.insert_base_into_production(text) OWNER TO evergreen;

--
-- Name: insert_into_production(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.insert_into_production(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        production_table ALIAS FOR $2;
        base_staging_table TEXT;
        columns RECORD;
    BEGIN
        base_staging_table = REPLACE( production_table, '.', '_' );
        --RAISE INFO 'In migration_tools.insert_into_production(%,%) -> %', migration_schema, production_table, base_staging_table;
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || production_table || ' SELECT * FROM ' || migration_schema || '.' || base_staging_table || ';' );
    END;
$_$;


ALTER FUNCTION migration_tools.insert_into_production(text, text) OWNER TO evergreen;

--
-- Name: insert_metarecords_for_incumbent_database(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.insert_metarecords_for_incumbent_database() RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
  INSERT INTO metabib.metarecord (fingerprint, master_record)
    SELECT  DISTINCT ON (b.fingerprint) b.fingerprint, b.id
      FROM  biblio.record_entry b
      WHERE NOT b.deleted
        AND b.id IN (SELECT r.id FROM biblio.record_entry r LEFT JOIN metabib.metarecord_source_map k ON (k.source = r.id) WHERE k.id IS NULL AND r.fingerprint IS NOT NULL)
        AND NOT EXISTS ( SELECT 1 FROM metabib.metarecord WHERE fingerprint = b.fingerprint )
      ORDER BY b.fingerprint, b.quality DESC;
  INSERT INTO metabib.metarecord_source_map (metarecord, source)
    SELECT  m.id, r.id
      FROM  biblio.record_entry r
        JOIN metabib.metarecord m USING (fingerprint)
      WHERE NOT r.deleted
        AND r.id IN (SELECT b.id FROM biblio.record_entry b LEFT JOIN metabib.metarecord_source_map k ON (k.source = b.id) WHERE k.id IS NULL);
END;
    
$$;


ALTER FUNCTION migration_tools.insert_metarecords_for_incumbent_database() OWNER TO evergreen;

--
-- Name: insert_metarecords_for_pristine_database(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.insert_metarecords_for_pristine_database() RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN
  INSERT INTO metabib.metarecord (fingerprint, master_record)
    SELECT  DISTINCT ON (b.fingerprint) b.fingerprint, b.id
      FROM  biblio.record_entry b
      WHERE NOT b.deleted
        AND b.id IN (SELECT r.id FROM biblio.record_entry r LEFT JOIN metabib.metarecord_source_map k ON (k.source = r.id) WHERE k.id IS NULL AND r.fingerprint IS NOT NULL)
        AND NOT EXISTS ( SELECT 1 FROM metabib.metarecord WHERE fingerprint = b.fingerprint )
      ORDER BY b.fingerprint, b.quality DESC;
  INSERT INTO metabib.metarecord_source_map (metarecord, source)
    SELECT  m.id, r.id
      FROM  biblio.record_entry r
      JOIN  metabib.metarecord m USING (fingerprint)
     WHERE  NOT r.deleted;
END;
  
$$;


ALTER FUNCTION migration_tools.insert_metarecords_for_pristine_database() OWNER TO evergreen;

--
-- Name: insert_tags(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.insert_tags(text, text) RETURNS text
    LANGUAGE plperlu STABLE
    AS $_X$

  my ($marcxml, $tags) = @_;

  use MARC::Record;
  use MARC::File::XML;

  my $xml = $marcxml;

  eval {
    my $marc = MARC::Record->new_from_xml($marcxml, 'UTF-8');
    my $to_insert = MARC::Record->new_from_xml("<record>$tags</record>", 'UTF-8');

    my @incumbents = ();

    foreach my $field ( $marc->fields() ) {
      push @incumbents, $field->as_formatted();
    }

    foreach $field ( $to_insert->fields() ) {
      if (!grep {$_ eq $field->as_formatted()} @incumbents) {
        $marc->insert_fields_ordered( ($field) );
      }
    }

    $xml = $marc->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;
  };

  return $xml;

$_X$;


ALTER FUNCTION migration_tools.insert_tags(text, text) OWNER TO evergreen;

--
-- Name: is_blank(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.is_blank(text) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
  BEGIN
    RETURN CASE WHEN $1 = '' THEN TRUE ELSE FALSE END;
  END;
$_$;


ALTER FUNCTION migration_tools.is_blank(text) OWNER TO evergreen;

--
-- Name: is_staff_profile(integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.is_staff_profile(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
  DECLARE
    profile ALIAS FOR $1;
  BEGIN
    RETURN CASE WHEN 'Staff' IN (select (permission.grp_ancestors(profile)).name) THEN TRUE ELSE FALSE END;
  END;
$_$;


ALTER FUNCTION migration_tools.is_staff_profile(integer) OWNER TO evergreen;

--
-- Name: keyword(integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.keyword(breid integer) RETURNS void
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    ind_data        metabib.field_entry_template%ROWTYPE;
    old_mr          INT;
    tmp_mr          metabib.metarecord%ROWTYPE;
    source_count    INT;
    deleted_mrs     INT[];
    uris            TEXT[];
    uri_xml         TEXT;
    uri_label       TEXT;
    uri_href        TEXT;
    uri_use         TEXT;
    uri_owner       TEXT;
    uri_owner_id    INT;
    uri_id          INT;
    uri_cn_id       INT;
    uri_map_id      INT;

    ind_vector      TSVECTOR;

    fclass          RECORD;
BEGIN

    -- And now the indexing data
    FOR ind_data IN SELECT * FROM biblio.extract_metabib_field_entry( breid ) LOOP
        IF ind_data.field < 0 THEN
            ind_vector = '';
            ind_data.field = -1 * ind_data.field;
        ELSE
            ind_vector = NULL;
        END IF;

        EXECUTE $$
            INSERT INTO metabib.$$ || ind_data.field_class || $$_field_entry (field, source, value, index_vector)
                VALUES ($$ ||
                    quote_literal(ind_data.field) || $$, $$ ||
                    quote_literal(ind_data.source) || $$, $$ ||
                    quote_literal(ind_data.value) || $$, $$ ||
                    COALESCE(quote_literal(ind_vector),'NULL'::TEXT) ||
                $$);$$;
    END LOOP;

END;
$_X$;


ALTER FUNCTION migration_tools.keyword(breid integer) OWNER TO evergreen;

--
-- Name: log(text, text, integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.log(text, text, integer) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        sql ALIAS FOR $2;
        nrows ALIAS FOR $3;
    BEGIN
        EXECUTE 'INSERT INTO ' || migration_schema || '.sql_log ( sql, row_count ) VALUES ( ' || quote_literal(sql) || ', ' || nrows || ' );';
    END;
$_$;


ALTER FUNCTION migration_tools.log(text, text, integer) OWNER TO evergreen;

--
-- Name: map_base_circ_table_dynamic(text, text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_base_circ_table_dynamic(text, text, text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        field_map TEXT;
        circ_table ALIAS FOR $2;
        item_table ALIAS FOR $3;
        patron_table ALIAS FOR $4;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        sql_where4 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.base_circ_field_map(migration_schema) INTO STRICT field_map;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || field_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || circ_table || ' AS c SET duration = ' || quote_literal(output.loan_period) || '::INTERVAL, renewal_remaining = ' || quote_literal(output.max_renewals) || '::INTEGER, recuring_fine = ' || quote_literal(output.fine_amount) || '::NUMERIC(6,2), fine_interval = ' || quote_literal(output.fine_interval) || '::INTERVAL, max_fine = ' || quote_literal(output.max_fine) || '::NUMERIC(6,2) FROM ' || field_map || ' AS m, ' || item_table || ' AS i, ' || patron_table || ' AS u WHERE c.usr = u.id AND c.target_copy = i.id AND ';
            sql_where1 := NULLIF(output.item_field1,'') || ' = ' || quote_literal( output.item_value1 ) || ' AND item_field1 = ' || quote_literal(output.item_field1) || ' AND item_value1 = ' || quote_literal(output.item_value1);
            sql_where2 := NULLIF(output.item_field2,'') || ' = ' || quote_literal( output.item_value2 ) || ' AND item_field2 = ' || quote_literal(output.item_field2) || ' AND item_value2 = ' || quote_literal(output.item_value2);
            sql_where3 := NULLIF(output.patron_field1,'') || ' = ' || quote_literal( output.patron_value1 ) || ' AND patron_field1 = ' || quote_literal(output.patron_field1) || ' AND patron_value1 = ' || quote_literal(output.patron_value1);
            sql_where4 := NULLIF(output.patron_field2,'') || ' = ' || quote_literal( output.patron_value2 ) || ' AND patron_field2 = ' || quote_literal(output.patron_field2) || ' AND patron_value2 = ' || quote_literal(output.patron_value2);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || CASE WHEN sql_where3 <> '' AND sql_where4 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where4,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_base_circ_field_mapping'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_base_circ_field_mapping'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_base_circ_table_dynamic(text, text, text, text) OWNER TO evergreen;

--
-- Name: map_base_item_table_dynamic(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_base_item_table_dynamic(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        field_map TEXT;
        item_table ALIAS FOR $2;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.base_item_dynamic_field_map(migration_schema) INTO STRICT field_map;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || field_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || item_table || ' AS i SET ' || output.evergreen_field || E' = ' || quote_literal(output.evergreen_value) || '::' || output.evergreen_datatype || E' FROM ' || field_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_base_item_mapping_dynamic'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_base_item_mapping_dynamic'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_base_item_table_dynamic(text, text) OWNER TO evergreen;

--
-- Name: map_base_item_table_locations(text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_base_item_table_locations(text, text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        base_copy_location_map TEXT;
        item_table ALIAS FOR $2;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.base_copy_location_map(migration_schema) INTO STRICT base_copy_location_map;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || base_copy_location_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || item_table || ' AS i SET location = m.location FROM ' || base_copy_location_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_base_item_mapping_locations'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_base_item_mapping_locations'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_base_item_table_locations(text, text) OWNER TO evergreen;

--
-- Name: map_base_patron_profile(text, text, integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_base_patron_profile(text, text, integer) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        profile_map TEXT;
        patron_table ALIAS FOR $2;
        default_patron_profile ALIAS FOR $3;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.base_profile_map(migration_schema) INTO STRICT profile_map;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || profile_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || patron_table || ' AS u SET profile = perm_grp_id FROM ' || profile_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        PERFORM migration_tools.exec( $1, 'UPDATE ' || patron_table || ' AS u SET profile = ' || quote_literal(default_patron_profile) || ' WHERE profile IS NULL;'  );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_base_patron_mapping_profile'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_base_patron_mapping_profile'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_base_patron_profile(text, text, integer) OWNER TO evergreen;

--
-- Name: map_subfield(bigint, text, text, text, text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_subfield(bibid bigint, old_marc text, source_tag text, source_sf text, dest_tag text, dest_sf text, map text DEFAULT ''::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
        sf_value        TEXT;
        new_marc        TEXT;
BEGIN
        -- NOTE!!! This will strip the ENTIRE destination tag ... you are warned.
        sf_value := extract_marc_field('biblio.record_entry', bibid, '//*[@tag="' || source_tag || '"][1]/*[@code="' || source_sf || '"][1]');
        -- RAISE NOTICE '%', sf_value;
        sf_value := generic_map_normalizer(sf_value, map);
        -- RAISE NOTICE '%', sf_value;
        -- make sure it's gone
        new_marc := vandelay.strip_field( old_marc, dest_tag);
        -- RAISE NOTICE '%', new_marc;
        new_marc := migration_tools.insert_tags( new_marc, '<datafield tag="'||dest_tag||'"><subfield code="'||dest_sf||'">'||sf_value||'</subfield></datafield>');
        -- RAISE NOTICE '%', new_marc;
        -- UPDATE biblio.record_entry SET marc = new_marc WHERE id = bibid;
        RETURN new_marc;
END;
$$;


ALTER FUNCTION migration_tools.map_subfield(bibid bigint, old_marc text, source_tag text, source_sf text, dest_tag text, dest_sf text, map text) OWNER TO evergreen;

--
-- Name: map_unicorn_circulation(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_circulation(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;

        SELECT '
            UPDATE ' || migration_schema || E'.action_circulation_unicorn c SET
                usr = p.usr FROM ' || migration_schema || E'.actor_card p WHERE p.barcode = l_user_id
        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );

        SELECT '
            UPDATE ' || migration_schema || E'.action_circulation_unicorn c SET
                circ_lib = m.org_id FROM ' || org_map || E' m WHERE l_library = l_charging_lib
        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );

        SELECT '
            UPDATE ' || migration_schema || E'.action_circulation_unicorn c SET
                circ_staff = m.default_circ_staff FROM ' || org_map || E' m WHERE l_library = l_charging_lib
        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );

        SELECT '
            UPDATE ' || migration_schema || E'.action_circulation_unicorn c SET
                target_copy = i.id FROM ' || migration_schema || E'.asset_copy i WHERE i.barcode = l_item_id
        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );

        SELECT '
            UPDATE ' || migration_schema || E'.action_circulation_unicorn AS c SET
                renewal_remaining = 5,
                xact_start = l_date_charged::TIMESTAMP,
                due_date = COALESCE( NULLIF(l_date_due,''NEVER''), ''2030-01-01'' )::TIMESTAMP,
                duration = COALESCE( NULLIF(l_date_due,''NEVER''), ''2030-01-01'' )::TIMESTAMP - l_date_charged::TIMESTAMP,
                recurring_fine = 0.00,
                max_fine = 10.00,
                stop_fines = CASE WHEN l_date_claim_returned <> '''' THEN ''CLAIMSRETURNED'' ELSE NULL END,
                stop_fines_time = CASE WHEN l_date_claim_returned <> '''' THEN l_date_claim_returned::TIMESTAMP ELSE NULL END,
                duration_rule = ' || quote_literal(migration_schema) || E',
                recurring_fine_rule = ' || quote_literal(migration_schema) || E',
                max_fine_rule = ' || quote_literal(migration_schema) || E' 

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_circulation_mapping'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_circulation_mapping'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_circulation(text) OWNER TO evergreen;

--
-- Name: map_unicorn_holds(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_holds(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        item_table TEXT;
        patron_table TEXT;
        user_key_barcode_map TEXT;
        item_key_barcode_map TEXT;
        default_selection_depth INTEGER;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        SELECT migration_tools.unicorn_user_key_barcode_map(migration_schema) INTO STRICT user_key_barcode_map;
        SELECT migration_tools.unicorn_item_key_barcode_map(migration_schema) INTO STRICT item_key_barcode_map;
        SELECT migration_tools.unicorn_default_selection_depth(migration_schema) INTO STRICT default_selection_depth;
        SELECT '

            UPDATE
                ' || migration_schema || '.action_hold_request_unicorn h
            SET
                _item_barcode = BTRIM(im.barcode)
            FROM
                ' || migration_schema || '.item_key_barcode_map im
            WHERE
                h.l_cat_key::TEXT = im.key1 AND
                h.l_call_key::TEXT = im.key2 AND
                h.l_item_key::TEXT = im.key3;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE
                ' || migration_schema || '.action_hold_request_unicorn h
            SET
                _user_barcode = BTRIM(um.barcode)
            FROM
                ' || migration_schema || '.user_key_barcode_map um
            WHERE
                h.l_user_key::TEXT = um.key;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || migration_schema || E'.action_hold_request_unicorn AS h SET

                _bib_id = ( SELECT DISTINCT i._final_eg_bibid FROM ' || item_table || E' AS i WHERE barcode = _item_barcode ),
                current_copy = ( SELECT DISTINCT i.id FROM ' || item_table || E' AS i WHERE barcode = _item_barcode ),
                usr = ( SELECT DISTINCT p.id FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode ),
                request_time = l_hold_date::TIMESTAMP,
                capture_time = CASE
                    WHEN l_item_available = ''Y'' THEN l_hold_date::TIMESTAMP
                    ELSE NULL
                END,
                selection_depth = ' || quote_literal(default_selection_depth) || E',
                selection_ou = ( SELECT DISTINCT p.home_ou FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode ),
                hold_type = CASE -- Let us not trust the Unicorn values
                    WHEN l_hold_type = ''C'' THEN ''C''
                    ELSE ''T''
                END,
                phone_notify = ( SELECT DISTINCT COALESCE(NULLIF(day_phone,''''),NULLIF(evening_phone,''''),NULLIF(other_phone,'''')) FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode );

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || migration_schema || E'.action_hold_request_unicorn AS h SET

                target = CASE
                    WHEN l_hold_type = ''C'' THEN current_copy
                    ELSE _bib_id
                END,
                requestor = usr,
                request_lib = selection_ou,
                pickup_lib = selection_ou;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_hold_mapping'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_hold_mapping'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_holds(text) OWNER TO evergreen;

--
-- Name: map_unicorn_holds_with_pickup_location(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_holds_with_pickup_location(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        item_table TEXT;
        patron_table TEXT;
        user_key_barcode_map TEXT;
        item_key_barcode_map TEXT;
        default_selection_depth INTEGER;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        SELECT migration_tools.unicorn_user_key_barcode_map(migration_schema) INTO STRICT user_key_barcode_map;
        SELECT migration_tools.unicorn_item_key_barcode_map(migration_schema) INTO STRICT item_key_barcode_map;
        SELECT migration_tools.unicorn_default_selection_depth(migration_schema) INTO STRICT default_selection_depth;
        SELECT '

            UPDATE
                ' || migration_schema || '.action_hold_request_unicorn h
            SET
                _item_barcode = BTRIM(im.barcode)
            FROM
                ' || migration_schema || '.item_key_barcode_map im
            WHERE
                h.l_cat_key::TEXT = im.key1 AND
                h.l_call_key::TEXT = im.key2 AND
                h.l_item_key::TEXT = im.key3;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE
                ' || migration_schema || '.action_hold_request_unicorn h
            SET
                _user_barcode = BTRIM(um.barcode)
            FROM
                ' || migration_schema || '.user_key_barcode_map um
            WHERE
                h.l_user_key::TEXT = um.key;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE 
                ' || migration_schema || E'.action_hold_request_unicorn h
            SET
                _bib_id = i._final_eg_bibid
            FROM
                ' || item_table || ' i
            WHERE
                i.barcode = h._item_barcode;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE 
                ' || migration_schema || E'.action_hold_request_unicorn h
            SET
                current_copy = i.id
            FROM
                ' || item_table || ' i
            WHERE
                i.barcode = h._item_barcode;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || migration_schema || E'.action_hold_request_unicorn AS h SET

                usr = ( SELECT DISTINCT p.id FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode ),
                request_time = l_hold_date::TIMESTAMP,
                capture_time = CASE
                    WHEN l_item_available = ''Y'' THEN l_hold_date::TIMESTAMP
                    ELSE NULL
                END,
                selection_depth = ' || quote_literal(default_selection_depth) || E',
                selection_ou = ( SELECT DISTINCT p.home_ou FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode ),
                pickup_lib = ( SELECT DISTINCT id FROM actor.org_unit ou WHERE ou.shortname = l_pickup_lib ),
                hold_type = CASE -- Let us not trust the Unicorn values
                    WHEN l_hold_type = ''C'' THEN ''C''
                    ELSE ''T''
                END,
                phone_notify = ( SELECT DISTINCT COALESCE(NULLIF(day_phone,''''),NULLIF(evening_phone,''''),NULLIF(other_phone,'''')) FROM ' || patron_table || E' AS p WHERE l_user_id = _user_barcode );

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || migration_schema || E'.action_hold_request_unicorn AS h SET

                target = CASE
                    WHEN l_hold_type = ''C'' THEN current_copy
                    ELSE _bib_id
                END,
                requestor = usr,
                request_lib = selection_ou;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_hold_mapping'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_hold_mapping'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_holds_with_pickup_location(text) OWNER TO evergreen;

--
-- Name: map_unicorn_item_table_base(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_item_table_base(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        item_table TEXT;
        default_item_status INTEGER;
        default_item_holdable_flag BOOLEAN;
        default_item_circulate_flag BOOLEAN;
        default_item_creator INTEGER;
        default_item_editor INTEGER;
        default_item_loan_duration INTEGER;
        default_item_fine_level INTEGER;
        default_item_age_protect INTEGER;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        SELECT migration_tools.unicorn_default_item_status(migration_schema) INTO STRICT default_item_status;
        SELECT migration_tools.unicorn_default_item_holdable_flag(migration_schema) INTO STRICT default_item_holdable_flag;
        SELECT migration_tools.unicorn_default_item_circulate_flag(migration_schema) INTO STRICT default_item_circulate_flag;
        SELECT migration_tools.unicorn_default_item_creator(migration_schema) INTO STRICT default_item_creator;
        SELECT migration_tools.unicorn_default_item_editor(migration_schema) INTO STRICT default_item_editor;
        SELECT migration_tools.unicorn_default_item_loan_duration(migration_schema) INTO STRICT default_item_loan_duration;
        SELECT migration_tools.unicorn_default_item_fine_level(migration_schema) INTO STRICT default_item_fine_level;
        SELECT migration_tools.unicorn_default_item_age_protect(migration_schema) INTO STRICT default_item_age_protect;
        SELECT '

            UPDATE ' || item_table || E' AS i SET 

                barcode = migration_tools.rebarcode( l_barcode, (SELECT item_rebarcode_offset FROM ' || org_map || E' AS m WHERE m.l_library = i.l_library) ),
                price = CASE
                    WHEN length(l_price) >= 11 THEN 999999.99
                    WHEN l_price !~ E''^\\\\$?\\\\d*\\\\.\\\\d\\\\d$'' THEN 0.00
                    ELSE COALESCE( NULLIF( REPLACE(REPLACE(l_price,'' '',''''),''$'',''''), '''' ), ''0.00'' )::NUMERIC(8,2)
                END,
                create_date = NULLIF(l_acq_date,'''')::TIMESTAMP,
                edit_date = NULLIF(l_acq_date,'''')::TIMESTAMP,
                status = ' || quote_literal(default_item_status) || E',
                creator = ' || quote_literal(default_item_creator) || E',
                editor = ' || quote_literal(default_item_editor) || E',
                loan_duration = ' || quote_literal(default_item_loan_duration) || E',
                fine_level = ' || quote_literal(default_item_fine_level) || E',
                age_protect = ' || CASE WHEN default_item_age_protect IS NULL THEN 'NULL' ELSE quote_literal(default_item_age_protect) END || E',
                holdable = ' || CASE WHEN default_item_holdable_flag THEN 'TRUE' ELSE 'FALSE' END || E',
                circulate = CASE
                    WHEN l_circ_flag = ''Y'' THEN TRUE
                    WHEN l_circ_flag = ''N'' THEN FALSE
                    ELSE ' || CASE WHEN default_item_circulate_flag THEN 'TRUE' ELSE 'FALSE' END || E'
                END,
                circ_lib = (SELECT org_id FROM ' || org_map || E' AS m WHERE m.l_library = i.l_library)

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_item_mapping_base'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_item_mapping_base'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_item_table_base(text) OWNER TO evergreen;

--
-- Name: map_unicorn_item_table_dynamic(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_item_table_dynamic(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        field_map TEXT;
        item_table TEXT;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.unicorn_item_dynamic_field_map(migration_schema) INTO STRICT field_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || field_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || item_table || ' AS i SET ' || output.evergreen_field || E' = ' || quote_literal(output.evergreen_value) || '::' || output.evergreen_datatype || E' FROM ' || field_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_item_mapping_dynamic'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_item_mapping_dynamic'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_item_table_dynamic(text) OWNER TO evergreen;

--
-- Name: map_unicorn_item_table_locations(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_item_table_locations(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        home_location_map TEXT;
        item_table TEXT;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_home_location_map(migration_schema) INTO STRICT home_location_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || home_location_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || item_table || ' AS i SET location = m.location FROM ' || home_location_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_item_mapping_locations'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_item_mapping_locations'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_item_table_locations(text) OWNER TO evergreen;

--
-- Name: map_unicorn_item_table_volumes(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_item_table_volumes(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        item_table TEXT;
        default_item_creator INTEGER;
        default_item_editor INTEGER;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        SELECT migration_tools.unicorn_default_item_creator(migration_schema) INTO STRICT default_item_creator;
        SELECT migration_tools.unicorn_default_item_editor(migration_schema) INTO STRICT default_item_editor;
        SELECT '

            INSERT INTO ' || migration_schema || E'.asset_call_number ( label, record, owning_lib, creator, editor ) SELECT DISTINCT
                BTRIM(l_call_number),
                _final_eg_bibid,
                (SELECT org_id FROM ' || org_map || E' AS m WHERE m.l_library = i.l_library),
                ' || quote_literal(default_item_creator) || E'::INTEGER,
                ' || quote_literal(default_item_editor) || E'::INTEGER
            FROM ' || item_table || E' AS i WHERE _final_eg_bibid <> -1 ORDER BY 1,2,3;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || item_table || E' AS i SET call_number = COALESCE(

                (SELECT c.id FROM ' || migration_schema || E'.asset_call_number AS c WHERE label = BTRIM(l_call_number) AND record = _final_eg_bibid AND owning_lib = (SELECT org_id FROM ' || org_map || E' AS m WHERE m.l_library = i.l_library)),

                -1 -- Precat

            );

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_item_mapping_volumes'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_item_mapping_volumes'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_item_table_volumes(text) OWNER TO evergreen;

--
-- Name: map_unicorn_money(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_money(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        item_table TEXT;
        patron_table TEXT;
        sql TEXT;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_item_table(migration_schema) INTO STRICT item_table;
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            UPDATE ' || migration_schema || E'.money_grocery_unicorn AS g SET

                usr = ( SELECT p.id FROM ' || patron_table || E' AS p WHERE p.l_user_id = g.l_user_id ),
                xact_start = l_bill_date::TIMESTAMP,
                note = ' || quote_literal(migration_schema) || E',
                billing_location = (SELECT org_id FROM ' || org_map || E' AS m WHERE l_library = l_billing_lib);

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );
        SELECT '

            INSERT INTO ' || migration_schema || E'.money_billing ( xact, amount, billing_type, note) SELECT
                id,
                CASE
                    WHEN l_bill_amt !~ E''^\\\\$?\\\\d*\\\\.\\\\d\\\\d$'' THEN 0.00
                    ELSE COALESCE( NULLIF( REPLACE(REPLACE(l_bill_amt,'' '',''''),''$'',''''), '''' ), ''0.00'' )::NUMERIC(6,2)
                END,
                ''Legacy '' || l_bill_reason,
                COALESCE(''Item: '' || NULLIF(l_item_id,''''), '''')
            FROM ' || migration_schema || E'.money_grocery_unicorn;

        ' INTO sql;
        PERFORM migration_tools.exec( $1, sql );

        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_money_mapping'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_money_mapping'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_money(text) OWNER TO evergreen;

--
-- Name: map_unicorn_patron_profile(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_patron_profile(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        profile_map TEXT;
        patron_table TEXT;
        default_patron_profile INTEGER;
        sql TEXT;
        sql_update TEXT;
        sql_where1 TEXT := '';
        sql_where2 TEXT := '';
        sql_where3 TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.unicorn_profile_map(migration_schema) INTO STRICT profile_map;
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        SELECT migration_tools.unicorn_default_patron_profile(migration_schema) INTO STRICT default_patron_profile;
        FOR output IN 
            EXECUTE 'SELECT * FROM ' || profile_map || E' ORDER BY id;'
        LOOP
            sql_update := 'UPDATE ' || patron_table || ' AS u SET profile = perm_grp_id FROM ' || profile_map || ' AS m WHERE ';
            sql_where1 := NULLIF(output.legacy_field1,'') || ' = ' || quote_literal( output.legacy_value1 ) || ' AND legacy_field1 = ' || quote_literal(output.legacy_field1) || ' AND legacy_value1 = ' || quote_literal(output.legacy_value1);
            sql_where2 := NULLIF(output.legacy_field2,'') || ' = ' || quote_literal( output.legacy_value2 ) || ' AND legacy_field2 = ' || quote_literal(output.legacy_field2) || ' AND legacy_value2 = ' || quote_literal(output.legacy_value2);
            sql_where3 := NULLIF(output.legacy_field3,'') || ' = ' || quote_literal( output.legacy_value3 ) || ' AND legacy_field3 = ' || quote_literal(output.legacy_field3) || ' AND legacy_value3 = ' || quote_literal(output.legacy_value3);
            sql := sql_update || COALESCE(sql_where1,'') || CASE WHEN sql_where1 <> '' AND sql_where2<> ''  THEN ' AND ' ELSE '' END || COALESCE(sql_where2,'') || CASE WHEN sql_where2 <> '' AND sql_where3 <> '' THEN ' AND ' ELSE '' END || COALESCE(sql_where3,'') || ';';
            --RAISE INFO 'sql = %', sql;
            PERFORM migration_tools.exec( $1, sql );
        END LOOP;
        PERFORM migration_tools.exec( $1, 'UPDATE ' || patron_table || ' AS u SET profile = ' || quote_literal(default_patron_profile) || ' WHERE profile IS NULL;'  );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_patron_mapping_profile'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_patron_mapping_profile'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_patron_profile(text) OWNER TO evergreen;

--
-- Name: map_unicorn_patron_table_addresses(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_patron_table_addresses(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        patron_table TEXT;
    BEGIN
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET _address1 = migration_tools.unicorn_make_address(
                        ' || quote_literal(migration_schema) || E',
                        id, l_addr1_std_line1, l_addr1_std_line2, l_addr1_care_of,  l_addr1_std_city, l_addr1_std_state, l_addr1_std_zip, ''Legacy Address #1'' );

        ' );
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET _address2 = migration_tools.unicorn_make_address(
                        ' || quote_literal(migration_schema) || E',
                        id, l_addr2_std_line1, l_addr2_std_line2, l_addr2_care_of,  l_addr2_std_city, l_addr2_std_state, l_addr2_std_zip, ''Legacy Address #2'' );

        ' );
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET _address3 = migration_tools.unicorn_make_address(
                        ' || quote_literal(migration_schema) || E',
                        id, l_addr3_std_line1, l_addr3_std_line2, l_addr3_care_of,  l_addr3_std_city, l_addr3_std_state, l_addr3_std_zip, ''Legacy Address #3'' );

        ' );
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET 

                mailing_address = CASE
                    WHEN l_user_mailingaddr = ''1'' THEN _address1
                    WHEN l_user_mailingaddr = ''2'' THEN _address2
                    WHEN l_user_mailingaddr = ''3'' THEN _address3
                    ELSE COALESCE( _address1, _address2, _address3 )
                END;

        ' );
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET billing_address = mailing_address;

        ' );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_patron_mapping_addresses'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_patron_mapping_addresses'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_patron_table_addresses(text) OWNER TO evergreen;

--
-- Name: map_unicorn_patron_table_base(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_patron_table_base(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        org_map TEXT;
        patron_table TEXT;
        default_net_access_level INTEGER;
    BEGIN
        SELECT migration_tools.unicorn_org_map(migration_schema) INTO STRICT org_map;
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        SELECT migration_tools.unicorn_default_net_access_level(migration_schema) INTO STRICT default_net_access_level;
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET 

                passwd = l_user_pin,
                family_name = BTRIM( l_last_name ),
                first_given_name = BTRIM( l_first_name ),
                second_given_name = BTRIM( l_middle_name ),
                suffix = BTRIM( l_suffix_name ),
                prefix = BTRIM( l_prefix_name ),
                dob = NULLIF( NULLIF(l_birthdate, ''''), ''NEVER'' )::TIMESTAMP,
                create_date = COALESCE( NULLIF( NULLIF(l_user_priv_granted, ''''), ''NEVER'' ), now()::DATE::TEXT )::TIMESTAMP,
                expire_date = COALESCE( NULLIF( NULLIF(l_user_priv_expires, ''''), ''NEVER'' ), ''2030-01-01'' )::TIMESTAMP,
                day_phone = BTRIM(
                    COALESCE( NULLIF(l_addr1_workphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr1_dayphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr2_dayphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr3_dayphone,'''') || '' '', '''' ) 
                ),
                evening_phone = BTRIM(
                    COALESCE( NULLIF(l_addr1_phone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr1_homephone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr2_homephone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr3_homephone,'''') || '' '', '''' ) 
                ),
                other_phone = BTRIM(
                    COALESCE( NULLIF(l_addr2_workphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr3_workphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr2_phone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr3_phone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr1_cellphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr2_cellphone,'''') || '' '', '''' ) ||
                    COALESCE( NULLIF(l_addr3_cellphone,'''') || '' '', '''' )
                ),
                email = BTRIM(
                    COALESCE(
                        NULLIF(l_addr1_email,''''),
                        NULLIF(l_addr2_email,''''),
                        NULLIF(l_addr3_email,''''),
                        ''''
                    )
                ),
                ident_type = 3,
                ident_value = BTRIM(
                    COALESCE(
                        NULLIF(l_license,''''),
                        NULLIF(l_user_id,''''),
                        ''''
                    )
                ),
                ident_type2 = CASE WHEN l_ssn <> '''' THEN 2 ELSE 3 END,
                ident_value2 = BTRIM(
                    COALESCE(
                        NULLIF(l_ssn,''''),
                        NULLIF(l_guardian,''''),
                        NULLIF(l_user_altid,''''),
                        ''''
                    )
                ),
                home_ou = (SELECT org_id FROM ' || org_map || E' AS m WHERE m.l_library = u.l_user_library),
                usrname = migration_tools.rebarcode( l_user_id, (SELECT patron_rebarcode_offset FROM ' || org_map || E' AS m WHERE m.l_library = u.l_user_library) ),
                alert_message = NULLIF(
                    BTRIM(
                        CASE WHEN l_user_profile = ''LOSTCARD'' THEN ''Legacy LOSTCARD user.  Check for duplicate account.  '' ELSE '''' END
                        || COALESCE( ''Legacy Comment: '' || NULLIF(l_comment,'''') || ''  '', '''' )
                        || COALESCE( ''Legacy Note: '' || NULLIF(l_note,'''') || ''  '', '''' )
                        -- || COALESCE( ''Legacy Staff Note: '' || NULLIF(l_staff_note,'''') || ''  '', '''' )
                        || COALESCE( ''Legacy WebCatPref Note: '' || NULLIF(l_webcatpref,'''') || ''  '', '''' )
                    ),
                    ''''
                ),
                net_access_level = ' || quote_literal(default_net_access_level) || E',
                active = COALESCE( NULLIF(l_user_profile,''''), '''' ) != ''LOSTCARD'';

        ' );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_patron_mapping_base'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_patron_mapping_base'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_patron_table_base(text) OWNER TO evergreen;

--
-- Name: map_unicorn_patron_table_cards(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.map_unicorn_patron_table_cards(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        patron_table TEXT;
    BEGIN
        SELECT migration_tools.unicorn_patron_table(migration_schema) INTO STRICT patron_table;
        PERFORM migration_tools.exec( $1, '

            SELECT  
                migration_tools.unicorn_make_card( ' || quote_literal(migration_schema) || ',id,l_user_id,l_userid_active <> ''f'')
            FROM ' || patron_table || ';

        ' );
        PERFORM migration_tools.exec( $1, '

						DROP TABLE IF EXISTS ' || migration_schema || '.barcodes_to_add;

        ' );
        PERFORM migration_tools.exec( $1, '

            CREATE TABLE ' || migration_schema || '.barcodes_to_add ( barcode TEXT );

        ' );
        PERFORM migration_tools.exec( $1, '

						CREATE INDEX ' || migration_schema || '_barcodes_to_add_idx ON ' || migration_schema || '.barcodes_to_add ( barcode );

        ' );
        PERFORM migration_tools.exec( $1, '

            INSERT INTO ' || migration_schema || '.barcodes_to_add 
                SELECT l_inactive_barcode1 FROM ' || patron_table || ' WHERE l_inactive_barcode1 <> '''' ORDER BY 1;

        ' );
        PERFORM migration_tools.exec( $1, '

            DELETE FROM ' || migration_schema || '.barcodes_to_add WHERE barcode IN (
                SELECT barcode FROM ' || migration_schema || '.actor_card);

        ' );
        PERFORM migration_tools.exec( $1, '

            SELECT  
                migration_tools.unicorn_make_card( ' || quote_literal(migration_schema) || ',u.id,u.l_inactive_barcode1,false)
            FROM ' || patron_table || ' u,
                 ' || migration_schema || '.barcodes_to_add ok
            WHERE u.l_inactive_barcode1 = ok.barcode;                  

        ' );
        PERFORM migration_tools.exec( $1, '

						DROP TABLE IF EXISTS ' || migration_schema || '.barcodes_to_add;

        ' );
        PERFORM migration_tools.exec( $1, '

            CREATE TABLE ' || migration_schema || '.barcodes_to_add ( barcode TEXT );

        ' );
        PERFORM migration_tools.exec( $1, '

						CREATE INDEX ' || migration_schema || '_barcodes_to_add_idx ON ' || migration_schema || '.barcodes_to_add ( barcode );

        ' );
        PERFORM migration_tools.exec( $1, '

            INSERT INTO ' || migration_schema || '.barcodes_to_add 
                SELECT l_inactive_barcode2 FROM ' || patron_table || ' WHERE l_inactive_barcode2 <> '''' ORDER BY 1;

        ' );
        PERFORM migration_tools.exec( $1, '

            DELETE FROM ' || migration_schema || '.barcodes_to_add WHERE barcode IN (
                SELECT barcode FROM ' || migration_schema || '.actor_card);

        ' );
        PERFORM migration_tools.exec( $1, '

            SELECT  
                migration_tools.unicorn_make_card( ' || quote_literal(migration_schema) || ',u.id,u.l_inactive_barcode2,false)
            FROM ' || patron_table || ' u,
                 ' || migration_schema || '.barcodes_to_add ok
            WHERE u.l_inactive_barcode2 = ok.barcode;                  

        ' );
        PERFORM migration_tools.exec( $1, '

            UPDATE ' || patron_table || E' AS u SET 

                card = (SELECT MIN(c.id) FROM ' || migration_schema || E'.actor_card AS c WHERE usr = u.id);

        ' );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_patron_mapping_cards'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_patron_mapping_cards'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.map_unicorn_patron_table_cards(text) OWNER TO evergreen;

--
-- Name: name_parse_out_last_comma_prefix_first_middle_suffix(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.name_parse_out_last_comma_prefix_first_middle_suffix(text) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
    DECLARE
        full_name TEXT := $1;
        temp TEXT;
        family_name TEXT := '';
        first_given_name TEXT := '';
        second_given_name TEXT := '';
        suffix TEXT := '';
        prefix TEXT := '';
    BEGIN
        temp := full_name;
        -- Use values, not structure, for prefix/suffix, unless we come up with a better idea
        IF temp ilike '%MR.%' THEN
            prefix := 'Mr.';
            temp := REGEXP_REPLACE( temp, E'MR\.\\s*', '', 'i' );
        END IF;
        IF temp ilike '%MRS.%' THEN
            prefix := 'Mrs.';
            temp := REGEXP_REPLACE( temp, E'MRS\.\\s*', '', 'i' );
        END IF;
        IF temp ilike '%MS.%' THEN
            prefix := 'Ms.';
            temp := REGEXP_REPLACE( temp, E'MS\.\\s*', '', 'i' );
        END IF;
        IF temp ilike '%DR.%' THEN
            prefix := 'Dr.';
            temp := REGEXP_REPLACE( temp, E'DR\.\\s*', '', 'i' );
        END IF;
        IF temp ilike '%JR%' THEN
            suffix := 'Jr.';
            temp := REGEXP_REPLACE( temp, E'JR\.?\\s*', '', 'i' );
        END IF;
        IF temp ilike '%JR,%' THEN
            suffix := 'Jr.';
            temp := REGEXP_REPLACE( temp, E'JR,\\s*', ',', 'i' );
        END IF;
        IF temp ilike '%SR%' THEN
            suffix := 'Sr.';
            temp := REGEXP_REPLACE( temp, E'SR\.?\\s*', '', 'i' );
        END IF;
        IF temp ilike '%SR,%' THEN
            suffix := 'Sr.';
            temp := REGEXP_REPLACE( temp, E'SR,\\s*', ',', 'i' );
        END IF;
        IF temp ~ E'\\sII$' THEN
            suffix := 'II';
            temp := REGEXP_REPLACE( temp, E'II$', '', 'i' );
        END IF;
        IF temp ~ E'\\sIII$' THEN
            suffix := 'III';
            temp := REGEXP_REPLACE( temp, E'III$', '', 'i' );
        END IF;
        IF temp ~ E'\\sIV$' THEN
            suffix := 'IV';
            temp := REGEXP_REPLACE( temp, E'IV$', '', 'i' );
        END IF;

        family_name := BTRIM( REGEXP_REPLACE(temp,E'^([^,]*)\\s*,.*$',E'\\1') );
        first_given_name := BTRIM( CASE WHEN temp ~ ',' THEN REGEXP_REPLACE(temp,E'^[^,]*\\s*,\\s*([^,\\s]*)\\s*.*$',E'\\1') ELSE 'N/A' END );
        second_given_name := BTRIM( CASE WHEN temp ~ ',' THEN REGEXP_REPLACE(temp,E'^[^,]*\\s*,\\s*[^,\\s]*\\s*(.*)$',E'\\1') ELSE ''  END );

        RETURN ARRAY[ family_name, prefix, first_given_name, second_given_name, suffix ];
    END;
$_$;


ALTER FUNCTION migration_tools.name_parse_out_last_comma_prefix_first_middle_suffix(text) OWNER TO evergreen;

--
-- Name: pop_rfr(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.pop_rfr() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    ind_data        metabib.field_entry_template%ROWTYPE;
    old_mr          INT;
    tmp_mr          metabib.metarecord%ROWTYPE;
    source_count    INT;
    deleted_mrs     INT[];
    uris            TEXT[];
    uri_xml         TEXT;
    uri_label       TEXT;
    uri_href        TEXT;
    uri_use         TEXT;
    uri_owner       TEXT;
    uri_owner_id    INT;
    uri_id          INT;
    uri_cn_id       INT;
    uri_map_id      INT;

    ind_vector      TSVECTOR;

    fclass          RECORD;
BEGIN

    -- Shove the flattened MARC in
    INSERT INTO metabib.full_rec (record, tag, ind1, ind2, subfield, value)
        SELECT record, tag, ind1, ind2, subfield, value FROM biblio.flatten_marc( NEW.id );

    RETURN NEW;

END;
$$;


ALTER FUNCTION migration_tools.pop_rfr() OWNER TO evergreen;

--
-- Name: production_tables(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.production_tables(text) RETURNS text[]
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output  RECORD;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT string_to_array(value,'','') AS tables FROM ' || migration_schema || '.config WHERE key = ''production_tables'';'
        LOOP
            RETURN output.tables;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.production_tables(text) OWNER TO evergreen;

--
-- Name: rebarcode(text, bigint); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.rebarcode(o text, t bigint) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
    DECLARE
        n TEXT := o;
    BEGIN
        IF o ~ E'^\\d+$' AND o !~ E'^0' AND length(o) < 19 THEN -- for reference, the max value for a bigint is 9223372036854775807.  May also want to consider the case where folks want to add prefixes to non-numeric barcodes
            IF o::BIGINT < t THEN
                n = o::BIGINT + t;
            END IF;
        END IF;

        RETURN n;
    END;
$_$;


ALTER FUNCTION migration_tools.rebarcode(o text, t bigint) OWNER TO evergreen;

--
-- Name: rec_descriptor(integer); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.rec_descriptor(breid integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    ind_data        metabib.field_entry_template%ROWTYPE;
    old_mr          INT;
    tmp_mr          metabib.metarecord%ROWTYPE;
    source_count    INT;
    deleted_mrs     INT[];
    uris            TEXT[];
    uri_xml         TEXT;
    uri_label       TEXT;
    uri_href        TEXT;
    uri_use         TEXT;
    uri_owner       TEXT;
    uri_owner_id    INT;
    uri_id          INT;
    uri_cn_id       INT;
    uri_map_id      INT;

    ind_vector      TSVECTOR;

    fclass          RECORD;
BEGIN

    -- Then, the rec_descriptor
    INSERT INTO metabib.rec_descriptor (record, item_type, item_form, bib_level, control_type, enc_level, audience, lit_form, type_mat, cat_form, pub_status, item_lang, vr_format, date1, date2)
        SELECT  breid,
                biblio.marc21_extract_fixed_field( breid, 'Type' ),
                biblio.marc21_extract_fixed_field( breid, 'Form' ),
                biblio.marc21_extract_fixed_field( breid, 'BLvl' ),
                biblio.marc21_extract_fixed_field( breid, 'Ctrl' ),
                biblio.marc21_extract_fixed_field( breid, 'ELvl' ),
                biblio.marc21_extract_fixed_field( breid, 'Audn' ),
                biblio.marc21_extract_fixed_field( breid, 'LitF' ),
                biblio.marc21_extract_fixed_field( breid, 'TMat' ),
                biblio.marc21_extract_fixed_field( breid, 'Desc' ),
                biblio.marc21_extract_fixed_field( breid, 'DtSt' ),
                biblio.marc21_extract_fixed_field( breid, 'Lang' ),
                (   SELECT  v.value
                      FROM  biblio.marc21_physical_characteristics( breid) p
                            JOIN config.marc21_physical_characteristic_subfield_map s ON (s.id = p.subfield)
                            JOIN config.marc21_physical_characteristic_value_map v ON (v.id = p.value)
                      WHERE p.ptype = 'v' AND s.subfield = 'e'    ),
                biblio.marc21_extract_fixed_field( breid, 'Date1'),
                biblio.marc21_extract_fixed_field( breid, 'Date2');

 

END;
$$;


ALTER FUNCTION migration_tools.rec_descriptor(breid integer) OWNER TO evergreen;

--
-- Name: refresh_opac_visible_copies(); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.refresh_opac_visible_copies() RETURNS void
    LANGUAGE plpgsql
    AS $$

BEGIN	

	DELETE FROM asset.opac_visible_copies;

	INSERT INTO asset.opac_visible_copies (id, circ_lib, record)
		SELECT DISTINCT
			cp.id, cp.circ_lib, cn.record
		FROM
			asset.copy cp
			JOIN asset.call_number cn ON (cn.id = cp.call_number)
			JOIN actor.org_unit a ON (cp.circ_lib = a.id)
			JOIN asset.copy_location cl ON (cp.location = cl.id)
			JOIN config.copy_status cs ON (cp.status = cs.id)
			JOIN biblio.record_entry b ON (cn.record = b.id)
		WHERE 
			NOT cp.deleted AND
			NOT cn.deleted AND
			NOT b.deleted AND
			cs.opac_visible AND
			cl.opac_visible AND
			cp.opac_visible AND
			a.opac_visible AND
			cp.id NOT IN (SELECT id FROM asset.opac_visible_copies);

END;

$$;


ALTER FUNCTION migration_tools.refresh_opac_visible_copies() OWNER TO evergreen;

--
-- Name: restore_index(text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.restore_index(_table_schema text, _table_name text, _index_name text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    restore TEXT;
BEGIN
    SELECT restore_command INTO restore
        FROM migration_tools.db_object_stash
        WHERE schema_name = _table_schema
        AND   table_name = _table_name
        AND   object_name = _index_name
        AND   object_type = 'index';
    EXECUTE restore;
    DELETE FROM migration_tools.db_object_stash
        WHERE schema_name = _table_schema
        AND   table_name = _table_name
        AND   object_name = _index_name
        AND   object_type = 'index';
END;
$$;


ALTER FUNCTION migration_tools.restore_index(_table_schema text, _table_name text, _index_name text) OWNER TO evergreen;

--
-- Name: set_008(text, integer, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.set_008(text, integer, text) RETURNS text
    LANGUAGE plperlu STABLE
    AS $_$
  my ($marcxml, $pos, $value) = @_;

  use MARC::Record;
  use MARC::File::XML;

  my $xml = $marcxml;
  eval {
    my $marc = MARC::Record->new_from_xml($marcxml, 'UTF-8');
    my $f008 = $marc->field('008');

    if ($f008) {
       my $field = $f008->data();
       substr($field, $pos, 1) = $value;
       $f008->update($field);
       $xml = $marc->as_xml_record;
       $xml =~ s/^<\?.+?\?>$//mo;
       $xml =~ s/\n//sgo;
       $xml =~ s/>\s+</></sgo;
    }
  };
  return $xml;
$_$;


ALTER FUNCTION migration_tools.set_008(text, integer, text) OWNER TO evergreen;

--
-- Name: set_leader(text, integer, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.set_leader(text, integer, text) RETURNS text
    LANGUAGE plperlu STABLE
    AS $_$
  my ($marcxml, $pos, $value) = @_;

  use MARC::Record;
  use MARC::File::XML;

  my $xml = $marcxml;
  eval {
    my $marc = MARC::Record->new_from_xml($marcxml, 'UTF-8');
    my $leader = $marc->leader();
    substr($leader, $pos, 1) = $value;
    $marc->leader($leader);
    $xml = $marc->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;
  };
  return $xml;
$_$;


ALTER FUNCTION migration_tools.set_leader(text, integer, text) OWNER TO evergreen;

--
-- Name: stage_not_applicable_asset_stat_cats(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.stage_not_applicable_asset_stat_cats(schemaname text) RETURNS void
    LANGUAGE plpgsql
    AS $$

-- USAGE: Make sure the stat_cat and stat_cat_entry tables are populated, including exactly one 'Not Applicable' entry per stat cat.
--        Then SELECT migration_tools.stage_not_applicable_asset_stat_cats('m_foo');

-- TODO: Make a variant that will go directly to production tables -- which would be useful for retrofixing the absence of N/A cats.
-- TODO: Add a similar tool for actor stat cats, which behave differently.

DECLARE
	c                    TEXT := schemaname || '.asset_copy_legacy';
	sc									 TEXT := schemaname || '.asset_stat_cat';
	sce									 TEXT := schemaname || '.asset_stat_cat_entry';
	scecm								 TEXT := schemaname || '.asset_stat_cat_entry_copy_map';
	stat_cat						 INT;
  stat_cat_entry       INT;
  
BEGIN

  FOR stat_cat IN EXECUTE ('SELECT id FROM ' || sc) LOOP

		EXECUTE ('SELECT id FROM ' || sce || ' WHERE stat_cat = ' || stat_cat || E' AND value = \'Not Applicable\';') INTO stat_cat_entry;

		EXECUTE ('INSERT INTO ' || scecm || ' (owning_copy, stat_cat, stat_cat_entry)
							SELECT c.id, ' || stat_cat || ', ' || stat_cat_entry || ' FROM ' || c || ' c WHERE c.id NOT IN
							(SELECT owning_copy FROM ' || scecm || ' WHERE stat_cat = ' || stat_cat || ');');

  END LOOP;

  RETURN;
END;

$$;


ALTER FUNCTION migration_tools.stage_not_applicable_asset_stat_cats(schemaname text) OWNER TO evergreen;

--
-- Name: stash_index(text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.stash_index(_table_schema text, _table_name text, _index_name text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    restore TEXT;
BEGIN
    SELECT indexdef INTO restore
        FROM pg_indexes
        WHERE schemaname = _table_schema
        AND   tablename = _table_name
        AND   indexname = _index_name;
    IF restore IS NULL
    THEN
       RAISE EXCEPTION 'no restore command for %', _index_name;
    END IF;
    INSERT INTO migration_tools.db_object_stash (schema_name, table_name, object_name, object_type, restore_command)
        VALUES(_table_schema, _table_name, _index_name, 'index', restore);
    EXECUTE 'DROP INDEX ' || _table_schema || '.' || _index_name;
END;
$$;


ALTER FUNCTION migration_tools.stash_index(_table_schema text, _table_name text, _index_name text) OWNER TO evergreen;

--
-- Name: unaccent_string(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unaccent_string(text) RETURNS text
    LANGUAGE plperl
    AS $_$
my ($input_string) = @_;
$input_string =~ s/[âãäåāăą]/a/g;
$input_string =~ s/[ÁÂÃÄÅĀĂĄ]/A/g;
$input_string =~ s/[èééêëēĕėęě]/e/g;
$input_string =~ s/[ĒĔĖĘĚ]/E/g;
$input_string =~ s/[ìíîïìĩīĭ]/i/g;
$input_string =~ s/[ÌÍÎÏÌĨĪĬ]/I/g;
$input_string =~ s/[óôõöōŏő]/o/g;
$input_string =~ s/[ÒÓÔÕÖŌŎŐ]/O/g;
$input_string =~ s/[ùúûüũūŭů]/u/g;
$input_string =~ s/[ÙÚÛÜŨŪŬŮ]/U/g;
return $input_string;
$_$;


ALTER FUNCTION migration_tools.unaccent_string(text) OWNER TO evergreen;

--
-- Name: unicorn_actor_stat_cat_entry_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_actor_stat_cat_entry_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''actor_stat_cat_entry_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_actor_stat_cat_entry_map(text) OWNER TO evergreen;

--
-- Name: unicorn_actor_stat_cat_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_actor_stat_cat_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''actor_stat_cat_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_actor_stat_cat_map(text) OWNER TO evergreen;

--
-- Name: unicorn_card_collisions_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_card_collisions_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''card_collisions'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_card_collisions_table(text) OWNER TO evergreen;

--
-- Name: unicorn_circ_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_circ_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''circ_table'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_circ_table(text) OWNER TO evergreen;

--
-- Name: unicorn_create_circ_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_create_circ_table(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.action_circulation_unicorn (
            l_form TEXT NOT NULL CHECK ( l_form = ''LDCHARGE'' ),
            l_user_id TEXT,
            l_item_id TEXT,
            l_charging_lib TEXT,
            l_date_charged TEXT,
            l_date_due TEXT,
            l_date_claim_returned TEXT
        ) INHERITS ( ' || migration_schema || '.action_circulation);' ); 
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_create_circ_table(text) OWNER TO evergreen;

--
-- Name: unicorn_create_hold_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_create_hold_table(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
				PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.action_hold_request_unicorn;' );
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.action_hold_request_unicorn (
            _bib_id BIGINT,
            _item_barcode TEXT,
            _user_barcode TEXT,
            l_cat_key integer, 
            l_call_key integer, 
            l_item_key integer, 
            l_hold_key integer, 
            l_user_key integer, 
            l_hold_type text, 
            l_item_available text, 
            l_hold_date text,
						l_pickup_lib text 
        ) INHERITS ( ' || migration_schema || '.action_hold_request);' ); 
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_create_hold_table(text) OWNER TO evergreen;

--
-- Name: unicorn_create_item_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_create_item_table(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.asset_copy_unicorn (
            _orig_eg_bibid BIGINT,
            _final_eg_bibid BIGINT,
            l_library TEXT,
            l_barcode TEXT,
            l_location_current TEXT,
            l_location_home TEXT,
            l_call_number TEXT,
            l_item_type TEXT,
            l_acq_date TEXT,
            l_price TEXT,
            l_circ_flag TEXT,
            l_total_charges TEXT,
            l_cat1 TEXT,
            l_cat2 TEXT
        ) INHERITS ( ' || migration_schema || '.asset_copy);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_orig_eg_bibid ON ' || migration_schema || '.asset_copy_unicorn ( _orig_eg_bibid );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_final_eg_bibid ON ' || migration_schema || '.asset_copy_unicorn ( _final_eg_bibid );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_barcode ON ' || migration_schema || '.asset_copy_unicorn ( l_barcode );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_location_home ON ' || migration_schema || '.asset_copy_unicorn ( l_location_home );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_location_current ON ' || migration_schema || '.asset_copy_unicorn ( l_location_current );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_library ON ' || migration_schema || '.asset_copy_unicorn ( l_library );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_unicorn_item_type ON ' || migration_schema || '.asset_copy_unicorn ( l_item_type );' );
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_create_item_table(text) OWNER TO evergreen;

--
-- Name: unicorn_create_money_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_create_money_table(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.money_grocery_unicorn;' );
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.money_grocery_unicorn (
            l_form TEXT NOT NULL CHECK ( l_form = ''LDBILL'' ),
            l_user_id TEXT,
            l_item_id TEXT,
            l_billing_lib TEXT,
            l_bill_date TEXT,
            l_bill_amt TEXT,
            l_bill_reason TEXT
        ) INHERITS ( ' || migration_schema || '.money_grocery);' ); 
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_create_money_table(text) OWNER TO evergreen;

--
-- Name: unicorn_create_patron_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_create_patron_table(text) RETURNS void
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.actor_usr_unicorn;' );
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.actor_usr_unicorn (
            l_user_id TEXT,
            l_user_altid TEXT,
            l_user_pin TEXT,
            l_user_profile TEXT,
            l_user_status TEXT,
            l_user_library TEXT,
            l_user_priv_granted TEXT,
            l_user_priv_expires TEXT,
            l_user_mailingaddr TEXT,
            l_birthdate TEXT,
            l_prefix_name TEXT,
            l_last_name TEXT,
            l_first_name TEXT,
            l_middle_name TEXT,
            l_suffix_name TEXT,
            l_note TEXT,
            l_note1 TEXT,
            l_patron TEXT,
            l_comment TEXT,
            l_staff TEXT,
            l_webcatpref TEXT,
            l_user_category1 TEXT,
            l_user_category2 TEXT,
            l_user_category3 TEXT,
            l_user_category4 TEXT,
            l_dept TEXT,
            l_guardian TEXT,
            l_license TEXT,
            l_ssn TEXT,
            l_misc TEXT,
            l_aup TEXT,
            l_photo TEXT,
            l_notify_via TEXT,
            l_user_claims_ret TEXT,
            l_user_environment TEXT,
            l_user_department TEXT,
            l_ums_id TEXT,
            l_user_last_activity TEXT,
            l_placcard TEXT,
            l_user_email TEXT,
            l_addr1_std_line1 TEXT,
            l_addr1_std_line2 TEXT,
            l_addr1_std_city TEXT,
            l_addr1_std_state TEXT,
            l_addr1_std_zip TEXT,
            l_addr1_country TEXT,
            l_addr1_county TEXT,
            l_addr1_township TEXT,
            l_addr1_room TEXT,
            l_addr1_company TEXT,
            l_addr1_office TEXT,
            l_addr1_phone TEXT,
            l_addr1_dayphone TEXT,
            l_addr1_homephone TEXT,
            l_addr1_workphone TEXT,
            l_addr1_cellphone TEXT,
            l_addr1_fax TEXT,
            l_addr1_email TEXT,
            l_addr1_location TEXT,
            l_addr1_usefor TEXT,
            l_addr1_care_of TEXT,
            l_addr1_known_bad TEXT,
            l_addr1_ums_addrid TEXT,
            l_addr2_std_line1 TEXT,
            l_addr2_std_line2 TEXT,
            l_addr2_std_city TEXT,
            l_addr2_std_state TEXT,
            l_addr2_std_zip TEXT,
            l_addr2_country TEXT,
            l_addr2_county TEXT,
            l_addr2_township TEXT,
            l_addr2_room TEXT,
            l_addr2_company TEXT,
            l_addr2_office TEXT,
            l_addr2_phone TEXT,
            l_addr2_dayphone TEXT,
            l_addr2_homephone TEXT,
            l_addr2_workphone TEXT,
            l_addr2_cellphone TEXT,
            l_addr2_fax TEXT,
            l_addr2_email TEXT,
            l_addr2_location TEXT,
            l_addr2_usefor TEXT,
            l_addr2_care_of TEXT,
            l_addr2_known_bad TEXT,
            l_addr2_ums_addrid TEXT,
            l_addr3_std_line1 TEXT,
            l_addr3_std_line2 TEXT,
            l_addr3_std_city TEXT,
            l_addr3_std_state TEXT,
            l_addr3_std_zip TEXT,
            l_addr3_country TEXT,
            l_addr3_county TEXT,
            l_addr3_township TEXT,
            l_addr3_room TEXT,
            l_addr3_company TEXT,
            l_addr3_office TEXT,
            l_addr3_phone TEXT,
            l_addr3_dayphone TEXT,
            l_addr3_homephone TEXT,
            l_addr3_workphone TEXT,
            l_addr3_cellphone TEXT,
            l_addr3_fax TEXT,
            l_addr3_email TEXT,
            l_addr3_location TEXT,
            l_addr3_usefor TEXT,
            l_addr3_care_of TEXT,
            l_addr3_known_bad TEXT,
            l_addr3_ums_addrid TEXT,
            l_identific TEXT,
            l_noempl TEXT,
            l_profession TEXT,
            l_program TEXT,
            l_represent TEXT,
            l_userid_active TEXT,
            l_inactive_barcode1 TEXT,
            l_inactive_barcode2 TEXT,
            _address1 INTEGER,
            _address2 INTEGER,
            _address3 INTEGER
        ) INHERITS ( ' || migration_schema || '.actor_usr);' ); 
        -- watch out for MARC8 with these files
        -- \COPY foo.actor_usr_unicorn ( l_user_id, l_user_altid, l_user_pin, l_user_profile, l_user_status, l_user_library, l_user_priv_granted, l_user_priv_expires, l_user_mailingaddr, l_birthdate, l_last_name, l_first_name, l_middle_name, l_suffix_name, l_note, l_note1, l_patron, l_comment, l_staff, l_webcatpref, l_user_category1, l_user_category2, l_user_category3, l_user_category4, l_dept, l_guardian, l_license, l_ssn, l_misc, l_aup, l_photo, l_notify_via, l_user_claims_ret, l_user_environment, l_user_department, l_ums_id, l_user_last_activity, l_placcard, l_user_email, l_addr1_std_line1, l_addr1_std_line2, l_addr1_std_city, l_addr1_std_state, l_addr1_std_zip, l_addr1_country, l_addr1_township, l_addr1_room, l_addr1_company, l_addr1_office, l_addr1_phone, l_addr1_dayphone, l_addr1_homephone, l_addr1_workphone, l_addr1_cellphone, l_addr1_email, l_addr1_location, l_addr1_usefor, l_addr1_care_of, l_addr1_known_bad, l_addr1_ums_addrid, l_addr2_std_line1, l_addr2_std_line2, l_addr2_std_city, l_addr2_std_state, l_addr2_std_zip, l_addr2_country, l_addr2_township, l_addr2_room, l_addr2_company, l_addr2_office, l_addr2_phone, l_addr2_dayphone, l_addr2_homephone, l_addr2_workphone, l_addr2_cellphone, l_addr2_email, l_addr2_location, l_addr2_usefor, l_addr2_care_of, l_addr2_known_bad, l_addr2_ums_addrid, l_addr3_std_line1, l_addr3_std_line2, l_addr3_std_city, l_addr3_std_state, l_addr3_std_zip, l_addr3_country, l_addr3_township, l_addr3_room, l_addr3_company, l_addr3_office, l_addr3_phone, l_addr3_dayphone, l_addr3_homephone, l_addr3_workphone, l_addr3_cellphone, l_addr3_email, l_addr3_location, l_addr3_usefor, l_addr3_care_of, l_addr3_known_bad, l_addr3_ums_addrid, l_identific, l_noempl, l_profession, l_program, l_represent, l_userid_active, l_inactive_barcode1, l_inactive_barcode2 ) FROM 'users.tabbed.txt'
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_create_patron_table(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_age_protect(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_default_item_age_protect(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_age_protect'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_age_protect(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_circulate_flag(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_default_item_circulate_flag(text) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output BOOLEAN;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value = ''t'' FROM ' || migration_schema || '.config WHERE key = ''default_item_circulate_flag'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_circulate_flag(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_creator(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_default_item_creator(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_creator'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_creator(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_editor(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_default_item_editor(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_editor'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_editor(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_fine_level(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_default_item_fine_level(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_fine_level'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_fine_level(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_holdable_flag(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_default_item_holdable_flag(text) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output BOOLEAN;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value = ''t'' FROM ' || migration_schema || '.config WHERE key = ''default_item_holdable_flag'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_holdable_flag(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_loan_duration(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_default_item_loan_duration(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_loan_duration'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_loan_duration(text) OWNER TO evergreen;

--
-- Name: unicorn_default_item_status(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_default_item_status(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_item_status'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_item_status(text) OWNER TO evergreen;

--
-- Name: unicorn_default_net_access_level(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_default_net_access_level(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_net_access_level'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_net_access_level(text) OWNER TO evergreen;

--
-- Name: unicorn_default_patron_profile(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_default_patron_profile(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_patron_profile'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_patron_profile(text) OWNER TO evergreen;

--
-- Name: unicorn_default_selection_depth(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_default_selection_depth(text) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output INTEGER;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT value::INTEGER FROM ' || migration_schema || '.config WHERE key = ''default_selection_depth'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_default_selection_depth(text) OWNER TO evergreen;

--
-- Name: unicorn_hold_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_hold_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''hold_table'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_hold_table(text) OWNER TO evergreen;

--
-- Name: unicorn_home_location_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_home_location_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''home_location_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_home_location_map(text) OWNER TO evergreen;

--
-- Name: unicorn_init(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_init(text) RETURNS void
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
    BEGIN
        PERFORM migration_tools.exec( $1, 'DELETE FROM ' || migration_schema || '.config WHERE key IN ( ''ils_type'', ''item_table'', ''patron_table'', ''circ_table'', ''hold_table'', ''money_table'', ''org_map'', ''profile_map'', ''item_dynamic_field_map'', ''default_patron_profile'', ''default_net_access_level'', ''actor_stat_cat_map'', ''actor_stat_cat_entry_map'', ''default_item_status'', ''default_item_holdable_flag'', ''default_item_circulate_flag'', ''default_item_creator'', ''default_item_editor'', ''default_item_loan_duration'', ''default_item_fine_level'', ''default_item_age_protect'', ''default_selection_depth'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''ils_type'', ''Unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''item_table'', ''asset_copy_unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''patron_table'', ''actor_usr_unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''circ_table'', ''action_circulation_unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''hold_table'', ''action_hold_request_unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''money_table'', ''money_grocery_unicorn'' );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_patron_profile'', ''1'' );' ); -- Users
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_net_access_level'', ''2'' );' ); -- Unrestricted
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_status'', ''0'' );' ); -- Available
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_holdable_flag'', ''t'' );' ); -- true
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_circulate_flag'', ''t'' );' ); -- true
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_creator'', ''1'' );' ); -- Admin
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_editor'', ''1'' );' ); -- Admin
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_fine_level'', ''1'' );' ); -- Normal
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_loan_duration'', ''1'' );' ); -- Normal
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_item_age_protect'', NULL );' ); -- none
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''default_selection_depth'', ''0'' );' ); -- Consortium
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.org_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.org_map ( 
            id SERIAL,
            org_id INTEGER, 
            transcribed_shortname TEXT,
            l_library TEXT UNIQUE NOT NULL, 
            patron_rebarcode_offset BIGINT NOT NULL DEFAULT 0, 
            item_rebarcode_offset BIGINT NOT NULL DEFAULT 0,
            default_circ_staff INTEGER NOT NULL DEFAULT 1 
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''org_map'', ''org_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.profile_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.profile_map ( 
            id SERIAL,
            perm_grp_id INTEGER,
            transcribed_perm_group TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''profile_map'', ''profile_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.home_location_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.home_location_map ( 
            id SERIAL,
            location INTEGER,
            holdable BOOLEAN NOT NULL DEFAULT TRUE,
            hold_verify BOOLEAN NOT NULL DEFAULT FALSE,
            opac_visible BOOLEAN NOT NULL DEFAULT TRUE,
            circulate BOOLEAN NOT NULL DEFAULT TRUE,
            transcribed_location TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_home_location_lf1_idx ON ' || migration_schema || '.home_location_map (legacy_field1,legacy_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_home_location_lf2_idx ON ' || migration_schema || '.home_location_map (legacy_field2,legacy_value2);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_home_location_lf3_idx ON ' || migration_schema || '.home_location_map (legacy_field3,legacy_value3);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_home_location_loc_idx ON ' || migration_schema || '.home_location_map (transcribed_location);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''home_location_map'', ''home_location_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.item_dynamic_field_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || E'.item_dynamic_field_map ( 
            id SERIAL,
            evergreen_field TEXT,
            evergreen_value TEXT,
            evergreen_datatype TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            legacy_field2 TEXT,
            legacy_value2 TEXT,
            legacy_field3 TEXT,
            legacy_value3 TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_unicorn_item_dynamic_lf1_idx ON ' || migration_schema || '.item_dynamic_field_map (legacy_field1,legacy_value1);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_unicorn_item_dynamic_lf2_idx ON ' || migration_schema || '.item_dynamic_field_map (legacy_field2,legacy_value2);' ); 
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_unicorn_item_dynamic_lf3_idx ON ' || migration_schema || '.item_dynamic_field_map (legacy_field3,legacy_value3);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''item_dynamic_field_map'', ''item_dynamic_field_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.card_collisions;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.card_collisions ( 
            id SERIAL,
            reason TEXT,
            usr INTEGER,
            barcode TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''card_collisions'', ''card_collisions'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.actor_stat_cat_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.actor_stat_cat_map ( 
            id SERIAL,
            stat_cat INTEGER,
            org_id INTEGER,
            l_library TEXT,
            name TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''actor_stat_cat_map'', ''actor_stat_cat_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.actor_stat_cat_entry_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.actor_stat_cat_entry_map ( 
            id SERIAL,
            stat_cat INTEGER,
            stat_cat_entry INTEGER,
            org_id INTEGER,
            l_library TEXT,
            name TEXT,
            legacy_field1 TEXT,
            legacy_value1 TEXT,
            entry TEXT
        );' );
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''actor_stat_cat_entry_map'', ''actor_stat_cat_entry_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.item_key_barcode_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.item_key_barcode_map ( 
            key1 text,
            key2 text,
            key3 text,
            barcode text
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_item_key_barcode_map_idx ON ' || migration_schema || '.item_key_barcode_map (key1,key2,key3);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''item_key_barcode_map'', ''item_key_barcode_map'' );' );
        PERFORM migration_tools.exec( $1, 'DROP TABLE IF EXISTS ' || migration_schema || '.user_key_barcode_map;' );  
        PERFORM migration_tools.exec( $1, 'CREATE TABLE ' || migration_schema || '.user_key_barcode_map ( 
            key text,
            barcode text
        );' );
        PERFORM migration_tools.exec( $1, 'CREATE INDEX ' || migration_schema || '_user_key_barcode_map_idx ON ' || migration_schema || '.user_key_barcode_map (key);' ); 
        PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''user_key_barcode_map'', ''user_key_barcode_map'' );' );
        BEGIN
            PERFORM migration_tools.exec( $1, 'INSERT INTO ' || migration_schema || '.config (key,value) VALUES ( ''last_unicorn_init'', now() );' );
        EXCEPTION
            WHEN OTHERS THEN PERFORM migration_tools.exec( $1, 'UPDATE ' || migration_schema || '.config SET value = now() WHERE key = ''last_unicorn_init'';' );
        END;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_init(text) OWNER TO evergreen;

--
-- Name: unicorn_item_dynamic_field_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_item_dynamic_field_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''item_dynamic_field_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_item_dynamic_field_map(text) OWNER TO evergreen;

--
-- Name: unicorn_item_key_barcode_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_item_key_barcode_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''item_key_barcode_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_item_key_barcode_map(text) OWNER TO evergreen;

--
-- Name: unicorn_item_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_item_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''item_table'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_item_table(text) OWNER TO evergreen;

--
-- Name: unicorn_make_address(text, integer, text, text, text, text, text, text, text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_make_address(text, integer, text, text, text, text, text, text, text) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        au_id ALIAS FOR $2;
        line1 ALIAS FOR $3;
        line2 ALIAS FOR $4;
        care_of ALIAS FOR $5;
        city ALIAS FOR $6;
        state ALIAS FOR $7;
        zip ALIAS FOR $8;
        label ALIAS FOR $9;
        _street1 TEXT := ''; _street2 TEXT := ''; _city TEXT := ''; _county TEXT := ''; _state TEXT := ''; _country TEXT := ''; _post_code TEXT := '';
        output RECORD;
    BEGIN
        SELECT migration_tools.country_code(migration_schema) INTO _country;
        _street1 := BTRIM(line1);
        _street2 := BTRIM(line2) || CASE WHEN line2 <> '' AND care_of <> '' THEN ' ' ELSE '' END || CASE WHEN care_of <> '' THEN 'Care Of: ' || BTRIM(care_of) ELSE '' END;
        _city := BTRIM(city);
        _state := BTRIM(state);
        _post_code := BTRIM(zip);
        IF _street1 = '' AND _street2 = '' AND _city = '' AND _state = '' AND _post_code = '' THEN
            RETURN NULL;
        END IF;
        PERFORM migration_tools.exec($1, '
            INSERT INTO ' || migration_schema || E'.actor_usr_address ( address_type, usr, street1, street2, city, county, state, country, post_code ) VALUES ( 
                COALESCE( NULLIF(' || quote_literal(label) || E',''''),''Legacy Address''), 
                ' || quote_literal(au_id) || E', 
                ' || quote_literal(_street1) || E', 
                ' || quote_literal(_street2) || E', 
                ' || quote_literal(_city) || E', 
                ' || quote_literal(_county) || E', 
                ' || quote_literal(_state) || E', 
                ' || quote_literal(_country) || E', 
                ' || quote_literal(_post_code) || E' 
            );
        ');
        EXECUTE 'SELECT max(id) AS a FROM ' || migration_schema || E'.actor_usr_address;' INTO output;
        RETURN output.a;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_make_address(text, integer, text, text, text, text, text, text, text) OWNER TO evergreen;

--
-- Name: unicorn_make_card(text, integer, text, boolean); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_make_card(text, integer, text, boolean) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        au_id ALIAS FOR $2;
        barcode ALIAS FOR $3;
        barcode_valid ALIAS FOR $4;
        card_collisions_table TEXT;
        output RECORD;
    BEGIN
        SELECT migration_tools.unicorn_card_collisions_table(migration_schema) INTO STRICT card_collisions_table;
        IF barcode = '' THEN
            RETURN NULL;
        END IF;
        IF LENGTH(barcode) <> 0 THEN
            EXECUTE 'SELECT id FROM ' || migration_schema || E'.actor_card WHERE barcode = ' || quote_literal(barcode) || ';' INTO output;
            IF output.id IS NULL THEN

                EXECUTE 'SELECT id FROM actor.card WHERE barcode = ' || quote_literal(barcode) || ';' INTO output;
                IF output.id IS NULL THEN
                    PERFORM migration_tools.exec($1, '
                        INSERT INTO ' || migration_schema || E'.actor_card ( usr, barcode, active ) VALUES (
                            ' || (au_id) || E',
                            ' || quote_literal(barcode) || E',
                            ' || CASE WHEN barcode_valid THEN 'true' ELSE 'false' END || E'
                        );
                    ');
                ELSE
                    PERFORM migration_tools.exec($1, '
                        INSERT INTO ' || card_collisions_table || E' ( reason, usr, barcode ) VALUES (
                            ''collision with incumbent barcode'',
                            ' || quote_literal(au_id) || E',
                            ' || quote_literal(barcode) || E'
                        );
                    ');
                    PERFORM migration_tools.exec($1, '
                        INSERT INTO ' || migration_schema || E'.actor_card ( usr, barcode, active ) VALUES (
                            ' || (au_id) || E',
                            ' || quote_literal('coll1_usr_id_'||au_id) || E',
                            ' || CASE WHEN barcode_valid THEN 'true' ELSE 'false' END || E'
                        );
                    ');
                END IF;

            ELSE
                PERFORM migration_tools.exec($1, '
                    INSERT INTO ' || card_collisions_table || E' ( reason, usr, barcode ) VALUES (
                        ''collision with another barcode in same dataset'',
                        ' || quote_literal(au_id) || E',
                        ' || quote_literal(barcode) || E'
                    );
                ');
                PERFORM migration_tools.exec($1, '
                    INSERT INTO ' || migration_schema || E'.actor_card ( usr, barcode, active ) VALUES (
                        ' || (au_id) || E',
                        ' || quote_literal('coll2_usr_id_'||au_id) || E',
                        false
                    );
                ');
            END IF;
        END IF;
        EXECUTE 'SELECT MIN(id) AS a FROM ' || migration_schema || '.actor_card WHERE usr = ' || quote_literal(au_id) || ';' INTO output;
        RETURN output.a;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_make_card(text, integer, text, boolean) OWNER TO evergreen;

--
-- Name: unicorn_money_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_money_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''money_table'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_money_table(text) OWNER TO evergreen;

--
-- Name: unicorn_org_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_org_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''org_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_org_map(text) OWNER TO evergreen;

--
-- Name: unicorn_patron_table(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_patron_table(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''patron_table'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_patron_table(text) OWNER TO evergreen;

--
-- Name: unicorn_profile_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_profile_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''profile_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_profile_map(text) OWNER TO evergreen;

--
-- Name: unicorn_user_key_barcode_map(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.unicorn_user_key_barcode_map(text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
    DECLARE
        migration_schema ALIAS FOR $1;
        output TEXT;
    BEGIN
        FOR output IN
            EXECUTE 'SELECT ''' || migration_schema || '.'' || value FROM ' || migration_schema || '.config WHERE key = ''user_key_barcode_map'';'
        LOOP
            RETURN output;
        END LOOP;
    END;
$_$;


ALTER FUNCTION migration_tools.unicorn_user_key_barcode_map(text) OWNER TO evergreen;

--
-- Name: zip_to_city_state_county(text); Type: FUNCTION; Schema: migration_tools; Owner: evergreen
--

CREATE FUNCTION migration_tools.zip_to_city_state_county(text) RETURNS text[]
    LANGUAGE plperlu STABLE
    AS $_X$

	my $input = $_[0];
	my %zipdata;

	open (FH, '<', '/openils/var/data/zips.txt') or return ('No File Found', 'No File Found', 'No File Found');

	while (<FH>) {
		chomp;
		my ($junk, $state, $city, $zip, $foo, $bar, $county, $baz, $morejunk) = split(/\|/);
		$zipdata{$zip} = [$city, $state, $county];
	}

	if (defined $zipdata{$input}) {
		my ($city, $state, $county) = @{$zipdata{$input}};
		return [$city, $state, $county];
	} elsif (defined $zipdata{substr $input, 0, 5}) {
		my ($city, $state, $county) = @{$zipdata{substr $input, 0, 5}};
		return [$city, $state, $county];
	} else {
		return ['ZIP not found', 'ZIP not found', 'ZIP not found'];
	}
  
$_X$;


ALTER FUNCTION migration_tools.zip_to_city_state_county(text) OWNER TO evergreen;

--
-- Name: age_billings_and_payments(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.age_billings_and_payments() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Age billings and payments linked to transactions which were 
-- completed at least 'older_than' time ago.
DECLARE
    xact_id BIGINT;
    counter INTEGER DEFAULT 0;
    keep_age INTERVAL;
BEGIN

    SELECT value::INTERVAL INTO keep_age FROM config.global_flag 
        WHERE name = 'history.money.retention_age' AND enabled;

    -- Confirm interval-based aging is enabled.
    IF keep_age IS NULL THEN RETURN counter; END IF;

    -- Start with non-circulation transactions
    FOR xact_id IN SELECT DISTINCT(xact.id) FROM money.billable_xact xact
        -- confirm there is something to age
        JOIN money.billing mb ON mb.xact = xact.id
        -- Avoid aging money linked to non-aged circulations.
        LEFT JOIN action.circulation circ ON circ.id = xact.id
        WHERE circ.id IS NULL AND AGE(NOW(), xact.xact_finish) > keep_age LOOP

        PERFORM money.age_billings_and_payments_for_xact(xact_id);
        counter := counter + 1;
    END LOOP;

    -- Then handle aged circulation money.
    FOR xact_id IN SELECT DISTINCT(xact.id) FROM action.aged_circulation xact
        -- confirm there is something to age
        JOIN money.billing mb ON mb.xact = xact.id
        WHERE AGE(NOW(), xact.xact_finish) > keep_age LOOP

        PERFORM money.age_billings_and_payments_for_xact(xact_id);
        counter := counter + 1;
    END LOOP;

    RETURN counter;
END;
$$;


ALTER FUNCTION money.age_billings_and_payments() OWNER TO evergreen;

--
-- Name: age_billings_and_payments_for_xact(bigint); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.age_billings_and_payments_for_xact(xact_id bigint) RETURNS void
    LANGUAGE sql
    AS $_$

    INSERT INTO money.aged_billing
        SELECT * FROM money.billing WHERE xact = $1;

    INSERT INTO money.aged_payment 
        SELECT * FROM money.payment_view_for_aging WHERE xact = xact_id;

    DELETE FROM money.payment WHERE xact = $1;
    DELETE FROM money.billing WHERE xact = $1;

$_$;


ALTER FUNCTION money.age_billings_and_payments_for_xact(xact_id bigint) OWNER TO evergreen;

--
-- Name: maintain_billing_ts(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.maintain_billing_ts() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	NEW.billing_ts := COALESCE(NEW.period_end, NEW.create_date);
	RETURN NEW;
END;
$$;


ALTER FUNCTION money.maintain_billing_ts() OWNER TO evergreen;

--
-- Name: mat_summary_create(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.mat_summary_create() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	INSERT INTO money.materialized_billable_xact_summary (id, usr, xact_start, xact_finish, total_paid, total_owed, balance_owed, xact_type)
		VALUES ( NEW.id, NEW.usr, NEW.xact_start, NEW.xact_finish, 0.0, 0.0, 0.0, TG_ARGV[0]);
	RETURN NEW;
END;
$$;


ALTER FUNCTION money.mat_summary_create() OWNER TO evergreen;

--
-- Name: mat_summary_delete(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.mat_summary_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	DELETE FROM money.materialized_billable_xact_summary WHERE id = OLD.id;
	RETURN OLD;
END;
$$;


ALTER FUNCTION money.mat_summary_delete() OWNER TO evergreen;

--
-- Name: mat_summary_update(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.mat_summary_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	UPDATE	money.materialized_billable_xact_summary
	  SET	usr = NEW.usr,
		xact_start = NEW.xact_start,
		xact_finish = NEW.xact_finish
	  WHERE	id = NEW.id;
	RETURN NEW;
END;
$$;


ALTER FUNCTION money.mat_summary_update() OWNER TO evergreen;

--
-- Name: materialized_summary_billing_add(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.materialized_summary_billing_add() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NOT NEW.voided THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = COALESCE(total_owed, 0.0::numeric) + NEW.amount,
			last_billing_ts = NEW.billing_ts,
			last_billing_note = NEW.note,
			last_billing_type = NEW.billing_type,
			balance_owed = balance_owed + NEW.amount
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_billing_add() OWNER TO evergreen;

--
-- Name: materialized_summary_billing_del(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.materialized_summary_billing_del() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
        prev_billing    money.billing%ROWTYPE;
        old_billing     money.billing%ROWTYPE;
BEGIN
        SELECT * INTO prev_billing FROM money.billing WHERE xact = OLD.xact AND NOT voided ORDER BY billing_ts DESC LIMIT 1 OFFSET 1;
        SELECT * INTO old_billing FROM money.billing WHERE xact = OLD.xact AND NOT voided ORDER BY billing_ts DESC LIMIT 1;

        IF OLD.id = old_billing.id THEN
                UPDATE  money.materialized_billable_xact_summary
                  SET   last_billing_ts = prev_billing.billing_ts,
                        last_billing_note = prev_billing.note,
                        last_billing_type = prev_billing.billing_type
                  WHERE id = OLD.xact;
        END IF;

        IF NOT OLD.voided THEN
                UPDATE  money.materialized_billable_xact_summary
                  SET   total_owed = total_owed - OLD.amount,
                        balance_owed = balance_owed - OLD.amount
                  WHERE id = OLD.xact;
        END IF;

        RETURN OLD;
END;
$$;


ALTER FUNCTION money.materialized_summary_billing_del() OWNER TO evergreen;

--
-- Name: materialized_summary_billing_update(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.materialized_summary_billing_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	old_billing	money.billing%ROWTYPE;
	old_voided	money.billing%ROWTYPE;
BEGIN

	SELECT * INTO old_billing FROM money.billing WHERE xact = NEW.xact AND NOT voided ORDER BY billing_ts DESC LIMIT 1;
	SELECT * INTO old_voided FROM money.billing WHERE xact = NEW.xact ORDER BY billing_ts DESC LIMIT 1;

	IF NEW.voided AND NOT OLD.voided THEN
		IF OLD.id = old_voided.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_billing_ts = old_billing.billing_ts,
				last_billing_note = old_billing.note,
				last_billing_type = old_billing.billing_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = total_owed - NEW.amount,
			balance_owed = balance_owed - NEW.amount
		  WHERE	id = NEW.xact;

	ELSIF NOT NEW.voided AND OLD.voided THEN

		IF OLD.id = old_billing.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_billing_ts = old_billing.billing_ts,
				last_billing_note = old_billing.note,
				last_billing_type = old_billing.billing_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = total_owed + NEW.amount,
			balance_owed = balance_owed + NEW.amount
		  WHERE	id = NEW.xact;

	ELSE
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_owed = total_owed - (OLD.amount - NEW.amount),
			balance_owed = balance_owed - (OLD.amount - NEW.amount)
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_billing_update() OWNER TO evergreen;

--
-- Name: materialized_summary_payment_add(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.materialized_summary_payment_add() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NOT NEW.voided THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = COALESCE(total_paid, 0.0::numeric) + NEW.amount,
			last_payment_ts = NEW.payment_ts,
			last_payment_note = NEW.note,
			last_payment_type = TG_ARGV[0],
			balance_owed = balance_owed - NEW.amount
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_payment_add() OWNER TO evergreen;

--
-- Name: materialized_summary_payment_del(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.materialized_summary_payment_del() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	prev_payment	money.payment_view%ROWTYPE;
	old_payment	money.payment_view%ROWTYPE;
BEGIN
	SELECT * INTO prev_payment FROM money.payment_view WHERE xact = OLD.xact AND NOT voided ORDER BY payment_ts DESC LIMIT 1 OFFSET 1;
	SELECT * INTO old_payment FROM money.payment_view WHERE xact = OLD.xact AND NOT voided ORDER BY payment_ts DESC LIMIT 1;

	IF OLD.id = old_payment.id THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	last_payment_ts = prev_payment.payment_ts,
			last_payment_note = prev_payment.note,
			last_payment_type = prev_payment.payment_type
		  WHERE	id = OLD.xact;
	END IF;

	IF NOT OLD.voided THEN
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid - OLD.amount,
			balance_owed = balance_owed + OLD.amount
		  WHERE	id = OLD.xact;
	END IF;

	RETURN OLD;
END;
$$;


ALTER FUNCTION money.materialized_summary_payment_del() OWNER TO evergreen;

--
-- Name: materialized_summary_payment_update(); Type: FUNCTION; Schema: money; Owner: evergreen
--

CREATE FUNCTION money.materialized_summary_payment_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	old_payment	money.payment_view%ROWTYPE;
	old_voided	money.payment_view%ROWTYPE;
BEGIN

	SELECT * INTO old_payment FROM money.payment_view WHERE xact = NEW.xact AND NOT voided ORDER BY payment_ts DESC LIMIT 1;
	SELECT * INTO old_voided FROM money.payment_view WHERE xact = NEW.xact ORDER BY payment_ts DESC LIMIT 1;

	IF NEW.voided AND NOT OLD.voided THEN
		IF OLD.id = old_voided.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_payment_ts = old_payment.payment_ts,
				last_payment_note = old_payment.note,
				last_payment_type = old_payment.payment_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid - NEW.amount,
			balance_owed = balance_owed + NEW.amount
		  WHERE	id = NEW.xact;

	ELSIF NOT NEW.voided AND OLD.voided THEN

		IF OLD.id = old_payment.id THEN
			UPDATE	money.materialized_billable_xact_summary
			  SET	last_payment_ts = old_payment.payment_ts,
				last_payment_note = old_payment.note,
				last_payment_type = old_payment.payment_type
			  WHERE	id = OLD.xact;
		END IF;

		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid + NEW.amount,
			balance_owed = balance_owed - NEW.amount
		  WHERE	id = NEW.xact;

	ELSE
		UPDATE	money.materialized_billable_xact_summary
		  SET	total_paid = total_paid - (OLD.amount - NEW.amount),
			balance_owed = balance_owed + (OLD.amount - NEW.amount)
		  WHERE	id = NEW.xact;
	END IF;

	RETURN NEW;
END;
$$;


ALTER FUNCTION money.materialized_summary_payment_update() OWNER TO evergreen;

--
-- Name: auth_is_visible_by_axis(bigint, text); Type: FUNCTION; Schema: oai; Owner: evergreen
--

CREATE FUNCTION oai.auth_is_visible_by_axis(auth bigint, ax text) RETURNS boolean
    LANGUAGE sql STABLE
    AS $$
  SELECT EXISTS (SELECT 1 FROM authority.browse_axis_authority_field_map m JOIN authority.simple_heading r on (r.atag = m.field AND r.record = auth AND m.axis = ax))
$$;


ALTER FUNCTION oai.auth_is_visible_by_axis(auth bigint, ax text) OWNER TO evergreen;

--
-- Name: bib_is_visible_at_org_by_copy(bigint, integer); Type: FUNCTION; Schema: oai; Owner: evergreen
--

CREATE FUNCTION oai.bib_is_visible_at_org_by_copy(bib bigint, org integer) RETURNS boolean
    LANGUAGE sql STABLE
    AS $$
WITH corgs AS (SELECT array_agg(id) AS list FROM actor.org_unit_descendants(org))
  SELECT EXISTS (SELECT 1 FROM asset.copy_vis_attr_cache, corgs WHERE vis_attr_vector @@ search.calculate_visibility_attribute_test('circ_lib', corgs.list)::query_int AND bib=record)
$$;


ALTER FUNCTION oai.bib_is_visible_at_org_by_copy(bib bigint, org integer) OWNER TO evergreen;

--
-- Name: bib_is_visible_at_org_by_luri(bigint, integer); Type: FUNCTION; Schema: oai; Owner: evergreen
--

CREATE FUNCTION oai.bib_is_visible_at_org_by_luri(bib bigint, org integer) RETURNS boolean
    LANGUAGE sql STABLE
    AS $$
WITH lorgs AS(SELECT array_agg(id) AS list FROM actor.org_unit_ancestors(org))
  SELECT EXISTS (SELECT 1 FROM biblio.record_entry, lorgs WHERE vis_attr_vector @@ search.calculate_visibility_attribute_test('luri_org', lorgs.list)::query_int AND bib=id)
$$;


ALTER FUNCTION oai.bib_is_visible_at_org_by_luri(bib bigint, org integer) OWNER TO evergreen;

--
-- Name: bib_is_visible_by_source(bigint, text); Type: FUNCTION; Schema: oai; Owner: evergreen
--

CREATE FUNCTION oai.bib_is_visible_by_source(bib bigint, src text) RETURNS boolean
    LANGUAGE sql STABLE
    AS $$
  SELECT EXISTS (SELECT 1 FROM biblio.record_entry b JOIN config.bib_source s ON (b.source = s.id) WHERE transcendant AND s.source = src AND bib=b.id)
$$;


ALTER FUNCTION oai.bib_is_visible_by_source(bib bigint, src text) OWNER TO evergreen;

--
-- Name: grp_tree; Type: TABLE; Schema: permission; Owner: evergreen
--

CREATE TABLE permission.grp_tree (
    id integer NOT NULL,
    name text NOT NULL,
    parent integer,
    usergroup boolean DEFAULT true NOT NULL,
    perm_interval interval DEFAULT '3 years'::interval NOT NULL,
    description text,
    application_perm text,
    hold_priority integer DEFAULT 0 NOT NULL
);


ALTER TABLE permission.grp_tree OWNER TO evergreen;

--
-- Name: grp_ancestors(integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.grp_ancestors(integer) RETURNS SETOF permission.grp_tree
    LANGUAGE sql ROWS 1
    AS $_$
    WITH RECURSIVE grp_ancestors_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT ou.parent, ouad.distance+1
            FROM permission.grp_tree ou JOIN grp_ancestors_distance ouad ON (ou.id = ouad.id)
            WHERE ou.parent IS NOT NULL
    )
    SELECT ou.* FROM permission.grp_tree ou JOIN grp_ancestors_distance ouad USING (id) ORDER BY ouad.distance DESC;
$_$;


ALTER FUNCTION permission.grp_ancestors(integer) OWNER TO evergreen;

--
-- Name: grp_ancestors_distance(integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.grp_ancestors_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE grp_ancestors_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT pgt.parent, gad.distance+1
            FROM permission.grp_tree pgt JOIN grp_ancestors_distance gad ON pgt.id = gad.id
            WHERE pgt.parent IS NOT NULL
    )
    SELECT * FROM grp_ancestors_distance;
$_$;


ALTER FUNCTION permission.grp_ancestors_distance(integer) OWNER TO evergreen;

--
-- Name: grp_descendants(integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.grp_descendants(integer) RETURNS SETOF permission.grp_tree
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE descendant_depth AS (
        SELECT  gr.id,
                gr.parent
          FROM  permission.grp_tree gr
          WHERE gr.id = $1
            UNION ALL
        SELECT  gr.id,
                gr.parent
          FROM  permission.grp_tree gr
                JOIN descendant_depth dd ON (dd.id = gr.parent)
    ) SELECT gr.* FROM permission.grp_tree gr JOIN descendant_depth USING (id);
$_$;


ALTER FUNCTION permission.grp_descendants(integer) OWNER TO evergreen;

--
-- Name: grp_descendants_distance(integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.grp_descendants_distance(integer) RETURNS TABLE(id integer, distance integer)
    LANGUAGE sql STABLE ROWS 1
    AS $_$
    WITH RECURSIVE grp_descendants_distance(id, distance) AS (
            SELECT $1, 0
        UNION
            SELECT pgt.id, gdd.distance+1
            FROM permission.grp_tree pgt JOIN grp_descendants_distance gdd ON pgt.parent = gdd.id
    )
    SELECT * FROM grp_descendants_distance;
$_$;


ALTER FUNCTION permission.grp_descendants_distance(integer) OWNER TO evergreen;

--
-- Name: grp_tree_combined_ancestors(integer, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.grp_tree_combined_ancestors(integer, integer) RETURNS SETOF permission.grp_tree
    LANGUAGE sql STABLE ROWS 1
    AS $_$
        SELECT  *
          FROM  permission.grp_ancestors($1)
                        UNION
        SELECT  *
          FROM  permission.grp_ancestors($2);
$_$;


ALTER FUNCTION permission.grp_tree_combined_ancestors(integer, integer) OWNER TO evergreen;

--
-- Name: grp_tree_common_ancestors(integer, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.grp_tree_common_ancestors(integer, integer) RETURNS SETOF permission.grp_tree
    LANGUAGE sql STABLE ROWS 1
    AS $_$
        SELECT  *
          FROM  permission.grp_ancestors($1)
                        INTERSECT
        SELECT  *
          FROM  permission.grp_ancestors($2);
$_$;


ALTER FUNCTION permission.grp_tree_common_ancestors(integer, integer) OWNER TO evergreen;

--
-- Name: grp_tree_full_path(integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.grp_tree_full_path(integer) RETURNS SETOF permission.grp_tree
    LANGUAGE sql STABLE ROWS 1
    AS $_$
        SELECT  *
          FROM  permission.grp_ancestors($1)
                        UNION
        SELECT  *
          FROM  permission.grp_descendants($1);
$_$;


ALTER FUNCTION permission.grp_tree_full_path(integer) OWNER TO evergreen;

--
-- Name: usr_can_grant_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.usr_can_grant_perm(iuser integer, tperm text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_usr	actor.usr%ROWTYPE;
	r_perm	permission.usr_perm_map%ROWTYPE;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	FOR r_perm IN	SELECT	*
			  FROM	permission.usr_perms(iuser) p
				JOIN permission.perm_list l
					ON (l.id = p.perm)
			  WHERE	(l.code = tperm AND p.grantable IS TRUE)
		LOOP

		PERFORM	*
		  FROM	actor.org_unit_descendants(target_ou,r_perm.depth)
		  WHERE	id = r_usr.home_ou;

		IF FOUND THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END LOOP;

	RETURN FALSE;
END;
$$;


ALTER FUNCTION permission.usr_can_grant_perm(iuser integer, tperm text, target_ou integer) OWNER TO evergreen;

--
-- Name: usr_has_home_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.usr_has_home_perm(iuser integer, tperm text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_usr	actor.usr%ROWTYPE;
	r_perm	permission.usr_perm_map%ROWTYPE;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	FOR r_perm IN	SELECT	*
			  FROM	permission.usr_perms(iuser) p
				JOIN permission.perm_list l
					ON (l.id = p.perm)
			  WHERE	l.code = tperm
			  	OR p.perm = -1 LOOP

		PERFORM	*
		  FROM	actor.org_unit_descendants(target_ou,r_perm.depth)
		  WHERE	id = r_usr.home_ou;

		IF FOUND THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END LOOP;

	RETURN FALSE;
END;
$$;


ALTER FUNCTION permission.usr_has_home_perm(iuser integer, tperm text, target_ou integer) OWNER TO evergreen;

--
-- Name: usr_has_object_perm(integer, text, text, text); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.usr_has_object_perm(integer, text, text, text) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT permission.usr_has_object_perm( $1, $2, $3, $4, -1 );
$_$;


ALTER FUNCTION permission.usr_has_object_perm(integer, text, text, text) OWNER TO evergreen;

--
-- Name: usr_has_object_perm(integer, text, text, text, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.usr_has_object_perm(iuser integer, tperm text, obj_type text, obj_id text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_usr	actor.usr%ROWTYPE;
	res     BOOL;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	SELECT TRUE INTO res FROM permission.usr_object_perm_map WHERE usr = r_usr.id AND object_type = obj_type AND object_id = obj_id;

	IF FOUND THEN
		RETURN TRUE;
	END IF;

	IF target_ou > -1 THEN
		RETURN permission.usr_has_perm( iuser, tperm, target_ou);
	END IF;

	RETURN FALSE;

END;
$$;


ALTER FUNCTION permission.usr_has_object_perm(iuser integer, tperm text, obj_type text, obj_id text, target_ou integer) OWNER TO evergreen;

--
-- Name: usr_has_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.usr_has_perm(integer, text, integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
	SELECT	CASE
			WHEN permission.usr_has_home_perm( $1, $2, $3 ) THEN TRUE
			WHEN permission.usr_has_work_perm( $1, $2, $3 ) THEN TRUE
			ELSE FALSE
		END;
$_$;


ALTER FUNCTION permission.usr_has_perm(integer, text, integer) OWNER TO evergreen;

--
-- Name: usr_has_perm_at(integer, text); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.usr_has_perm_at(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE sql ROWS 1
    AS $_$
SELECT DISTINCT * FROM permission.usr_has_perm_at_nd( $1, $2 );
$_$;


ALTER FUNCTION permission.usr_has_perm_at(user_id integer, perm_code text) OWNER TO evergreen;

--
-- Name: usr_has_perm_at_all(integer, text); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.usr_has_perm_at_all(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE sql ROWS 1
    AS $_$
SELECT DISTINCT * FROM permission.usr_has_perm_at_all_nd( $1, $2 );
$_$;


ALTER FUNCTION permission.usr_has_perm_at_all(user_id integer, perm_code text) OWNER TO evergreen;

--
-- Name: usr_has_perm_at_all_nd(integer, text); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.usr_has_perm_at_all_nd(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE plpgsql ROWS 1
    AS $$
--
-- Return a set of all the org units for which a given user has a given
-- permission, granted either directly or through inheritance from a parent
-- org unit.
--
-- The permissions apply to a minimum depth of the org unit hierarchy, and
-- to the subordinates of those org units, for the org unit(s) to which the
-- user is assigned.
--
-- For purposes of this function, the permission.usr_work_ou_map table
-- assigns users to org units.  I.e. we ignore the home_ou column of actor.usr.
--
-- The result set may contain duplicates, which should be eliminated
-- by a DISTINCT clause.
--
DECLARE
	n_head_ou     INTEGER;
	n_child_ou    INTEGER;
BEGIN
	FOR n_head_ou IN
		SELECT DISTINCT * FROM permission.usr_has_perm_at_nd( user_id, perm_code )
	LOOP
		--
		-- The permission applies only at a depth greater than the work org unit.
		--
		FOR n_child_ou IN
            SELECT id
            FROM actor.org_unit_descendants(n_head_ou)
		LOOP
			RETURN NEXT n_child_ou;
		END LOOP;
	END LOOP;
	--
	RETURN;
	--
END;
$$;


ALTER FUNCTION permission.usr_has_perm_at_all_nd(user_id integer, perm_code text) OWNER TO evergreen;

--
-- Name: usr_has_perm_at_nd(integer, text); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.usr_has_perm_at_nd(user_id integer, perm_code text) RETURNS SETOF integer
    LANGUAGE plpgsql ROWS 1
    AS $$
--
-- Return a set of all the org units for which a given user has a given
-- permission, granted directly (not through inheritance from a parent
-- org unit).
--
-- The permissions apply to a minimum depth of the org unit hierarchy,
-- for the org unit(s) to which the user is assigned.  (They also apply
-- to the subordinates of those org units, but we don't report the
-- subordinates here.)
--
-- For purposes of this function, the permission.usr_work_ou_map table
-- defines which users belong to which org units.  I.e. we ignore the
-- home_ou column of actor.usr.
--
-- The result set may contain duplicates, which should be eliminated
-- by a DISTINCT clause.
--
DECLARE
	b_super       BOOLEAN;
	n_perm        INTEGER;
	n_min_depth   INTEGER; 
	n_work_ou     INTEGER;
	n_curr_ou     INTEGER;
	n_depth       INTEGER;
	n_curr_depth  INTEGER;
BEGIN
	--
	-- Check for superuser
	--
	SELECT INTO b_super
		super_user
	FROM
		actor.usr
	WHERE
		id = user_id;
	--
	IF NOT FOUND THEN
		return;				-- No user?  No permissions.
	ELSIF b_super THEN
		--
		-- Super user has all permissions everywhere
		--
		FOR n_work_ou IN
			SELECT
				id
			FROM
				actor.org_unit
			WHERE
				parent_ou IS NULL
		LOOP
			RETURN NEXT n_work_ou; 
		END LOOP;
		RETURN;
	END IF;
	--
	-- Translate the permission name
	-- to a numeric permission id
	--
	SELECT INTO n_perm
		id
	FROM
		permission.perm_list
	WHERE
		code = perm_code;
	--
	IF NOT FOUND THEN
		RETURN;               -- No such permission
	END IF;
	--
	-- Find the highest-level org unit (i.e. the minimum depth)
	-- to which the permission is applied for this user
	--
	-- This query is modified from the one in permission.usr_perms().
	--
	SELECT INTO n_min_depth
		min( depth )
	FROM	(
		SELECT depth 
		  FROM permission.usr_perm_map upm
		 WHERE upm.usr = user_id 
		   AND (upm.perm = n_perm OR upm.perm = -1)
       				UNION
		SELECT	gpm.depth
		  FROM	permission.grp_perm_map gpm
		  WHERE	(gpm.perm = n_perm OR gpm.perm = -1)
	        AND gpm.grp IN (
	 		   SELECT	(permission.grp_ancestors(
					(SELECT profile FROM actor.usr WHERE id = user_id)
				)).id
			)
       				UNION
		SELECT	p.depth
		  FROM	permission.grp_perm_map p 
		  WHERE (p.perm = n_perm OR p.perm = -1)
		    AND p.grp IN (
		  		SELECT (permission.grp_ancestors(m.grp)).id 
				FROM   permission.usr_grp_map m
				WHERE  m.usr = user_id
			)
	) AS x;
	--
	IF NOT FOUND THEN
		RETURN;                -- No such permission for this user
	END IF;
	--
	-- Identify the org units to which the user is assigned.  Note that
	-- we pay no attention to the home_ou column in actor.usr.
	--
	FOR n_work_ou IN
		SELECT
			work_ou
		FROM
			permission.usr_work_ou_map
		WHERE
			usr = user_id
	LOOP            -- For each org unit to which the user is assigned
		--
		-- Determine the level of the org unit by a lookup in actor.org_unit_type.
		-- We take it on faith that this depth agrees with the actual hierarchy
		-- defined in actor.org_unit.
		--
		SELECT INTO n_depth
		    type.depth
		FROM
		    actor.org_unit_type type
		        INNER JOIN actor.org_unit ou
		            ON ( ou.ou_type = type.id )
		WHERE
		    ou.id = n_work_ou;
		--
		IF NOT FOUND THEN
			CONTINUE;        -- Maybe raise exception?
		END IF;
		--
		-- Compare the depth of the work org unit to the
		-- minimum depth, and branch accordingly
		--
		IF n_depth = n_min_depth THEN
			--
			-- The org unit is at the right depth, so return it.
			--
			RETURN NEXT n_work_ou;
		ELSIF n_depth > n_min_depth THEN
			--
			-- Traverse the org unit tree toward the root,
			-- until you reach the minimum depth determined above
			--
			n_curr_depth := n_depth;
			n_curr_ou := n_work_ou;
			WHILE n_curr_depth > n_min_depth LOOP
				SELECT INTO n_curr_ou
					parent_ou
				FROM
					actor.org_unit
				WHERE
					id = n_curr_ou;
				--
				IF FOUND THEN
					n_curr_depth := n_curr_depth - 1;
				ELSE
					--
					-- This can happen only if the hierarchy defined in
					-- actor.org_unit is corrupted, or out of sync with
					-- the depths defined in actor.org_unit_type.
					-- Maybe we should raise an exception here, instead
					-- of silently ignoring the problem.
					--
					n_curr_ou = NULL;
					EXIT;
				END IF;
			END LOOP;
			--
			IF n_curr_ou IS NOT NULL THEN
				RETURN NEXT n_curr_ou;
			END IF;
		ELSE
			--
			-- The permission applies only at a depth greater than the work org unit.
			-- Use connectby() to find all dependent org units at the specified depth.
			--
			FOR n_curr_ou IN
				SELECT id
				FROM actor.org_unit_descendants_distance(n_work_ou)
				WHERE
					distance = n_min_depth - n_depth
			LOOP
				RETURN NEXT n_curr_ou;
			END LOOP;
		END IF;
		--
	END LOOP;
	--
	RETURN;
	--
END;
$$;


ALTER FUNCTION permission.usr_has_perm_at_nd(user_id integer, perm_code text) OWNER TO evergreen;

--
-- Name: usr_has_work_perm(integer, text, integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.usr_has_work_perm(iuser integer, tperm text, target_ou integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	r_woum	permission.usr_work_ou_map%ROWTYPE;
	r_usr	actor.usr%ROWTYPE;
	r_perm	permission.usr_perm_map%ROWTYPE;
BEGIN

	SELECT * INTO r_usr FROM actor.usr WHERE id = iuser;

	IF r_usr.active = FALSE THEN
		RETURN FALSE;
	END IF;

	IF r_usr.super_user = TRUE THEN
		RETURN TRUE;
	END IF;

	FOR r_perm IN	SELECT	*
			  FROM	permission.usr_perms(iuser) p
				JOIN permission.perm_list l
					ON (l.id = p.perm)
			  WHERE	l.code = tperm
			  	OR p.perm = -1
		LOOP

		FOR r_woum IN	SELECT	*
				  FROM	permission.usr_work_ou_map
				  WHERE	usr = iuser
			LOOP

			PERFORM	*
			  FROM	actor.org_unit_descendants(target_ou,r_perm.depth)
			  WHERE	id = r_woum.work_ou;

			IF FOUND THEN
				RETURN TRUE;
			END IF;

		END LOOP;

	END LOOP;

	RETURN FALSE;
END;
$$;


ALTER FUNCTION permission.usr_has_work_perm(iuser integer, tperm text, target_ou integer) OWNER TO evergreen;

--
-- Name: usr_perm_map; Type: TABLE; Schema: permission; Owner: evergreen
--

CREATE TABLE permission.usr_perm_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    perm integer NOT NULL,
    depth integer NOT NULL,
    grantable boolean DEFAULT false NOT NULL
);


ALTER TABLE permission.usr_perm_map OWNER TO evergreen;

--
-- Name: usr_perms(integer); Type: FUNCTION; Schema: permission; Owner: evergreen
--

CREATE FUNCTION permission.usr_perms(integer) RETURNS SETOF permission.usr_perm_map
    LANGUAGE sql STABLE ROWS 10
    AS $_$
    SELECT	DISTINCT ON (usr,perm) *
	  FROM	(
			(SELECT * FROM permission.usr_perm_map WHERE usr = $1)
            UNION ALL
			(SELECT	-p.id, $1 AS usr, p.perm, p.depth, p.grantable
			  FROM	permission.grp_perm_map p
			  WHERE	p.grp IN (
      SELECT	(permission.grp_ancestors(
      (SELECT profile FROM actor.usr WHERE id = $1)
					)).id
				)
			)
            UNION ALL
			(SELECT	-p.id, $1 AS usr, p.perm, p.depth, p.grantable
			  FROM	permission.grp_perm_map p
			  WHERE	p.grp IN (SELECT (permission.grp_ancestors(m.grp)).id FROM permission.usr_grp_map m WHERE usr = $1))
		) AS x
	  ORDER BY 2, 3, 4 ASC, 5 DESC ;
$_$;


ALTER FUNCTION permission.usr_perms(integer) OWNER TO evergreen;

--
-- Name: approximate_date(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.approximate_date(text, text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT REGEXP_REPLACE( $1, E'\\D', $2, 'g' );
$_$;


ALTER FUNCTION public.approximate_date(text, text) OWNER TO evergreen;

--
-- Name: approximate_high_date(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.approximate_high_date(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT approximate_date( $1, '9');
$_$;


ALTER FUNCTION public.approximate_high_date(text) OWNER TO evergreen;

--
-- Name: approximate_low_date(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.approximate_low_date(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT approximate_date( $1, '0');
$_$;


ALTER FUNCTION public.approximate_low_date(text) OWNER TO evergreen;

--
-- Name: auth_n_bib_generator(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.auth_n_bib_generator(auth_heading text) RETURNS public.auth_n_bib
    LANGUAGE plpgsql
    AS $_$
DECLARE
    auth_n_bib_data	auth_n_bib;
    temp_bibs		BIGINT[] := '{}';
    temp_afr		authority.full_rec%ROWTYPE;
    sub_tag		TEXT;
BEGIN
    -- ver 0.3

    -- Add % to end to take into consideration additonal characters like '.' and date ($d).
    -- This may get us more bibs then wanted but will a little more is better than missing some.
    auth_heading := auth_heading || '%';

    -- Get the auth record full rec for the given auth heading
    SELECT * INTO temp_afr FROM authority.full_rec WHERE value ILIKE auth_heading AND tag LIKE '1__' AND subfield LIKE 'a';

    --------- PRIMARY AUTH RECORD ---------
    -- Set the primary auth record id
    auth_n_bib_data.primary_auth := temp_afr.record;

    -- Get all bib record id's associated with the primary auth record
    SELECT * INTO auth_n_bib_data.bibs FROM public.generate_bibs_associated_to_auth_heading(temp_afr.tag, auth_heading);

    --------- LINKED AUTH RECORDS ---------
    -- Loop for getting all linked auth record id's and their associated bib record id's
    FOR temp_afr IN SELECT afr2.* FROM authority.full_rec AS afr1 JOIN authority.full_rec AS afr2 ON afr1.record = afr2.record WHERE afr1.value ILIKE auth_heading AND afr1.tag LIKE '5__' AND afr2.tag LIKE '1__' AND afr2.subfield LIKE 'a' LOOP
        -- Add auth record id to the list
        auth_n_bib_data.auths := array_append(auth_n_bib_data.auths, temp_afr.record);

        -- Add linked bib id's to the list
        SELECT * INTO temp_bibs FROM public.generate_bibs_associated_to_auth_heading(temp_afr.tag, temp_afr.value);
        SELECT INTO auth_n_bib_data.bibs ARRAY( SELECT unnest(auth_n_bib_data.bibs) AS e UNION SELECT unnest(temp_bibs) AS e ORDER BY e);
    END LOOP;

    RETURN auth_n_bib_data;
END;
$_$;


ALTER FUNCTION public.auth_n_bib_generator(auth_heading text) OWNER TO evergreen;

--
-- Name: btean13cmp(public.ean13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btean13cmp(public.ean13, public.ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: btean13cmp(public.ean13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btean13cmp(public.ean13, public.isbn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: btean13cmp(public.ean13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btean13cmp(public.ean13, public.isbn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: btean13cmp(public.ean13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btean13cmp(public.ean13, public.ismn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: btean13cmp(public.ean13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btean13cmp(public.ean13, public.ismn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: btean13cmp(public.ean13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btean13cmp(public.ean13, public.issn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: btean13cmp(public.ean13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btean13cmp(public.ean13, public.issn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: btean13cmp(public.ean13, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btean13cmp(public.ean13, public.upc) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btean13cmp(public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: btisbn13cmp(public.isbn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btisbn13cmp(public.isbn13, public.ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbn13cmp(public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: btisbn13cmp(public.isbn13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btisbn13cmp(public.isbn13, public.isbn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbn13cmp(public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: btisbn13cmp(public.isbn13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btisbn13cmp(public.isbn13, public.isbn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbn13cmp(public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: btisbncmp(public.isbn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btisbncmp(public.isbn, public.ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbncmp(public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: btisbncmp(public.isbn, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btisbncmp(public.isbn, public.isbn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbncmp(public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: btisbncmp(public.isbn, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btisbncmp(public.isbn, public.isbn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btisbncmp(public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: btismn13cmp(public.ismn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btismn13cmp(public.ismn13, public.ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismn13cmp(public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: btismn13cmp(public.ismn13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btismn13cmp(public.ismn13, public.ismn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismn13cmp(public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: btismn13cmp(public.ismn13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btismn13cmp(public.ismn13, public.ismn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismn13cmp(public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: btismncmp(public.ismn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btismncmp(public.ismn, public.ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismncmp(public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: btismncmp(public.ismn, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btismncmp(public.ismn, public.ismn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismncmp(public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: btismncmp(public.ismn, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btismncmp(public.ismn, public.ismn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btismncmp(public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: btissn13cmp(public.issn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btissn13cmp(public.issn13, public.ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissn13cmp(public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: btissn13cmp(public.issn13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btissn13cmp(public.issn13, public.issn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissn13cmp(public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: btissn13cmp(public.issn13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btissn13cmp(public.issn13, public.issn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissn13cmp(public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: btissncmp(public.issn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btissncmp(public.issn, public.ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissncmp(public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: btissncmp(public.issn, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btissncmp(public.issn, public.issn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissncmp(public.issn, public.issn) OWNER TO evergreen;

--
-- Name: btissncmp(public.issn, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btissncmp(public.issn, public.issn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btissncmp(public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: btupccmp(public.upc, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btupccmp(public.upc, public.ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btupccmp(public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: btupccmp(public.upc, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.btupccmp(public.upc, public.upc) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$btint8cmp$$;


ALTER FUNCTION public.btupccmp(public.upc, public.upc) OWNER TO evergreen;

--
-- Name: call_number_dewey(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.call_number_dewey(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
	my $txt = shift;
	$txt =~ s/^\s+//o;
	$txt =~ s/[\[\]\{\}\(\)`'"#<>\*\?\-\+\$\\]+//og;
	$txt =~ s/\s+$//o;
	if ($txt =~ /(\d{3}(?:\.\d+)?)/o) {
		return $1;
	} else {
		return (split /\s+/, $txt)[0];
	}
$_$;


ALTER FUNCTION public.call_number_dewey(text) OWNER TO evergreen;

--
-- Name: call_number_dewey(text, integer); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.call_number_dewey(text, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT SUBSTRING(call_number_dewey($1) FROM 1 FOR $2);
$_$;


ALTER FUNCTION public.call_number_dewey(text, integer) OWNER TO evergreen;

--
-- Name: cleanup_acq_marc(); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.cleanup_acq_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF TG_OP = 'UPDATE' THEN
		DELETE FROM acq.lineitem_attr
	    		WHERE lineitem = OLD.id AND attr_type IN ('lineitem_provider_attr_definition', 'lineitem_marc_attr_definition','lineitem_generated_attr_definition');
		RETURN NEW;
	ELSE
		DELETE FROM acq.lineitem_attr WHERE lineitem = OLD.id;
		RETURN OLD;
	END IF;
END;
$$;


ALTER FUNCTION public.cleanup_acq_marc() OWNER TO evergreen;

--
-- Name: connectby(text, text, text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.connectby(text, text, text, text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text';


ALTER FUNCTION public.connectby(text, text, text, text, integer) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.connectby(text, text, text, text, integer, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text';


ALTER FUNCTION public.connectby(text, text, text, text, integer, text) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.connectby(text, text, text, text, text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text_serial';


ALTER FUNCTION public.connectby(text, text, text, text, text, integer) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, text, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.connectby(text, text, text, text, text, integer, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text_serial';


ALTER FUNCTION public.connectby(text, text, text, text, text, integer, text) OWNER TO postgres;

--
-- Name: content_or_null(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.content_or_null(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT CASE WHEN $1 ~ E'^\\s*$' THEN NULL ELSE $1 END
$_$;


ALTER FUNCTION public.content_or_null(text) OWNER TO evergreen;

--
-- Name: crosstab(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab(text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab(text) OWNER TO postgres;

--
-- Name: crosstab(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab(text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab(text, integer) OWNER TO postgres;

--
-- Name: crosstab(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab(text, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab_hash';


ALTER FUNCTION public.crosstab(text, text) OWNER TO postgres;

--
-- Name: crosstab2(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab2(text) RETURNS SETOF public.tablefunc_crosstab_2
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab2(text) OWNER TO postgres;

--
-- Name: crosstab3(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab3(text) RETURNS SETOF public.tablefunc_crosstab_3
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab3(text) OWNER TO postgres;

--
-- Name: crosstab4(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab4(text) RETURNS SETOF public.tablefunc_crosstab_4
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab4(text) OWNER TO postgres;


--
-- Name: entityize(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.entityize(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
    use Unicode::Normalize;

    my $x = NFC(shift);
    $x =~ s/([\x{0080}-\x{fffd}])/sprintf('&#x%X;',ord($1))/sgoe;
    return $x;

$_$;


ALTER FUNCTION public.entityize(text) OWNER TO evergreen;

--
-- Name: explode_array(anyarray); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.explode_array(anyarray) RETURNS SETOF anyelement
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT ($1)[s] FROM generate_series(1, array_upper($1, 1)) AS s;
$_$;


ALTER FUNCTION public.explode_array(anyarray) OWNER TO evergreen;

--
-- Name: export_ids_has_copy(bigint); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.export_ids_has_copy(record_to_check bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

-- Returns true if a record has a copy attached
DECLARE
  v_row_count BIGINT;
BEGIN

  SELECT count(acp.id) INTO v_row_count
  FROM biblio.record_entry AS bre
  JOIN asset.call_number AS acn
  ON bre.id = acn.record
  JOIN asset.copy AS acp
  ON acn.id = acp.call_number
  WHERE bre.id = record_to_check;
  
  IF v_row_count > 0 THEN
     RETURN TRUE;
  ELSE
     RETURN FALSE;
  END IF;
    
END $$;


ALTER FUNCTION public.export_ids_has_copy(record_to_check bigint) OWNER TO evergreen;

--
-- Name: export_ids_ldr(bigint); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.export_ids_ldr(record_to_check bigint) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

-- Returns true if a record has an 'f' in deleted field of biblio.record_entry
DECLARE
  export_bib BOOLEAN;
BEGIN

  SELECT deleted into export_bib
  FROM biblio.record_entry
  WHERE id = record_to_check;

  IF export_bib  = 'f' THEN
     RETURN TRUE;
  ELSE
     RETURN FALSE;
  END IF;
     
END $$;


ALTER FUNCTION public.export_ids_ldr(record_to_check bigint) OWNER TO evergreen;

--
-- Name: extract_acq_marc_field(bigint, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.extract_acq_marc_field(bigint, text, text) RETURNS text
    LANGUAGE sql
    AS $_$    
    SELECT extract_marc_field('acq.lineitem', $1, $2, $3);
$_$;


ALTER FUNCTION public.extract_acq_marc_field(bigint, text, text) OWNER TO evergreen;

--
-- Name: extract_acq_marc_field_set(bigint, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.extract_acq_marc_field_set(bigint, text, text) RETURNS SETOF text
    LANGUAGE sql
    AS $_$
	SELECT extract_marc_field_set('acq.lineitem', $1, $2, $3);
$_$;


ALTER FUNCTION public.extract_acq_marc_field_set(bigint, text, text) OWNER TO evergreen;

--
-- Name: extract_marc_field(text, bigint, text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.extract_marc_field(text, bigint, text, text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT regexp_replace(string_agg(output,' '),$4,'','g') FROM oils_xpath_table('id', 'marc', $1, $3, 'id='||$2)x(id INT, output TEXT);
$_$;


ALTER FUNCTION public.extract_marc_field(text, bigint, text, text) OWNER TO evergreen;

--
-- Name: first5(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.first5(text) RETURNS text
    LANGUAGE sql
    AS $_$
	SELECT SUBSTRING( $1, 1, 5);
$_$;


ALTER FUNCTION public.first5(text) OWNER TO evergreen;

--
-- Name: first_agg(anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.first_agg(anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql STABLE
    AS $_$
	SELECT CASE WHEN $1 IS NULL THEN $2 ELSE $1 END;
$_$;


ALTER FUNCTION public.first_agg(anyelement, anyelement) OWNER TO evergreen;

--
-- Name: first_word(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.first_word(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_X$
        SELECT COALESCE(SUBSTRING( $1 FROM $_$^\S+$_$), '');
$_X$;


ALTER FUNCTION public.first_word(text) OWNER TO evergreen;

--
-- Name: force_to_isbn13(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.force_to_isbn13(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    use Business::ISBN;
    use strict;
    use warnings;

    # Find the first ISBN, force it to ISBN13 and return it

    my $input = shift;

    foreach my $word (split(/\s/, $input)) {
        my $isbn = Business::ISBN->new($word);

        # First check the checksum; if it is not valid, fix it and add the original
        # bad-checksum ISBN to the output
        if ($isbn && $isbn->is_valid_checksum() == Business::ISBN::BAD_CHECKSUM) {
            $isbn->fix_checksum();
        }

        # If we now have a valid ISBN, force it to ISBN13 and return it
        return $isbn->as_isbn13->isbn if ($isbn && $isbn->is_valid());
    }
    return undef;
$_$;


ALTER FUNCTION public.force_to_isbn13(text) OWNER TO evergreen;

--
-- Name: FUNCTION force_to_isbn13(text); Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON FUNCTION public.force_to_isbn13(text) IS '
/*
 * Copyright (C) 2011 Equinox Software
 * Mike Rylander <mrylander@gmail.com>
 *
 * Inspired by translate_isbn1013
 *
 * The force_to_isbn13 function takes an input ISBN and returns the ISBN13
 * version without hypens and with a repaired checksum if the checksum was bad
 */
';


--
-- Name: generate_bibs_associated_to_auth_heading(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.generate_bibs_associated_to_auth_heading(field text, auth_heading text) RETURNS bigint[]
    LANGUAGE plpgsql
    AS $_$
DECLARE
    temp_bibs		BIGINT[] := '{}';
BEGIN
    -- ver 0.1

    -- Add % to end to take into consideration additonal characters like '.' and date ($d).
    -- This may get us more bibs then wanted but will a little more is better than missing some.
    auth_heading := auth_heading || '%';

    -- Get all bib record id's associated with the primary auth record
    CASE field
        WHEN '100' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag IN ('100', '600', '700', '800');
        WHEN '110' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag IN ('110', '610', '710', '810');
        WHEN '111' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag IN ('111', '611', '711', '811');
        WHEN '130' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag IN ('130', '630', '730', '830');
        WHEN '150' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag LIKE '650';
        WHEN '151' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag LIKE '651';
        WHEN '155' THEN
            SELECT INTO temp_bibs COALESCE(ARRAY_AGG(record), ARRAY[]::BIGINT[])
                FROM metabib.real_full_rec WHERE value ILIKE auth_heading AND subfield LIKE 'a' AND tag LIKE '655';
        ELSE
    END CASE;

    RETURN temp_bibs;
END;
$_$;


ALTER FUNCTION public.generate_bibs_associated_to_auth_heading(field text, auth_heading text) OWNER TO evergreen;

--
-- Name: get_ind(bigint, integer); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.get_ind(source bigint, field integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    ind TEXT := NULL;
    ind_record RECORD;
BEGIN  
    IF field = 6 THEN
	SELECT ind2 AS ind INTO ind_record FROM metabib.real_full_rec WHERE record = source AND tag = '245' AND subfield = 'a' GROUP BY ind;
	ind := ind_record.ind;
    ELSIF field = 3 THEN
	SELECT ind2 AS ind INTO ind_record FROM metabib.real_full_rec WHERE record = source AND tag = '240' AND subfield = 'a' GROUP BY ind;
	ind := ind_record.ind;
    ELSIF field = 5 THEN
	SELECT ind1 AS ind INTO ind_record FROM metabib.real_full_rec WHERE record = source AND tag = '130' AND subfield = 'a' GROUP BY ind;
	ind := ind_record.ind;
    ELSIF field = 216 THEN
	SELECT ind2 AS ind INTO ind_record FROM metabib.real_full_rec WHERE record = source AND tag = '222' AND subfield = 'a' GROUP BY ind;
	ind := ind_record.ind;
    ELSIF field = 227 THEN
	SELECT ind1 AS ind INTO ind_record FROM metabib.real_full_rec WHERE record = source AND tag = '730' AND subfield = 'a' GROUP BY ind;
	ind := ind_record.ind;
    END IF;

    return ind;
END;
$$;


ALTER FUNCTION public.get_ind(source bigint, field integer) OWNER TO evergreen;

--
-- Name: hashean13(public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.hashean13(public.ean13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashean13(public.ean13) OWNER TO evergreen;

--
-- Name: hashisbn(public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.hashisbn(public.isbn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashisbn(public.isbn) OWNER TO evergreen;

--
-- Name: hashisbn13(public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.hashisbn13(public.isbn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashisbn13(public.isbn13) OWNER TO evergreen;

--
-- Name: hashismn(public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.hashismn(public.ismn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashismn(public.ismn) OWNER TO evergreen;

--
-- Name: hashismn13(public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.hashismn13(public.ismn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashismn13(public.ismn13) OWNER TO evergreen;

--
-- Name: hashissn(public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.hashissn(public.issn) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashissn(public.issn) OWNER TO evergreen;

--
-- Name: hashissn13(public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.hashissn13(public.issn13) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashissn13(public.issn13) OWNER TO evergreen;

--
-- Name: hashupc(public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.hashupc(public.upc) RETURNS integer
    LANGUAGE internal IMMUTABLE STRICT
    AS $$hashint8$$;


ALTER FUNCTION public.hashupc(public.upc) OWNER TO evergreen;

--
-- Name: ingest_acq_marc(); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.ingest_acq_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
	value		TEXT;
	atype		TEXT;
	prov		INT;
	pos 		INT;
	adef		RECORD;
	xpath_string	TEXT;
BEGIN
	FOR adef IN SELECT *,tableoid FROM acq.lineitem_attr_definition LOOP

		SELECT relname::TEXT INTO atype FROM pg_class WHERE oid = adef.tableoid;

		IF (atype NOT IN ('lineitem_usr_attr_definition','lineitem_local_attr_definition')) THEN
			IF (atype = 'lineitem_provider_attr_definition') THEN
				SELECT provider INTO prov FROM acq.lineitem_provider_attr_definition WHERE id = adef.id;
				CONTINUE WHEN NEW.provider IS NULL OR prov <> NEW.provider;
			END IF;
			
			IF (atype = 'lineitem_provider_attr_definition') THEN
				SELECT xpath INTO xpath_string FROM acq.lineitem_provider_attr_definition WHERE id = adef.id;
			ELSIF (atype = 'lineitem_marc_attr_definition') THEN
				SELECT xpath INTO xpath_string FROM acq.lineitem_marc_attr_definition WHERE id = adef.id;
			ELSIF (atype = 'lineitem_generated_attr_definition') THEN
				SELECT xpath INTO xpath_string FROM acq.lineitem_generated_attr_definition WHERE id = adef.id;
			END IF;

            xpath_string := REGEXP_REPLACE(xpath_string,$re$//?text\(\)$$re$,'');

            IF (adef.code = 'title' OR adef.code = 'author') THEN
                -- title and author should not be split
                -- FIXME: once oils_xpath can grok XPATH 2.0 functions, we can use
                -- string-join in the xpath and remove this special case
    			SELECT extract_acq_marc_field(id, xpath_string, adef.remove) INTO value FROM acq.lineitem WHERE id = NEW.id;
    			IF (value IS NOT NULL AND value <> '') THEN
				    INSERT INTO acq.lineitem_attr (lineitem, definition, attr_type, attr_name, attr_value)
	     			    VALUES (NEW.id, adef.id, atype, adef.code, value);
                END IF;
            ELSE
                pos := 1;
                LOOP
                    -- each application of the regex may produce multiple values
                    FOR value IN
                        SELECT * FROM extract_acq_marc_field_set(
                            NEW.id, xpath_string || '[' || pos || ']', adef.remove)
                        LOOP

                        IF (value IS NOT NULL AND value <> '') THEN
                            INSERT INTO acq.lineitem_attr
                                (lineitem, definition, attr_type, attr_name, attr_value)
                                VALUES (NEW.id, adef.id, atype, adef.code, value);
                        ELSE
                            EXIT;
                        END IF;
                    END LOOP;
                    IF NOT FOUND THEN
                        EXIT;
                    END IF;
                    pos := pos + 1;
               END LOOP;
            END IF;

		END IF;

	END LOOP;

	RETURN NULL;
END;
$_$;


ALTER FUNCTION public.ingest_acq_marc() OWNER TO evergreen;

--
-- Name: integer_or_null(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.integer_or_null(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT CASE WHEN $1 ~ E'^\\d+$' THEN $1 ELSE NULL END
$_$;


ALTER FUNCTION public.integer_or_null(text) OWNER TO evergreen;

--
-- Name: is_valid(public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.is_valid(public.ean13) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(public.ean13) OWNER TO evergreen;

--
-- Name: is_valid(public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.is_valid(public.isbn) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(public.isbn) OWNER TO evergreen;

--
-- Name: is_valid(public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.is_valid(public.isbn13) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(public.isbn13) OWNER TO evergreen;

--
-- Name: is_valid(public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.is_valid(public.ismn) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(public.ismn) OWNER TO evergreen;

--
-- Name: is_valid(public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.is_valid(public.ismn13) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(public.ismn13) OWNER TO evergreen;

--
-- Name: is_valid(public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.is_valid(public.issn) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(public.issn) OWNER TO evergreen;

--
-- Name: is_valid(public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.is_valid(public.issn13) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(public.issn13) OWNER TO evergreen;

--
-- Name: is_valid(public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.is_valid(public.upc) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'is_valid';


ALTER FUNCTION public.is_valid(public.upc) OWNER TO evergreen;

--
-- Name: isn_weak(); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isn_weak() RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'weak_input_status';


ALTER FUNCTION public.isn_weak() OWNER TO evergreen;

--
-- Name: isn_weak(boolean); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isn_weak(boolean) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'accept_weak_input';


ALTER FUNCTION public.isn_weak(boolean) OWNER TO evergreen;

--
-- Name: isneq(public.ean13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ean13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: isneq(public.ean13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ean13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: isneq(public.ean13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ean13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: isneq(public.ean13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ean13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: isneq(public.ean13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ean13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: isneq(public.ean13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ean13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: isneq(public.ean13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ean13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: isneq(public.ean13, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ean13, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: isneq(public.isbn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.isbn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: isneq(public.isbn, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.isbn, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: isneq(public.isbn, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.isbn, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: isneq(public.isbn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.isbn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: isneq(public.isbn13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.isbn13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: isneq(public.isbn13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.isbn13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: isneq(public.ismn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ismn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: isneq(public.ismn, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ismn, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: isneq(public.ismn, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ismn, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: isneq(public.ismn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ismn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: isneq(public.ismn13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ismn13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: isneq(public.ismn13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.ismn13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: isneq(public.issn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.issn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: isneq(public.issn, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.issn, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.issn, public.issn) OWNER TO evergreen;

--
-- Name: isneq(public.issn, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.issn, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: isneq(public.issn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.issn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: isneq(public.issn13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.issn13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: isneq(public.issn13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.issn13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: isneq(public.upc, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.upc, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: isneq(public.upc, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isneq(public.upc, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8eq$$;


ALTER FUNCTION public.isneq(public.upc, public.upc) OWNER TO evergreen;

--
-- Name: isnge(public.ean13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ean13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: isnge(public.ean13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ean13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: isnge(public.ean13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ean13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: isnge(public.ean13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ean13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: isnge(public.ean13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ean13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: isnge(public.ean13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ean13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: isnge(public.ean13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ean13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: isnge(public.ean13, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ean13, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: isnge(public.isbn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.isbn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: isnge(public.isbn, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.isbn, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: isnge(public.isbn, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.isbn, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: isnge(public.isbn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.isbn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnge(public.isbn13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.isbn13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: isnge(public.isbn13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.isbn13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: isnge(public.ismn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ismn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: isnge(public.ismn, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ismn, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: isnge(public.ismn, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ismn, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: isnge(public.ismn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ismn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnge(public.ismn13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ismn13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: isnge(public.ismn13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.ismn13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: isnge(public.issn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.issn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: isnge(public.issn, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.issn, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.issn, public.issn) OWNER TO evergreen;

--
-- Name: isnge(public.issn, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.issn, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: isnge(public.issn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.issn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnge(public.issn13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.issn13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: isnge(public.issn13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.issn13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: isnge(public.upc, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.upc, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: isnge(public.upc, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnge(public.upc, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ge$$;


ALTER FUNCTION public.isnge(public.upc, public.upc) OWNER TO evergreen;

--
-- Name: isngt(public.ean13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ean13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: isngt(public.ean13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ean13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: isngt(public.ean13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ean13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: isngt(public.ean13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ean13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: isngt(public.ean13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ean13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: isngt(public.ean13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ean13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: isngt(public.ean13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ean13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: isngt(public.ean13, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ean13, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: isngt(public.isbn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.isbn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: isngt(public.isbn, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.isbn, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: isngt(public.isbn, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.isbn, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: isngt(public.isbn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.isbn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: isngt(public.isbn13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.isbn13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: isngt(public.isbn13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.isbn13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: isngt(public.ismn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ismn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: isngt(public.ismn, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ismn, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: isngt(public.ismn, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ismn, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: isngt(public.ismn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ismn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: isngt(public.ismn13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ismn13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: isngt(public.ismn13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.ismn13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: isngt(public.issn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.issn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: isngt(public.issn, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.issn, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.issn, public.issn) OWNER TO evergreen;

--
-- Name: isngt(public.issn, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.issn, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: isngt(public.issn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.issn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: isngt(public.issn13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.issn13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: isngt(public.issn13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.issn13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: isngt(public.upc, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.upc, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: isngt(public.upc, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isngt(public.upc, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8gt$$;


ALTER FUNCTION public.isngt(public.upc, public.upc) OWNER TO evergreen;

--
-- Name: isnle(public.ean13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ean13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: isnle(public.ean13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ean13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: isnle(public.ean13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ean13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: isnle(public.ean13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ean13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: isnle(public.ean13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ean13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: isnle(public.ean13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ean13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: isnle(public.ean13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ean13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: isnle(public.ean13, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ean13, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: isnle(public.isbn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.isbn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: isnle(public.isbn, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.isbn, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: isnle(public.isbn, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.isbn, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: isnle(public.isbn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.isbn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnle(public.isbn13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.isbn13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: isnle(public.isbn13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.isbn13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: isnle(public.ismn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ismn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: isnle(public.ismn, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ismn, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: isnle(public.ismn, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ismn, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: isnle(public.ismn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ismn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnle(public.ismn13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ismn13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: isnle(public.ismn13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.ismn13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: isnle(public.issn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.issn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: isnle(public.issn, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.issn, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.issn, public.issn) OWNER TO evergreen;

--
-- Name: isnle(public.issn, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.issn, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: isnle(public.issn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.issn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnle(public.issn13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.issn13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: isnle(public.issn13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.issn13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: isnle(public.upc, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.upc, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: isnle(public.upc, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnle(public.upc, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8le$$;


ALTER FUNCTION public.isnle(public.upc, public.upc) OWNER TO evergreen;

--
-- Name: isnlt(public.ean13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ean13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: isnlt(public.ean13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ean13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: isnlt(public.ean13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ean13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: isnlt(public.ean13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ean13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: isnlt(public.ean13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ean13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: isnlt(public.ean13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ean13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: isnlt(public.ean13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ean13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: isnlt(public.ean13, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ean13, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: isnlt(public.isbn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.isbn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: isnlt(public.isbn, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.isbn, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: isnlt(public.isbn, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.isbn, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: isnlt(public.isbn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.isbn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnlt(public.isbn13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.isbn13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: isnlt(public.isbn13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.isbn13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: isnlt(public.ismn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ismn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: isnlt(public.ismn, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ismn, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: isnlt(public.ismn, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ismn, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: isnlt(public.ismn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ismn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnlt(public.ismn13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ismn13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: isnlt(public.ismn13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.ismn13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: isnlt(public.issn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.issn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: isnlt(public.issn, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.issn, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.issn, public.issn) OWNER TO evergreen;

--
-- Name: isnlt(public.issn, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.issn, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: isnlt(public.issn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.issn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnlt(public.issn13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.issn13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: isnlt(public.issn13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.issn13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: isnlt(public.upc, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.upc, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: isnlt(public.upc, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnlt(public.upc, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8lt$$;


ALTER FUNCTION public.isnlt(public.upc, public.upc) OWNER TO evergreen;

--
-- Name: isnne(public.ean13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ean13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: isnne(public.ean13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ean13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: isnne(public.ean13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ean13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: isnne(public.ean13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ean13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: isnne(public.ean13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ean13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: isnne(public.ean13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ean13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: isnne(public.ean13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ean13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: isnne(public.ean13, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ean13, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: isnne(public.isbn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.isbn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: isnne(public.isbn, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.isbn, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: isnne(public.isbn, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.isbn, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: isnne(public.isbn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.isbn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnne(public.isbn13, public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.isbn13, public.isbn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: isnne(public.isbn13, public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.isbn13, public.isbn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: isnne(public.ismn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ismn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: isnne(public.ismn, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ismn, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: isnne(public.ismn, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ismn, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: isnne(public.ismn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ismn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnne(public.ismn13, public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ismn13, public.ismn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: isnne(public.ismn13, public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.ismn13, public.ismn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: isnne(public.issn, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.issn, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: isnne(public.issn, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.issn, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.issn, public.issn) OWNER TO evergreen;

--
-- Name: isnne(public.issn, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.issn, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: isnne(public.issn13, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.issn13, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: isnne(public.issn13, public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.issn13, public.issn) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: isnne(public.issn13, public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.issn13, public.issn13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: isnne(public.upc, public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.upc, public.ean13) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: isnne(public.upc, public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.isnne(public.upc, public.upc) RETURNS boolean
    LANGUAGE internal IMMUTABLE STRICT
    AS $$int8ne$$;


ALTER FUNCTION public.isnne(public.upc, public.upc) OWNER TO evergreen;

--
-- Name: last_agg(anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.last_agg(anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql STABLE
    AS $_$
	SELECT $2;
$_$;


ALTER FUNCTION public.last_agg(anyelement, anyelement) OWNER TO evergreen;

--
-- Name: left_trunc(text, integer); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.left_trunc(text, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT SUBSTRING($1,$2);
$_$;


ALTER FUNCTION public.left_trunc(text, integer) OWNER TO evergreen;

--
-- Name: lowercase(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.lowercase(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
    return lc(shift);
$$;


ALTER FUNCTION public.lowercase(text) OWNER TO evergreen;

--
-- Name: make_valid(public.ean13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.make_valid(public.ean13) RETURNS public.ean13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(public.ean13) OWNER TO evergreen;

--
-- Name: make_valid(public.isbn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.make_valid(public.isbn) RETURNS public.isbn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(public.isbn) OWNER TO evergreen;

--
-- Name: make_valid(public.isbn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.make_valid(public.isbn13) RETURNS public.isbn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(public.isbn13) OWNER TO evergreen;

--
-- Name: make_valid(public.ismn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.make_valid(public.ismn) RETURNS public.ismn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(public.ismn) OWNER TO evergreen;

--
-- Name: make_valid(public.ismn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.make_valid(public.ismn13) RETURNS public.ismn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(public.ismn13) OWNER TO evergreen;

--
-- Name: make_valid(public.issn); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.make_valid(public.issn) RETURNS public.issn
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(public.issn) OWNER TO evergreen;

--
-- Name: make_valid(public.issn13); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.make_valid(public.issn13) RETURNS public.issn13
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(public.issn13) OWNER TO evergreen;

--
-- Name: make_valid(public.upc); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.make_valid(public.upc) RETURNS public.upc
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/isn', 'make_valid';


ALTER FUNCTION public.make_valid(public.upc) OWNER TO evergreen;

--
-- Name: naco_normalize(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.naco_normalize(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT public.naco_normalize($1,'');
$_$;


ALTER FUNCTION public.naco_normalize(text) OWNER TO evergreen;

--
-- Name: naco_normalize(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.naco_normalize(text, text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$

    use strict;
    use Unicode::Normalize;
    use Encode;

    my $str = shift;
    my $sf = shift;

    # Apply NACO normalization to input string; based on
    # https://www.loc.gov/aba/pcc/naco/documents/SCA_PccNormalization_Final_revised.pdf
    #
    # Note that unlike a strict reading of the NACO normalization rules,
    # output is returned as lowercase instead of uppercase for compatibility
    # with previous versions of the Evergreen naco_normalize routine.

    # Convert to upper-case first; even though final output will be lowercase, doing this will
    # ensure that the German eszett (ß) and certain ligatures (ﬀ, ﬁ, ﬄ, etc.) will be handled correctly.
    # If there are any bugs in Perl's implementation of upcasing, they will be passed through here.
    $str = uc $str;

    # remove non-filing strings
    $str =~ s/\x{0098}.*?\x{009C}//g;

    $str = NFKD($str);

    # additional substitutions - 3.6.
    $str =~ s/\x{00C6}/AE/g;
    $str =~ s/\x{00DE}/TH/g;
    $str =~ s/\x{0152}/OE/g;
    $str =~ tr/\x{0110}\x{00D0}\x{00D8}\x{0141}\x{2113}\x{02BB}\x{02BC}]['/DDOLl/d;

    # transformations based on Unicode category codes
    $str =~ s/[\p{Cc}\p{Cf}\p{Co}\p{Cs}\p{Lm}\p{Mc}\p{Me}\p{Mn}]//g;

	if ($sf && $sf =~ /^a/o) {
		my $commapos = index($str, ',');
		if ($commapos > -1) {
			if ($commapos != length($str) - 1) {
                $str =~ s/,/\x07/; # preserve first comma
			}
		}
	}

    # since we've stripped out the control characters, we can now
    # use a few as placeholders temporarily
    $str =~ tr/+&@\x{266D}\x{266F}#/\x01\x02\x03\x04\x05\x06/;
    $str =~ s/[\p{Pc}\p{Pd}\p{Pe}\p{Pf}\p{Pi}\p{Po}\p{Ps}\p{Sk}\p{Sm}\p{So}\p{Zl}\p{Zp}\p{Zs}]/ /g;
    $str =~ tr/\x01\x02\x03\x04\x05\x06\x07/+&@\x{266D}\x{266F}#,/;

    # decimal digits
    $str =~ tr/\x{0660}-\x{0669}\x{06F0}-\x{06F9}\x{07C0}-\x{07C9}\x{0966}-\x{096F}\x{09E6}-\x{09EF}\x{0A66}-\x{0A6F}\x{0AE6}-\x{0AEF}\x{0B66}-\x{0B6F}\x{0BE6}-\x{0BEF}\x{0C66}-\x{0C6F}\x{0CE6}-\x{0CEF}\x{0D66}-\x{0D6F}\x{0E50}-\x{0E59}\x{0ED0}-\x{0ED9}\x{0F20}-\x{0F29}\x{1040}-\x{1049}\x{1090}-\x{1099}\x{17E0}-\x{17E9}\x{1810}-\x{1819}\x{1946}-\x{194F}\x{19D0}-\x{19D9}\x{1A80}-\x{1A89}\x{1A90}-\x{1A99}\x{1B50}-\x{1B59}\x{1BB0}-\x{1BB9}\x{1C40}-\x{1C49}\x{1C50}-\x{1C59}\x{A620}-\x{A629}\x{A8D0}-\x{A8D9}\x{A900}-\x{A909}\x{A9D0}-\x{A9D9}\x{AA50}-\x{AA59}\x{ABF0}-\x{ABF9}\x{FF10}-\x{FF19}/0-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-9/;

    # intentionally skipping step 8 of the NACO algorithm; if the string
    # gets normalized away, that's fine.

    # leading and trailing spaces
    $str =~ s/\s+/ /g;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//g;

    return lc $str;
$_$;


ALTER FUNCTION public.naco_normalize(text, text) OWNER TO evergreen;

--
-- Name: naco_normalize_keep_comma(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.naco_normalize_keep_comma(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT public.naco_normalize($1,'a');
$_$;


ALTER FUNCTION public.naco_normalize_keep_comma(text) OWNER TO evergreen;

--
-- Name: naco_normalize_keep_decimal(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.naco_normalize_keep_decimal(text, text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$    use strict;
    use Unicode::Normalize;
    use Encode;

    my $str = decode_utf8(shift);
    my $sf = shift;

    # Altered version of the naco_normalize function

    $str = uc $str;

    # remove non-filing strings
    $str =~ s/\x{0098}.*?\x{009C}//g;

    $str = NFKD($str);

    # additional substitutions - 3.6.
    $str =~ s/\x{00C6}/AE/g;
    $str =~ s/\x{00DE}/TH/g;
    $str =~ s/\x{0152}/OE/g;
    $str =~ tr/\x{0110}\x{00D0}\x{00D8}\x{0141}\x{2113}\x{02BB}\x{02BC}]['/DDOLl/d;
     # transformations based on Unicode category codes
    $str =~ s/[\p{Cc}\p{Cf}\p{Co}\p{Cs}\p{Lm}\p{Mc}\p{Me}\p{Mn}]//g;

    if ($sf) {$str =~ s/,/\x{009F}/;}

    $str =~ s/\'//g;
    $str =~ s/\,//g;
    $str =~ s/\'//g;
    # since we`ve stripped out the control characters, we can now
    # use a few as placeholders temporarily
    $str =~ tr/+&@\x{266D}\x{266F}#/\x01\x02\x03\x04\x05\x06/;

    $str =~ tr/\x01\x02\x03\x04\x05\x06\x07/+&@\x{266D}\x{266F}#,/;

    # intentionally skipping step 8 of the NACO algorithm; if the string
    # gets normalized away, that`s fine.

    # leading and trailing spaces
    $str =~ s/\s+/ /g;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//g;

	$str =~ s/\x{009F}/,/; #Put comma back

    return lc $str;
$_$;


ALTER FUNCTION public.naco_normalize_keep_decimal(text, text) OWNER TO evergreen;

--
-- Name: non_filing_normalize(text, "char"); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.non_filing_normalize(text, "char") RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT  SUBSTRING(
                        REGEXP_REPLACE(
                                REGEXP_REPLACE(
                                        $1,
                                        E'\W*$',
					''
				),
                                '  ',
                                ' '
                        ),
                        CASE
				WHEN $2::INT NOT BETWEEN 48 AND 57 THEN 1
				ELSE $2::TEXT::INT + 1
			END
		);
$_$;


ALTER FUNCTION public.non_filing_normalize(text, "char") OWNER TO evergreen;

--
-- Name: normal_rand(integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.normal_rand(integer, double precision, double precision) RETURNS SETOF double precision
    LANGUAGE c STRICT
    AS '$libdir/tablefunc', 'normal_rand';


ALTER FUNCTION public.normal_rand(integer, double precision, double precision) OWNER TO postgres;

--
-- Name: normalize_space(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.normalize_space(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace(regexp_replace(regexp_replace($1, E'\\n', ' ', 'g'), E'(?:^\\s+)|(\\s+$)', '', 'g'), E'\\s+', ' ', 'g');
$_$;


ALTER FUNCTION public.normalize_space(text) OWNER TO evergreen;

--
-- Name: oils_tsearch2(); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.oils_tsearch2() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    normalizer      RECORD;
    value           TEXT := '';
    temp_vector     TEXT := '';
    ts_rec          RECORD;
    cur_weight      "char";
BEGIN

    value := NEW.value;
    NEW.index_vector = ''::tsvector;

    IF TG_TABLE_NAME::TEXT ~ 'field_entry$' THEN
        FOR normalizer IN
            SELECT  n.func AS func,
                    n.param_count AS param_count,
                    m.params AS params
              FROM  config.index_normalizer n
                    JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
              WHERE field = NEW.field AND m.pos < 0
              ORDER BY m.pos LOOP
                EXECUTE 'SELECT ' || normalizer.func || '(' ||
                    quote_literal( value ) ||
                    CASE
                        WHEN normalizer.param_count > 0
                            THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                            ELSE ''
                        END ||
                    ')' INTO value;

        END LOOP;

        NEW.value = value;

        FOR normalizer IN
            SELECT  n.func AS func,
                    n.param_count AS param_count,
                    m.params AS params
              FROM  config.index_normalizer n
                    JOIN config.metabib_field_index_norm_map m ON (m.norm = n.id)
              WHERE field = NEW.field AND m.pos >= 0
              ORDER BY m.pos LOOP
                EXECUTE 'SELECT ' || normalizer.func || '(' ||
                    quote_literal( value ) ||
                    CASE
                        WHEN normalizer.param_count > 0
                            THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                            ELSE ''
                        END ||
                    ')' INTO value;

        END LOOP;
   END IF;

    IF TG_TABLE_NAME::TEXT ~ 'browse_entry$' THEN

        value :=  ARRAY_TO_STRING(
            evergreen.regexp_split_to_array(value, E'\\W+'), ' '
        );
        value := public.search_normalize(value);
        NEW.index_vector = to_tsvector(TG_ARGV[0]::regconfig, value);

    ELSIF TG_TABLE_NAME::TEXT ~ 'field_entry$' THEN
        FOR ts_rec IN

            SELECT DISTINCT m.ts_config, m.index_weight
            FROM config.metabib_class_ts_map m
                 LEFT JOIN metabib.record_attr_vector_list r ON (r.source = NEW.source)
                 LEFT JOIN config.coded_value_map ccvm ON (
                    ccvm.ctype IN ('item_lang', 'language') AND
                    ccvm.code = m.index_lang AND
                    r.vlist @> intset(ccvm.id)
                )
            WHERE m.field_class = TG_ARGV[0]
                AND m.active
                AND (m.always OR NOT EXISTS (SELECT 1 FROM config.metabib_field_ts_map WHERE metabib_field = NEW.field))
                AND (m.index_lang IS NULL OR ccvm.id IS NOT NULL)
                        UNION
            SELECT DISTINCT m.ts_config, m.index_weight
            FROM config.metabib_field_ts_map m
                 LEFT JOIN metabib.record_attr_vector_list r ON (r.source = NEW.source)
                 LEFT JOIN config.coded_value_map ccvm ON (
                    ccvm.ctype IN ('item_lang', 'language') AND
                    ccvm.code = m.index_lang AND
                    r.vlist @> intset(ccvm.id)
                )
            WHERE m.metabib_field = NEW.field
                AND m.active
                AND (m.index_lang IS NULL OR ccvm.id IS NOT NULL)
            ORDER BY index_weight ASC

        LOOP

            IF cur_weight IS NOT NULL AND cur_weight != ts_rec.index_weight THEN
                NEW.index_vector = NEW.index_vector || setweight(temp_vector::tsvector,cur_weight);
                temp_vector = '';
            END IF;

            cur_weight = ts_rec.index_weight;
            SELECT INTO temp_vector temp_vector || ' ' || to_tsvector(ts_rec.ts_config::regconfig, value)::TEXT;

        END LOOP;
        NEW.index_vector = NEW.index_vector || setweight(temp_vector::tsvector,cur_weight);
    ELSE
        NEW.index_vector = to_tsvector(TG_ARGV[0]::regconfig, value);
    END IF;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION public.oils_tsearch2() OWNER TO evergreen;

--
-- Name: remove_commas(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.remove_commas(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace($1, ',', '', 'g');
$_$;


ALTER FUNCTION public.remove_commas(text) OWNER TO evergreen;

--
-- Name: remove_diacritics(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.remove_diacritics(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
    use Unicode::Normalize;

    my $x = NFD(shift);
    $x =~ s/\pM+//go;
    return $x;

$_$;


ALTER FUNCTION public.remove_diacritics(text) OWNER TO evergreen;

--
-- Name: remove_insignificants(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.remove_insignificants(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$
	my $str = shift;
	my @char_array = split ('', $str);
	
		if($char_array[2] eq ' ' && $char_array[1] eq 'n' && $char_array[0] eq 'a'){
			$str =~ s/^an //;
		}elsif($char_array[1] eq ' ' && $char_array[0] eq 'a'){
			$str =~ s/^a //;
		}elsif($char_array[3] eq ' ' && $char_array[2] eq 'e' && $char_array[1] eq 'h' && $char_array[0] eq 't'){
			$str =~ s/^the //;
		}
		
	return $str;
		
$_$;


ALTER FUNCTION public.remove_insignificants(text) OWNER TO evergreen;

--
-- Name: remove_paren_substring(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.remove_paren_substring(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace($1, $$\([^)]+\)$$, '', 'g');
$_$;


ALTER FUNCTION public.remove_paren_substring(text) OWNER TO evergreen;

--
-- Name: remove_whitespace(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.remove_whitespace(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT regexp_replace(normalize_space($1), E'\\s+', '', 'g');
$_$;


ALTER FUNCTION public.remove_whitespace(text) OWNER TO evergreen;

--
-- Name: replace_ampersand(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.replace_ampersand(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT REGEXP_REPLACE( $1, '&amp|&', 'and', 'g' );
$_$;


ALTER FUNCTION public.replace_ampersand(text) OWNER TO evergreen;

--
-- Name: right_trunc(text, integer); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.right_trunc(text, integer) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT SUBSTRING($1,1,$2);
$_$;


ALTER FUNCTION public.right_trunc(text, integer) OWNER TO evergreen;

--
-- Name: search_normalize(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.search_normalize(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
	SELECT public.search_normalize($1,'');
$_$;


ALTER FUNCTION public.search_normalize(text) OWNER TO evergreen;

--
-- Name: search_normalize(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.search_normalize(text, text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$

    use strict;
    use Unicode::Normalize;
    use Encode;

    my $str = shift;
    my $sf = shift;

    # Apply NACO normalization to input string; based on
    # https://www.loc.gov/aba/pcc/naco/documents/SCA_PccNormalization_Final_revised.pdf
    #
    # Note that unlike a strict reading of the NACO normalization rules,
    # output is returned as lowercase instead of uppercase for compatibility
    # with previous versions of the Evergreen naco_normalize routine.

    # Convert to upper-case first; even though final output will be lowercase, doing this will
    # ensure that the German eszett (ß) and certain ligatures (ﬀ, ﬁ, ﬄ, etc.) will be handled correctly.
    # If there are any bugs in Perl's implementation of upcasing, they will be passed through here.
    $str = uc $str;

    # remove non-filing strings
    $str =~ s/\x{0098}.*?\x{009C}//g;

    $str = NFKD($str);

    # additional substitutions - 3.6.
    $str =~ s/\x{00C6}/AE/g;
    $str =~ s/\x{00DE}/TH/g;
    $str =~ s/\x{0152}/OE/g;
    $str =~ tr/\x{0110}\x{00D0}\x{00D8}\x{0141}\x{2113}\x{02BB}\x{02BC}][/DDOLl/d;

    # transformations based on Unicode category codes
    $str =~ s/[\p{Cc}\p{Cf}\p{Co}\p{Cs}\p{Lm}\p{Mc}\p{Me}\p{Mn}]//g;

    # JBAS-1284 Strip apostrophes
    # JBAS-2008 Recover customization
    $str =~ s/\'//g;

	if ($sf && $sf =~ /^a/o) {
		my $commapos = index($str, ',');
		if ($commapos > -1) {
			if ($commapos != length($str) - 1) {
                $str =~ s/,/\x07/; # preserve first comma
			}
		}
	}

    # since we've stripped out the control characters, we can now
    # use a few as placeholders temporarily
    $str =~ tr/+&@\x{266D}\x{266F}#/\x01\x02\x03\x04\x05\x06/;
    $str =~ s/[\p{Pc}\p{Pd}\p{Pe}\p{Pf}\p{Pi}\p{Po}\p{Ps}\p{Sk}\p{Sm}\p{So}\p{Zl}\p{Zp}\p{Zs}]/ /g;
    $str =~ tr/\x01\x02\x03\x04\x05\x06\x07/+&@\x{266D}\x{266F}#,/;

    # decimal digits
    $str =~ tr/\x{0660}-\x{0669}\x{06F0}-\x{06F9}\x{07C0}-\x{07C9}\x{0966}-\x{096F}\x{09E6}-\x{09EF}\x{0A66}-\x{0A6F}\x{0AE6}-\x{0AEF}\x{0B66}-\x{0B6F}\x{0BE6}-\x{0BEF}\x{0C66}-\x{0C6F}\x{0CE6}-\x{0CEF}\x{0D66}-\x{0D6F}\x{0E50}-\x{0E59}\x{0ED0}-\x{0ED9}\x{0F20}-\x{0F29}\x{1040}-\x{1049}\x{1090}-\x{1099}\x{17E0}-\x{17E9}\x{1810}-\x{1819}\x{1946}-\x{194F}\x{19D0}-\x{19D9}\x{1A80}-\x{1A89}\x{1A90}-\x{1A99}\x{1B50}-\x{1B59}\x{1BB0}-\x{1BB9}\x{1C40}-\x{1C49}\x{1C50}-\x{1C59}\x{A620}-\x{A629}\x{A8D0}-\x{A8D9}\x{A900}-\x{A909}\x{A9D0}-\x{A9D9}\x{AA50}-\x{AA59}\x{ABF0}-\x{ABF9}\x{FF10}-\x{FF19}/0-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-90-9/;

    # intentionally skipping step 8 of the NACO algorithm; if the string
    # gets normalized away, that's fine.

    # leading and trailing spaces
    $str =~ s/\s+/ /g;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//g;

    return lc $str;
$_$;


ALTER FUNCTION public.search_normalize(text, text) OWNER TO evergreen;

--
-- Name: search_normalize_keep_comma(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.search_normalize_keep_comma(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT public.search_normalize($1,'a');
$_$;


ALTER FUNCTION public.search_normalize_keep_comma(text) OWNER TO evergreen;

--
-- Name: short_title(text, integer); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.short_title(text, integer) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $_$

    my $str = shift;
    my $num = shift;

    $str =~ s/[;\/:, ]+$//;
    my @tokens = split /\s+/, $str;
    if (@tokens <= $num) {
        return $str;
    } else {
        return '';
    }

$_$;


ALTER FUNCTION public.short_title(text, integer) OWNER TO evergreen;

--
-- Name: split_date_range(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.split_date_range(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
        SELECT REGEXP_REPLACE( $1, E'(\\d{4})-(\\d{4})', E'\\1 \\2', 'g' );
$_$;


ALTER FUNCTION public.split_date_range(text) OWNER TO evergreen;

--
-- Name: text_concat(text, text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.text_concat(text, text) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
SELECT
	CASE	WHEN $1 IS NULL
			THEN $2
		WHEN $2 IS NULL
			THEN $1
		ELSE $1 || ' ' || $2
	END;
$_$;


ALTER FUNCTION public.text_concat(text, text) OWNER TO evergreen;

--
-- Name: translate_isbn1013(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.translate_isbn1013(text) RETURNS text
    LANGUAGE plperlu
    AS $_$
    use Business::ISBN;
    use strict;
    use warnings;

    # For each ISBN found in a single string containing a set of ISBNs:
    #   * Normalize an incoming ISBN to have the correct checksum and no hyphens
    #   * Convert an incoming ISBN10 or ISBN13 to its counterpart and return

    my $input = shift;
    my $output = '';

    if ($input =~ m/^(on\d{10})|(on\d{13})$/i) {
	return $input;
    }

    foreach my $word (split(/\s/, $input)) {
        my $isbn = Business::ISBN->new($word);

        # First check the checksum; if it is not valid, fix it and add the original
        # bad-checksum ISBN to the output
        if ($isbn && $isbn->is_valid_checksum() == Business::ISBN::BAD_CHECKSUM) {
            $output .= $isbn->isbn() . " ";
            $isbn->fix_checksum();
        }

        # If we now have a valid ISBN, convert it to its counterpart ISBN10/ISBN13
        # and add the normalized original ISBN to the output
        if ($isbn && $isbn->is_valid()) {
            my $isbn_xlated = ($isbn->type eq "ISBN13") ? $isbn->as_isbn10 : $isbn->as_isbn13;
            $output .= $isbn->isbn . " ";

            # If we successfully converted the ISBN to its counterpart, add the
            # converted ISBN to the output as well
            $output .= ($isbn_xlated->isbn . " ") if ($isbn_xlated);
        }
    }
    return $output if $output;

    # If there were no valid ISBNs, just return the raw input
    return $input;
$_$;


ALTER FUNCTION public.translate_isbn1013(text) OWNER TO evergreen;

--
-- Name: FUNCTION translate_isbn1013(text); Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON FUNCTION public.translate_isbn1013(text) IS '

/*
 * Copyright (C) 2010 Merrimack Valley Library Consortium
 * Jason Stephenson <jstephenson@mvlc.org>
 * Copyright (C) 2010 Laurentian University
 * Dan Scott <dscott@laurentian.ca>
 *
 * The translate_isbn1013 function takes an input ISBN and returns the
 * following in a single space-delimited string if the input ISBN is valid:
 *   - The normalized input ISBN (hyphens stripped)
 *   - The normalized input ISBN with a fixed checksum if the checksum was bad
 *   - The ISBN converted to its ISBN10 or ISBN13 counterpart, if possible
 */
';


--
-- Name: tsvector_concat(tsvector, tsvector); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.tsvector_concat(tsvector, tsvector) RETURNS tsvector
    LANGUAGE sql STABLE
    AS $_$
SELECT
	CASE	WHEN $1 IS NULL
			THEN $2
		WHEN $2 IS NULL
			THEN $1
		ELSE $1 || ' ' || $2
	END;
$_$;


ALTER FUNCTION public.tsvector_concat(tsvector, tsvector) OWNER TO evergreen;

--
-- Name: uppercase(text); Type: FUNCTION; Schema: public; Owner: evergreen
--

CREATE FUNCTION public.uppercase(text) RETURNS text
    LANGUAGE plperlu IMMUTABLE STRICT
    AS $$
    return uc(shift);
$$;


ALTER FUNCTION public.uppercase(text) OWNER TO evergreen;

--
-- Name: xml_encode_special_chars(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xml_encode_special_chars(text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xml_encode_special_chars';


ALTER FUNCTION public.xml_encode_special_chars(text) OWNER TO postgres;

--
-- Name: xml_is_well_formed(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xml_is_well_formed(text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xml_is_well_formed';


ALTER FUNCTION public.xml_is_well_formed(text) OWNER TO postgres;

--
-- Name: xml_valid(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xml_valid(text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xml_is_well_formed';


ALTER FUNCTION public.xml_valid(text) OWNER TO postgres;

--
-- Name: xpath_bool(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xpath_bool(text, text) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xpath_bool';


ALTER FUNCTION public.xpath_bool(text, text) OWNER TO postgres;

--
-- Name: xpath_list(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xpath_list(text, text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT xpath_list($1,$2,',')$_$;


ALTER FUNCTION public.xpath_list(text, text) OWNER TO postgres;

--
-- Name: xpath_list(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xpath_list(text, text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xpath_list';


ALTER FUNCTION public.xpath_list(text, text, text) OWNER TO postgres;

--
-- Name: xpath_nodeset(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xpath_nodeset(text, text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT xpath_nodeset($1,$2,'','')$_$;


ALTER FUNCTION public.xpath_nodeset(text, text) OWNER TO postgres;

--
-- Name: xpath_nodeset(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xpath_nodeset(text, text, text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$SELECT xpath_nodeset($1,$2,'',$3)$_$;


ALTER FUNCTION public.xpath_nodeset(text, text, text) OWNER TO postgres;

--
-- Name: xpath_nodeset(text, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xpath_nodeset(text, text, text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xpath_nodeset';


ALTER FUNCTION public.xpath_nodeset(text, text, text, text) OWNER TO postgres;

--
-- Name: xpath_number(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xpath_number(text, text) RETURNS real
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xpath_number';


ALTER FUNCTION public.xpath_number(text, text) OWNER TO postgres;

--
-- Name: xpath_string(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xpath_string(text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xpath_string';


ALTER FUNCTION public.xpath_string(text, text) OWNER TO postgres;

--
-- Name: xpath_table(text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xpath_table(text, text, text, text, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/pgxml', 'xpath_table';


ALTER FUNCTION public.xpath_table(text, text, text, text, text) OWNER TO postgres;

--
-- Name: xslt_process(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xslt_process(text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgxml', 'xslt_process';


ALTER FUNCTION public.xslt_process(text, text) OWNER TO postgres;

--
-- Name: xslt_process(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.xslt_process(text, text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/pgxml', 'xslt_process';


ALTER FUNCTION public.xslt_process(text, text, text) OWNER TO postgres;

--
-- Name: bib_pub_age(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.bib_pub_age(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    PERFORM rating.precalc_bibs_by_copy_or_uri(badge_id);

    SET LOCAL client_min_messages = error;
    DROP TABLE IF EXISTS precalc_bib_list;
    CREATE TEMP TABLE precalc_bib_list ON COMMIT DROP AS
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_or_uri_list;

    RETURN QUERY
     SELECT pop.id AS bib,
            s.value::NUMERIC
      FROM  precalc_bib_list pop
            JOIN metabib.record_sorter s ON (
                s.source = pop.id
                AND s.attr = 'pubdate'
                AND s.value ~ '^\d+$'
            )
      WHERE s.value::INT <= EXTRACT(YEAR FROM NOW())::INT;
END;
$_$;


ALTER FUNCTION rating.bib_pub_age(badge_id integer) OWNER TO evergreen;

--
-- Name: bib_record_age(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.bib_record_age(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    PERFORM rating.precalc_bibs_by_copy_or_uri(badge_id);

    SET LOCAL client_min_messages = error;
    DROP TABLE IF EXISTS precalc_bib_list;
    CREATE TEMP TABLE precalc_bib_list ON COMMIT DROP AS
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_or_uri_list;

    RETURN QUERY
     SELECT b.id,
            1.0 / EXTRACT(EPOCH FROM AGE(b.create_date))::NUMERIC + 1.0
      FROM  precalc_bib_list pop
            JOIN biblio.record_entry b ON (b.id = pop.id);
END;
$$;


ALTER FUNCTION rating.bib_record_age(badge_id integer) OWNER TO evergreen;

--
-- Name: checked_out_total_ratio(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.checked_out_total_ratio(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    DELETE FROM precalc_copy_filter_bib_list WHERE id NOT IN (
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list
    );

    ANALYZE precalc_copy_filter_bib_list;

    RETURN QUERY
     SELECT bib,
            SUM(checked_out)::NUMERIC / SUM(total)::NUMERIC
      FROM  (SELECT cn.record AS bib,
                    (cp.status = 1)::INT AS checked_out,
                    1 AS total
              FROM  asset.copy cp
                    JOIN precalc_copy_filter_bib_list c ON (cp.id = c.copy)
                    JOIN asset.call_number cn ON (cn.id = cp.call_number)
              WHERE cn.owning_lib = ANY (badge.orgs)
            ) x
      GROUP BY 1;
END;
$$;


ALTER FUNCTION rating.checked_out_total_ratio(badge_id integer) OWNER TO evergreen;

--
-- Name: circs_over_time(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.circs_over_time(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
    iage    INT     := 1;
    iint    INT     := NULL;
    iscale  NUMERIC := NULL;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    IF badge.horizon_age IS NULL THEN
        RAISE EXCEPTION 'Badge "%" with id % requires a horizon age but has none.',
            badge.name,
            badge.id;
    END IF;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    DELETE FROM precalc_copy_filter_bib_list WHERE id NOT IN (
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list
    );

    ANALYZE precalc_copy_filter_bib_list;

    iint := EXTRACT(EPOCH FROM badge.importance_interval);
    IF badge.importance_age IS NOT NULL THEN
        iage := (EXTRACT(EPOCH FROM badge.importance_age) / iint)::INT;
    END IF;

    -- if iscale is smaller than 1, scaling slope will be shallow ... BEWARE!
    iscale := COALESCE(badge.importance_scale, 1.0);

    RETURN QUERY
     SELECT bib,
            SUM( circs * GREATEST( iscale * (iage - cage), 1.0 ))
      FROM (
         SELECT cn.record AS bib,
                (1 + EXTRACT(EPOCH FROM AGE(c.xact_start)) / iint)::INT AS cage,
                COUNT(c.id)::INT AS circs
          FROM  action.circulation c
                JOIN precalc_copy_filter_bib_list cf ON (c.target_copy = cf.copy)
                JOIN asset.copy cp ON (cp.id = c.target_copy)
                JOIN asset.call_number cn ON (cn.id = cp.call_number)
          WHERE c.xact_start >= NOW() - badge.horizon_age
                AND cn.owning_lib = ANY (badge.orgs)
                AND c.phone_renewal IS FALSE  -- we don't count renewals
                AND c.desk_renewal IS FALSE
                AND c.opac_renewal IS FALSE
          GROUP BY 1, 2
      ) x
      GROUP BY 1;
END;
$$;


ALTER FUNCTION rating.circs_over_time(badge_id integer) OWNER TO evergreen;

--
-- Name: copy_count(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.copy_count(badge_id integer) RETURNS TABLE(record integer, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    DELETE FROM precalc_copy_filter_bib_list WHERE id NOT IN (
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list
    );
    ANALYZE precalc_copy_filter_bib_list;

    RETURN QUERY
     SELECT f.id::INT AS bib,
            COUNT(f.copy)::NUMERIC
      FROM  precalc_copy_filter_bib_list f
            JOIN asset.copy cp ON (f.copy = cp.id)
            JOIN asset.call_number cn ON (cn.id = cp.call_number)
      WHERE cn.owning_lib = ANY (badge.orgs) GROUP BY 1;

END;
$$;


ALTER FUNCTION rating.copy_count(badge_id integer) OWNER TO evergreen;

--
-- Name: current_circ_count(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.current_circ_count(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    DELETE FROM precalc_copy_filter_bib_list WHERE id NOT IN (
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list
    );

    ANALYZE precalc_copy_filter_bib_list;

    RETURN QUERY
     SELECT cn.record AS bib,
            COUNT(c.id)::NUMERIC AS circs
      FROM  action.circulation c
            JOIN precalc_copy_filter_bib_list cf ON (c.target_copy = cf.copy)
            JOIN asset.copy cp ON (cp.id = c.target_copy)
            JOIN asset.call_number cn ON (cn.id = cp.call_number)
      WHERE c.checkin_time IS NULL
            AND cn.owning_lib = ANY (badge.orgs)
      GROUP BY 1;

END;
$$;


ALTER FUNCTION rating.current_circ_count(badge_id integer) OWNER TO evergreen;

--
-- Name: current_hold_count(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.current_hold_count(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    DELETE FROM precalc_copy_filter_bib_list WHERE id NOT IN (
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list
    );

    ANALYZE precalc_copy_filter_bib_list;

    RETURN QUERY
     SELECT rhrr.bib_record AS bib,
            COUNT(DISTINCT h.id)::NUMERIC AS holds
      FROM  action.hold_request h
            JOIN reporter.hold_request_record rhrr ON (rhrr.id = h.id)
            JOIN action.hold_copy_map m ON (m.hold = h.id)
            JOIN precalc_copy_filter_bib_list cf ON (rhrr.bib_record = cf.id AND m.target_copy = cf.copy)
      WHERE h.fulfillment_time IS NULL
            AND h.request_lib = ANY (badge.orgs)
      GROUP BY 1;
END;
$$;


ALTER FUNCTION rating.current_hold_count(badge_id integer) OWNER TO evergreen;

--
-- Name: generic_fixed_rating_by_copy(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.generic_fixed_rating_by_copy(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
BEGIN
    PERFORM rating.precalc_bibs_by_copy(badge_id);
    RETURN QUERY
        SELECT id, 1.0 FROM precalc_filter_bib_list
            INTERSECT
        SELECT id, 1.0 FROM precalc_bibs_by_copy_list;
END;
$$;


ALTER FUNCTION rating.generic_fixed_rating_by_copy(badge_id integer) OWNER TO evergreen;

--
-- Name: generic_fixed_rating_by_copy_or_uri(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.generic_fixed_rating_by_copy_or_uri(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
BEGIN
    PERFORM rating.precalc_bibs_by_copy_or_uri(badge_id);
    RETURN QUERY
        (SELECT id, 1.0 FROM precalc_filter_bib_list
            INTERSECT
        SELECT id, 1.0 FROM precalc_bibs_by_copy_list)
            UNION
        (SELECT id, 1.0 FROM precalc_bib_filter_bib_list
            INTERSECT
        SELECT id, 1.0 FROM precalc_bibs_by_uri_list);
END;
$$;


ALTER FUNCTION rating.generic_fixed_rating_by_copy_or_uri(badge_id integer) OWNER TO evergreen;

--
-- Name: generic_fixed_rating_by_uri(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.generic_fixed_rating_by_uri(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
BEGIN
    PERFORM rating.precalc_bibs_by_uri(badge_id);
    RETURN QUERY
        SELECT id, 1.0 FROM precalc_bib_filter_bib_list
            INTERSECT
        SELECT id, 1.0 FROM precalc_bibs_by_uri_list;
END;
$$;


ALTER FUNCTION rating.generic_fixed_rating_by_uri(badge_id integer) OWNER TO evergreen;

--
-- Name: generic_fixed_rating_global(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.generic_fixed_rating_global(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
BEGIN
    RETURN QUERY
        SELECT id, 1.0 FROM precalc_bib_filter_bib_list;
END;
$$;


ALTER FUNCTION rating.generic_fixed_rating_global(badge_id integer) OWNER TO evergreen;

--
-- Name: holds_filled_over_time(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.holds_filled_over_time(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
    iage    INT     := 1;
    iint    INT     := NULL;
    iscale  NUMERIC := NULL;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    IF badge.horizon_age IS NULL THEN
        RAISE EXCEPTION 'Badge "%" with id % requires a horizon age but has none.',
            badge.name,
            badge.id;
    END IF;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    SET LOCAL client_min_messages = error;
    DROP TABLE IF EXISTS precalc_bib_list;
    CREATE TEMP TABLE precalc_bib_list ON COMMIT DROP AS
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list;

    iint := EXTRACT(EPOCH FROM badge.importance_interval);
    IF badge.importance_age IS NOT NULL THEN
        iage := (EXTRACT(EPOCH FROM badge.importance_age) / iint)::INT;
    END IF;

    -- if iscale is smaller than 1, scaling slope will be shallow ... BEWARE!
    iscale := COALESCE(badge.importance_scale, 1.0);

    RETURN QUERY
     SELECT bib,
            SUM( holds * GREATEST( iscale * (iage - hage), 1.0 ))
      FROM (
         SELECT f.id AS bib,
                (1 + EXTRACT(EPOCH FROM AGE(h.fulfillment_time)) / iint)::INT AS hage,
                COUNT(h.id)::INT AS holds
          FROM  action.hold_request h
                JOIN reporter.hold_request_record rhrr ON (rhrr.id = h.id)
                JOIN precalc_bib_list f ON (f.id = rhrr.bib_record)
          WHERE h.fulfillment_time >= NOW() - badge.horizon_age
                AND h.request_lib = ANY (badge.orgs)
          GROUP BY 1, 2
      ) x
      GROUP BY 1;
END;
$$;


ALTER FUNCTION rating.holds_filled_over_time(badge_id integer) OWNER TO evergreen;

--
-- Name: holds_holdable_ratio(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.holds_holdable_ratio(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    DELETE FROM precalc_copy_filter_bib_list WHERE id NOT IN (
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list
    );

    ANALYZE precalc_copy_filter_bib_list;

    RETURN QUERY
     SELECT cn.record AS bib,
            COUNT(DISTINCT m.hold)::NUMERIC / COUNT(DISTINCT cp.id)::NUMERIC
      FROM  asset.copy cp
            JOIN precalc_copy_filter_bib_list c ON (cp.id = c.copy)
            JOIN asset.copy_location cl ON (cl.id = cp.location)
            JOIN config.copy_status cs ON (cs.id = cp.status)
            JOIN asset.call_number cn ON (cn.id = cp.call_number)
            JOIN action.hold_copy_map m ON (m.target_copy = cp.id)
      WHERE cn.owning_lib = ANY (badge.orgs)
            AND cp.holdable IS TRUE
            AND cl.holdable IS TRUE
            AND cs.holdable IS TRUE
      GROUP BY 1;
END;
$$;


ALTER FUNCTION rating.holds_holdable_ratio(badge_id integer) OWNER TO evergreen;

--
-- Name: holds_placed_over_time(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.holds_placed_over_time(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
    iage    INT     := 1;
    iint    INT     := NULL;
    iscale  NUMERIC := NULL;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    IF badge.horizon_age IS NULL THEN
        RAISE EXCEPTION 'Badge "%" with id % requires a horizon age but has none.',
            badge.name,
            badge.id;
    END IF;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    SET LOCAL client_min_messages = error;
    DROP TABLE IF EXISTS precalc_bib_list;
    CREATE TEMP TABLE precalc_bib_list ON COMMIT DROP AS
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list;

    iint := EXTRACT(EPOCH FROM badge.importance_interval);
    IF badge.importance_age IS NOT NULL THEN
        iage := (EXTRACT(EPOCH FROM badge.importance_age) / iint)::INT;
    END IF;

    -- if iscale is smaller than 1, scaling slope will be shallow ... BEWARE!
    iscale := COALESCE(badge.importance_scale, 1.0);

    RETURN QUERY
     SELECT bib,
            SUM( holds * GREATEST( iscale * (iage - hage), 1.0 ))
      FROM (
         SELECT f.id AS bib,
                (1 + EXTRACT(EPOCH FROM AGE(h.request_time)) / iint)::INT AS hage,
                COUNT(h.id)::INT AS holds
          FROM  action.hold_request h
                JOIN reporter.hold_request_record rhrr ON (rhrr.id = h.id)
                JOIN precalc_bib_list f ON (f.id = rhrr.bib_record)
          WHERE h.request_time >= NOW() - badge.horizon_age
                AND h.request_lib = ANY (badge.orgs)
          GROUP BY 1, 2
      ) x
      GROUP BY 1;
END;
$$;


ALTER FUNCTION rating.holds_placed_over_time(badge_id integer) OWNER TO evergreen;

--
-- Name: holds_total_ratio(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.holds_total_ratio(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    DELETE FROM precalc_copy_filter_bib_list WHERE id NOT IN (
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list
    );

    ANALYZE precalc_copy_filter_bib_list;

    RETURN QUERY
     SELECT cn.record AS bib,
            COUNT(DISTINCT m.hold)::NUMERIC / COUNT(DISTINCT cp.id)::NUMERIC
      FROM  asset.copy cp
            JOIN precalc_copy_filter_bib_list c ON (cp.id = c.copy)
            JOIN asset.call_number cn ON (cn.id = cp.call_number)
            JOIN action.hold_copy_map m ON (m.target_copy = cp.id)
      WHERE cn.owning_lib = ANY (badge.orgs)
      GROUP BY 1;
END;
$$;


ALTER FUNCTION rating.holds_total_ratio(badge_id integer) OWNER TO evergreen;

--
-- Name: inhouse_over_time(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.inhouse_over_time(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
    iage    INT     := 1;
    iint    INT     := NULL;
    iscale  NUMERIC := NULL;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    IF badge.horizon_age IS NULL THEN
        RAISE EXCEPTION 'Badge "%" with id % requires a horizon age but has none.',
            badge.name,
            badge.id;
    END IF;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    DELETE FROM precalc_copy_filter_bib_list WHERE id NOT IN (
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list
    );

    ANALYZE precalc_copy_filter_bib_list;

    iint := EXTRACT(EPOCH FROM badge.importance_interval);
    IF badge.importance_age IS NOT NULL THEN
        iage := (EXTRACT(EPOCH FROM badge.importance_age) / iint)::INT;
    END IF;

    -- if iscale is smaller than 1, scaling slope will be shallow ... BEWARE!
    iscale := COALESCE(badge.importance_scale, 1.0);

    RETURN QUERY
     SELECT bib,
            SUM( uses * GREATEST( iscale * (iage - cage), 1.0 ))
      FROM (
         SELECT cn.record AS bib,
                (1 + EXTRACT(EPOCH FROM AGE(u.use_time)) / iint)::INT AS cage,
                COUNT(u.id)::INT AS uses
          FROM  action.in_house_use u
                JOIN precalc_copy_filter_bib_list cf ON (u.item = cf.copy)
                JOIN asset.copy cp ON (cp.id = u.item)
                JOIN asset.call_number cn ON (cn.id = cp.call_number)
          WHERE u.use_time >= NOW() - badge.horizon_age
                AND cn.owning_lib = ANY (badge.orgs)
          GROUP BY 1, 2
      ) x
      GROUP BY 1;
END;
$$;


ALTER FUNCTION rating.inhouse_over_time(badge_id integer) OWNER TO evergreen;

--
-- Name: org_unit_count(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.org_unit_count(badge_id integer) RETURNS TABLE(record integer, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    DELETE FROM precalc_copy_filter_bib_list WHERE id NOT IN (
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list
    );
    ANALYZE precalc_copy_filter_bib_list;

    -- Use circ rather than owning lib here as that means "on the shelf at..."
    RETURN QUERY
     SELECT f.id::INT AS bib,
            COUNT(DISTINCT cp.circ_lib)::NUMERIC
     FROM asset.copy cp
          JOIN precalc_copy_filter_bib_list f ON (cp.id = f.copy)
     WHERE cp.circ_lib = ANY (badge.orgs) GROUP BY 1;

END;
$$;


ALTER FUNCTION rating.org_unit_count(badge_id integer) OWNER TO evergreen;

--
-- Name: percent_time_circulating(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.percent_time_circulating(badge_id integer) RETURNS TABLE(record bigint, value numeric)
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
    badge   rating.badge_with_orgs%ROWTYPE;
BEGIN

    SELECT * INTO badge FROM rating.badge_with_orgs WHERE id = badge_id;

    PERFORM rating.precalc_bibs_by_copy(badge_id);

    DELETE FROM precalc_copy_filter_bib_list WHERE id NOT IN (
        SELECT id FROM precalc_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_bibs_by_copy_list
    );

    ANALYZE precalc_copy_filter_bib_list;

    RETURN QUERY
     SELECT bib,
            SUM(COALESCE(circ_time,0))::NUMERIC / SUM(age)::NUMERIC
      FROM  (SELECT cn.record AS bib,
                    cp.id,
                    EXTRACT( EPOCH FROM AGE(cp.active_date) ) + 1 AS age,
                    SUM(  -- time copy spent circulating
                        EXTRACT(
                            EPOCH FROM
                            AGE(
                                COALESCE(circ.checkin_time, circ.stop_fines_time, NOW()),
                                circ.xact_start
                            )
                        )
                    )::NUMERIC AS circ_time
              FROM  asset.copy cp
                    JOIN precalc_copy_filter_bib_list c ON (cp.id = c.copy)
                    JOIN asset.call_number cn ON (cn.id = cp.call_number)
                    LEFT JOIN action.all_circulation_slim circ ON (
                        circ.target_copy = cp.id
                        AND stop_fines NOT IN (
                            'LOST',
                            'LONGOVERDUE',
                            'CLAIMSRETURNED',
                            'LONGOVERDUE'
                        )
                        AND NOT (
                            checkin_time IS NULL AND
                            stop_fines = 'MAXFINES'
                        )
                    )
              WHERE cn.owning_lib = ANY (badge.orgs)
                    AND cp.active_date IS NOT NULL
                    -- Next line requires that copies with no circs (circ.id IS NULL) also not be deleted
                    AND ((circ.id IS NULL AND NOT cp.deleted) OR circ.id IS NOT NULL)
              GROUP BY 1,2,3
            ) x
      GROUP BY 1;
END;
$$;


ALTER FUNCTION rating.percent_time_circulating(badge_id integer) OWNER TO evergreen;

--
-- Name: precalc_attr_filter(text); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.precalc_attr_filter(attr_filter text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    cnt     INT := 0;
    afilter TEXT;
BEGIN

    SET LOCAL client_min_messages = error;
    DROP TABLE IF EXISTS precalc_attr_filter_bib_list;
    IF attr_filter IS NOT NULL THEN
        afilter := metabib.compile_composite_attr(attr_filter);
        CREATE TEMP TABLE precalc_attr_filter_bib_list ON COMMIT DROP AS
            SELECT source AS id FROM metabib.record_attr_vector_list
            WHERE vlist @@ metabib.compile_composite_attr(attr_filter);
    ELSE
        CREATE TEMP TABLE precalc_attr_filter_bib_list ON COMMIT DROP AS
            SELECT source AS id FROM metabib.record_attr_vector_list;
    END IF;

    SELECT count(*) INTO cnt FROM precalc_attr_filter_bib_list;
    RETURN cnt;
END;
$$;


ALTER FUNCTION rating.precalc_attr_filter(attr_filter text) OWNER TO evergreen;

--
-- Name: precalc_bibs_by_copy(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.precalc_bibs_by_copy(badge_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    cnt         INT     := 0;
    badge_row   rating.badge_with_orgs%ROWTYPE;
    base        TEXT;
    whr         TEXT;
BEGIN

    SELECT * INTO badge_row FROM rating.badge_with_orgs WHERE id = badge_id;

    SET LOCAL client_min_messages = error;
    DROP TABLE IF EXISTS precalc_bibs_by_copy_list;
    CREATE TEMP TABLE precalc_bibs_by_copy_list ON COMMIT DROP AS
        SELECT  DISTINCT cn.record AS id
          FROM  asset.call_number cn
                JOIN asset.copy cp ON (cp.call_number = cn.id AND NOT cp.deleted)
                JOIN precalc_copy_filter_bib_list f ON (cp.id = f.copy)
          WHERE cn.owning_lib = ANY (badge_row.orgs)
                AND NOT cn.deleted;

    SELECT count(*) INTO cnt FROM precalc_bibs_by_copy_list;
    RETURN cnt;
END;
$$;


ALTER FUNCTION rating.precalc_bibs_by_copy(badge_id integer) OWNER TO evergreen;

--
-- Name: precalc_bibs_by_copy_or_uri(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.precalc_bibs_by_copy_or_uri(badge_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    cnt         INT     := 0;
BEGIN

    PERFORM rating.precalc_bibs_by_copy(badge_id);
    PERFORM rating.precalc_bibs_by_uri(badge_id);

    SET LOCAL client_min_messages = error;
    DROP TABLE IF EXISTS precalc_bibs_by_copy_or_uri_list;
    CREATE TEMP TABLE precalc_bibs_by_copy_or_uri_list ON COMMIT DROP AS
        SELECT id FROM precalc_bibs_by_copy_list
            UNION
        SELECT id FROM precalc_bibs_by_uri_list;

    SELECT count(*) INTO cnt FROM precalc_bibs_by_copy_or_uri_list;
    RETURN cnt;
END;
$$;


ALTER FUNCTION rating.precalc_bibs_by_copy_or_uri(badge_id integer) OWNER TO evergreen;

--
-- Name: precalc_bibs_by_uri(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.precalc_bibs_by_uri(badge_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    cnt         INT     := 0;
    badge_row   rating.badge_with_orgs%ROWTYPE;
BEGIN

    SELECT * INTO badge_row FROM rating.badge_with_orgs WHERE id = badge_id;

    SET LOCAL client_min_messages = error;
    DROP TABLE IF EXISTS precalc_bibs_by_uri_list;
    CREATE TEMP TABLE precalc_bibs_by_uri_list ON COMMIT DROP AS
        SELECT  DISTINCT record AS id
          FROM  asset.call_number cn
                JOIN asset.uri_call_number_map urim ON (urim.call_number = cn.id)
                JOIN asset.uri uri ON (urim.uri = uri.id AND uri.active)
          WHERE cn.owning_lib = ANY (badge_row.orgs)
                AND cn.label = '##URI##'
                AND NOT cn.deleted;

    SELECT count(*) INTO cnt FROM precalc_bibs_by_uri_list;
    RETURN cnt;
END;
$$;


ALTER FUNCTION rating.precalc_bibs_by_uri(badge_id integer) OWNER TO evergreen;

--
-- Name: precalc_circ_mod_filter(text); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.precalc_circ_mod_filter(cm text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    cnt     INT     := 0;
BEGIN

    SET LOCAL client_min_messages = error;
    DROP TABLE IF EXISTS precalc_circ_mod_filter_bib_list;
    IF cm IS NOT NULL THEN
        CREATE TEMP TABLE precalc_circ_mod_filter_bib_list ON COMMIT DROP AS
            SELECT  cn.record AS id,
                    cp.id AS copy
              FROM  asset.call_number cn
                    JOIN asset.copy cp ON (cn.id = cp.call_number)
              WHERE cp.circ_modifier = cm
                    AND NOT cp.deleted;
    ELSE
        CREATE TEMP TABLE precalc_circ_mod_filter_bib_list ON COMMIT DROP AS
            SELECT  cn.record AS id,
                    cp.id AS copy
              FROM  asset.call_number cn
                    JOIN asset.copy cp ON (cn.id = cp.call_number)
              WHERE NOT cp.deleted;
    END IF;

    SELECT count(*) INTO cnt FROM precalc_circ_mod_filter_bib_list;
    RETURN cnt;
END;
$$;


ALTER FUNCTION rating.precalc_circ_mod_filter(cm text) OWNER TO evergreen;

--
-- Name: precalc_location_filter(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.precalc_location_filter(loc integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    cnt     INT     := 0;
BEGIN

    SET LOCAL client_min_messages = error;
    DROP TABLE IF EXISTS precalc_location_filter_bib_list;
    IF loc IS NOT NULL THEN
        CREATE TEMP TABLE precalc_location_filter_bib_list ON COMMIT DROP AS
            SELECT  cn.record AS id,
                    cp.id AS copy
              FROM  asset.call_number cn
                    JOIN asset.copy cp ON (cn.id = cp.call_number)
                    JOIN asset.copy_location_group_map lg ON (cp.location = lg.location)
              WHERE lg.lgroup = loc
                    AND NOT cp.deleted;
    ELSE
        CREATE TEMP TABLE precalc_location_filter_bib_list ON COMMIT DROP AS
            SELECT  cn.record AS id,
                    cp.id AS copy
              FROM  asset.call_number cn
                    JOIN asset.copy cp ON (cn.id = cp.call_number)
              WHERE NOT cp.deleted;
    END IF;

    SELECT count(*) INTO cnt FROM precalc_location_filter_bib_list;
    RETURN cnt;
END;
$$;


ALTER FUNCTION rating.precalc_location_filter(loc integer) OWNER TO evergreen;

--
-- Name: precalc_src_filter(integer); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.precalc_src_filter(src integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    cnt     INT     := 0;
BEGIN

    SET LOCAL client_min_messages = error;
    DROP TABLE IF EXISTS precalc_src_filter_bib_list;
    IF src IS NOT NULL THEN
        CREATE TEMP TABLE precalc_src_filter_bib_list ON COMMIT DROP AS
            SELECT id FROM biblio.record_entry
            WHERE source = src AND NOT deleted;
    ELSE
        CREATE TEMP TABLE precalc_src_filter_bib_list ON COMMIT DROP AS
            SELECT id FROM biblio.record_entry
            WHERE id > 0 AND NOT deleted;
    END IF;

    SELECT count(*) INTO cnt FROM precalc_src_filter_bib_list;
    RETURN cnt;
END;
$$;


ALTER FUNCTION rating.precalc_src_filter(src integer) OWNER TO evergreen;

--
-- Name: recalculate_badge_score(integer, boolean); Type: FUNCTION; Schema: rating; Owner: evergreen
--

CREATE FUNCTION rating.recalculate_badge_score(badge_id integer, setup_only boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    badge_row           rating.badge%ROWTYPE;
    param           rating.popularity_parameter%ROWTYPE;
BEGIN
    SET LOCAL client_min_messages = error;

    -- Find what we're doing    
    SELECT * INTO badge_row FROM rating.badge WHERE id = badge_id;
    SELECT * INTO param FROM rating.popularity_parameter WHERE id = badge_row.popularity_parameter;

    -- Calculate the filtered bib set, or all bibs if none
    PERFORM rating.precalc_attr_filter(badge_row.attr_filter);
    PERFORM rating.precalc_src_filter(badge_row.src_filter);
    PERFORM rating.precalc_circ_mod_filter(badge_row.circ_mod_filter);
    PERFORM rating.precalc_location_filter(badge_row.loc_grp_filter);

    -- Bring the bib-level filter lists together
    DROP TABLE IF EXISTS precalc_bib_filter_bib_list;
    CREATE TEMP TABLE precalc_bib_filter_bib_list ON COMMIT DROP AS
        SELECT id FROM precalc_attr_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_src_filter_bib_list;

    -- Bring the copy-level filter lists together. We're keeping this for bib_by_copy filtering later.
    DROP TABLE IF EXISTS precalc_copy_filter_bib_list;
    CREATE TEMP TABLE precalc_copy_filter_bib_list ON COMMIT DROP AS
        SELECT id, copy FROM precalc_circ_mod_filter_bib_list
            INTERSECT
        SELECT id, copy FROM precalc_location_filter_bib_list;

    -- Bring the collapsed filter lists together
    DROP TABLE IF EXISTS precalc_filter_bib_list;
    CREATE TEMP TABLE precalc_filter_bib_list ON COMMIT DROP AS
        SELECT id FROM precalc_bib_filter_bib_list
            INTERSECT
        SELECT id FROM precalc_copy_filter_bib_list;

    CREATE INDEX precalc_filter_bib_list_idx
        ON precalc_filter_bib_list (id);

    IF setup_only THEN
        RETURN;
    END IF;

    -- If it's a fixed-rating badge, just do it ...
    IF badge_row.fixed_rating IS NOT NULL THEN
        DELETE FROM rating.record_badge_score WHERE badge = badge_id;
        EXECUTE $e$
            INSERT INTO rating.record_badge_score (record, badge, score)
                SELECT record, $1, $2 FROM $e$ || param.func || $e$($1)$e$
        USING badge_id, badge_row.fixed_rating;

        UPDATE rating.badge SET last_calc = NOW() WHERE id = badge_id;

        RETURN;
    END IF;
    -- else, calculate!

    -- Make a session-local scratchpad for calculating scores
    CREATE TEMP TABLE record_score_scratchpad (
        bib     BIGINT,
        value   NUMERIC
    ) ON COMMIT DROP;

    -- Gather raw values
    EXECUTE $e$
        INSERT INTO record_score_scratchpad (bib, value)
            SELECT * FROM $e$ || param.func || $e$($1)$e$
    USING badge_id;

    IF badge_row.discard > 0 OR badge_row.percentile IS NOT NULL THEN
        -- To speed up discard-common
        CREATE INDEX record_score_scratchpad_score_idx ON record_score_scratchpad (value);
        ANALYZE record_score_scratchpad;
    END IF;

    IF badge_row.discard > 0 THEN -- Remove common low values (trim the long tail)
        DELETE FROM record_score_scratchpad WHERE value IN (
            SELECT DISTINCT value FROM record_score_scratchpad ORDER BY value LIMIT badge_row.discard
        );
    END IF;

    IF badge_row.percentile IS NOT NULL THEN -- Cut population down to exceptional records
        DELETE FROM record_score_scratchpad WHERE value <= (
            SELECT value FROM (
                SELECT  value,
                        CUME_DIST() OVER (ORDER BY value) AS p
                  FROM  record_score_scratchpad
            ) x WHERE p < badge_row.percentile / 100.0 ORDER BY p DESC LIMIT 1
        );
    END IF;


    -- And, finally, push new data in
    DELETE FROM rating.record_badge_score WHERE badge = badge_id;
    INSERT INTO rating.record_badge_score (badge, record, score)
        SELECT  badge_id,
                bib,
                GREATEST(ROUND((CUME_DIST() OVER (ORDER BY value)) * 5), 1) AS value
          FROM  record_score_scratchpad;

    DROP TABLE record_score_scratchpad;

    -- Now, finally-finally, mark the badge as recalculated
    UPDATE rating.badge SET last_calc = NOW() WHERE id = badge_id;

    RETURN;
END;
$_$;


ALTER FUNCTION rating.recalculate_badge_score(badge_id integer, setup_only boolean) OWNER TO evergreen;

--
-- Name: disable_materialized_simple_record_trigger(); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.disable_materialized_simple_record_trigger() RETURNS void
    LANGUAGE sql
    AS $$
    DROP TRIGGER IF EXISTS bbb_simple_rec_trigger ON biblio.record_entry;
$$;


ALTER FUNCTION reporter.disable_materialized_simple_record_trigger() OWNER TO evergreen;

--
-- Name: enable_materialized_simple_record_trigger(); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.enable_materialized_simple_record_trigger() RETURNS void
    LANGUAGE sql
    AS $$

    TRUNCATE TABLE reporter.materialized_simple_record;

    INSERT INTO reporter.materialized_simple_record
        (id,fingerprint,quality,tcn_source,tcn_value,title,author,publisher,pubdate,isbn,issn)
        SELECT DISTINCT ON (id) * FROM reporter.old_super_simple_record;

    CREATE TRIGGER bbb_simple_rec_trigger
        AFTER INSERT OR UPDATE OR DELETE ON biblio.record_entry
        FOR EACH ROW EXECUTE PROCEDURE reporter.simple_rec_trigger();

$$;


ALTER FUNCTION reporter.enable_materialized_simple_record_trigger() OWNER TO evergreen;

--
-- Name: hold_request_record_mapper(); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.hold_request_record_mapper() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO reporter.hold_request_record (id, target, hold_type, bib_record)
        SELECT  NEW.id,
                NEW.target,
                NEW.hold_type,
                CASE
                    WHEN NEW.hold_type = 'T'
                        THEN NEW.target
                    WHEN NEW.hold_type = 'I'
                        THEN (SELECT ssub.record_entry FROM serial.subscription ssub JOIN serial.issuance si ON (si.subscription = ssub.id) WHERE si.id = NEW.target)
                    WHEN NEW.hold_type = 'V'
                        THEN (SELECT cn.record FROM asset.call_number cn WHERE cn.id = NEW.target)
                    WHEN NEW.hold_type IN ('C','R','F')
                        THEN (SELECT cn.record FROM asset.call_number cn JOIN asset.copy cp ON (cn.id = cp.call_number) WHERE cp.id = NEW.target)
                    WHEN NEW.hold_type = 'M'
                        THEN (SELECT mr.master_record FROM metabib.metarecord mr WHERE mr.id = NEW.target)
                    WHEN NEW.hold_type = 'P'
                        THEN (SELECT bmp.record FROM biblio.monograph_part bmp WHERE bmp.id = NEW.target)
                END AS bib_record;
    ELSIF TG_OP = 'UPDATE' AND (OLD.target <> NEW.target OR OLD.hold_type <> NEW.hold_type) THEN
        UPDATE  reporter.hold_request_record
          SET   target = NEW.target,
                hold_type = NEW.hold_type,
                bib_record = CASE
                    WHEN NEW.hold_type = 'T'
                        THEN NEW.target
                    WHEN NEW.hold_type = 'I'
                        THEN (SELECT ssub.record_entry FROM serial.subscription ssub JOIN serial.issuance si ON (si.subscription = ssub.id) WHERE si.id = NEW.target)
                    WHEN NEW.hold_type = 'V'
                        THEN (SELECT cn.record FROM asset.call_number cn WHERE cn.id = NEW.target)
                    WHEN NEW.hold_type IN ('C','R','F')
                        THEN (SELECT cn.record FROM asset.call_number cn JOIN asset.copy cp ON (cn.id = cp.call_number) WHERE cp.id = NEW.target)
                    WHEN NEW.hold_type = 'M'
                        THEN (SELECT mr.master_record FROM metabib.metarecord mr WHERE mr.id = NEW.target)
                    WHEN NEW.hold_type = 'P'
                        THEN (SELECT bmp.record FROM biblio.monograph_part bmp WHERE bmp.id = NEW.target)
                END
         WHERE  id = NEW.id;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION reporter.hold_request_record_mapper() OWNER TO evergreen;

--
-- Name: intersect_user_perm_ou(bigint, bigint, text); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.intersect_user_perm_ou(context_ou bigint, staff_id bigint, perm_code text) RETURNS boolean
    LANGUAGE sql
    AS $$
  SELECT CASE WHEN context_ou IN (SELECT * FROM permission.usr_has_perm_at_all(staff_id::INT, perm_code)) THEN TRUE ELSE FALSE END;
$$;


ALTER FUNCTION reporter.intersect_user_perm_ou(context_ou bigint, staff_id bigint, perm_code text) OWNER TO evergreen;

--
-- Name: metabib_browse_entry_window_next(text, text); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.metabib_browse_entry_window_next(browse_type text, pivot_sort_value text) RETURNS TABLE(next_entry bigint, next_entry_value text, next_entry_sort_value text, next_entry_create_date timestamp with time zone, next_bib_record bigint, next_bib_editor integer, next_bib_edit_date timestamp with time zone, next_bib_create_date timestamp with time zone, next_bib_cataloging_date timestamp with time zone, next_field_def integer, next_field_label text, next_auth_tag character)
    LANGUAGE sql
    AS $$
    SELECT * FROM
        reporter.metabib_browse_entry_window_part(
            browse_type, pivot_sort_value, TRUE);
$$;


ALTER FUNCTION reporter.metabib_browse_entry_window_next(browse_type text, pivot_sort_value text) OWNER TO evergreen;

--
-- Name: metabib_browse_entry_window_part(text, text, boolean); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.metabib_browse_entry_window_part(browse_type text, pivot_sort_value text, is_next boolean) RETURNS TABLE(entry bigint, entry_value text, entry_sort_value text, entry_create_date timestamp with time zone, bib_record bigint, bib_editor integer, bib_edit_date timestamp with time zone, bib_create_date timestamp with time zone, bib_cataloging_date timestamp with time zone, field_def integer, field_label text, auth_tag character)
    LANGUAGE plpgsql
    AS $_$
DECLARE
    pivot_where TEXT;
    pivot_sort TEXT;
BEGIN

    pivot_where := '<';
    pivot_sort := 'DESC';

    IF is_next THEN
        pivot_where := '>';
        pivot_sort := 'ASC';
    END IF;

    RETURN QUERY EXECUTE $$
        WITH target_entry AS (
            SELECT * FROM metabib.browse_entry mbe
            WHERE metabib_fields_cache && (
                SELECT ARRAY_AGG(id) 
                FROM config.metabib_field 
                WHERE field_class = $$ || QUOTE_LITERAL(browse_type) || $$
            )
            AND mbe.truncated_sort_value $$ || pivot_where || ' ' 
                || QUOTE_LITERAL(pivot_sort_value) || $$
            ORDER BY mbe.truncated_sort_value $$ || pivot_sort || $$
            LIMIT 1
        )
        SELECT 
            entry.id, entry.value, entry.sort_value, entry.create_date,
            bre.id, bre.editor, bre.edit_date, bre.create_date,
            bre.cataloging_date, map.def, cmf.label, field.tag
            FROM target_entry entry
                LEFT JOIN metabib.browse_entry_def_map map
                    ON (map.entry = entry.id)
                LEFT JOIN biblio.record_entry bre
                    ON (bre.id = map.source AND NOT bre.deleted)
                LEFT JOIN config.metabib_field cmf ON (cmf.id = map.def)
                LEFT JOIN metabib.browse_entry_simple_heading_map hmap
                    ON (map.source IS NULL AND hmap.entry = entry.id)
                LEFT JOIN authority.simple_heading ash ON
                    (ash.id = hmap.simple_heading)
                LEFT JOIN authority.control_set_authority_field field
                    ON (field.id = ash.atag)
        -- The JOIN on metabib.browse_entry_def_map can return multiple rows, 
        -- resulting in duplicates in the resulting output for the current entry.
        LIMIT 1
    $$;
END;
$_$;


ALTER FUNCTION reporter.metabib_browse_entry_window_part(browse_type text, pivot_sort_value text, is_next boolean) OWNER TO evergreen;

--
-- Name: metabib_browse_entry_window_prev(text, text); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.metabib_browse_entry_window_prev(browse_type text, pivot_sort_value text) RETURNS TABLE(prev_entry bigint, prev_entry_value text, prev_entry_sort_value text, prev_entry_create_date timestamp with time zone, prev_bib_record bigint, prev_bib_editor integer, prev_bib_edit_date timestamp with time zone, prev_bib_create_date timestamp with time zone, prev_bib_cataloging_date timestamp with time zone, prev_field_def integer, prev_field_label text, prev_auth_tag character)
    LANGUAGE sql
    AS $$
    SELECT * FROM
        reporter.metabib_browse_entry_window_part(
            browse_type, pivot_sort_value, FALSE);
$$;


ALTER FUNCTION reporter.metabib_browse_entry_window_prev(browse_type text, pivot_sort_value text) OWNER TO evergreen;

--
-- Name: refresh_materialized_simple_record(); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.refresh_materialized_simple_record() RETURNS void
    LANGUAGE sql
    AS $$
    SELECT reporter.disable_materialized_simple_record_trigger();
    SELECT reporter.enable_materialized_simple_record_trigger();
$$;


ALTER FUNCTION reporter.refresh_materialized_simple_record() OWNER TO evergreen;

--
-- Name: simple_rec_delete(bigint); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.simple_rec_delete(r_id bigint) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT reporter.simple_rec_update($1, TRUE);
$_$;


ALTER FUNCTION reporter.simple_rec_delete(r_id bigint) OWNER TO evergreen;

--
-- Name: simple_rec_trigger(); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.simple_rec_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        PERFORM reporter.simple_rec_delete(NEW.id);
    ELSE
        PERFORM reporter.simple_rec_update(NEW.id);
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION reporter.simple_rec_trigger() OWNER TO evergreen;

--
-- Name: simple_rec_update(bigint); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.simple_rec_update(r_id bigint) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT reporter.simple_rec_update($1, FALSE);
$_$;


ALTER FUNCTION reporter.simple_rec_update(r_id bigint) OWNER TO evergreen;

--
-- Name: simple_rec_update(bigint, boolean); Type: FUNCTION; Schema: reporter; Owner: evergreen
--

CREATE FUNCTION reporter.simple_rec_update(r_id bigint, deleted boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN                                                                          
                                                                               
    DELETE FROM reporter.materialized_simple_record WHERE id = r_id;           
                                                                               
    IF NOT deleted THEN                                                        
        INSERT INTO reporter.materialized_simple_record 
            (id, fingerprint, quality, tcn_source, tcn_value, 
            title, title_proper, author, publisher, pubdate, isbn, issn)
	    	SELECT DISTINCT ON (id) 
            id, fingerprint, quality, tcn_source, tcn_value, 
            title, title_proper, author, publisher, pubdate, isbn, issn
            FROM reporter.old_super_simple_record WHERE id = r_id;
    END IF;                                                                    
                                                                               
    RETURN TRUE;                                                               
                                                                               
END;                                                                           
$$;


ALTER FUNCTION reporter.simple_rec_update(r_id bigint, deleted boolean) OWNER TO evergreen;

--
-- Name: calculate_visibility_attribute(integer, text); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.calculate_visibility_attribute(value integer, attr text) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$
SELECT  ((CASE $2

            WHEN 'luri_org'         THEN 0 -- "b" attr
            WHEN 'bib_source'       THEN 1 -- "b" attr

            WHEN 'copy_flags'       THEN 0 -- "c" attr
            WHEN 'owning_lib'       THEN 1 -- "c" attr
            WHEN 'circ_lib'         THEN 2 -- "c" attr
            WHEN 'status'           THEN 3 -- "c" attr
            WHEN 'location'         THEN 4 -- "c" attr
            WHEN 'location_group'   THEN 5 -- "c" attr

        END) << 28 ) | $1;

/* copy_flags bit positions, LSB-first:

 0: asset.copy.opac_visible


   When adding flags, you must update asset.all_visible_flags()

   Because bib and copy values are stored separately, we can reuse
   shifts, saving us some space. We could probably take back a bit
   too, but I'm not sure its worth squeezing that last one out. We'd
   be left with just 2 slots for copy attrs, rather than 10.
*/

$_$;


ALTER FUNCTION search.calculate_visibility_attribute(value integer, attr text) OWNER TO evergreen;

--
-- Name: calculate_visibility_attribute_list(text, integer[]); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.calculate_visibility_attribute_list(attr text, value integer[]) RETURNS integer[]
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT ARRAY_AGG(search.calculate_visibility_attribute(x, $1)) FROM UNNEST($2) AS X;
$_$;


ALTER FUNCTION search.calculate_visibility_attribute_list(attr text, value integer[]) OWNER TO evergreen;

--
-- Name: calculate_visibility_attribute_test(text, integer[], boolean); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.calculate_visibility_attribute_test(attr text, value integer[], negate boolean DEFAULT false) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT  CASE WHEN $3 THEN '!' ELSE '' END || '(' || ARRAY_TO_STRING(search.calculate_visibility_attribute_list($1,$2),'|') || ')';
$_$;


ALTER FUNCTION search.calculate_visibility_attribute_test(attr text, value integer[], negate boolean) OWNER TO evergreen;

--
-- Name: disable_symspell_reification(); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.disable_symspell_reification() RETURNS void
    LANGUAGE sql
    AS $$
    INSERT INTO config.internal_flag (name,enabled)
      VALUES ('ingest.disable_symspell_reification',TRUE)
    ON CONFLICT (name) DO UPDATE SET enabled = TRUE;
$$;


ALTER FUNCTION search.disable_symspell_reification() OWNER TO evergreen;

--
-- Name: enable_symspell_reification(); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.enable_symspell_reification() RETURNS void
    LANGUAGE sql
    AS $$
    UPDATE config.internal_flag SET enabled = FALSE WHERE name = 'ingest.disable_symspell_reification';
$$;


ALTER FUNCTION search.enable_symspell_reification() OWNER TO evergreen;

--
-- Name: facets_for_metarecord_set(text[], bigint[]); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.facets_for_metarecord_set(ignore_facet_classes text[], hits bigint[]) RETURNS TABLE(id integer, value text, count bigint)
    LANGUAGE sql
    AS $_$
    SELECT id, value, count FROM (
        SELECT mfae.field AS id,
               mfae.value,
               COUNT(DISTINCT mmrsm.metarecord),
               row_number() OVER (
                PARTITION BY mfae.field ORDER BY COUNT(distinct mmrsm.metarecord) DESC
               ) AS rownum
        FROM metabib.facet_entry mfae
        JOIN metabib.metarecord_source_map mmrsm ON (mfae.source = mmrsm.source)
        JOIN config.metabib_field cmf ON (cmf.id = mfae.field)
        WHERE mmrsm.metarecord IN (SELECT * FROM unnest($2))
        AND cmf.facet_field
        AND cmf.field_class NOT IN (SELECT * FROM unnest($1))
        GROUP by 1, 2
    ) all_facets
    WHERE rownum <= (SELECT COALESCE((SELECT value::INT FROM config.global_flag WHERE name = 'search.max_facets_per_field' AND enabled), 1000));
$_$;


ALTER FUNCTION search.facets_for_metarecord_set(ignore_facet_classes text[], hits bigint[]) OWNER TO evergreen;

--
-- Name: facets_for_record_set(text[], bigint[]); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.facets_for_record_set(ignore_facet_classes text[], hits bigint[]) RETURNS TABLE(id integer, value text, count bigint)
    LANGUAGE sql
    AS $_$
    SELECT id, value, count
      FROM (
        SELECT  mfae.field AS id,
                mfae.value,
                COUNT(DISTINCT mfae.source),
                row_number() OVER (
                    PARTITION BY mfae.field ORDER BY COUNT(DISTINCT mfae.source) DESC
                ) AS rownum
          FROM  metabib.facet_entry mfae
                JOIN config.metabib_field cmf ON (cmf.id = mfae.field)
          WHERE mfae.source = ANY ($2)
                AND cmf.facet_field
                AND cmf.field_class NOT IN (SELECT * FROM unnest($1))
          GROUP by 1, 2
      ) all_facets
      WHERE rownum <= (
        SELECT COALESCE(
            (SELECT value::INT FROM config.global_flag WHERE name = 'search.max_facets_per_field' AND enabled),
            1000
        )
      );
$_$;


ALTER FUNCTION search.facets_for_record_set(ignore_facet_classes text[], hits bigint[]) OWNER TO evergreen;

--
-- Name: highlight_display_fields(bigint, text, text, boolean, integer, integer, integer, integer, text); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.highlight_display_fields(rid bigint, tsq_map text, css_class text DEFAULT 'oils_SH'::text, hl_all boolean DEFAULT true, minwords integer DEFAULT 5, maxwords integer DEFAULT 25, shortwords integer DEFAULT 0, maxfrags integer DEFAULT 0, delimiter text DEFAULT ' ... '::text) RETURNS SETOF search.highlight_result
    LANGUAGE plpgsql ROWS 10
    AS $$
DECLARE
    tsq_hstore  TEXT;
    tsq         TEXT;
    fields      TEXT;
    afields     INT[];
    seen        INT[];
BEGIN
    IF (tsq_map ILIKE 'hstore%') THEN
        EXECUTE 'SELECT ' || tsq_map INTO tsq_hstore;
    ELSE
        tsq_hstore := tsq_map::HSTORE;
    END IF;

    FOR tsq, fields IN SELECT key, value FROM each(tsq_hstore::HSTORE) LOOP
        SELECT  ARRAY_AGG(unnest::INT) INTO afields
          FROM  unnest(regexp_split_to_array(fields,','));
        seen := seen || afields;

        RETURN QUERY
            SELECT * FROM search.highlight_display_fields_impl(
                rid, tsq, afields, css_class, hl_all,minwords,
                maxwords, shortwords, maxfrags, delimiter
            );
    END LOOP;

    RETURN QUERY
        SELECT  id,
                source,
                field,
                evergreen.escape_for_html(value) AS value,
                evergreen.escape_for_html(value) AS highlight
          FROM  metabib.display_entry
          WHERE source = rid
                AND NOT (field = ANY (seen));
END;
$$;


ALTER FUNCTION search.highlight_display_fields(rid bigint, tsq_map text, css_class text, hl_all boolean, minwords integer, maxwords integer, shortwords integer, maxfrags integer, delimiter text) OWNER TO evergreen;

--
-- Name: highlight_display_fields_impl(bigint, text, integer[], text, boolean, integer, integer, integer, integer, text); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.highlight_display_fields_impl(rid bigint, tsq text, field_list integer[] DEFAULT '{}'::integer[], css_class text DEFAULT 'oils_SH'::text, hl_all boolean DEFAULT true, minwords integer DEFAULT 5, maxwords integer DEFAULT 25, shortwords integer DEFAULT 0, maxfrags integer DEFAULT 0, delimiter text DEFAULT ' ... '::text) RETURNS SETOF search.highlight_result
    LANGUAGE plpgsql
    AS $_$
DECLARE
    opts            TEXT := '';
    v_css_class     TEXT := css_class;
    v_delimiter     TEXT := delimiter;
    v_field_list    INT[] := field_list;
    hl_query        TEXT;
BEGIN
    IF v_delimiter LIKE $$%'%$$ OR v_delimiter LIKE '%"%' THEN --"
        v_delimiter := ' ... ';
    END IF;

    IF NOT hl_all THEN
        opts := opts || 'MinWords=' || minwords;
        opts := opts || ', MaxWords=' || maxwords;
        opts := opts || ', ShortWords=' || shortwords;
        opts := opts || ', MaxFragments=' || maxfrags;
        opts := opts || ', FragmentDelimiter="' || delimiter || '"';
    ELSE
        opts := opts || 'HighlightAll=TRUE';
    END IF;

    IF v_css_class LIKE $$%'%$$ OR v_css_class LIKE '%"%' THEN -- "
        v_css_class := 'oils_SH';
    END IF;

    opts := opts || $$, StopSel=</b>, StartSel="<b class='$$ || v_css_class; -- "

    IF v_field_list = '{}'::INT[] THEN
        SELECT ARRAY_AGG(id) INTO v_field_list FROM config.metabib_field WHERE display_field;
    END IF;

    hl_query := $$
        SELECT  de.id,
                de.source,
                de.field,
                evergreen.escape_for_html(de.value) AS value,
                ts_headline(
                    ts_config::REGCONFIG,
                    evergreen.escape_for_html(de.value),
                    $$ || quote_literal(tsq) || $$,
                    $1 || ' ' || mf.field_class || ' ' || mf.name || $xx$'>"$xx$ -- "'
                ) AS highlight
          FROM  metabib.display_entry de
                JOIN config.metabib_field mf ON (mf.id = de.field)
                JOIN search.best_tsconfig t ON (t.id = de.field)
          WHERE de.source = $2
                AND field = ANY ($3)
          ORDER BY de.id;$$;

    RETURN QUERY EXECUTE hl_query USING opts, rid, v_field_list;
END;
$_$;


ALTER FUNCTION search.highlight_display_fields_impl(rid bigint, tsq text, field_list integer[], css_class text, hl_all boolean, minwords integer, maxwords integer, shortwords integer, maxfrags integer, delimiter text) OWNER TO evergreen;

--
-- Name: symspell_dictionary; Type: TABLE; Schema: search; Owner: evergreen
--

CREATE TABLE search.symspell_dictionary (
    keyword_count integer DEFAULT 0 NOT NULL,
    title_count integer DEFAULT 0 NOT NULL,
    author_count integer DEFAULT 0 NOT NULL,
    subject_count integer DEFAULT 0 NOT NULL,
    series_count integer DEFAULT 0 NOT NULL,
    identifier_count integer DEFAULT 0 NOT NULL,
    prefix_key text NOT NULL,
    keyword_suggestions text[],
    title_suggestions text[],
    author_suggestions text[],
    subject_suggestions text[],
    series_suggestions text[],
    identifier_suggestions text[]
)
WITH (fillfactor='80');


ALTER TABLE search.symspell_dictionary OWNER TO evergreen;

--
-- Name: symspell_build_and_merge_entries(text, text, text, boolean); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.symspell_build_and_merge_entries(full_input text, source_class text, old_input text DEFAULT NULL::text, include_phrases boolean DEFAULT false) RETURNS SETOF search.symspell_dictionary
    LANGUAGE plpgsql
    AS $_X$
DECLARE
    new_entry       RECORD;
    conflict_entry  RECORD;
BEGIN

    IF full_input = old_input THEN -- neither NULL, and are the same
        RETURN;
    END IF;

    FOR new_entry IN EXECUTE $q$
        SELECT  count,
                prefix_key,
                s AS suggestions
          FROM  (SELECT prefix_key,
                        ARRAY_AGG(DISTINCT $q$ || source_class || $q$_suggestions[1]) s,
                        SUM($q$ || source_class || $q$_count) count
                  FROM  search.symspell_build_entries($1, $2, $3, $4)
                  GROUP BY 1) x
        $q$ USING full_input, source_class, old_input, include_phrases
    LOOP
        EXECUTE $q$
            SELECT  prefix_key,
                    $q$ || source_class || $q$_suggestions suggestions,
                    $q$ || source_class || $q$_count count
              FROM  search.symspell_dictionary
              WHERE prefix_key = $1 $q$
            INTO conflict_entry
            USING new_entry.prefix_key;

        IF new_entry.count <> 0 THEN -- Real word, and count changed
            IF conflict_entry.prefix_key IS NOT NULL THEN -- we'll be updating
                IF conflict_entry.count > 0 THEN -- it's a real word
                    RETURN QUERY EXECUTE $q$
                        UPDATE  search.symspell_dictionary
                           SET  $q$ || source_class || $q$_count = $2
                          WHERE prefix_key = $1
                          RETURNING * $q$
                        USING new_entry.prefix_key, GREATEST(0, new_entry.count + conflict_entry.count);
                ELSE -- it was a prefix key or delete-emptied word before
                    IF conflict_entry.suggestions @> new_entry.suggestions THEN -- already have all suggestions here...
                        RETURN QUERY EXECUTE $q$
                            UPDATE  search.symspell_dictionary
                               SET  $q$ || source_class || $q$_count = $2
                              WHERE prefix_key = $1
                              RETURNING * $q$
                            USING new_entry.prefix_key, GREATEST(0, new_entry.count);
                    ELSE -- new suggestion!
                        RETURN QUERY EXECUTE $q$
                            UPDATE  search.symspell_dictionary
                               SET  $q$ || source_class || $q$_count = $2,
                                    $q$ || source_class || $q$_suggestions = $3
                              WHERE prefix_key = $1
                              RETURNING * $q$
                            USING new_entry.prefix_key, GREATEST(0, new_entry.count), evergreen.text_array_merge_unique(conflict_entry.suggestions,new_entry.suggestions);
                    END IF;
                END IF;
            ELSE
                -- We keep the on-conflict clause just in case...
                RETURN QUERY EXECUTE $q$
                    INSERT INTO search.symspell_dictionary AS d (
                        $q$ || source_class || $q$_count,
                        prefix_key,
                        $q$ || source_class || $q$_suggestions
                    ) VALUES ( $1, $2, $3 ) ON CONFLICT (prefix_key) DO
                        UPDATE SET  $q$ || source_class || $q$_count = d.$q$ || source_class || $q$_count + EXCLUDED.$q$ || source_class || $q$_count,
                                    $q$ || source_class || $q$_suggestions = evergreen.text_array_merge_unique(d.$q$ || source_class || $q$_suggestions, EXCLUDED.$q$ || source_class || $q$_suggestions)
                        RETURNING * $q$
                    USING new_entry.count, new_entry.prefix_key, new_entry.suggestions;
            END IF;
        ELSE -- key only, or no change
            IF conflict_entry.prefix_key IS NOT NULL THEN -- we'll be updating
                IF NOT conflict_entry.suggestions @> new_entry.suggestions THEN -- There are new suggestions
                    RETURN QUERY EXECUTE $q$
                        UPDATE  search.symspell_dictionary
                           SET  $q$ || source_class || $q$_suggestions = $2
                          WHERE prefix_key = $1
                          RETURNING * $q$
                        USING new_entry.prefix_key, evergreen.text_array_merge_unique(conflict_entry.suggestions,new_entry.suggestions);
                END IF;
            ELSE
                RETURN QUERY EXECUTE $q$
                    INSERT INTO search.symspell_dictionary AS d (
                        $q$ || source_class || $q$_count,
                        prefix_key,
                        $q$ || source_class || $q$_suggestions
                    ) VALUES ( $1, $2, $3 ) ON CONFLICT (prefix_key) DO -- key exists, suggestions may be added due to this entry
                        UPDATE SET  $q$ || source_class || $q$_suggestions = evergreen.text_array_merge_unique(d.$q$ || source_class || $q$_suggestions, EXCLUDED.$q$ || source_class || $q$_suggestions)
                    RETURNING * $q$
                    USING new_entry.count, new_entry.prefix_key, new_entry.suggestions;
            END IF;
        END IF;
    END LOOP;
END;
$_X$;


ALTER FUNCTION search.symspell_build_and_merge_entries(full_input text, source_class text, old_input text, include_phrases boolean) OWNER TO evergreen;

--
-- Name: symspell_build_entries(text, text, text, boolean); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.symspell_build_entries(full_input text, source_class text, old_input text DEFAULT NULL::text, include_phrases boolean DEFAULT false) RETURNS SETOF search.symspell_dictionary
    LANGUAGE plpgsql
    AS $$
DECLARE
    prefix_length   INT;
    maxED           INT;
    word_list   TEXT[];
    input       TEXT;
    word        TEXT;
    entry       search.symspell_dictionary;
BEGIN
    IF full_input IS NOT NULL THEN
        SELECT value::INT INTO prefix_length FROM config.internal_flag WHERE name = 'symspell.prefix_length' AND enabled;
        prefix_length := COALESCE(prefix_length, 6);

        SELECT value::INT INTO maxED FROM config.internal_flag WHERE name = 'symspell.max_edit_distance' AND enabled;
        maxED := COALESCE(maxED, 3);

        input := evergreen.lowercase(full_input);
        word_list := ARRAY_AGG(x) FROM search.symspell_parse_words_distinct(input) x;
        IF word_list IS NULL THEN
            RETURN;
        END IF;
    
        IF CARDINALITY(word_list) > 1 AND include_phrases THEN
            RETURN QUERY SELECT * FROM search.symspell_build_raw_entry(input, source_class, TRUE, prefix_length, maxED);
        END IF;

        FOREACH word IN ARRAY word_list LOOP
            -- Skip words that have runs of 5 or more digits (I'm looking at you, ISxNs)
            CONTINUE WHEN CHARACTER_LENGTH(word) > 4 AND word ~ '\d{5,}';
            RETURN QUERY SELECT * FROM search.symspell_build_raw_entry(word, source_class, FALSE, prefix_length, maxED);
        END LOOP;
    END IF;

    IF old_input IS NOT NULL THEN
        input := evergreen.lowercase(old_input);

        FOR word IN SELECT x FROM search.symspell_parse_words_distinct(input) x LOOP
            -- similarly skip words that have 5 or more digits here to
            -- avoid adding erroneous prefix deletion entries to the dictionary
            CONTINUE WHEN CHARACTER_LENGTH(word) > 4 AND word ~ '\d{5,}';
            entry.prefix_key := word;

            entry.keyword_count := 0;
            entry.title_count := 0;
            entry.author_count := 0;
            entry.subject_count := 0;
            entry.series_count := 0;
            entry.identifier_count := 0;

            entry.keyword_suggestions := '{}';
            entry.title_suggestions := '{}';
            entry.author_suggestions := '{}';
            entry.subject_suggestions := '{}';
            entry.series_suggestions := '{}';
            entry.identifier_suggestions := '{}';

            IF source_class = 'keyword' THEN entry.keyword_count := -1; END IF;
            IF source_class = 'title' THEN entry.title_count := -1; END IF;
            IF source_class = 'author' THEN entry.author_count := -1; END IF;
            IF source_class = 'subject' THEN entry.subject_count := -1; END IF;
            IF source_class = 'series' THEN entry.series_count := -1; END IF;
            IF source_class = 'identifier' THEN entry.identifier_count := -1; END IF;

            RETURN NEXT entry;
        END LOOP;
    END IF;
END;
$$;


ALTER FUNCTION search.symspell_build_entries(full_input text, source_class text, old_input text, include_phrases boolean) OWNER TO evergreen;

--
-- Name: symspell_build_raw_entry(text, text, boolean, integer, integer); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.symspell_build_raw_entry(raw_input text, source_class text, no_limit boolean DEFAULT false, prefix_length integer DEFAULT 6, maxed integer DEFAULT 3) RETURNS SETOF search.symspell_dictionary
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    key         TEXT;
    del_key     TEXT;
    key_list    TEXT[];
    entry       search.symspell_dictionary%ROWTYPE;
BEGIN
    key := raw_input;

    IF NOT no_limit AND CHARACTER_LENGTH(raw_input) > prefix_length THEN
        key := SUBSTRING(key FROM 1 FOR prefix_length);
        key_list := ARRAY[raw_input, key];
    ELSE
        key_list := ARRAY[key];
    END IF;

    FOREACH del_key IN ARRAY key_list LOOP
        -- skip empty keys
        CONTINUE WHEN del_key IS NULL OR CHARACTER_LENGTH(del_key) = 0;

        entry.prefix_key := del_key;

        entry.keyword_count := 0;
        entry.title_count := 0;
        entry.author_count := 0;
        entry.subject_count := 0;
        entry.series_count := 0;
        entry.identifier_count := 0;

        entry.keyword_suggestions := '{}';
        entry.title_suggestions := '{}';
        entry.author_suggestions := '{}';
        entry.subject_suggestions := '{}';
        entry.series_suggestions := '{}';
        entry.identifier_suggestions := '{}';

        IF source_class = 'keyword' THEN entry.keyword_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'title' THEN entry.title_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'author' THEN entry.author_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'subject' THEN entry.subject_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'series' THEN entry.series_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'identifier' THEN entry.identifier_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'keyword' THEN entry.keyword_suggestions := ARRAY[raw_input]; END IF;

        IF del_key = raw_input THEN
            IF source_class = 'keyword' THEN entry.keyword_count := 1; END IF;
            IF source_class = 'title' THEN entry.title_count := 1; END IF;
            IF source_class = 'author' THEN entry.author_count := 1; END IF;
            IF source_class = 'subject' THEN entry.subject_count := 1; END IF;
            IF source_class = 'series' THEN entry.series_count := 1; END IF;
            IF source_class = 'identifier' THEN entry.identifier_count := 1; END IF;
        END IF;

        RETURN NEXT entry;
    END LOOP;

    FOR del_key IN SELECT x FROM UNNEST(search.symspell_generate_edits(key, 1, maxED)) x LOOP

        -- skip empty keys
        CONTINUE WHEN del_key IS NULL OR CHARACTER_LENGTH(del_key) = 0;
        -- skip suggestions that are already too long for the prefix key
        CONTINUE WHEN CHARACTER_LENGTH(del_key) <= (prefix_length - maxED) AND CHARACTER_LENGTH(raw_input) > prefix_length;

        entry.keyword_suggestions := '{}';
        entry.title_suggestions := '{}';
        entry.author_suggestions := '{}';
        entry.subject_suggestions := '{}';
        entry.series_suggestions := '{}';
        entry.identifier_suggestions := '{}';

        IF source_class = 'keyword' THEN entry.keyword_count := 0; END IF;
        IF source_class = 'title' THEN entry.title_count := 0; END IF;
        IF source_class = 'author' THEN entry.author_count := 0; END IF;
        IF source_class = 'subject' THEN entry.subject_count := 0; END IF;
        IF source_class = 'series' THEN entry.series_count := 0; END IF;
        IF source_class = 'identifier' THEN entry.identifier_count := 0; END IF;

        entry.prefix_key := del_key;

        IF source_class = 'keyword' THEN entry.keyword_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'title' THEN entry.title_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'author' THEN entry.author_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'subject' THEN entry.subject_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'series' THEN entry.series_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'identifier' THEN entry.identifier_suggestions := ARRAY[raw_input]; END IF;
        IF source_class = 'keyword' THEN entry.keyword_suggestions := ARRAY[raw_input]; END IF;

        RETURN NEXT entry;
    END LOOP;

END;
$$;


ALTER FUNCTION search.symspell_build_raw_entry(raw_input text, source_class text, no_limit boolean, prefix_length integer, maxed integer) OWNER TO evergreen;

--
-- Name: symspell_dictionary_full_reify(); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.symspell_dictionary_full_reify() RETURNS SETOF search.symspell_dictionary
    LANGUAGE sql
    AS $$
 WITH new_rows AS (
    DELETE FROM search.symspell_dictionary_updates RETURNING *
 ), computed_rows AS ( -- this collapses the rows deleted into the format we need for UPSERT
    SELECT  SUM(keyword_count)    AS keyword_count,
            SUM(title_count)      AS title_count,
            SUM(author_count)     AS author_count,
            SUM(subject_count)    AS subject_count,
            SUM(series_count)     AS series_count,
            SUM(identifier_count) AS identifier_count,

            prefix_key,

            ARRAY_REMOVE(ARRAY_AGG(DISTINCT keyword_suggestions[1]), NULL)    AS keyword_suggestions,
            ARRAY_REMOVE(ARRAY_AGG(DISTINCT title_suggestions[1]), NULL)      AS title_suggestions,
            ARRAY_REMOVE(ARRAY_AGG(DISTINCT author_suggestions[1]), NULL)     AS author_suggestions,
            ARRAY_REMOVE(ARRAY_AGG(DISTINCT subject_suggestions[1]), NULL)    AS subject_suggestions,
            ARRAY_REMOVE(ARRAY_AGG(DISTINCT series_suggestions[1]), NULL)     AS series_suggestions,
            ARRAY_REMOVE(ARRAY_AGG(DISTINCT identifier_suggestions[1]), NULL) AS identifier_suggestions
      FROM  new_rows
      GROUP BY prefix_key
 )
 INSERT INTO search.symspell_dictionary AS d SELECT * FROM computed_rows
 ON CONFLICT (prefix_key) DO UPDATE SET
    keyword_count = GREATEST(0, d.keyword_count + EXCLUDED.keyword_count),
    keyword_suggestions = evergreen.text_array_merge_unique(EXCLUDED.keyword_suggestions,d.keyword_suggestions),

    title_count = GREATEST(0, d.title_count + EXCLUDED.title_count),
    title_suggestions = evergreen.text_array_merge_unique(EXCLUDED.title_suggestions,d.title_suggestions),

    author_count = GREATEST(0, d.author_count + EXCLUDED.author_count),
    author_suggestions = evergreen.text_array_merge_unique(EXCLUDED.author_suggestions,d.author_suggestions),

    subject_count = GREATEST(0, d.subject_count + EXCLUDED.subject_count),
    subject_suggestions = evergreen.text_array_merge_unique(EXCLUDED.subject_suggestions,d.subject_suggestions),

    series_count = GREATEST(0, d.series_count + EXCLUDED.series_count),
    series_suggestions = evergreen.text_array_merge_unique(EXCLUDED.series_suggestions,d.series_suggestions),

    identifier_count = GREATEST(0, d.identifier_count + EXCLUDED.identifier_count),
    identifier_suggestions = evergreen.text_array_merge_unique(EXCLUDED.identifier_suggestions,d.identifier_suggestions)
 RETURNING *;
$$;


ALTER FUNCTION search.symspell_dictionary_full_reify() OWNER TO evergreen;

--
-- Name: symspell_dictionary_reify(); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.symspell_dictionary_reify() RETURNS SETOF search.symspell_dictionary
    LANGUAGE sql
    AS $$
 WITH new_rows AS (
    DELETE FROM search.symspell_dictionary_updates WHERE transaction_id = txid_current() RETURNING *
 ), computed_rows AS ( -- this collapses the rows deleted into the format we need for UPSERT
    SELECT  SUM(keyword_count)    AS keyword_count,
            SUM(title_count)      AS title_count,
            SUM(author_count)     AS author_count,
            SUM(subject_count)    AS subject_count,
            SUM(series_count)     AS series_count,
            SUM(identifier_count) AS identifier_count,

            prefix_key,

            ARRAY_REMOVE(ARRAY_AGG(DISTINCT keyword_suggestions[1]), NULL)    AS keyword_suggestions,
            ARRAY_REMOVE(ARRAY_AGG(DISTINCT title_suggestions[1]), NULL)      AS title_suggestions,
            ARRAY_REMOVE(ARRAY_AGG(DISTINCT author_suggestions[1]), NULL)     AS author_suggestions,
            ARRAY_REMOVE(ARRAY_AGG(DISTINCT subject_suggestions[1]), NULL)    AS subject_suggestions,
            ARRAY_REMOVE(ARRAY_AGG(DISTINCT series_suggestions[1]), NULL)     AS series_suggestions,
            ARRAY_REMOVE(ARRAY_AGG(DISTINCT identifier_suggestions[1]), NULL) AS identifier_suggestions
      FROM  new_rows
      GROUP BY prefix_key
 )
 INSERT INTO search.symspell_dictionary AS d SELECT * FROM computed_rows
 ON CONFLICT (prefix_key) DO UPDATE SET
    keyword_count = GREATEST(0, d.keyword_count + EXCLUDED.keyword_count),
    keyword_suggestions = evergreen.text_array_merge_unique(EXCLUDED.keyword_suggestions,d.keyword_suggestions),

    title_count = GREATEST(0, d.title_count + EXCLUDED.title_count),
    title_suggestions = evergreen.text_array_merge_unique(EXCLUDED.title_suggestions,d.title_suggestions),

    author_count = GREATEST(0, d.author_count + EXCLUDED.author_count),
    author_suggestions = evergreen.text_array_merge_unique(EXCLUDED.author_suggestions,d.author_suggestions),

    subject_count = GREATEST(0, d.subject_count + EXCLUDED.subject_count),
    subject_suggestions = evergreen.text_array_merge_unique(EXCLUDED.subject_suggestions,d.subject_suggestions),

    series_count = GREATEST(0, d.series_count + EXCLUDED.series_count),
    series_suggestions = evergreen.text_array_merge_unique(EXCLUDED.series_suggestions,d.series_suggestions),

    identifier_count = GREATEST(0, d.identifier_count + EXCLUDED.identifier_count),
    identifier_suggestions = evergreen.text_array_merge_unique(EXCLUDED.identifier_suggestions,d.identifier_suggestions)
 RETURNING *;
$$;


ALTER FUNCTION search.symspell_dictionary_reify() OWNER TO evergreen;

--
-- Name: symspell_generate_edits(text, integer, integer); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.symspell_generate_edits(raw_word text, dist integer DEFAULT 1, maxed integer DEFAULT 3) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    item    TEXT;
    list    TEXT[] := '{}';
    sublist TEXT[] := '{}';
BEGIN
    FOR I IN 1 .. CHARACTER_LENGTH(raw_word) LOOP
        item := SUBSTRING(raw_word FROM 1 FOR I - 1) || SUBSTRING(raw_word FROM I + 1);
        IF NOT list @> ARRAY[item] THEN
            list := item || list;
            IF dist < maxED AND CHARACTER_LENGTH(raw_word) > dist + 1 THEN
                sublist := search.symspell_generate_edits(item, dist + 1, maxED) || sublist;
            END IF;
        END IF;
    END LOOP;

    IF dist = 1 THEN
        RETURN evergreen.text_array_merge_unique(list, sublist);
    ELSE
        RETURN list || sublist;
    END IF;
END;
$$;


ALTER FUNCTION search.symspell_generate_edits(raw_word text, dist integer, maxed integer) OWNER TO evergreen;

--
-- Name: symspell_lookup(text, text, integer, boolean, integer, integer, integer, integer); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.symspell_lookup(raw_input text, search_class text, verbosity integer DEFAULT 2, xfer_case boolean DEFAULT false, count_threshold integer DEFAULT 1, soundex_weight integer DEFAULT 0, pg_trgm_weight integer DEFAULT 0, kbdist_weight integer DEFAULT 0) RETURNS SETOF search.symspell_lookup_output
    LANGUAGE plpgsql
    AS $_$
DECLARE
    prefix_length INT;
    maxED         INT;
    good_suggs  HSTORE;
    word_list   TEXT[];
    edit_list   TEXT[] := '{}';
    seen_list   TEXT[] := '{}';
    output      search.symspell_lookup_output;
    output_list search.symspell_lookup_output[];
    entry       RECORD;
    entry_key   TEXT;
    prefix_key  TEXT;
    sugg        TEXT;
    input       TEXT;
    word        TEXT;
    w_pos       INT := -1;
    smallest_ed INT := -1;
    global_ed   INT;
    i_len       INT;
    l_maxED     INT;
BEGIN
    SELECT value::INT INTO prefix_length FROM config.internal_flag WHERE name = 'symspell.prefix_length' AND enabled;
    prefix_length := COALESCE(prefix_length, 6);

    SELECT value::INT INTO maxED FROM config.internal_flag WHERE name = 'symspell.max_edit_distance' AND enabled;
    maxED := COALESCE(maxED, 3);

    word_list := ARRAY_AGG(x) FROM search.symspell_parse_words(raw_input) x;

    -- Common case exact match test for preformance
    IF verbosity = 0 AND CARDINALITY(word_list) = 1 AND CHARACTER_LENGTH(word_list[1]) <= prefix_length THEN
        EXECUTE
          'SELECT  '||search_class||'_suggestions AS suggestions,
                   '||search_class||'_count AS count,
                   prefix_key
             FROM  search.symspell_dictionary
             WHERE prefix_key = $1
                   AND '||search_class||'_count >= $2
                   AND '||search_class||'_suggestions @> ARRAY[$1]'
          INTO entry USING evergreen.lowercase(word_list[1]), COALESCE(count_threshold,1);
        IF entry.prefix_key IS NOT NULL THEN
            output.lev_distance := 0; -- definitionally
            output.prefix_key := entry.prefix_key;
            output.prefix_key_count := entry.count;
            output.suggestion_count := entry.count;
            output.input := word_list[1];
            IF xfer_case THEN
                output.suggestion := search.symspell_transfer_casing(output.input, entry.prefix_key);
            ELSE
                output.suggestion := entry.prefix_key;
            END IF;
            output.norm_input := entry.prefix_key;
            output.qwerty_kb_match := 1;
            output.pg_trgm_sim := 1;
            output.soundex_sim := 1;
            RETURN NEXT output;
            RETURN;
        END IF;
    END IF;

    <<word_loop>>
    FOREACH word IN ARRAY word_list LOOP
        w_pos := w_pos + 1;
        input := evergreen.lowercase(word);
        i_len := CHARACTER_LENGTH(input);
        l_maxED := maxED;

        IF CHARACTER_LENGTH(input) > prefix_length THEN
            prefix_key := SUBSTRING(input FROM 1 FOR prefix_length);
            edit_list := ARRAY[input,prefix_key] || search.symspell_generate_edits(prefix_key, 1, l_maxED);
        ELSE
            edit_list := input || search.symspell_generate_edits(input, 1, l_maxED);
        END IF;

        SELECT ARRAY_AGG(x ORDER BY CHARACTER_LENGTH(x) DESC) INTO edit_list FROM UNNEST(edit_list) x;

        output_list := '{}';
        seen_list := '{}';
        global_ed := NULL;

        <<entry_key_loop>>
        FOREACH entry_key IN ARRAY edit_list LOOP
            smallest_ed := -1;
            IF global_ed IS NOT NULL THEN
                smallest_ed := global_ed;
            END IF;

            FOR entry IN EXECUTE
                'SELECT  '||search_class||'_suggestions AS suggestions,
                         '||search_class||'_count AS count,
                         prefix_key
                   FROM  search.symspell_dictionary
                   WHERE prefix_key = $1
                         AND '||search_class||'_suggestions IS NOT NULL'
                USING entry_key
            LOOP

                SELECT  HSTORE(
                            ARRAY_AGG(
                                ARRAY[s, evergreen.levenshtein_damerau_edistance(input,s,l_maxED)::TEXT]
                                    ORDER BY evergreen.levenshtein_damerau_edistance(input,s,l_maxED) DESC
                            )
                        )
                  INTO  good_suggs
                  FROM  UNNEST(entry.suggestions) s
                  WHERE (ABS(CHARACTER_LENGTH(s) - i_len) <= maxEd AND evergreen.levenshtein_damerau_edistance(input,s,l_maxED) BETWEEN 0 AND l_maxED)
                        AND NOT seen_list @> ARRAY[s];

                CONTINUE WHEN good_suggs IS NULL;

                FOR sugg, output.suggestion_count IN EXECUTE
                    'SELECT  prefix_key, '||search_class||'_count
                       FROM  search.symspell_dictionary
                       WHERE prefix_key = ANY ($1)
                             AND '||search_class||'_count >= $2'
                    USING AKEYS(good_suggs), COALESCE(count_threshold,1)
                LOOP

                    output.lev_distance := good_suggs->sugg;
                    seen_list := seen_list || sugg;

                    -- Track the smallest edit distance among suggestions from this prefix key.
                    IF smallest_ed = -1 OR output.lev_distance < smallest_ed THEN
                        smallest_ed := output.lev_distance;
                    END IF;

                    -- Track the smallest edit distance for all prefix keys for this word.
                    IF global_ed IS NULL OR smallest_ed < global_ed THEN
                        global_ed = smallest_ed;
                        -- And if low verbosity, ignore suggs with a larger distance from here on.
                        IF verbosity <= 1 THEN
                            l_maxED := global_ed;
                        END IF;
                    END IF;

                    -- Lev distance is our main similarity measure. While
                    -- trgm or soundex similarity could be the main filter,
                    -- Lev is both language agnostic and faster.
                    --
                    -- Here we will skip suggestions that have a longer edit distance
                    -- than the shortest we've already found. This is simply an
                    -- optimization that allows us to avoid further processing
                    -- of this entry. It would be filtered out later.
                    CONTINUE WHEN output.lev_distance > global_ed AND verbosity <= 1;

                    -- If we have an exact match on the suggestion key we can also avoid
                    -- some function calls.
                    IF output.lev_distance = 0 THEN
                        output.qwerty_kb_match := 1;
                        output.pg_trgm_sim := 1;
                        output.soundex_sim := 1;
                    ELSE
                        IF kbdist_weight THEN
                            output.qwerty_kb_match := evergreen.qwerty_keyboard_distance_match(input, sugg);
                        ELSE
                            output.qwerty_kb_match := 0;
                        END IF;
                        IF pg_trgm_weight THEN
                            output.pg_trgm_sim := similarity(input, sugg);
                        ELSE
                            output.pg_trgm_sim := 0;
                        END IF;
                        IF soundex_weight THEN
                            output.soundex_sim := difference(input, sugg) / 4.0;
                        ELSE
                            output.soundex_sim := 0;
                        END IF;
                    END IF;

                    -- Fill in some fields
                    IF xfer_case AND input <> word THEN
                        output.suggestion := search.symspell_transfer_casing(word, sugg);
                    ELSE
                        output.suggestion := sugg;
                    END IF;
                    output.prefix_key := entry.prefix_key;
                    output.prefix_key_count := entry.count;
                    output.input := word;
                    output.norm_input := input;
                    output.word_pos := w_pos;

                    -- We can't "cache" a set of generated records directly, so
                    -- here we build up an array of search.symspell_lookup_output
                    -- records that we can revivicate later as a table using UNNEST().
                    output_list := output_list || output;

                    EXIT entry_key_loop WHEN smallest_ed = 0 AND verbosity = 0; -- exact match early exit
                    CONTINUE entry_key_loop WHEN smallest_ed = 0 AND verbosity = 1; -- exact match early jump to the next key

                END LOOP; -- loop over suggestions
            END LOOP; -- loop over entries
        END LOOP; -- loop over entry_keys

        -- Now we're done examining this word
        IF verbosity = 0 THEN
            -- Return the "best" suggestion from the smallest edit
            -- distance group.  We define best based on the weighting
            -- of the non-lev similarity measures and use the suggestion
            -- use count to break ties.
            RETURN QUERY
                SELECT * FROM UNNEST(output_list)
                    ORDER BY lev_distance,
                        (soundex_sim * COALESCE(soundex_weight,0))
                            + (pg_trgm_sim * COALESCE(pg_trgm_weight,0))
                            + (qwerty_kb_match * COALESCE(kbdist_weight,0)) DESC,
                        suggestion_count DESC
                        LIMIT 1;
        ELSIF verbosity = 1 THEN
            -- Return all suggestions from the smallest
            -- edit distance group.
            RETURN QUERY
                SELECT * FROM UNNEST(output_list) WHERE lev_distance = smallest_ed
                    ORDER BY (soundex_sim * COALESCE(soundex_weight,0))
                            + (pg_trgm_sim * COALESCE(pg_trgm_weight,0))
                            + (qwerty_kb_match * COALESCE(kbdist_weight,0)) DESC,
                        suggestion_count DESC;
        ELSIF verbosity = 2 THEN
            -- Return everything we find, along with relevant stats
            RETURN QUERY
                SELECT * FROM UNNEST(output_list)
                    ORDER BY lev_distance,
                        (soundex_sim * COALESCE(soundex_weight,0))
                            + (pg_trgm_sim * COALESCE(pg_trgm_weight,0))
                            + (qwerty_kb_match * COALESCE(kbdist_weight,0)) DESC,
                        suggestion_count DESC;
        ELSIF verbosity = 3 THEN
            -- Return everything we find from the two smallest edit distance groups
            RETURN QUERY
                SELECT * FROM UNNEST(output_list)
                    WHERE lev_distance IN (SELECT DISTINCT lev_distance FROM UNNEST(output_list) ORDER BY 1 LIMIT 2)
                    ORDER BY lev_distance,
                        (soundex_sim * COALESCE(soundex_weight,0))
                            + (pg_trgm_sim * COALESCE(pg_trgm_weight,0))
                            + (qwerty_kb_match * COALESCE(kbdist_weight,0)) DESC,
                        suggestion_count DESC;
        ELSIF verbosity = 4 THEN
            -- Return everything we find from the two smallest edit distance groups that are NOT 0 distance
            RETURN QUERY
                SELECT * FROM UNNEST(output_list)
                    WHERE lev_distance IN (SELECT DISTINCT lev_distance FROM UNNEST(output_list) WHERE lev_distance > 0 ORDER BY 1 LIMIT 2)
                    ORDER BY lev_distance,
                        (soundex_sim * COALESCE(soundex_weight,0))
                            + (pg_trgm_sim * COALESCE(pg_trgm_weight,0))
                            + (qwerty_kb_match * COALESCE(kbdist_weight,0)) DESC,
                        suggestion_count DESC;
        END IF;
    END LOOP; -- loop over words
END;
$_$;


ALTER FUNCTION search.symspell_lookup(raw_input text, search_class text, verbosity integer, xfer_case boolean, count_threshold integer, soundex_weight integer, pg_trgm_weight integer, kbdist_weight integer) OWNER TO evergreen;

--
-- Name: symspell_maintain_entries(); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.symspell_maintain_entries() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    search_class    TEXT;
    new_value       TEXT := NULL;
    old_value       TEXT := NULL;
BEGIN
    search_class := COALESCE(TG_ARGV[0], SPLIT_PART(TG_TABLE_NAME,'_',1));

    IF TG_OP IN ('INSERT', 'UPDATE') THEN
        new_value := NEW.value;
    END IF;

    IF TG_OP IN ('DELETE', 'UPDATE') THEN
        old_value := OLD.value;
    END IF;

    IF new_value = old_value THEN
        -- same, move along
    ELSE
        INSERT INTO search.symspell_dictionary_updates
            SELECT  txid_current(), *
              FROM  search.symspell_build_entries(
                        new_value,
                        search_class,
                        old_value
                    );
    END IF;

    RETURN NULL; -- always fired AFTER
END;
$$;


ALTER FUNCTION search.symspell_maintain_entries() OWNER TO evergreen;

--
-- Name: symspell_parse_words(text); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.symspell_parse_words(phrase text) RETURNS SETOF text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT UNNEST(x) FROM regexp_matches($1, '([[:alnum:]]+''*[[:alnum:]]*)', 'g') x;
$_$;


ALTER FUNCTION search.symspell_parse_words(phrase text) OWNER TO evergreen;

--
-- Name: symspell_parse_words_distinct(text); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.symspell_parse_words_distinct(phrase text) RETURNS SETOF text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
    SELECT DISTINCT UNNEST(x) FROM regexp_matches($1, '([[:alnum:]]+''*[[:alnum:]]*)', 'g') x;
$_$;


ALTER FUNCTION search.symspell_parse_words_distinct(phrase text) OWNER TO evergreen;

--
-- Name: symspell_transfer_casing(text, text); Type: FUNCTION; Schema: search; Owner: evergreen
--

CREATE FUNCTION search.symspell_transfer_casing(withcase text, withoutcase text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    woChars TEXT[];
    curr    TEXT;
    ind     INT := 1;
BEGIN
    woChars := regexp_split_to_array(withoutCase,'');
    FOR curr IN SELECT x FROM regexp_split_to_table(withCase, '') x LOOP
        IF curr = evergreen.uppercase(curr) THEN
            woChars[ind] := evergreen.uppercase(woChars[ind]);
        END IF;
        ind := ind + 1;
    END LOOP;
    RETURN ARRAY_TO_STRING(woChars,'');
END;
$$;


ALTER FUNCTION search.symspell_transfer_casing(withcase text, withoutcase text) OWNER TO evergreen;

--
-- Name: materialize_holding_code(); Type: FUNCTION; Schema: serial; Owner: evergreen
--

CREATE FUNCTION serial.materialize_holding_code() RETURNS trigger
    LANGUAGE plperlu
    AS $_X$ 
use strict;

use MARC::Field;
use JSON::XS;

if (not defined $_TD->{new}{holding_code}) {
    elog(WARNING, 'NULL in "holding_code" column of serial.issuance allowed for now, but may not be useful');
    return;
}

# Do nothing if holding_code has not changed...

if ($_TD->{new}{holding_code} eq $_TD->{old}{holding_code}) {
    # ... unless the following internal flag is set.

    my $flag_rv = spi_exec_query(q{
        SELECT * FROM config.internal_flag
        WHERE name = 'serial.rematerialize_on_same_holding_code' AND enabled
    }, 1);
    return unless $flag_rv->{processed};
}


my $holding_code = (new JSON::XS)->decode($_TD->{new}{holding_code});

my $field = new MARC::Field('999', @$holding_code); # tag doesnt matter

my $dstmt = spi_prepare(
    'DELETE FROM serial.materialized_holding_code WHERE issuance = $1',
    'INT'
);
spi_exec_prepared($dstmt, $_TD->{new}{id});

my $istmt = spi_prepare(
    q{
        INSERT INTO serial.materialized_holding_code (
            issuance, subfield, value
        ) VALUES ($1, $2, $3)
    }, qw{INT CHAR TEXT}
);

foreach ($field->subfields) {
    spi_exec_prepared(
        $istmt,
        $_TD->{new}{id},
        $_->[0],
        $_->[1]
    );
}

return;

$_X$;


ALTER FUNCTION serial.materialize_holding_code() OWNER TO evergreen;

--
-- Name: pattern_template; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.pattern_template (
    id integer NOT NULL,
    name text NOT NULL,
    pattern_code text NOT NULL,
    owning_lib integer,
    share_depth integer DEFAULT 0 NOT NULL
);


ALTER TABLE serial.pattern_template OWNER TO evergreen;

--
-- Name: pattern_templates_visible_to(integer); Type: FUNCTION; Schema: serial; Owner: evergreen
--

CREATE FUNCTION serial.pattern_templates_visible_to(org_unit integer) RETURNS SETOF serial.pattern_template
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY SELECT *
           FROM serial.pattern_template spt
           WHERE (
             SELECT ARRAY_AGG(id)
             FROM actor.org_unit_descendants(spt.owning_lib, spt.share_depth)
           ) @@ org_unit::TEXT::QUERY_INT;
END;
$$;


ALTER FUNCTION serial.pattern_templates_visible_to(org_unit integer) OWNER TO evergreen;

--
-- Name: purge_pending_users(); Type: FUNCTION; Schema: staging; Owner: evergreen
--

CREATE FUNCTION staging.purge_pending_users() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    org_id INT;
    intvl TEXT;
BEGIN
    FOR org_id IN SELECT DISTINCT(home_ou) FROM staging.user_stage LOOP

        SELECT INTO intvl value FROM 
            actor.org_unit_ancestor_setting(
                'opac.pending_user_expire_interval', org_id);

        CONTINUE WHEN intvl IS NULL OR intvl ILIKE 'null';

        -- de-JSON-ify the string
        SELECT INTO intvl TRIM(BOTH '"' FROM intvl);

        DELETE FROM staging.user_stage 
            WHERE home_ou = org_id AND row_date + intvl::INTERVAL < NOW();

    END LOOP;
END;
$$;


ALTER FUNCTION staging.purge_pending_users() OWNER TO evergreen;

--
-- Name: acl(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.acl(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name location,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    id AS ident,
                    holdable,
                    opac_visible,
                    label_prefix AS prefix,
                    label_suffix AS suffix
                ),
                name
            )
      FROM  asset.copy_location
      WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acl(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: acn(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.acn(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name volume,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@acn/' || acn.id AS id,
                        acn.id AS vol_id, o.shortname AS lib,
                        o.opac_visible AS opac_visible,
                        deleted, label, label_sortkey, label_class, record
                    ),
                    unapi.aou( owning_lib, $2, 'owning_lib', array_remove($4,'acn'), $5, $6, $7, $8),
                    CASE 
                        WHEN ('acp' = ANY ($4)) THEN
                            CASE WHEN $6 IS NOT NULL THEN
                                XMLELEMENT( name copies,
                                    (SELECT XMLAGG(acp ORDER BY rank_avail) FROM (
                                        SELECT  unapi.acp( cp.id, 'xml', 'copy', array_remove($4,'acn'), $5, $6, $7, $8, FALSE),
                                            evergreen.rank_cp(cp) AS rank_avail
                                          FROM  asset.copy cp
                                                JOIN actor.org_unit_descendants( (SELECT id FROM actor.org_unit WHERE shortname = $5), $6) aoud ON (cp.circ_lib = aoud.id)
                                          WHERE cp.call_number = acn.id
                                              AND cp.deleted IS FALSE
                                          ORDER BY rank_avail, COALESCE(cp.copy_number,0), cp.barcode
                                          LIMIT ($7 -> 'acp')::INT
                                          OFFSET ($8 -> 'acp')::INT
                                    )x)
                                )
                            ELSE
                                XMLELEMENT( name copies,
                                    (SELECT XMLAGG(acp ORDER BY rank_avail) FROM (
                                        SELECT  unapi.acp( cp.id, 'xml', 'copy', array_remove($4,'acn'), $5, $6, $7, $8, FALSE),
                                            evergreen.rank_cp(cp) AS rank_avail
                                          FROM  asset.copy cp
                                                JOIN actor.org_unit_descendants( (SELECT id FROM actor.org_unit WHERE shortname = $5) ) aoud ON (cp.circ_lib = aoud.id)
                                          WHERE cp.call_number = acn.id
                                              AND cp.deleted IS FALSE
                                          ORDER BY rank_avail, COALESCE(cp.copy_number,0), cp.barcode
                                          LIMIT ($7 -> 'acp')::INT
                                          OFFSET ($8 -> 'acp')::INT
                                    )x)
                                )
                            END
                        ELSE NULL
                    END,
                    XMLELEMENT(
                        name uris,
                        (SELECT XMLAGG(auri) FROM (SELECT unapi.auri(uri,'xml','uri', array_remove($4,'acn'), $5, $6, $7, $8, FALSE) FROM asset.uri_call_number_map WHERE call_number = acn.id)x)
                    ),
                    unapi.acnp( acn.prefix, 'marcxml', 'prefix', array_remove($4,'acn'), $5, $6, $7, $8, FALSE),
                    unapi.acns( acn.suffix, 'marcxml', 'suffix', array_remove($4,'acn'), $5, $6, $7, $8, FALSE),
                    CASE WHEN ('bre' = ANY ($4)) THEN unapi.bre( acn.record, 'marcxml', 'record', array_remove($4,'acn'), $5, $6, $7, $8, FALSE) ELSE NULL END
                ) AS x
          FROM  asset.call_number acn
                JOIN actor.org_unit o ON (o.id = acn.owning_lib)
          WHERE acn.id = $1
              AND acn.deleted IS FALSE
          GROUP BY acn.id, o.shortname, o.opac_visible, deleted, label, label_sortkey, label_class, owning_lib, record, acn.prefix, acn.suffix;
$_$;


ALTER FUNCTION unapi.acn(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: acnp(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.acnp(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name call_number_prefix,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        id AS ident,
                        label,
                        'tag:open-ils.org:U2@aou/' || owning_lib AS owning_lib,
                        label_sortkey
                    )
                )
          FROM  asset.call_number_prefix
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acnp(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: acns(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.acns(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name call_number_suffix,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        id AS ident,
                        label,
                        'tag:open-ils.org:U2@aou/' || owning_lib AS owning_lib,
                        label_sortkey
                    )
                )
          FROM  asset.call_number_suffix
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acns(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: acp(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.acp(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name copy,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@acp/' || id AS id, id AS copy_id,
                        create_date, edit_date, copy_number, circulate, deposit,
                        ref, holdable, deleted, deposit_amount, price, barcode,
                        circ_modifier, circ_as_type, opac_visible, age_protect
                    ),
                    unapi.ccs( status, $2, 'status', array_remove($4,'acp'), $5, $6, $7, $8, FALSE),
                    unapi.acl( location, $2, 'location', array_remove($4,'acp'), $5, $6, $7, $8, FALSE),
                    unapi.aou( circ_lib, $2, 'circ_lib', array_remove($4,'acp'), $5, $6, $7, $8),
                    unapi.aou( circ_lib, $2, 'circlib', array_remove($4,'acp'), $5, $6, $7, $8),
                    CASE WHEN ('acn' = ANY ($4)) THEN unapi.acn( call_number, $2, 'call_number', array_remove($4,'acp'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE 
                        WHEN ('acpn' = ANY ($4)) THEN
                            XMLELEMENT( name copy_notes,
                                (SELECT XMLAGG(acpn) FROM (
                                    SELECT  unapi.acpn( id, 'xml', 'copy_note', array_remove($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_note
                                      WHERE owning_copy = cp.id AND pub
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('ascecm' = ANY ($4)) THEN
                            XMLELEMENT( name statcats,
                                (SELECT XMLAGG(ascecm) FROM (
                                    SELECT  unapi.ascecm( stat_cat_entry, 'xml', 'statcat', array_remove($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.stat_cat_entry_copy_map
                                      WHERE owning_copy = cp.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE
                        WHEN ('bre' = ANY ($4)) THEN
                            XMLELEMENT( name foreign_records,
                                (SELECT XMLAGG(bre) FROM (
                                    SELECT  unapi.bre(peer_record,'marcxml','record','{}'::TEXT[], $5, $6, $7, $8, FALSE)
                                      FROM  biblio.peer_bib_copy_map
                                      WHERE target_copy = cp.id
                                )x)

                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('bmp' = ANY ($4)) THEN
                            XMLELEMENT( name monograph_parts,
                                (SELECT XMLAGG(bmp) FROM (
                                    SELECT  unapi.bmp( part, 'xml', 'monograph_part', array_remove($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_part_map
                                      WHERE target_copy = cp.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('circ' = ANY ($4)) THEN
                            XMLELEMENT( name current_circulation,
                                (SELECT XMLAGG(circ) FROM (
                                    SELECT  unapi.circ( id, 'xml', 'circ', array_remove($4,'circ'), $5, $6, $7, $8, FALSE)
                                      FROM  action.circulation
                                      WHERE target_copy = cp.id
                                            AND checkin_time IS NULL
                                )x)
                            )
                        ELSE NULL
                    END
                )
          FROM  asset.copy cp
          WHERE id = $1
              AND cp.deleted IS FALSE
          GROUP BY id, status, location, circ_lib, call_number, create_date,
              edit_date, copy_number, circulate, deposit, ref, holdable,
              deleted, deposit_amount, price, barcode, circ_modifier,
              circ_as_type, opac_visible, age_protect;
$_$;


ALTER FUNCTION unapi.acp(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: acpn(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.acpn(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name copy_note,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        create_date AS date,
                        title
                    ),
                    value
                )
          FROM  asset.copy_note
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.acpn(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: aou(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.aou(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    output XML;
BEGIN
    IF ename = 'circlib' THEN
        SELECT  XMLELEMENT(
                    name circlib,
                    XMLATTRIBUTES(
                        'http://open-ils.org/spec/actors/v1' AS xmlns,
                        id AS ident
                    ),
                    name
                ) INTO output
          FROM  actor.org_unit aou
          WHERE id = obj_id;
    ELSE
        EXECUTE $$SELECT  XMLELEMENT(
                    name $$ || ename || $$,
                    XMLATTRIBUTES(
                        'http://open-ils.org/spec/actors/v1' AS xmlns,
                        'tag:open-ils.org:U2@aou/' || id AS id,
                        shortname, name, opac_visible
                    )
                )
          FROM  actor.org_unit aou
         WHERE id = $1 $$ INTO output USING obj_id;
    END IF;

    RETURN output;

END;
$_$;


ALTER FUNCTION unapi.aou(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: ascecm(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.ascecm(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name statcat,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        sc.name,
                        sc.opac_visible
                    ),
                    asce.value
                )
          FROM  asset.stat_cat_entry asce
                JOIN asset.stat_cat sc ON (sc.id = asce.stat_cat)
          WHERE asce.id = $1;
$_$;


ALTER FUNCTION unapi.ascecm(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: auri(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.auri(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name uri,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@auri/' || uri.id AS id,
                        use_restriction,
                        href,
                        label
                    ),
                    CASE 
                        WHEN ('acn' = ANY ($4)) THEN
                            XMLELEMENT( name copies,
                                (SELECT XMLAGG(acn) FROM (SELECT unapi.acn( call_number, 'xml', 'copy', array_remove($4,'auri'), $5, $6, $7, $8, FALSE) FROM asset.uri_call_number_map WHERE uri = uri.id)x)
                            )
                        ELSE NULL
                    END
                ) AS x
          FROM  asset.uri uri
          WHERE uri.id = $1
          GROUP BY uri.id, use_restriction, href, label;
$_$;


ALTER FUNCTION unapi.auri(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: biblio_record_entry_feed(bigint[], text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean, text, text, text, text, text, xml, integer); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.biblio_record_entry_feed(id_list bigint[], format text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, title text DEFAULT NULL::text, description text DEFAULT NULL::text, creator text DEFAULT NULL::text, update_ts text DEFAULT NULL::text, unapi_url text DEFAULT NULL::text, header_xml xml DEFAULT NULL::xml, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    layout          unapi.bre_output_layout%ROWTYPE;
    transform       config.xml_transform%ROWTYPE;
    item_format     TEXT;
    tmp_xml         TEXT;
    xmlns_uri       TEXT := 'http://open-ils.org/spec/feed-xml/v1';
    ouid            INT;
    element_list    TEXT[];
BEGIN

    IF org = '-' OR org IS NULL THEN
        SELECT shortname INTO org FROM evergreen.org_top();
    END IF;

    SELECT id INTO ouid FROM actor.org_unit WHERE shortname = org;
    SELECT * INTO layout FROM unapi.bre_output_layout WHERE name = format;

    IF layout.name IS NULL THEN
        RETURN NULL::XML;
    END IF;

    SELECT * INTO transform FROM config.xml_transform WHERE name = layout.transform;
    xmlns_uri := COALESCE(transform.namespace_uri,xmlns_uri);

    -- Gather the bib xml
    SELECT XMLAGG( unapi.bre(i, format, '', includes, org, depth, slimit, soffset, include_xmlns, pref_lib)) INTO tmp_xml FROM UNNEST( id_list ) i;

    IF layout.title_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.title_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, title;
    END IF;

    IF layout.description_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.description_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, description;
    END IF;

    IF layout.creator_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.creator_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, creator;
    END IF;

    IF layout.update_ts_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.update_ts_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, update_ts;
    END IF;

    IF unapi_url IS NOT NULL THEN
        EXECUTE $$SELECT XMLCONCAT( XMLELEMENT( name link, XMLATTRIBUTES( 'http://www.w3.org/1999/xhtml' AS xmlns, 'unapi-server' AS rel, $1 AS href, 'unapi' AS title)), $2)$$ INTO tmp_xml USING unapi_url, tmp_xml::XML;
    END IF;

    IF header_xml IS NOT NULL THEN tmp_xml := XMLCONCAT(header_xml,tmp_xml::XML); END IF;

    element_list := regexp_split_to_array(layout.feed_top,E'\\.');
    FOR i IN REVERSE ARRAY_UPPER(element_list, 1) .. 1 LOOP
        EXECUTE 'SELECT XMLELEMENT( name '|| quote_ident(element_list[i]) ||', XMLATTRIBUTES( $1 AS xmlns), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML;
    END LOOP;

    RETURN tmp_xml::XML;
END;
$_$;


ALTER FUNCTION unapi.biblio_record_entry_feed(id_list bigint[], format text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, title text, description text, creator text, update_ts text, unapi_url text, header_xml xml, pref_lib integer) OWNER TO evergreen;

--
-- Name: bmp(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.bmp(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name monograph_part,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@bmp/' || id AS id,
                        id AS ident,
                        label,
                        label_sortkey,
                        'tag:open-ils.org:U2@bre/' || record AS record
                    ),
                    CASE 
                        WHEN ('acp' = ANY ($4)) THEN
                            XMLELEMENT( name copies,
                                (SELECT XMLAGG(acp) FROM (
                                    SELECT  unapi.acp( cp.id, 'xml', 'copy', array_remove($4,'bmp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy cp
                                            JOIN asset.copy_part_map cpm ON (cpm.target_copy = cp.id)
                                      WHERE cpm.part = $1
                                          AND cp.deleted IS FALSE
                                      ORDER BY COALESCE(cp.copy_number,0), cp.barcode
                                      LIMIT ($7 -> 'acp')::INT
                                      OFFSET ($8 -> 'acp')::INT

                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE WHEN ('bre' = ANY ($4)) THEN unapi.bre( record, 'marcxml', 'record', array_remove($4,'bmp'), $5, $6, $7, $8, FALSE) ELSE NULL END
                )
          FROM  biblio.monograph_part
          WHERE NOT deleted AND id = $1
          GROUP BY id, label, label_sortkey, record;
$_$;


ALTER FUNCTION unapi.bmp(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: bre(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean, integer); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.bre(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    me      biblio.record_entry%ROWTYPE;
    layout  unapi.bre_output_layout%ROWTYPE;
    xfrm    config.xml_transform%ROWTYPE;
    ouid    INT;
    tmp_xml TEXT;
    top_el  TEXT;
    output  XML;
    hxml    XML;
    axml    XML;
    source  XML;
BEGIN

    IF org = '-' OR org IS NULL THEN
        SELECT shortname INTO org FROM evergreen.org_top();
    END IF;

    SELECT id INTO ouid FROM actor.org_unit WHERE shortname = org;

    IF ouid IS NULL THEN
        RETURN NULL::XML;
    END IF;

    IF format = 'holdings_xml' THEN -- the special case
        output := unapi.holdings_xml( obj_id, ouid, org, depth, includes, slimit, soffset, include_xmlns);
        RETURN output;
    END IF;

    SELECT * INTO layout FROM unapi.bre_output_layout WHERE name = format;

    IF layout.name IS NULL THEN
        RETURN NULL::XML;
    END IF;

    SELECT * INTO xfrm FROM config.xml_transform WHERE name = layout.transform;

    SELECT * INTO me FROM biblio.record_entry WHERE id = obj_id;

    -- grab bib_source, if any
    IF ('cbs' = ANY (includes) AND me.source IS NOT NULL) THEN
        source := unapi.cbs(me.source,NULL,NULL,NULL,NULL);
    ELSE
        source := NULL::XML;
    END IF;

    -- grab SVF if we need them
    IF ('mra' = ANY (includes)) THEN 
        axml := unapi.mra(obj_id,NULL,NULL,NULL,NULL);
    ELSE
        axml := NULL::XML;
    END IF;

    -- grab holdings if we need them
    IF ('holdings_xml' = ANY (includes)) THEN 
        hxml := unapi.holdings_xml(obj_id, ouid, org, depth, array_remove(includes,'holdings_xml'), slimit, soffset, include_xmlns, pref_lib);
    ELSE
        hxml := NULL::XML;
    END IF;


    -- generate our item node


    IF format = 'marcxml' THEN
        tmp_xml := me.marc;
        IF tmp_xml !~ E'<marc:' THEN -- If we're not using the prefixed namespace in this record, then remove all declarations of it
           tmp_xml := REGEXP_REPLACE(tmp_xml, ' xmlns:marc="http://www.loc.gov/MARC21/slim"', '', 'g');
        END IF; 
    ELSE
        tmp_xml := oils_xslt_process(me.marc, xfrm.xslt)::XML;
    END IF;

    top_el := REGEXP_REPLACE(tmp_xml, E'^.*?<((?:\\S+:)?' || layout.holdings_element || ').*$', E'\\1');

    IF source IS NOT NULL THEN
        tmp_xml := REGEXP_REPLACE(tmp_xml, '</' || top_el || '>(.*?)$', source || '</' || top_el || E'>\\1');
    END IF;

    IF axml IS NOT NULL THEN 
        tmp_xml := REGEXP_REPLACE(tmp_xml, '</' || top_el || '>(.*?)$', axml || '</' || top_el || E'>\\1');
    END IF;

    IF hxml IS NOT NULL THEN -- XXX how do we configure the holdings position?
        tmp_xml := REGEXP_REPLACE(tmp_xml, '</' || top_el || '>(.*?)$', hxml || '</' || top_el || E'>\\1');
    END IF;

    IF ('bre.unapi' = ANY (includes)) THEN 
        output := REGEXP_REPLACE(
            tmp_xml,
            '</' || top_el || '>(.*?)',
            XMLELEMENT(
                name abbr,
                XMLATTRIBUTES(
                    'http://www.w3.org/1999/xhtml' AS xmlns,
                    'unapi-id' AS class,
                    'tag:open-ils.org:U2@bre/' || obj_id || '/' || org AS title
                )
            )::TEXT || '</' || top_el || E'>\\1'
        );
    ELSE
        output := tmp_xml;
    END IF;

    IF ('bre.extern' = ANY (includes)) THEN 
        output := REGEXP_REPLACE(
            tmp_xml,
            '</' || top_el || '>(.*?)',
            XMLELEMENT(
                name extern,
                XMLATTRIBUTES(
                    'http://open-ils.org/spec/biblio/v1' AS xmlns,
                    me.creator AS creator,
                    me.editor AS editor,
                    me.create_date AS create_date,
                    me.edit_date AS edit_date,
                    me.quality AS quality,
                    me.fingerprint AS fingerprint,
                    me.tcn_source AS tcn_source,
                    me.tcn_value AS tcn_value,
                    me.owner AS owner,
                    me.share_depth AS share_depth,
                    me.active AS active,
                    me.deleted AS deleted
                )
            )::TEXT || '</' || top_el || E'>\\1'
        );
    ELSE
        output := tmp_xml;
    END IF;

    output := REGEXP_REPLACE(output::TEXT,E'>\\s+<','><','gs')::XML;
    RETURN output;
END;
$_$;


ALTER FUNCTION unapi.bre(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, pref_lib integer) OWNER TO evergreen;

--
-- Name: bre_profiling(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean, integer); Type: FUNCTION; Schema: unapi; Owner: postgres
--

CREATE FUNCTION unapi.bre_profiling(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    me      biblio.record_entry%ROWTYPE;
    layout  unapi.bre_output_layout%ROWTYPE;
    xfrm    config.xml_transform%ROWTYPE;
    ouid    INT;
    tmp_xml TEXT;
    top_el  TEXT;
    output  XML;
    hxml    XML;
    axml    XML;
diff    interval;
current     timestamp with time zone;
BEGIN
current = clock_timestamp();
RAISE NOTICE 'PROFILING: Function start %', current;
    IF org = '-' OR org IS NULL THEN
        SELECT shortname INTO org FROM evergreen.org_top();
    END IF;

    SELECT id INTO ouid FROM actor.org_unit WHERE shortname = org;

    IF ouid IS NULL THEN
        RETURN NULL::XML;
    END IF;
diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 1 % DIFF: %', current, diff;

    IF format = 'holdings_xml' THEN -- the special case
        output := unapi.holdings_xml( obj_id, ouid, org, depth, includes, slimit, soffset, include_xmlns);
        RETURN output;
    END IF;
diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 2 % DIFF: %', current, diff;

    SELECT * INTO layout FROM unapi.bre_output_layout WHERE name = format;

    IF layout.name IS NULL THEN
        RETURN NULL::XML;
    END IF;
diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 3 % DIFF: %', current, diff;

    SELECT * INTO xfrm FROM config.xml_transform WHERE name = layout.transform;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 4 % DIFF: %', current, diff;

    SELECT * INTO me FROM biblio.record_entry WHERE id = obj_id;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 5 % DIFF: %', current, diff;

    -- grab SVF if we need them
    IF ('mra' = ANY (includes)) THEN 
        axml := unapi.mra(obj_id,NULL,NULL,NULL,NULL);
    ELSE
        axml := NULL::XML;
    END IF;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 6 % DIFF: %', current, diff;

    -- grab holdings if we need them
    IF ('holdings_xml' = ANY (includes)) THEN 
        hxml := unapi.holdings_xml(obj_id, ouid, org, depth, evergreen.array_remove_item_by_value(includes,'holdings_xml'), slimit, soffset, include_xmlns, pref_lib);
    ELSE
        hxml := NULL::XML;
    END IF;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 7 % DIFF: %', current, diff;


    -- generate our item node


    IF format = 'marcxml' THEN
        tmp_xml := me.marc;
        IF tmp_xml !~ E'<marc:' THEN -- If we're not using the prefixed namespace in this record, then remove all declarations of it
           tmp_xml := REGEXP_REPLACE(tmp_xml, ' xmlns:marc="http://www.loc.gov/MARC21/slim"', '', 'g');
        END IF; 
    ELSE
        tmp_xml := oils_xslt_process(me.marc, xfrm.xslt)::XML;
    END IF;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 8 % DIFF: %', current, diff;

    top_el := REGEXP_REPLACE(tmp_xml, E'^.*?<((?:\\S+:)?' || layout.holdings_element || ').*$', E'\\1');

    IF axml IS NOT NULL THEN 
        tmp_xml := REGEXP_REPLACE(tmp_xml, '</' || top_el || '>(.*?)$', axml || '</' || top_el || E'>\\1');
    END IF;

    IF hxml IS NOT NULL THEN -- XXX how do we configure the holdings position?
        tmp_xml := REGEXP_REPLACE(tmp_xml, '</' || top_el || '>(.*?)$', hxml || '</' || top_el || E'>\\1');
    END IF;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 9 % DIFF: %', current, diff;

    IF ('bre.unapi' = ANY (includes)) THEN 
        output := REGEXP_REPLACE(
            tmp_xml,
            '</' || top_el || '>(.*?)',
            XMLELEMENT(
                name abbr,
                XMLATTRIBUTES(
                    'http://www.w3.org/1999/xhtml' AS xmlns,
                    'unapi-id' AS class,
                    'tag:open-ils.org:U2@bre/' || obj_id || '/' || org AS title
                )
            )::TEXT || '</' || top_el || E'>\\1'
        );
    ELSE
        output := tmp_xml;
    END IF;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: STEP 10 % DIFF: %', current, diff;

    output := REGEXP_REPLACE(output::TEXT,E'>\\s+<','><','gs')::XML;

diff = clock_timestamp() - current;
current = clock_timestamp();
RAISE NOTICE 'PROFILING: END: % DIFF: %', current, diff;
    RETURN output;
END;
$_$;


ALTER FUNCTION unapi.bre_profiling(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, pref_lib integer) OWNER TO postgres;

--
-- Name: cbs(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.cbs(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name bib_source,
                XMLATTRIBUTES(
                    NULL AS xmlns, -- TODO needs equivalent to http://open-ils.org/spec/holdings/v1
                    id AS ident,
                    quality,
                    transcendant,
                    can_have_copies
                ),
                source
            )
      FROM  config.bib_source
      WHERE id = $1;
$_$;


ALTER FUNCTION unapi.cbs(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: ccs(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.ccs(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name status,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    id AS ident,
                    holdable,
                    opac_visible
                ),
                name
            )
      FROM  config.copy_status
      WHERE id = $1;
$_$;


ALTER FUNCTION unapi.ccs(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: circ(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.circ(obj_id bigint, format text, ename text, includes text[], org text DEFAULT '-'::text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT XMLELEMENT(
        name circ,
        XMLATTRIBUTES(
            CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
            'tag:open-ils.org:U2@circ/' || id AS id,
            xact_start,
            due_date
        ),
        CASE WHEN ('aou' = ANY ($4)) THEN unapi.aou( circ_lib, $2, 'circ_lib', array_remove($4,'circ'), $5, $6, $7, $8, FALSE) ELSE NULL END,
        CASE WHEN ('acp' = ANY ($4)) THEN unapi.acp( circ_lib, $2, 'target_copy', array_remove($4,'circ'), $5, $6, $7, $8, FALSE) ELSE NULL END
    )
    FROM action.circulation
    WHERE id = $1;
$_$;


ALTER FUNCTION unapi.circ(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: holdings_xml(bigint, integer, text, integer, text[], evergreen.hstore, evergreen.hstore, boolean, integer); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.holdings_xml(bid bigint, ouid integer, org text, depth integer DEFAULT NULL::integer, includes text[] DEFAULT NULL::text[], slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
     SELECT  XMLELEMENT(
                 name holdings,
                 XMLATTRIBUTES(
                    CASE WHEN $8 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    CASE WHEN ('bre' = ANY ($5)) THEN 'tag:open-ils.org:U2@bre/' || $1 || '/' || $3 ELSE NULL END AS id,
                    (SELECT record_has_holdable_copy FROM asset.record_has_holdable_copy($1)) AS has_holdable
                 ),
                 XMLELEMENT(
                     name counts,
                     (SELECT  XMLAGG(XMLELEMENT::XML) FROM (
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('public' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.opac_ou_record_copy_count($2,  $1)
                                     UNION
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('staff' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.staff_ou_record_copy_count($2, $1)
                                     UNION
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('pref_lib' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.opac_ou_record_copy_count($9,  $1)
                                     ORDER BY 1
                     )x)
                 ),
                 CASE 
                     WHEN ('bmp' = ANY ($5)) THEN
                        XMLELEMENT(
                            name monograph_parts,
                            (SELECT XMLAGG(bmp) FROM (
                                SELECT  unapi.bmp( id, 'xml', 'monograph_part', array_remove( array_remove($5,'bre'), 'holdings_xml'), $3, $4, $6, $7, FALSE)
                                  FROM  biblio.monograph_part
                                  WHERE NOT deleted AND record = $1
                            )x)
                        )
                     ELSE NULL
                 END,
                 XMLELEMENT(
                     name volumes,
                     (SELECT XMLAGG(acn ORDER BY rank, name, label_sortkey) FROM (
                        -- Physical copies
                        SELECT  unapi.acn(y.id,'xml','volume',array_remove( array_remove($5,'holdings_xml'),'bre'), $3, $4, $6, $7, FALSE), y.rank, name, label_sortkey
                        FROM evergreen.ranked_volumes($1, $2, $4, $6, $7, $9, $5) AS y
                        UNION ALL
                        -- Located URIs
                        SELECT unapi.acn(uris.id,'xml','volume',array_remove( array_remove($5,'holdings_xml'),'bre'), $3, $4, $6, $7, FALSE), uris.rank, name, label_sortkey
                        FROM evergreen.located_uris($1, $2, $9) AS uris
                     )x)
                 ),
                 CASE WHEN ('ssub' = ANY ($5)) THEN 
                     XMLELEMENT(
                         name subscriptions,
                         (SELECT XMLAGG(ssub) FROM (
                            SELECT  unapi.ssub(id,'xml','subscription','{}'::TEXT[], $3, $4, $6, $7, FALSE)
                              FROM  serial.subscription
                              WHERE record_entry = $1
                        )x)
                     )
                 ELSE NULL END,
                 CASE WHEN ('acp' = ANY ($5)) THEN 
                     XMLELEMENT(
                         name foreign_copies,
                         (SELECT XMLAGG(acp) FROM (
                            SELECT  unapi.acp(p.target_copy,'xml','copy',array_remove($5,'acp'), $3, $4, $6, $7, FALSE)
                              FROM  biblio.peer_bib_copy_map p
                                    JOIN asset.copy c ON (p.target_copy = c.id)
                              WHERE NOT c.deleted AND p.peer_record = $1
                            LIMIT ($6 -> 'acp')::INT
                            OFFSET ($7 -> 'acp')::INT
                        )x)
                     )
                 ELSE NULL END
             );
$_$;


ALTER FUNCTION unapi.holdings_xml(bid bigint, ouid integer, org text, depth integer, includes text[], slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, pref_lib integer) OWNER TO evergreen;

--
-- Name: memoize(text, bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.memoize(classname text, obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    key     TEXT;
    output  XML;
BEGIN
    key :=
        'id'        || COALESCE(obj_id::TEXT,'') ||
        'format'    || COALESCE(format::TEXT,'') ||
        'ename'     || COALESCE(ename::TEXT,'') ||
        'includes'  || COALESCE(includes::TEXT,'{}'::TEXT[]::TEXT) ||
        'org'       || COALESCE(org::TEXT,'') ||
        'depth'     || COALESCE(depth::TEXT,'') ||
        'slimit'    || COALESCE(slimit::TEXT,'') ||
        'soffset'   || COALESCE(soffset::TEXT,'') ||
        'include_xmlns'   || COALESCE(include_xmlns::TEXT,'');
    -- RAISE NOTICE 'memoize key: %', key;

    key := MD5(key);
    -- RAISE NOTICE 'memoize hash: %', key;

    -- XXX cache logic ... memcached? table?

    EXECUTE $$SELECT unapi.$$ || classname || $$( $1, $2, $3, $4, $5, $6, $7, $8, $9);$$ INTO output USING obj_id, format, ename, includes, org, depth, slimit, soffset, include_xmlns;
    RETURN output;
END;
$_$;


ALTER FUNCTION unapi.memoize(classname text, obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: metabib_virtual_record_feed(bigint[], text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean, text, text, text, text, text, xml, integer); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.metabib_virtual_record_feed(id_list bigint[], format text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, title text DEFAULT NULL::text, description text DEFAULT NULL::text, creator text DEFAULT NULL::text, update_ts text DEFAULT NULL::text, unapi_url text DEFAULT NULL::text, header_xml xml DEFAULT NULL::xml, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    layout          unapi.bre_output_layout%ROWTYPE;
    transform       config.xml_transform%ROWTYPE;
    item_format     TEXT;
    tmp_xml         TEXT;
    xmlns_uri       TEXT := 'http://open-ils.org/spec/feed-xml/v1';
    ouid            INT;
    element_list    TEXT[];
BEGIN

    IF org = '-' OR org IS NULL THEN
        SELECT shortname INTO org FROM evergreen.org_top();
    END IF;

    SELECT id INTO ouid FROM actor.org_unit WHERE shortname = org;
    SELECT * INTO layout FROM unapi.bre_output_layout WHERE name = format;

    IF layout.name IS NULL THEN
        RETURN NULL::XML;
    END IF;

    SELECT * INTO transform FROM config.xml_transform WHERE name = layout.transform;
    xmlns_uri := COALESCE(transform.namespace_uri,xmlns_uri);

    -- Gather the bib xml
    SELECT XMLAGG( unapi.mmr(i, format, '', includes, org, depth, slimit, soffset, include_xmlns, pref_lib)) INTO tmp_xml FROM UNNEST( id_list ) i;

    IF layout.title_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.title_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, title;
    END IF;

    IF layout.description_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.description_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, description;
    END IF;

    IF layout.creator_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.creator_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, creator;
    END IF;

    IF layout.update_ts_element IS NOT NULL THEN
        EXECUTE 'SELECT XMLCONCAT( XMLELEMENT( name '|| layout.update_ts_element ||', XMLATTRIBUTES( $1 AS xmlns), $3), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML, update_ts;
    END IF;

    IF unapi_url IS NOT NULL THEN
        EXECUTE $$SELECT XMLCONCAT( XMLELEMENT( name link, XMLATTRIBUTES( 'http://www.w3.org/1999/xhtml' AS xmlns, 'unapi-server' AS rel, $1 AS href, 'unapi' AS title)), $2)$$ INTO tmp_xml USING unapi_url, tmp_xml::XML;
    END IF;

    IF header_xml IS NOT NULL THEN tmp_xml := XMLCONCAT(header_xml,tmp_xml::XML); END IF;

    element_list := regexp_split_to_array(layout.feed_top,E'\\.');
    FOR i IN REVERSE ARRAY_UPPER(element_list, 1) .. 1 LOOP
        EXECUTE 'SELECT XMLELEMENT( name '|| quote_ident(element_list[i]) ||', XMLATTRIBUTES( $1 AS xmlns), $2)' INTO tmp_xml USING xmlns_uri, tmp_xml::XML;
    END LOOP;

    RETURN tmp_xml::XML;
END;
$_$;


ALTER FUNCTION unapi.metabib_virtual_record_feed(id_list bigint[], format text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, title text, description text, creator text, update_ts text, unapi_url text, header_xml xml, pref_lib integer) OWNER TO evergreen;

--
-- Name: mmr(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean, integer); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.mmr(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    mmrec   metabib.metarecord%ROWTYPE;
    leadrec biblio.record_entry%ROWTYPE;
    subrec biblio.record_entry%ROWTYPE;
    layout  unapi.bre_output_layout%ROWTYPE;
    xfrm    config.xml_transform%ROWTYPE;
    ouid    INT;
    xml_buf TEXT; -- growing XML document
    tmp_xml TEXT; -- single-use XML string
    xml_frag TEXT; -- single-use XML fragment
    top_el  TEXT;
    output  XML;
    hxml    XML;
    axml    XML;
    subxml  XML; -- subordinate records elements
    sub_xpath TEXT; 
    parts   TEXT[]; 
BEGIN

    -- xpath for extracting bre.marc values from subordinate records 
    -- so they may be appended to the MARC of the master record prior
    -- to XSLT processing.
    -- subjects, isbn, issn, upc -- anything else?
    sub_xpath := 
      '//*[starts-with(@tag, "6") or @tag="020" or @tag="022" or @tag="024"]';

    IF org = '-' OR org IS NULL THEN
        SELECT shortname INTO org FROM evergreen.org_top();
    END IF;

    SELECT id INTO ouid FROM actor.org_unit WHERE shortname = org;

    IF ouid IS NULL THEN
        RETURN NULL::XML;
    END IF;

    SELECT INTO mmrec * FROM metabib.metarecord WHERE id = obj_id;
    IF NOT FOUND THEN
        RETURN NULL::XML;
    END IF;

    -- TODO: aggregate holdings from constituent records
    IF format = 'holdings_xml' THEN -- the special case
        output := unapi.mmr_holdings_xml(
            obj_id, ouid, org, depth,
            array_remove(includes,'holdings_xml'),
            slimit, soffset, include_xmlns, pref_lib);
        RETURN output;
    END IF;

    SELECT * INTO layout FROM unapi.bre_output_layout WHERE name = format;

    IF layout.name IS NULL THEN
        RETURN NULL::XML;
    END IF;

    SELECT * INTO xfrm FROM config.xml_transform WHERE name = layout.transform;

    SELECT INTO leadrec * FROM biblio.record_entry WHERE id = mmrec.master_record;

    -- Grab distinct MVF for all records if requested
    IF ('mra' = ANY (includes)) THEN 
        axml := unapi.mmr_mra(obj_id,NULL,NULL,NULL,org,depth,NULL,NULL,TRUE,pref_lib);
    ELSE
        axml := NULL::XML;
    END IF;

    xml_buf = leadrec.marc;

    hxml := NULL::XML;
    IF ('holdings_xml' = ANY (includes)) THEN
        hxml := unapi.mmr_holdings_xml(
                    obj_id, ouid, org, depth,
                    array_remove(includes,'holdings_xml'),
                    slimit, soffset, include_xmlns, pref_lib);
    END IF;

    subxml := NULL::XML;
    parts := '{}'::TEXT[];
    FOR subrec IN SELECT bre.* FROM biblio.record_entry bre
         JOIN metabib.metarecord_source_map mmsm ON (mmsm.source = bre.id)
         JOIN metabib.metarecord mmr ON (mmr.id = mmsm.metarecord)
         WHERE mmr.id = obj_id AND NOT bre.deleted
         ORDER BY CASE WHEN bre.id = mmr.master_record THEN 0 ELSE bre.id END
         LIMIT COALESCE((slimit->'bre')::INT, 5) LOOP

        IF subrec.id = leadrec.id THEN CONTINUE; END IF;
        -- Append choice data from the the non-lead records to the 
        -- the lead record document

        parts := parts || xpath(sub_xpath, subrec.marc::XML)::TEXT[];
    END LOOP;

    SELECT ARRAY_TO_STRING( ARRAY_AGG( DISTINCT p ), '' )::XML INTO subxml FROM UNNEST(parts) p;

    -- append data from the subordinate records to the 
    -- main record document before applying the XSLT

    IF subxml IS NOT NULL THEN 
        xml_buf := REGEXP_REPLACE(xml_buf, 
            '</record>(.*?)$', subxml || '</record>' || E'\\1');
    END IF;

    IF format = 'marcxml' THEN
         -- If we're not using the prefixed namespace in 
         -- this record, then remove all declarations of it
        IF xml_buf !~ E'<marc:' THEN
           xml_buf := REGEXP_REPLACE(xml_buf, 
            ' xmlns:marc="http://www.loc.gov/MARC21/slim"', '', 'g');
        END IF; 
    ELSE
        xml_buf := oils_xslt_process(xml_buf, xfrm.xslt)::XML;
    END IF;

    -- update top_el to reflect the change in xml_buf, which may
    -- now be a different type of document (e.g. record -> mods)
    top_el := REGEXP_REPLACE(xml_buf, E'^.*?<((?:\\S+:)?' || 
        layout.holdings_element || ').*$', E'\\1');

    IF axml IS NOT NULL THEN 
        xml_buf := REGEXP_REPLACE(xml_buf, 
            '</' || top_el || '>(.*?)$', axml || '</' || top_el || E'>\\1');
    END IF;

    IF hxml IS NOT NULL THEN
        xml_buf := REGEXP_REPLACE(xml_buf, 
            '</' || top_el || '>(.*?)$', hxml || '</' || top_el || E'>\\1');
    END IF;

    IF ('mmr.unapi' = ANY (includes)) THEN 
        output := REGEXP_REPLACE(
            xml_buf,
            '</' || top_el || '>(.*?)',
            XMLELEMENT(
                name abbr,
                XMLATTRIBUTES(
                    'http://www.w3.org/1999/xhtml' AS xmlns,
                    'unapi-id' AS class,
                    'tag:open-ils.org:U2@mmr/' || obj_id || '/' || org AS title
                )
            )::TEXT || '</' || top_el || E'>\\1'
        );
    ELSE
        output := xml_buf;
    END IF;

    -- remove ignorable whitesace
    output := REGEXP_REPLACE(output::TEXT,E'>\\s+<','><','gs')::XML;
    RETURN output;
END;
$_$;


ALTER FUNCTION unapi.mmr(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, pref_lib integer) OWNER TO evergreen;

--
-- Name: mmr_holdings_xml(bigint, integer, text, integer, text[], evergreen.hstore, evergreen.hstore, boolean, integer); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.mmr_holdings_xml(mid bigint, ouid integer, org text, depth integer DEFAULT NULL::integer, includes text[] DEFAULT NULL::text[], slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
     SELECT  XMLELEMENT(
                 name holdings,
                 XMLATTRIBUTES(
                    CASE WHEN $8 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    CASE WHEN ('mmr' = ANY ($5)) THEN 'tag:open-ils.org:U2@mmr/' || $1 || '/' || $3 ELSE NULL END AS id,
                    (SELECT metarecord_has_holdable_copy FROM asset.metarecord_has_holdable_copy($1)) AS has_holdable
                 ),
                 XMLELEMENT(
                     name counts,
                     (SELECT  XMLAGG(XMLELEMENT::XML) FROM (
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('public' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.opac_ou_metarecord_copy_count($2,  $1)
                                     UNION
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('staff' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.staff_ou_metarecord_copy_count($2, $1)
                                     UNION
                         SELECT  XMLELEMENT(
                                     name count,
                                     XMLATTRIBUTES('pref_lib' as type, depth, org_unit, coalesce(transcendant,0) as transcendant, available, visible as count, unshadow)
                                 )::text
                           FROM  asset.opac_ou_metarecord_copy_count($9,  $1)
                                     ORDER BY 1
                     )x)
                 ),
                 -- XXX monograph_parts and foreign_copies are skipped in MRs ... put them back some day?
                 XMLELEMENT(
                     name volumes,
                     (SELECT XMLAGG(acn ORDER BY rank, name, label_sortkey) FROM (
                        -- Physical copies
                        SELECT  unapi.acn(y.id,'xml','volume',array_remove( array_remove($5,'holdings_xml'),'bre'), $3, $4, $6, $7, FALSE), y.rank, name, label_sortkey
                        FROM evergreen.ranked_volumes((SELECT ARRAY_AGG(source) FROM metabib.metarecord_source_map WHERE metarecord = $1), $2, $4, $6, $7, $9, $5) AS y
                        UNION ALL
                        -- Located URIs
                        SELECT unapi.acn(uris.id,'xml','volume',array_remove( array_remove($5,'holdings_xml'),'bre'), $3, $4, $6, $7, FALSE), uris.rank, name, label_sortkey
                        FROM evergreen.located_uris((SELECT ARRAY_AGG(source) FROM metabib.metarecord_source_map WHERE metarecord = $1), $2, $9) AS uris
                     )x)
                 ),
                 CASE WHEN ('ssub' = ANY ($5)) THEN
                     XMLELEMENT(
                         name subscriptions,
                         (SELECT XMLAGG(ssub) FROM (
                            SELECT  unapi.ssub(id,'xml','subscription','{}'::TEXT[], $3, $4, $6, $7, FALSE)
                              FROM  serial.subscription
                              WHERE record_entry IN (SELECT source FROM metabib.metarecord_source_map WHERE metarecord = $1)
                        )x)
                     )
                 ELSE NULL END
             );
$_$;


ALTER FUNCTION unapi.mmr_holdings_xml(mid bigint, ouid integer, org text, depth integer, includes text[], slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, pref_lib integer) OWNER TO evergreen;

--
-- Name: mmr_mra(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean, integer); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.mmr_mra(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true, pref_lib integer DEFAULT NULL::integer) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
        name attributes,
        XMLATTRIBUTES(
            CASE WHEN $9 THEN 'http://open-ils.org/spec/indexing/v1' ELSE NULL END AS xmlns,
            'tag:open-ils.org:U2@mmr/' || $1 AS metarecord
        ),
        (SELECT XMLAGG(foo.y)
          FROM (
            WITH sourcelist AS (
                WITH aou AS (SELECT COALESCE(id, (evergreen.org_top()).id) AS id FROM actor.org_unit WHERE shortname = $5 LIMIT 1),
                     basevm AS (SELECT c_attrs FROM  asset.patron_default_visibility_mask()),
                     circvm AS (SELECT search.calculate_visibility_attribute_test('circ_lib', ARRAY_AGG(aoud.id)) AS mask
                                  FROM aou, LATERAL actor.org_unit_descendants(aou.id, $6) aoud)
                SELECT  source
                  FROM  aou, circvm, basevm, metabib.metarecord_source_map mmsm
                  WHERE mmsm.metarecord = $1 AND (
                    EXISTS (
                        SELECT  1
                          FROM  circvm, basevm, asset.copy_vis_attr_cache acvac
                          WHERE acvac.vis_attr_vector @@ (basevm.c_attrs || '&' || circvm.mask)::query_int
                                AND acvac.record = mmsm.source
                    )
                    OR EXISTS (SELECT 1 FROM evergreen.located_uris(source, aou.id, $10) LIMIT 1)
                    OR EXISTS (SELECT 1 FROM biblio.record_entry b JOIN config.bib_source src ON (b.source = src.id) WHERE src.transcendant AND b.id = mmsm.source)
                )
            )
            SELECT  cmra.aid,
                    XMLELEMENT(
                        name field,
                        XMLATTRIBUTES(
                            cmra.attr AS name,
                            cmra.value AS "coded-value",
                            cmra.aid AS "cvmid",
                            rad.composite,
                            rad.multi,
                            rad.filter,
                            rad.sorter,
                            cmra.source_list
                        ),
                        cmra.value
                    )
              FROM  (
                SELECT DISTINCT aid, attr, value, STRING_AGG(x.id::TEXT, ',') AS source_list
                  FROM (
                    SELECT  v.source AS id,
                            c.id AS aid,
                            c.ctype AS attr,
                            c.code AS value
                      FROM  metabib.record_attr_vector_list v
                            JOIN config.coded_value_map c ON ( c.id = ANY( v.vlist ) )
                    ) AS x
                    JOIN sourcelist ON (x.id = sourcelist.source)
                    GROUP BY 1, 2, 3
                ) AS cmra
                JOIN config.record_attr_definition rad ON (cmra.attr = rad.name)
                UNION ALL
            SELECT  umra.aid,
                    XMLELEMENT(
                        name field,
                        XMLATTRIBUTES(
                            umra.attr AS name,
                            rad.composite,
                            rad.multi,
                            rad.filter,
                            rad.sorter
                        ),
                        umra.value
                    )
              FROM  (
                SELECT DISTINCT aid, attr, value
                  FROM (
                    SELECT  v.source AS id,
                            m.id AS aid,
                            m.attr AS attr,
                            m.value AS value
                      FROM  metabib.record_attr_vector_list v
                            JOIN metabib.uncontrolled_record_attr_value m ON ( m.id = ANY( v.vlist ) )
                    ) AS x
                    JOIN sourcelist ON (x.id = sourcelist.source)
                ) AS umra
                JOIN config.record_attr_definition rad ON (umra.attr = rad.name)
                ORDER BY 1

            )foo(id,y)
        )
    )
$_$;


ALTER FUNCTION unapi.mmr_mra(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean, pref_lib integer) OWNER TO evergreen;

--
-- Name: mra(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.mra(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
        name attributes,
        XMLATTRIBUTES(
            CASE WHEN $9 THEN 'http://open-ils.org/spec/indexing/v1' ELSE NULL END AS xmlns,
            'tag:open-ils.org:U2@mra/' || $1 AS id, 
            'tag:open-ils.org:U2@bre/' || $1 AS record 
        ),  
        (SELECT XMLAGG(foo.y)
          FROM (
            SELECT  XMLELEMENT(
                        name field,
                        XMLATTRIBUTES(
                            mra.attr AS name,
                            cvm.value AS "coded-value",
                            cvm.id AS "cvmid",
                            rad.composite,
                            rad.multi,
                            rad.filter,
                            rad.sorter
                        ),
                        mra.value
                    )
              FROM  metabib.record_attr_flat mra
                    JOIN config.record_attr_definition rad ON (mra.attr = rad.name)
                    LEFT JOIN config.coded_value_map cvm ON (cvm.ctype = mra.attr AND code = mra.value)
              WHERE mra.id = $1
            )foo(y)
        )   
    )   
$_$;


ALTER FUNCTION unapi.mra(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sbsum(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.sbsum(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name serial_summary,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sbsum/' || id AS id,
                    'sbsum' AS type, generated_coverage, textual_holdings, show_generated
                ),
                CASE WHEN ('sdist' = ANY ($4)) THEN unapi.sdist( distribution, 'xml', 'distribtion', array_remove($4,'ssum'), $5, $6, $7, $8, FALSE) ELSE NULL END
            )
      FROM  serial.basic_summary ssum
      WHERE id = $1
      GROUP BY id, generated_coverage, textual_holdings, distribution, show_generated;
$_$;


ALTER FUNCTION unapi.sbsum(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sdist(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.sdist(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name distribution,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@sdist/' || id AS id,
            			'tag:open-ils.org:U2@acn/' || receive_call_number AS receive_call_number,
			            'tag:open-ils.org:U2@acn/' || bind_call_number AS bind_call_number,
                        unit_label_prefix, label, unit_label_suffix, summary_method
                    ),
                    unapi.aou( holding_lib, $2, 'holding_lib', array_remove($4,'sdist'), $5, $6, $7, $8),
                    CASE WHEN subscription IS NOT NULL AND ('ssub' = ANY ($4)) THEN unapi.ssub( subscription, 'xml', 'subscription', array_remove($4,'sdist'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE 
                        WHEN ('sstr' = ANY ($4)) THEN
                            XMLELEMENT( name streams,
                                (SELECT XMLAGG(sstr) FROM (
                                    SELECT  unapi.sstr( id, 'xml', 'stream', array_remove($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.stream
                                      WHERE distribution = sdist.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    XMLELEMENT( name summaries,
                        CASE 
                            WHEN ('sbsum' = ANY ($4)) THEN
                                (SELECT XMLAGG(sbsum) FROM (
                                    SELECT  unapi.sbsum( id, 'xml', 'serial_summary', array_remove($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.basic_summary
                                      WHERE distribution = sdist.id
                                )x)
                            ELSE NULL
                        END,
                        CASE 
                            WHEN ('sisum' = ANY ($4)) THEN
                                (SELECT XMLAGG(sisum) FROM (
                                    SELECT  unapi.sisum( id, 'xml', 'serial_summary', array_remove($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.index_summary
                                      WHERE distribution = sdist.id
                                )x)
                            ELSE NULL
                        END,
                        CASE 
                            WHEN ('sssum' = ANY ($4)) THEN
                                (SELECT XMLAGG(sssum) FROM (
                                    SELECT  unapi.sssum( id, 'xml', 'serial_summary', array_remove($4,'sdist'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.supplement_summary
                                      WHERE distribution = sdist.id
                                )x)
                            ELSE NULL
                        END
                    )
                )
          FROM  serial.distribution sdist
          WHERE id = $1
          GROUP BY id, label, unit_label_prefix, unit_label_suffix, holding_lib, summary_method, subscription, receive_call_number, bind_call_number;
$_$;


ALTER FUNCTION unapi.sdist(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: siss(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.siss(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name issuance,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@siss/' || id AS id,
                    create_date, edit_date, label, date_published,
                    holding_code, holding_type, holding_link_id
                ),
                CASE WHEN subscription IS NOT NULL AND ('ssub' = ANY ($4)) THEN unapi.ssub( subscription, 'xml', 'subscription', array_remove($4,'siss'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                CASE 
                    WHEN ('sitem' = ANY ($4)) THEN
                        XMLELEMENT( name items,
                            (SELECT XMLAGG(sitem) FROM (
                                SELECT  unapi.sitem( id, 'xml', 'serial_item', array_remove($4,'siss'), $5, $6, $7, $8, FALSE)
                                  FROM  serial.item
                                  WHERE issuance = sstr.id
                            )x)
                        )
                    ELSE NULL
                END
            )
      FROM  serial.issuance sstr
      WHERE id = $1
      GROUP BY id, create_date, edit_date, label, date_published, holding_code, holding_type, holding_link_id, subscription;
$_$;


ALTER FUNCTION unapi.siss(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sisum(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.sisum(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name serial_summary,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sbsum/' || id AS id,
                    'sisum' AS type, generated_coverage, textual_holdings, show_generated
                ),
                CASE WHEN ('sdist' = ANY ($4)) THEN unapi.sdist( distribution, 'xml', 'distribtion', array_remove($4,'ssum'), $5, $6, $7, $8, FALSE) ELSE NULL END
            )
      FROM  serial.index_summary ssum
      WHERE id = $1
      GROUP BY id, generated_coverage, textual_holdings, distribution, show_generated;
$_$;


ALTER FUNCTION unapi.sisum(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sitem(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.sitem(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name serial_item,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@sitem/' || id AS id,
                        'tag:open-ils.org:U2@siss/' || issuance AS issuance,
                        date_expected, date_received
                    ),
                    CASE WHEN issuance IS NOT NULL AND ('siss' = ANY ($4)) THEN unapi.siss( issuance, $2, 'issuance', array_remove($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE WHEN stream IS NOT NULL AND ('sstr' = ANY ($4)) THEN unapi.sstr( stream, $2, 'stream', array_remove($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE WHEN unit IS NOT NULL AND ('sunit' = ANY ($4)) THEN unapi.sunit( unit, $2, 'serial_unit', array_remove($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    CASE WHEN uri IS NOT NULL AND ('auri' = ANY ($4)) THEN unapi.auri( uri, $2, 'uri', array_remove($4,'sitem'), $5, $6, $7, $8, FALSE) ELSE NULL END
--                    XMLELEMENT( name notes,
--                        CASE 
--                            WHEN ('acpn' = ANY ($4)) THEN
--                                (SELECT XMLAGG(acpn) FROM (
--                                    SELECT  unapi.acpn( id, 'xml', 'copy_note', array_remove($4,'acp'), $5, $6, $7, $8)
--                                      FROM  asset.copy_note
--                                      WHERE owning_copy = cp.id AND pub
--                                )x)
--                            ELSE NULL
--                        END
--                    )
                )
          FROM  serial.item sitem
          WHERE id = $1;
$_$;


ALTER FUNCTION unapi.sitem(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sssum(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.sssum(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name serial_summary,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sbsum/' || id AS id,
                    'sssum' AS type, generated_coverage, textual_holdings, show_generated
                ),
                CASE WHEN ('sdist' = ANY ($4)) THEN unapi.sdist( distribution, 'xml', 'distribtion', array_remove($4,'ssum'), $5, $6, $7, $8, FALSE) ELSE NULL END
            )
      FROM  serial.supplement_summary ssum
      WHERE id = $1
      GROUP BY id, generated_coverage, textual_holdings, distribution, show_generated;
$_$;


ALTER FUNCTION unapi.sssum(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sstr(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.sstr(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
    SELECT  XMLELEMENT(
                name stream,
                XMLATTRIBUTES(
                    CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                    'tag:open-ils.org:U2@sstr/' || id AS id,
                    routing_label
                ),
                CASE WHEN distribution IS NOT NULL AND ('sdist' = ANY ($4)) THEN unapi.sssum( distribution, 'xml', 'distribtion', array_remove($4,'sstr'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                CASE 
                    WHEN ('sitem' = ANY ($4)) THEN
                        XMLELEMENT( name items,
                            (SELECT XMLAGG(sitem) FROM (
                                SELECT  unapi.sitem( id, 'xml', 'serial_item', array_remove($4,'sstr'), $5, $6, $7, $8, FALSE)
                                  FROM  serial.item
                                  WHERE stream = sstr.id
                            )x)
                        )
                    ELSE NULL
                END
            )
      FROM  serial.stream sstr
      WHERE id = $1
      GROUP BY id, routing_label, distribution;
$_$;


ALTER FUNCTION unapi.sstr(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: ssub(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.ssub(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name subscription,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@ssub/' || id AS id,
                        'tag:open-ils.org:U2@aou/' || owning_lib AS owning_lib,
                        start_date AS start, end_date AS end, expected_date_offset
                    ),
                    CASE 
                        WHEN ('sdist' = ANY ($4)) THEN
                            XMLELEMENT( name distributions,
                                (SELECT XMLAGG(sdist) FROM (
                                    SELECT  unapi.sdist( id, 'xml', 'distribution', array_remove($4,'ssub'), $5, $6, $7, $8, FALSE)
                                      FROM  serial.distribution
                                      WHERE subscription = ssub.id
                                )x)
                            )
                        ELSE NULL
                    END
                )
          FROM  serial.subscription ssub
          WHERE id = $1
          GROUP BY id, start_date, end_date, expected_date_offset, owning_lib;
$_$;


ALTER FUNCTION unapi.ssub(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: sunit(bigint, text, text, text[], text, integer, evergreen.hstore, evergreen.hstore, boolean); Type: FUNCTION; Schema: unapi; Owner: evergreen
--

CREATE FUNCTION unapi.sunit(obj_id bigint, format text, ename text, includes text[], org text, depth integer DEFAULT NULL::integer, slimit evergreen.hstore DEFAULT NULL::evergreen.hstore, soffset evergreen.hstore DEFAULT NULL::evergreen.hstore, include_xmlns boolean DEFAULT true) RETURNS xml
    LANGUAGE sql STABLE
    AS $_$
        SELECT  XMLELEMENT(
                    name serial_unit,
                    XMLATTRIBUTES(
                        CASE WHEN $9 THEN 'http://open-ils.org/spec/holdings/v1' ELSE NULL END AS xmlns,
                        'tag:open-ils.org:U2@acp/' || id AS id, id AS copy_id,
                        create_date, edit_date, copy_number, circulate, deposit,
                        ref, holdable, deleted, deposit_amount, price, barcode,
                        circ_modifier, circ_as_type, opac_visible, age_protect,
                        status_changed_time, floating, mint_condition,
                        detailed_contents, sort_key, summary_contents, cost 
                    ),
                    unapi.ccs( status, $2, 'status', array_remove( array_remove($4,'acp'),'sunit'), $5, $6, $7, $8, FALSE),
                    unapi.acl( location, $2, 'location', array_remove( array_remove($4,'acp'),'sunit'), $5, $6, $7, $8, FALSE),
                    unapi.aou( circ_lib, $2, 'circ_lib', array_remove( array_remove($4,'acp'),'sunit'), $5, $6, $7, $8),
                    unapi.aou( circ_lib, $2, 'circlib', array_remove( array_remove($4,'acp'),'sunit'), $5, $6, $7, $8),
                    CASE WHEN ('acn' = ANY ($4)) THEN unapi.acn( call_number, $2, 'call_number', array_remove($4,'acp'), $5, $6, $7, $8, FALSE) ELSE NULL END,
                    XMLELEMENT( name copy_notes,
                        CASE 
                            WHEN ('acpn' = ANY ($4)) THEN
                                (SELECT XMLAGG(acpn) FROM (
                                    SELECT  unapi.acpn( id, 'xml', 'copy_note', array_remove( array_remove($4,'acp'),'sunit'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_note
                                      WHERE owning_copy = cp.id AND pub
                                )x)
                            ELSE NULL
                        END
                    ),
                    XMLELEMENT( name statcats,
                        CASE 
                            WHEN ('ascecm' = ANY ($4)) THEN
                                (SELECT XMLAGG(ascecm) FROM (
                                    SELECT  unapi.ascecm( stat_cat_entry, 'xml', 'statcat', array_remove($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.stat_cat_entry_copy_map
                                      WHERE owning_copy = cp.id
                                )x)
                            ELSE NULL
                        END
                    ),
                    XMLELEMENT( name foreign_records,
                        CASE
                            WHEN ('bre' = ANY ($4)) THEN
                                (SELECT XMLAGG(bre) FROM (
                                    SELECT  unapi.bre(peer_record,'marcxml','record','{}'::TEXT[], $5, $6, $7, $8, FALSE)
                                      FROM  biblio.peer_bib_copy_map
                                      WHERE target_copy = cp.id
                                )x)
                            ELSE NULL
                        END
                    ),
                    CASE 
                        WHEN ('bmp' = ANY ($4)) THEN
                            XMLELEMENT( name monograph_parts,
                                (SELECT XMLAGG(bmp) FROM (
                                    SELECT  unapi.bmp( part, 'xml', 'monograph_part', array_remove($4,'acp'), $5, $6, $7, $8, FALSE)
                                      FROM  asset.copy_part_map
                                      WHERE target_copy = cp.id
                                )x)
                            )
                        ELSE NULL
                    END,
                    CASE 
                        WHEN ('circ' = ANY ($4)) THEN
                            XMLELEMENT( name current_circulation,
                                (SELECT XMLAGG(circ) FROM (
                                    SELECT  unapi.circ( id, 'xml', 'circ', array_remove($4,'circ'), $5, $6, $7, $8, FALSE)
                                      FROM  action.circulation
                                      WHERE target_copy = cp.id
                                            AND checkin_time IS NULL
                                )x)
                            )
                        ELSE NULL
                    END
                )
          FROM  serial.unit cp
          WHERE id = $1
              AND cp.deleted IS FALSE
          GROUP BY id, status, location, circ_lib, call_number, create_date,
              edit_date, copy_number, circulate, floating, mint_condition,
              deposit, ref, holdable, deleted, deposit_amount, price,
              barcode, circ_modifier, circ_as_type, opac_visible,
              status_changed_time, detailed_contents, sort_key,
              summary_contents, cost, age_protect;
$_$;


ALTER FUNCTION unapi.sunit(obj_id bigint, format text, ename text, includes text[], org text, depth integer, slimit evergreen.hstore, soffset evergreen.hstore, include_xmlns boolean) OWNER TO evergreen;

--
-- Name: extract_urls(integer, integer); Type: FUNCTION; Schema: url_verify; Owner: evergreen
--

CREATE FUNCTION url_verify.extract_urls(session_id integer, item_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    last_seen_tag TEXT;
    current_tag TEXT;
    current_sf TEXT;
    current_url TEXT;
    current_ord INT;
    current_url_pos INT;
    current_selector url_verify.url_selector%ROWTYPE;
BEGIN
    current_ord := 1;

    FOR current_selector IN SELECT * FROM url_verify.url_selector s WHERE s.session = session_id LOOP
        current_url_pos := 1;
        LOOP
            SELECT  (oils_xpath(current_selector.xpath || '/text()', b.marc))[current_url_pos] INTO current_url
              FROM  biblio.record_entry b
                    JOIN container.biblio_record_entry_bucket_item c ON (c.target_biblio_record_entry = b.id)
              WHERE c.id = item_id;

            EXIT WHEN current_url IS NULL;

            SELECT  (oils_xpath(current_selector.xpath || '/../@tag', b.marc))[current_url_pos] INTO current_tag
              FROM  biblio.record_entry b
                    JOIN container.biblio_record_entry_bucket_item c ON (c.target_biblio_record_entry = b.id)
              WHERE c.id = item_id;

            IF current_tag IS NULL THEN
                current_tag := last_seen_tag;
            ELSE
                last_seen_tag := current_tag;
            END IF;

            SELECT  (oils_xpath(current_selector.xpath || '/@code', b.marc))[current_url_pos] INTO current_sf
              FROM  biblio.record_entry b
                    JOIN container.biblio_record_entry_bucket_item c ON (c.target_biblio_record_entry = b.id)
              WHERE c.id = item_id;

            INSERT INTO url_verify.url (session, item, url_selector, tag, subfield, ord, full_url)
              VALUES ( session_id, item_id, current_selector.id, current_tag, current_sf, current_ord, current_url);

            current_url_pos := current_url_pos + 1;
            current_ord := current_ord + 1;
        END LOOP;
    END LOOP;

    RETURN current_ord - 1;
END;
$$;


ALTER FUNCTION url_verify.extract_urls(session_id integer, item_id integer) OWNER TO evergreen;

--
-- Name: ingest_url(); Type: FUNCTION; Schema: url_verify; Owner: evergreen
--

CREATE FUNCTION url_verify.ingest_url() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    tmp_row url_verify.url%ROWTYPE;
BEGIN
    SELECT * INTO tmp_row FROM url_verify.parse_url(NEW.full_url);

    NEW.scheme          := tmp_row.scheme;
    NEW.username        := tmp_row.username;
    NEW.password        := tmp_row.password;
    NEW.host            := tmp_row.host;
    NEW.domain          := tmp_row.domain;
    NEW.tld             := tmp_row.tld;
    NEW.port            := tmp_row.port;
    NEW.path            := tmp_row.path;
    NEW.page            := tmp_row.page;
    NEW.query           := tmp_row.query;
    NEW.fragment        := tmp_row.fragment;

    RETURN NEW;
END;
$$;


ALTER FUNCTION url_verify.ingest_url() OWNER TO evergreen;

--
-- Name: url; Type: TABLE; Schema: url_verify; Owner: evergreen
--

CREATE TABLE url_verify.url (
    id integer NOT NULL,
    redirect_from integer,
    item integer,
    url_selector integer,
    session integer,
    tag text,
    subfield text,
    ord integer,
    full_url text NOT NULL,
    scheme text,
    username text,
    password text,
    host text,
    domain text,
    tld text,
    port text,
    path text,
    page text,
    query text,
    fragment text,
    CONSTRAINT redirect_or_from_item CHECK (((redirect_from IS NOT NULL) OR ((item IS NOT NULL) AND (url_selector IS NOT NULL) AND (tag IS NOT NULL) AND (subfield IS NOT NULL) AND (ord IS NOT NULL))))
);


ALTER TABLE url_verify.url OWNER TO evergreen;

--
-- Name: parse_url(text); Type: FUNCTION; Schema: url_verify; Owner: evergreen
--

CREATE FUNCTION url_verify.parse_url(url_in text) RETURNS url_verify.url
    LANGUAGE plperlu
    AS $_X$

use Rose::URI;

my $url_in = shift;
my $url = Rose::URI->new($url_in);

my %parts = map { $_ => $url->$_ } qw/scheme username password host port path query fragment/;

$parts{full_url} = $url_in;
($parts{domain} = $parts{host}) =~ s/^[^.]+\.//;
($parts{tld} = $parts{domain}) =~ s/(?:[^.]+\.)+//;
($parts{page} = $parts{path}) =~ s#(?:[^/]*/)+##;

return \%parts;

$_X$;


ALTER FUNCTION url_verify.parse_url(url_in text) OWNER TO evergreen;

--
-- Name: match_set_point; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.match_set_point (
    id integer NOT NULL,
    match_set integer,
    parent integer,
    bool_op text,
    svf text,
    tag text,
    subfield text,
    negate boolean DEFAULT false,
    quality integer DEFAULT 1 NOT NULL,
    heading boolean DEFAULT false NOT NULL,
    CONSTRAINT match_set_point_bool_op_check CHECK (((bool_op IS NULL) OR (bool_op = ANY (ARRAY['AND'::text, 'OR'::text, 'NOT'::text])))),
    CONSTRAINT vmsp_need_a_subfield_with_a_tag CHECK ((((tag IS NOT NULL) AND (subfield IS NOT NULL)) OR (tag IS NULL))),
    CONSTRAINT vmsp_need_a_tag_or_a_ff_or_a_heading_or_a_bo CHECK ((((tag IS NOT NULL) AND (svf IS NULL) AND (heading IS FALSE) AND (bool_op IS NULL)) OR ((tag IS NULL) AND (svf IS NOT NULL) AND (heading IS FALSE) AND (bool_op IS NULL)) OR ((tag IS NULL) AND (svf IS NULL) AND (heading IS TRUE) AND (bool_op IS NULL)) OR ((tag IS NULL) AND (svf IS NULL) AND (heading IS FALSE) AND (bool_op IS NOT NULL))))
);


ALTER TABLE vandelay.match_set_point OWNER TO evergreen;

--
-- Name: _get_expr_push_jrow(vandelay.match_set_point, evergreen.hstore, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay._get_expr_push_jrow(node vandelay.match_set_point, tags_rstore evergreen.hstore, auth_heading text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    jrow        TEXT;
    my_alias    TEXT;
    op          TEXT;
    tagkey      TEXT;
    caseless    BOOL;
    jrow_count  INT;
    my_using    TEXT;
    my_join     TEXT;
    rec_table   TEXT;
BEGIN
    -- remember $1 is tags_rstore, and $2 is svf_rstore
    -- a non-NULL auth_heading means we're matching authority records

    IF auth_heading IS NOT NULL THEN
        rec_table := 'authority.full_rec';
    ELSE
        rec_table := 'metabib.full_rec';
    END IF;

    caseless := FALSE;
    SELECT COUNT(*) INTO jrow_count FROM _vandelay_tmp_jrows;
    IF jrow_count > 0 THEN
        my_using := ' USING (record)';
        my_join := 'FULL OUTER JOIN';
    ELSE
        my_using := '';
        my_join := 'FROM';
    END IF;

    IF node.tag IS NOT NULL THEN
        caseless := (node.tag IN ('020', '022', '024'));
        tagkey := node.tag;
        IF node.subfield IS NOT NULL THEN
            tagkey := tagkey || node.subfield;
        END IF;
    END IF;

    IF node.negate THEN
        IF caseless THEN
            op := 'NOT LIKE';
        ELSE
            op := '<>';
        END IF;
    ELSE
        IF caseless THEN
            op := 'LIKE';
        ELSE
            op := '=';
        END IF;
    END IF;

    my_alias := 'n' || node.id::TEXT;

    jrow := my_join || ' (SELECT *, ';
    IF node.tag IS NOT NULL THEN
        jrow := jrow  || node.quality ||
            ' AS quality FROM ' || rec_table || ' mfr WHERE mfr.tag = ''' ||
            node.tag || '''';
        IF node.subfield IS NOT NULL THEN
            jrow := jrow || ' AND mfr.subfield = ''' ||
                node.subfield || '''';
        END IF;
        jrow := jrow || ' AND (';
        jrow := jrow || vandelay._node_tag_comparisons(caseless, op, tags_rstore, tagkey);
        jrow := jrow || ')) ' || my_alias || my_using || E'\n';
    ELSE    -- svf
        IF auth_heading IS NOT NULL THEN -- authority record
            IF node.heading AND auth_heading <> '' THEN
                jrow := jrow || 'id AS record, ' || node.quality ||
                ' AS quality FROM authority.record_entry are ' ||
                ' WHERE are.heading = ''' || auth_heading || '''';
                jrow := jrow || ') ' || my_alias || my_using || E'\n';
            END IF;
        ELSE -- bib record
            jrow := jrow || 'id AS record, ' || node.quality ||
                ' AS quality FROM metabib.record_attr_flat mraf WHERE mraf.attr = ''' ||
                node.svf || ''' AND mraf.value ' || op || ' $2->''' || node.svf || ''') ' ||
                my_alias || my_using || E'\n';
        END IF;
    END IF;
    INSERT INTO _vandelay_tmp_jrows (j) VALUES (jrow);
END;
$_$;


ALTER FUNCTION vandelay._get_expr_push_jrow(node vandelay.match_set_point, tags_rstore evergreen.hstore, auth_heading text) OWNER TO evergreen;

--
-- Name: _get_expr_push_jrow_auth(vandelay.match_set_point, evergreen.hstore); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay._get_expr_push_jrow_auth(node vandelay.match_set_point, tags_rstore evergreen.hstore) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    jrow        TEXT;
    my_alias    TEXT;
    op          TEXT;
    tagkey      TEXT;
    caseless    BOOL;
    jrow_count  INT;
    my_using    TEXT;
    my_join     TEXT;
BEGIN
    --ver1.0
    -- remember $1 is tags_rstore, and $2 is svf_rstore

    caseless := FALSE;
    SELECT COUNT(*) INTO jrow_count FROM _vandelay_tmp_jrows_auth;
    IF jrow_count > 0 THEN
        my_using := ' USING (record)';
        my_join := 'FULL OUTER JOIN';
    ELSE
        my_using := '';
        my_join := 'FROM';
    END IF;

    IF node.tag IS NOT NULL THEN
        caseless := (node.tag IN ('020', '022', '024'));
        tagkey := node.tag;
        IF node.subfield IS NOT NULL THEN
            tagkey := tagkey || node.subfield;
        END IF;
    END IF;

    IF node.negate THEN
        IF caseless THEN
            op := 'NOT LIKE';
        ELSE
            op := '<>';
        END IF;
    ELSE
        IF caseless THEN
            op := 'LIKE';
        ELSE
            op := '=';
        END IF;
    END IF;

    my_alias := 'n' || node.id::TEXT;

    jrow := my_join || ' (SELECT *, ';
    IF node.tag IS NOT NULL THEN
        jrow := jrow  || node.quality ||
            ' AS quality FROM authority.full_rec mfr WHERE mfr.tag = ''' ||
            node.tag || '''';
        IF node.subfield IS NOT NULL THEN
            jrow := jrow || ' AND mfr.subfield = ''' ||
                node.subfield || '''';
        END IF;
        jrow := jrow || ' AND (';
        jrow := jrow || vandelay._node_tag_comparisons(caseless, op, tags_rstore, tagkey);
        jrow := jrow || ')) ' || my_alias || my_using || E'\n';
    ELSE    -- svf
        jrow := jrow || 'id AS record, ' || node.quality ||
            ' AS quality FROM metabib.record_attr mra WHERE mra.attrs->''' ||
            node.svf || ''' ' || op || ' $2->''' || node.svf || ''') ' ||
            my_alias || my_using || E'\n';
    END IF;
    INSERT INTO _vandelay_tmp_jrows_auth (j) VALUES (jrow);
END;
$_$;


ALTER FUNCTION vandelay._get_expr_push_jrow_auth(node vandelay.match_set_point, tags_rstore evergreen.hstore) OWNER TO evergreen;

--
-- Name: _get_expr_push_qrow(vandelay.match_set_point); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay._get_expr_push_qrow(node vandelay.match_set_point) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    INSERT INTO _vandelay_tmp_qrows (q) VALUES (node.id);
END;
$$;


ALTER FUNCTION vandelay._get_expr_push_qrow(node vandelay.match_set_point) OWNER TO evergreen;

--
-- Name: _get_expr_push_qrow_auth(vandelay.match_set_point); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay._get_expr_push_qrow_auth(node vandelay.match_set_point) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    --ver1.0
    INSERT INTO _vandelay_tmp_qrows_auth (q) VALUES (node.id);
END;
$$;


ALTER FUNCTION vandelay._get_expr_push_qrow_auth(node vandelay.match_set_point) OWNER TO evergreen;

--
-- Name: _get_expr_render_one(vandelay.match_set_point); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay._get_expr_render_one(node vandelay.match_set_point) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    s           TEXT;
BEGIN
    IF node.bool_op IS NOT NULL THEN
        RETURN node.bool_op;
    ELSE
        RETURN '(n' || node.id::TEXT || '.id IS NOT NULL)';
    END IF;
END;
$$;


ALTER FUNCTION vandelay._get_expr_render_one(node vandelay.match_set_point) OWNER TO evergreen;

--
-- Name: _node_tag_comparisons(boolean, text, evergreen.hstore, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay._node_tag_comparisons(caseless boolean, op text, tags_rstore evergreen.hstore, tagkey text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    result  TEXT;
    i       INT;
    vals    TEXT[];
BEGIN
    i := 1;
    vals := tags_rstore->tagkey;
    result := '';

    WHILE TRUE LOOP
        IF i > 1 THEN
            IF vals[i] IS NULL THEN
                EXIT;
            ELSE
                result := result || ' OR ';
            END IF;
        END IF;

        IF caseless THEN
            result := result || 'LOWER(mfr.value) ' || op;
        ELSE
            result := result || 'mfr.value ' || op;
        END IF;

        result := result || ' ' || COALESCE('''' || vals[i] || '''', 'NULL');

        IF vals[i] IS NULL THEN
            EXIT;
        END IF;
        i := i + 1;
    END LOOP;

    RETURN result;

END;
$$;


ALTER FUNCTION vandelay._node_tag_comparisons(caseless boolean, op text, tags_rstore evergreen.hstore, tagkey text) OWNER TO evergreen;

--
-- Name: add_field(text, text, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.add_field(target_xml text, source_xml text, field text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT vandelay.add_field( $1, $2, $3, 0 );
$_$;


ALTER FUNCTION vandelay.add_field(target_xml text, source_xml text, field text) OWNER TO evergreen;

--
-- Name: add_field(text, text, text, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.add_field(target_xml text, source_xml text, field text, force_add integer) RETURNS text
    LANGUAGE plperlu
    AS $_X$

    use MARC::Record;
    use MARC::File::XML (BinaryEncoding => 'UTF-8');
    use MARC::Charset;
    use strict;

    MARC::Charset->assume_unicode(1);

    my $target_xml = shift;
    my $source_xml = shift;
    my $field_spec = shift;
    my $force_add = shift || 0;

    my $target_r = MARC::Record->new_from_xml( $target_xml );
    my $source_r = MARC::Record->new_from_xml( $source_xml );

    return $target_xml unless ($target_r && $source_r);

    my @field_list = split(',', $field_spec);

    my %fields;
    for my $f (@field_list) {
        $f =~ s/^\s*//; $f =~ s/\s*$//;
        if ($f =~ /^(.{3})(\w*)(?:\[([^]]*)\])?$/) {
            my $field = $1;
            $field =~ s/\s+//;
            my $sf = $2;
            $sf =~ s/\s+//;
            my $match = $3;
            $match =~ s/^\s*//; $match =~ s/\s*$//;
            $fields{$field} = { sf => [ split('', $sf) ] };
            if ($match) {
                my ($msf,$mre) = split('~', $match);
                if (length($msf) > 0 and length($mre) > 0) {
                    $msf =~ s/^\s*//; $msf =~ s/\s*$//;
                    $mre =~ s/^\s*//; $mre =~ s/\s*$//;
                    $fields{$field}{match} = { sf => $msf, re => qr/$mre/ };
                }
            }
        }
    }

    for my $f ( keys %fields) {
        if ( @{$fields{$f}{sf}} ) {
            for my $from_field ($source_r->field( $f )) {
                my @tos = $target_r->field( $f );
                if (!@tos) {
                    next if (exists($fields{$f}{match}) and !$force_add);
                    my @new_fields = map { $_->clone } $source_r->field( $f );
                    $target_r->insert_fields_ordered( @new_fields );
                } else {
                    for my $to_field (@tos) {
                        if (exists($fields{$f}{match})) {
                            next unless (grep { $_ =~ $fields{$f}{match}{re} } $to_field->subfield($fields{$f}{match}{sf}));
                        }
                        for my $old_sf ($from_field->subfields) {
                            $to_field->add_subfields( @$old_sf ) if grep(/$$old_sf[0]/,@{$fields{$f}{sf}});
                        }
                    }
                }
            }
        } else {
            my @new_fields = map { $_->clone } $source_r->field( $f );
            $target_r->insert_fields_ordered( @new_fields );
        }
    }

    $target_xml = $target_r->as_xml_record;
    $target_xml =~ s/^<\?.+?\?>$//mo;
    $target_xml =~ s/\n//sgo;
    $target_xml =~ s/>\s+</></sgo;

    return $target_xml;

$_X$;


ALTER FUNCTION vandelay.add_field(target_xml text, source_xml text, field text, force_add integer) OWNER TO evergreen;

--
-- Name: auto_overlay_authority_queue(bigint); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.auto_overlay_authority_queue(queue_id bigint) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.auto_overlay_authority_queue( $1, NULL );
$_$;


ALTER FUNCTION vandelay.auto_overlay_authority_queue(queue_id bigint) OWNER TO evergreen;

--
-- Name: auto_overlay_authority_queue(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.auto_overlay_authority_queue(queue_id bigint, merge_profile_id integer) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    queued_record   vandelay.queued_authority_record%ROWTYPE;
BEGIN

    FOR queued_record IN SELECT * FROM vandelay.queued_authority_record WHERE queue = queue_id AND import_time IS NULL LOOP

        IF vandelay.auto_overlay_authority_record( queued_record.id, merge_profile_id ) THEN
            RETURN NEXT queued_record.id;
        END IF;

    END LOOP;

    RETURN;

END;
$$;


ALTER FUNCTION vandelay.auto_overlay_authority_queue(queue_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: auto_overlay_authority_record(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.auto_overlay_authority_record(import_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    match_count     INT;
BEGIN
    SELECT COUNT(*) INTO match_count FROM vandelay.authority_match WHERE queued_record = import_id;

    IF match_count <> 1 THEN
        -- RAISE NOTICE 'not an exact match';
        RETURN FALSE;
    END IF;

    SELECT  m.eg_record INTO eg_id
      FROM  vandelay.authority_match m
      WHERE m.queued_record = import_id
      LIMIT 1;

    IF eg_id IS NULL THEN
        RETURN FALSE;
    END IF;

    RETURN vandelay.overlay_authority_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_authority_record(import_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: auto_overlay_authority_record_with_best(bigint, integer, numeric); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.auto_overlay_authority_record_with_best(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    lwm_ratio_value NUMERIC;
BEGIN

    lwm_ratio_value := COALESCE(lwm_ratio_value_p, 0.0);

    PERFORM * FROM vandelay.queued_authority_record WHERE import_time IS NOT NULL AND id = import_id;

    IF FOUND THEN
        -- RAISE NOTICE 'already imported, cannot auto-overlay'
        RETURN FALSE;
    END IF;

    SELECT  m.eg_record INTO eg_id
      FROM  vandelay.authority_match m
            JOIN vandelay.queued_authority_record qr ON (m.queued_record = qr.id)
            JOIN vandelay.authority_queue q ON (qr.queue = q.id)
            JOIN authority.record_entry r ON (r.id = m.eg_record)
      WHERE m.queued_record = import_id
            AND qr.quality::NUMERIC / COALESCE(NULLIF(m.quality,0),1)::NUMERIC >= lwm_ratio_value
      ORDER BY  m.match_score DESC, -- required match score
                qr.quality::NUMERIC / COALESCE(NULLIF(m.quality,0),1)::NUMERIC DESC, -- quality tie breaker
                m.id -- when in doubt, use the first match
      LIMIT 1;

    IF eg_id IS NULL THEN
        -- RAISE NOTICE 'incoming record is not of high enough quality';
        RETURN FALSE;
    END IF;

    RETURN vandelay.overlay_authority_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_authority_record_with_best(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_queue(bigint); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.auto_overlay_bib_queue(queue_id bigint) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT * FROM vandelay.auto_overlay_bib_queue( $1, NULL );
$_$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue(queue_id bigint) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_queue(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.auto_overlay_bib_queue(queue_id bigint, merge_profile_id integer) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    queued_record   vandelay.queued_bib_record%ROWTYPE;
BEGIN

    FOR queued_record IN SELECT * FROM vandelay.queued_bib_record WHERE queue = queue_id AND import_time IS NULL LOOP

        IF vandelay.auto_overlay_bib_record( queued_record.id, merge_profile_id ) THEN
            RETURN NEXT queued_record.id;
        END IF;

    END LOOP;

    RETURN;

END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue(queue_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_queue_with_best(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.auto_overlay_bib_queue_with_best(import_id bigint, merge_profile_id integer) RETURNS SETOF bigint
    LANGUAGE sql
    AS $_$
    SELECT vandelay.auto_overlay_bib_queue_with_best( $1, $2, p.lwm_ratio ) FROM vandelay.merge_profile p WHERE id = $2;
$_$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue_with_best(import_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_queue_with_best(bigint, integer, numeric); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.auto_overlay_bib_queue_with_best(queue_id bigint, merge_profile_id integer, lwm_ratio_value numeric) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
    queued_record   vandelay.queued_bib_record%ROWTYPE;
BEGIN

    FOR queued_record IN SELECT * FROM vandelay.queued_bib_record WHERE queue = queue_id AND import_time IS NULL LOOP

        IF vandelay.auto_overlay_bib_record_with_best( queued_record.id, merge_profile_id, lwm_ratio_value ) THEN
            RETURN NEXT queued_record.id;
        END IF;

    END LOOP;

    RETURN;
    
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_queue_with_best(queue_id bigint, merge_profile_id integer, lwm_ratio_value numeric) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_record(bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.auto_overlay_bib_record(import_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    match_count     INT;
BEGIN

    PERFORM * FROM vandelay.queued_bib_record WHERE import_time IS NOT NULL AND id = import_id;

    IF FOUND THEN
        -- RAISE NOTICE 'already imported, cannot auto-overlay'
        RETURN FALSE;
    END IF;

    SELECT COUNT(*) INTO match_count FROM vandelay.bib_match WHERE queued_record = import_id;

    IF match_count <> 1 THEN
        -- RAISE NOTICE 'not an exact match';
        RETURN FALSE;
    END IF;

    -- Check that the one match is on the first 901c
    SELECT  m.eg_record INTO eg_id
      FROM  vandelay.queued_bib_record q
            JOIN vandelay.bib_match m ON (m.queued_record = q.id)
      WHERE q.id = import_id
            AND m.eg_record = oils_xpath_string('//*[@tag="901"]/*[@code="c"][1]',marc)::BIGINT;

    IF NOT FOUND THEN
        -- RAISE NOTICE 'not a 901c match';
        RETURN FALSE;
    END IF;

    RETURN vandelay.overlay_bib_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_record(import_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: auto_overlay_bib_record_with_best(bigint, integer, numeric); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.auto_overlay_bib_record_with_best(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    lwm_ratio_value NUMERIC;
BEGIN

    lwm_ratio_value := COALESCE(lwm_ratio_value_p, 0.0);

    PERFORM * FROM vandelay.queued_bib_record WHERE import_time IS NOT NULL AND id = import_id;

    IF FOUND THEN
        -- RAISE NOTICE 'already imported, cannot auto-overlay'
        RETURN FALSE;
    END IF;

    SELECT  m.eg_record INTO eg_id
      FROM  vandelay.bib_match m
            JOIN vandelay.queued_bib_record qr ON (m.queued_record = qr.id)
            JOIN vandelay.bib_queue q ON (qr.queue = q.id)
            JOIN biblio.record_entry r ON (r.id = m.eg_record)
      WHERE m.queued_record = import_id
            AND qr.quality::NUMERIC / COALESCE(NULLIF(m.quality,0),1)::NUMERIC >= lwm_ratio_value
      ORDER BY  m.match_score DESC, -- required match score
                qr.quality::NUMERIC / COALESCE(NULLIF(m.quality,0),1)::NUMERIC DESC, -- quality tie breaker
                m.id -- when in doubt, use the first match
      LIMIT 1;

    IF eg_id IS NULL THEN
        -- RAISE NOTICE 'incoming record is not of high enough quality';
        RETURN FALSE;
    END IF;

    RETURN vandelay.overlay_bib_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_bib_record_with_best(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) OWNER TO evergreen;

--
-- Name: auto_overlay_org_unit_copies(bigint, integer, numeric); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.auto_overlay_org_unit_copies(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    eg_id           BIGINT;
    match_count     INT;
    rec             vandelay.bib_match%ROWTYPE;
    v_owning_lib    INT;
    scope_org       INT;
    scope_orgs      INT[];
    copy_count      INT := 0;
    max_copy_count  INT := 0;
BEGIN

    PERFORM * FROM vandelay.queued_bib_record WHERE import_time IS NOT NULL AND id = import_id;

    IF FOUND THEN
        -- RAISE NOTICE 'already imported, cannot auto-overlay'
        RETURN FALSE;
    END IF;

    -- Gather all the owning libs for our import items.
    -- These are our initial scope_orgs.
    SELECT ARRAY_AGG(DISTINCT owning_lib) INTO scope_orgs
        FROM vandelay.import_item
        WHERE record = import_id;

    WHILE CARDINALITY(scope_orgs) > 0 LOOP
        FOR scope_org IN SELECT * FROM UNNEST(scope_orgs) LOOP
            -- For each match, get a count of all copies at descendants of our scope org.
            FOR rec IN SELECT * FROM vandelay.bib_match AS vbm
                WHERE queued_record = import_id
                ORDER BY vbm.eg_record DESC
            LOOP
                SELECT COUNT(acp.id) INTO copy_count
                    FROM asset.copy AS acp
                    INNER JOIN asset.call_number AS acn
                        ON acp.call_number = acn.id
                    WHERE acn.owning_lib IN (SELECT id FROM
                        actor.org_unit_descendants(scope_org))
                    AND acn.record = rec.eg_record
                    AND acp.deleted = FALSE;
                IF copy_count > max_copy_count THEN
                    max_copy_count := copy_count;
                    eg_id := rec.eg_record;
                END IF;
            END LOOP;
        END LOOP;

        -- If no matching bibs had holdings, gather our next set of orgs to check, and iterate.
        IF max_copy_count = 0 THEN 
            SELECT ARRAY_AGG(DISTINCT parent_ou) INTO scope_orgs
                FROM actor.org_unit
                WHERE id IN (SELECT * FROM UNNEST(scope_orgs))
                AND parent_ou IS NOT NULL;
        END IF;
    END LOOP;

    IF eg_id IS NULL THEN
        -- Could not determine best match via copy count
        -- fall back to default best match
        IF (SELECT * FROM vandelay.auto_overlay_bib_record_with_best( import_id, merge_profile_id, lwm_ratio_value_p )) THEN
            RETURN TRUE;
        ELSE
            RETURN FALSE;
        END IF;
    END IF;

    RETURN vandelay.overlay_bib_record( import_id, eg_id, merge_profile_id );
END;
$$;


ALTER FUNCTION vandelay.auto_overlay_org_unit_copies(import_id bigint, merge_profile_id integer, lwm_ratio_value_p numeric) OWNER TO evergreen;

--
-- Name: cleanup_authority_marc(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.cleanup_authority_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.queued_authority_record_attr WHERE record = OLD.id;
    IF TG_OP = 'UPDATE' THEN
        RETURN NEW;
    END IF;
    RETURN OLD;
END;
$$;


ALTER FUNCTION vandelay.cleanup_authority_marc() OWNER TO evergreen;

--
-- Name: cleanup_bib_marc(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.cleanup_bib_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.queued_bib_record_attr WHERE record = OLD.id;
    DELETE FROM vandelay.import_item WHERE record = OLD.id;

    IF TG_OP = 'UPDATE' THEN
        RETURN NEW;
    END IF;
    RETURN OLD;
END;
$$;


ALTER FUNCTION vandelay.cleanup_bib_marc() OWNER TO evergreen;

--
-- Name: compile_profile(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.compile_profile(incoming_xml text) RETURNS vandelay.compile_profile
    LANGUAGE plpgsql
    AS $$
DECLARE
    output              vandelay.compile_profile%ROWTYPE;
    profile             vandelay.merge_profile%ROWTYPE;
    profile_tmpl        TEXT;
    profile_tmpl_owner  TEXT;
    add_rule            TEXT := '';
    strip_rule          TEXT := '';
    replace_rule        TEXT := '';
    preserve_rule       TEXT := '';

BEGIN

    profile_tmpl := (oils_xpath('//*[@tag="905"]/*[@code="t"]/text()',incoming_xml))[1];
    profile_tmpl_owner := (oils_xpath('//*[@tag="905"]/*[@code="o"]/text()',incoming_xml))[1];

    IF profile_tmpl IS NOT NULL AND profile_tmpl <> '' AND profile_tmpl_owner IS NOT NULL AND profile_tmpl_owner <> '' THEN
        SELECT  p.* INTO profile
          FROM  vandelay.merge_profile p
                JOIN actor.org_unit u ON (u.id = p.owner)
          WHERE p.name = profile_tmpl
                AND u.shortname = profile_tmpl_owner;

        IF profile.id IS NOT NULL THEN
            add_rule := COALESCE(profile.add_spec,'');
            strip_rule := COALESCE(profile.strip_spec,'');
            replace_rule := COALESCE(profile.replace_spec,'');
            preserve_rule := COALESCE(profile.preserve_spec,'');
        END IF;
    END IF;

    add_rule := add_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="a"]/text()',incoming_xml),','),'');
    strip_rule := strip_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="d"]/text()',incoming_xml),','),'');
    replace_rule := replace_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="r"]/text()',incoming_xml),','),'');
    preserve_rule := preserve_rule || ',' || COALESCE(ARRAY_TO_STRING(oils_xpath('//*[@tag="905"]/*[@code="p"]/text()',incoming_xml),','),'');

    output.add_rule := BTRIM(add_rule,',');
    output.replace_rule := BTRIM(replace_rule,',');
    output.strip_rule := BTRIM(strip_rule,',');
    output.preserve_rule := BTRIM(preserve_rule,',');

    RETURN output;
END;
$$;


ALTER FUNCTION vandelay.compile_profile(incoming_xml text) OWNER TO evergreen;

--
-- Name: extract_rec_attrs(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.extract_rec_attrs(xml text) RETURNS evergreen.hstore
    LANGUAGE sql
    AS $_$
    SELECT vandelay.extract_rec_attrs( $1, (SELECT ARRAY_AGG(name) FROM config.record_attr_definition));
$_$;


ALTER FUNCTION vandelay.extract_rec_attrs(xml text) OWNER TO evergreen;

--
-- Name: extract_rec_attrs(text, text[]); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.extract_rec_attrs(xml text, attr_defs text[]) RETURNS evergreen.hstore
    LANGUAGE plpgsql
    AS $$
DECLARE
    transformed_xml TEXT;
    prev_xfrm       TEXT;
    normalizer      RECORD;
    xfrm            config.xml_transform%ROWTYPE;
    attr_value      TEXT;
    new_attrs       HSTORE := ''::HSTORE;
    attr_def        config.record_attr_definition%ROWTYPE;
BEGIN

    FOR attr_def IN SELECT * FROM config.record_attr_definition WHERE name IN (SELECT * FROM UNNEST(attr_defs)) ORDER BY format LOOP

        IF attr_def.tag IS NOT NULL THEN -- tag (and optional subfield list) selection
            SELECT  STRING_AGG(x.value, COALESCE(attr_def.joiner,' ')) INTO attr_value
              FROM  vandelay.flatten_marc(xml) AS x
              WHERE x.tag LIKE attr_def.tag
                    AND CASE
                        WHEN attr_def.sf_list IS NOT NULL
                            THEN POSITION(x.subfield IN attr_def.sf_list) > 0
                        ELSE TRUE
                        END
              GROUP BY x.tag
              ORDER BY x.tag
              LIMIT 1;

        ELSIF attr_def.fixed_field IS NOT NULL THEN -- a named fixed field, see config.marc21_ff_pos_map.fixed_field
            attr_value := vandelay.marc21_extract_fixed_field(xml, attr_def.fixed_field);

        ELSIF attr_def.xpath IS NOT NULL THEN -- and xpath expression

            SELECT INTO xfrm * FROM config.xml_transform WHERE name = attr_def.format;

            -- See if we can skip the XSLT ... it's expensive
            IF prev_xfrm IS NULL OR prev_xfrm <> xfrm.name THEN
                -- Can't skip the transform
                IF xfrm.xslt <> '---' THEN
                    transformed_xml := oils_xslt_process(xml,xfrm.xslt);
                ELSE
                    transformed_xml := xml;
                END IF;

                prev_xfrm := xfrm.name;
            END IF;

            IF xfrm.name IS NULL THEN
                -- just grab the marcxml (empty) transform
                SELECT INTO xfrm * FROM config.xml_transform WHERE xslt = '---' LIMIT 1;
                prev_xfrm := xfrm.name;
            END IF;

            attr_value := oils_xpath_string(attr_def.xpath, transformed_xml, COALESCE(attr_def.joiner,' '), ARRAY[ARRAY[xfrm.prefix, xfrm.namespace_uri]]);

        ELSIF attr_def.phys_char_sf IS NOT NULL THEN -- a named Physical Characteristic, see config.marc21_physical_characteristic_*_map
            SELECT  m.value::TEXT INTO attr_value
              FROM  vandelay.marc21_physical_characteristics(xml) v
                    JOIN config.marc21_physical_characteristic_value_map m ON (m.id = v.value)
              WHERE v.subfield = attr_def.phys_char_sf
              LIMIT 1; -- Just in case ...

        END IF;

        -- apply index normalizers to attr_value
        FOR normalizer IN
            SELECT  n.func AS func,
                    n.param_count AS param_count,
                    m.params AS params
              FROM  config.index_normalizer n
                    JOIN config.record_attr_index_norm_map m ON (m.norm = n.id)
              WHERE attr = attr_def.name
              ORDER BY m.pos LOOP
                EXECUTE 'SELECT ' || normalizer.func || '(' ||
                    quote_nullable( attr_value ) ||
                    CASE
                        WHEN normalizer.param_count > 0
                            THEN ',' || REPLACE(REPLACE(BTRIM(normalizer.params,'[]'),E'\'',E'\\\''),E'"',E'\'')
                            ELSE ''
                        END ||
                    ')' INTO attr_value;

        END LOOP;

        -- Add the new value to the hstore
        new_attrs := new_attrs || hstore( attr_def.name, attr_value );

    END LOOP;

    RETURN new_attrs;
END;
$$;


ALTER FUNCTION vandelay.extract_rec_attrs(xml text, attr_defs text[]) OWNER TO evergreen;

--
-- Name: find_bib_tcn_data(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.find_bib_tcn_data(xml text) RETURNS SETOF vandelay.tcn_data
    LANGUAGE plpgsql
    AS $_$
DECLARE
    eg_tcn          TEXT;
    eg_tcn_source   TEXT;
    output          vandelay.tcn_data%ROWTYPE;
BEGIN

    -- 001/003
    eg_tcn := BTRIM((oils_xpath('//*[@tag="001"]/text()',xml))[1]);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := BTRIM((oils_xpath('//*[@tag="003"]/text()',xml))[1]);
        IF eg_tcn_source IS NULL OR eg_tcn_source = '' THEN
            eg_tcn_source := 'System Local';
        END IF;

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 901 ab
    eg_tcn := BTRIM((oils_xpath('//*[@tag="901"]/*[@code="a"]/text()',xml))[1]);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := BTRIM((oils_xpath('//*[@tag="901"]/*[@code="b"]/text()',xml))[1]);
        IF eg_tcn_source IS NULL OR eg_tcn_source = '' THEN
            eg_tcn_source := 'System Local';
        END IF;

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 039 ab
    eg_tcn := BTRIM((oils_xpath('//*[@tag="039"]/*[@code="a"]/text()',xml))[1]);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := BTRIM((oils_xpath('//*[@tag="039"]/*[@code="b"]/text()',xml))[1]);
        IF eg_tcn_source IS NULL OR eg_tcn_source = '' THEN
            eg_tcn_source := 'System Local';
        END IF;

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 020 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="020"]/*[@code="a"]/text()',xml))[1], $re$^(\w+).*?$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'ISBN';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 022 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="022"]/*[@code="a"]/text()',xml))[1], $re$^(\w+).*?$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'ISSN';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 010 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="010"]/*[@code="a"]/text()',xml))[1], $re$^(\w+).*?$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'LCCN';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    -- 035 a
    eg_tcn := REGEXP_REPLACE((oils_xpath('//*[@tag="035"]/*[@code="a"]/text()',xml))[1], $re$^.*?(\w+)$$re$, $re$\1$re$);
    IF eg_tcn IS NOT NULL AND eg_tcn <> '' THEN

        eg_tcn_source := 'System Legacy';

        PERFORM id FROM biblio.record_entry WHERE tcn_value = eg_tcn  AND NOT deleted;

        IF NOT FOUND THEN
            output.used := FALSE;
        ELSE
            output.used := TRUE;
        END IF;

        output.tcn := eg_tcn;
        output.tcn_source := eg_tcn_source;
        RETURN NEXT output;

    END IF;

    RETURN;
END;
$_$;


ALTER FUNCTION vandelay.find_bib_tcn_data(xml text) OWNER TO evergreen;

--
-- Name: flatten_marc(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.flatten_marc(marc text) RETURNS SETOF vandelay.flat_marc
    LANGUAGE plpgsql
    AS $$
DECLARE
    output  vandelay.flat_marc%ROWTYPE;
    field   RECORD;
BEGIN
    FOR field IN SELECT * FROM vandelay.flay_marc( marc ) LOOP
        output.ind1 := field.ind1;
        output.ind2 := field.ind2;
        output.tag := field.tag;
        output.subfield := field.subfield;
        IF field.subfield IS NOT NULL AND field.tag NOT IN ('020','022','024') THEN -- exclude standard numbers and control fields
            output.value := naco_normalize(field.value, field.subfield);
        ELSE
            output.value := field.value;
        END IF;

        CONTINUE WHEN output.value IS NULL;

        RETURN NEXT output;
    END LOOP;
END;
$$;


ALTER FUNCTION vandelay.flatten_marc(marc text) OWNER TO evergreen;

--
-- Name: flatten_marc_hstore(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.flatten_marc_hstore(record_xml text) RETURNS evergreen.hstore
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN (SELECT
        HSTORE(
            ARRAY_AGG(tag || (COALESCE(subfield, ''))),
            ARRAY_AGG(value)
        )
        FROM (
            SELECT  tag, subfield, ARRAY_AGG(value)::TEXT AS value
              FROM  (SELECT tag,
                            subfield,
                            CASE WHEN tag = '020' THEN -- caseless -- isbn
                                LOWER((SELECT REGEXP_MATCHES(value,$$^(\S{10,17})$$))[1] || '%')
                            WHEN tag = '022' THEN -- caseless -- issn
                                LOWER((SELECT REGEXP_MATCHES(value,$$^(\S{4}[- ]?\S{4})$$))[1] || '%')
                            WHEN tag = '024' THEN -- caseless -- upc (other)
                                LOWER(value || '%')
                            ELSE
                                value
                            END AS value
                      FROM  vandelay.flatten_marc(record_xml)) x
                GROUP BY tag, subfield ORDER BY tag, subfield
        ) subquery
    );
END;
$_$;


ALTER FUNCTION vandelay.flatten_marc_hstore(record_xml text) OWNER TO evergreen;

--
-- Name: flay_marc(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.flay_marc(text) RETURNS SETOF vandelay.flat_marc
    LANGUAGE plperlu
    AS $_$

use MARC::Record;
use MARC::File::XML (BinaryEncoding => 'UTF-8');
use MARC::Charset;
use strict;

MARC::Charset->assume_unicode(1);

my $xml = shift;
my $r = MARC::Record->new_from_xml( $xml );

return_next( { tag => 'LDR', value => $r->leader } );

for my $f ( $r->fields ) {
    if ($f->is_control_field) {
        return_next({ tag => $f->tag, value => $f->data });
    } else {
        for my $s ($f->subfields) {
            return_next({
                tag      => $f->tag,
                ind1     => $f->indicator(1),
                ind2     => $f->indicator(2),
                subfield => $s->[0],
                value    => $s->[1]
            });

            if ( $f->tag eq '245' and $s->[0] eq 'a' ) {
                my $trim = $f->indicator(2) || 0;
                return_next({
                    tag      => 'tnf',
                    ind1     => $f->indicator(1),
                    ind2     => $f->indicator(2),
                    subfield => 'a',
                    value    => substr( $s->[1], $trim )
                });
            }
        }
    }
}

return undef;

$_$;


ALTER FUNCTION vandelay.flay_marc(text) OWNER TO evergreen;

--
-- Name: get_expr_from_match_set(integer, evergreen.hstore); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.get_expr_from_match_set(match_set_id integer, tags_rstore evergreen.hstore) RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN vandelay.get_expr_from_match_set(
        match_set_id, tags_rstore, NULL);
END;
$$;


ALTER FUNCTION vandelay.get_expr_from_match_set(match_set_id integer, tags_rstore evergreen.hstore) OWNER TO evergreen;

--
-- Name: get_expr_from_match_set(integer, evergreen.hstore, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.get_expr_from_match_set(match_set_id integer, tags_rstore evergreen.hstore, auth_heading text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    root vandelay.match_set_point;
BEGIN
    SELECT * INTO root FROM vandelay.match_set_point
        WHERE parent IS NULL AND match_set = match_set_id;

    RETURN vandelay.get_expr_from_match_set_point(
        root, tags_rstore, auth_heading);
END;
$$;


ALTER FUNCTION vandelay.get_expr_from_match_set(match_set_id integer, tags_rstore evergreen.hstore, auth_heading text) OWNER TO evergreen;

--
-- Name: get_expr_from_match_set_auth(integer, evergreen.hstore); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.get_expr_from_match_set_auth(match_set_id integer, tags_rstore evergreen.hstore) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    root    vandelay.match_set_point;
BEGIN
    --ver1.0
    SELECT * INTO root FROM vandelay.match_set_point
        WHERE parent IS NULL AND match_set = match_set_id;

    RETURN vandelay.get_expr_from_match_set_point_auth(root, tags_rstore);
END;
$$;


ALTER FUNCTION vandelay.get_expr_from_match_set_auth(match_set_id integer, tags_rstore evergreen.hstore) OWNER TO evergreen;

--
-- Name: get_expr_from_match_set_point(vandelay.match_set_point, evergreen.hstore, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.get_expr_from_match_set_point(node vandelay.match_set_point, tags_rstore evergreen.hstore, auth_heading text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    q           TEXT;
    i           INTEGER;
    this_op     TEXT;
    children    INTEGER[];
    child       vandelay.match_set_point;
BEGIN
    SELECT ARRAY_AGG(id) INTO children FROM vandelay.match_set_point
        WHERE parent = node.id;

    IF ARRAY_LENGTH(children, 1) > 0 THEN
        this_op := vandelay._get_expr_render_one(node);
        q := '(';
        i := 1;
        WHILE children[i] IS NOT NULL LOOP
            SELECT * INTO child FROM vandelay.match_set_point
                WHERE id = children[i];
            IF i > 1 THEN
                q := q || ' ' || this_op || ' ';
            END IF;
            i := i + 1;
            q := q || vandelay.get_expr_from_match_set_point(
                child, tags_rstore, auth_heading);
        END LOOP;
        q := q || ')';
        RETURN q;
    ELSIF node.bool_op IS NULL THEN
        PERFORM vandelay._get_expr_push_qrow(node);
        PERFORM vandelay._get_expr_push_jrow(node, tags_rstore, auth_heading);
        RETURN vandelay._get_expr_render_one(node);
    ELSE
        RETURN '';
    END IF;
END;
$$;


ALTER FUNCTION vandelay.get_expr_from_match_set_point(node vandelay.match_set_point, tags_rstore evergreen.hstore, auth_heading text) OWNER TO evergreen;

--
-- Name: get_expr_from_match_set_point_auth(vandelay.match_set_point, evergreen.hstore); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.get_expr_from_match_set_point_auth(node vandelay.match_set_point, tags_rstore evergreen.hstore) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    q           TEXT;
    i           INTEGER;
    this_op     TEXT;
    children    INTEGER[];
    child       vandelay.match_set_point;
BEGIN
    --ver1.0
    SELECT array_agg(id) INTO children FROM vandelay.match_set_point
        WHERE parent = node.id;

    IF ARRAY_LENGTH(children, 1) > 0 THEN
        this_op := vandelay._get_expr_render_one(node);
        q := '(';
        i := 1;
        WHILE children[i] IS NOT NULL LOOP
            SELECT * INTO child FROM vandelay.match_set_point
                WHERE id = children[i];
            IF i > 1 THEN
                q := q || ' ' || this_op || ' ';
            END IF;
            i := i + 1;
            q := q || vandelay.get_expr_from_match_set_point_auth(child, tags_rstore);
        END LOOP;
        q := q || ')';
        RETURN q;
    ELSIF node.bool_op IS NULL THEN
        PERFORM vandelay._get_expr_push_qrow_auth(node);
        PERFORM vandelay._get_expr_push_jrow_auth(node, tags_rstore);
        RETURN vandelay._get_expr_render_one(node);
    ELSE
        RETURN '';
    END IF;
END;
$$;


ALTER FUNCTION vandelay.get_expr_from_match_set_point_auth(node vandelay.match_set_point, tags_rstore evergreen.hstore) OWNER TO evergreen;

--
-- Name: get_matched_records(bigint, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.get_matched_records(queued_bib bigint, bib_type text) RETURNS SETOF evergreen.matched_records
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	m_record matched_records;
BEGIN
        --ver1.0
		IF bib_type = 'bib' THEN
				FOR m_record IN
					SELECT create_date, creator, edit_date, bre.id, vqbr.quality, source, tcn_source, tcn_value,
					'null' as _id, vbm.match_score, vbm.quality as match_quality
					FROM biblio.record_entry bre
					INNER JOIN vandelay.bib_match vbm
					ON vbm.eg_record = bre.id
					INNER JOIN vandelay.queued_bib_record vqbr
					ON vqbr.id = vbm.queued_record
					WHERE vqbr.id = queued_bib
					ORDER BY bre.id DESC
				LOOP
				RETURN NEXT m_record;
				END LOOP;
		ELSE
				FOR m_record IN
					SELECT create_date, creator, edit_date, are.id, vqar.quality, source, '' as tcn_source, '' as tcn_value,
					'null' as _id, vam.match_score, vam.quality as match_quality
					FROM authority.record_entry are
					INNER JOIN vandelay.authority_match vam
					ON vam.eg_record = are.id
					INNER JOIN vandelay.queued_authority_record  vqar
					ON vqar.id = vam.queued_record
					WHERE vqar.id = queued_bib
					ORDER BY are.id DESC
				LOOP
				RETURN NEXT m_record;
				END LOOP;
		END IF;
	RETURN;
END;
$$;


ALTER FUNCTION vandelay.get_matched_records(queued_bib bigint, bib_type text) OWNER TO evergreen;

--
-- Name: ingest_authority_marc(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.ingest_authority_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    value   TEXT;
    atype   TEXT;
    adef    RECORD;
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    FOR adef IN SELECT * FROM vandelay.authority_attr_definition LOOP

        SELECT extract_marc_field('vandelay.queued_authority_record', id, adef.xpath, adef.remove) INTO value FROM vandelay.queued_authority_record WHERE id = NEW.id;
        IF (value IS NOT NULL AND value <> '') THEN
            INSERT INTO vandelay.queued_authority_record_attr (record, field, attr_value) VALUES (NEW.id, adef.id, value);
        END IF;

    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.ingest_authority_marc() OWNER TO evergreen;

--
-- Name: ingest_bib_items(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.ingest_bib_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    attr_def    BIGINT;
    item_data   vandelay.import_item%ROWTYPE;
BEGIN

    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    SELECT item_attr_def INTO attr_def FROM vandelay.bib_queue WHERE id = NEW.queue;

    FOR item_data IN SELECT * FROM vandelay.ingest_items( NEW.id::BIGINT, attr_def ) LOOP
        INSERT INTO vandelay.import_item (
            record,
            definition,
            owning_lib,
            circ_lib,
            call_number,
            copy_number,
            status,
            location,
            circulate,
            deposit,
            deposit_amount,
            ref,
            holdable,
            price,
            barcode,
            circ_modifier,
            circ_as_type,
            alert_message,
            pub_note,
            priv_note,
            internal_id,
            opac_visible,
            stat_cat_data,
            parts_data,
            import_error,
            error_detail
        ) VALUES (
            NEW.id,
            item_data.definition,
            item_data.owning_lib,
            item_data.circ_lib,
            item_data.call_number,
            item_data.copy_number,
            item_data.status,
            item_data.location,
            item_data.circulate,
            item_data.deposit,
            item_data.deposit_amount,
            item_data.ref,
            item_data.holdable,
            item_data.price,
            item_data.barcode,
            item_data.circ_modifier,
            item_data.circ_as_type,
            item_data.alert_message,
            item_data.pub_note,
            item_data.priv_note,
            item_data.internal_id,
            item_data.opac_visible,
            item_data.stat_cat_data,
            item_data.parts_data,
            item_data.import_error,
            item_data.error_detail
        );
    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.ingest_bib_items() OWNER TO evergreen;

--
-- Name: ingest_bib_marc(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.ingest_bib_marc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    value   TEXT;
    atype   TEXT;
    adef    RECORD;
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    FOR adef IN SELECT * FROM vandelay.bib_attr_definition LOOP

        SELECT extract_marc_field('vandelay.queued_bib_record', id, adef.xpath, adef.remove) INTO value FROM vandelay.queued_bib_record WHERE id = NEW.id;
        IF (value IS NOT NULL AND value <> '') THEN
            INSERT INTO vandelay.queued_bib_record_attr (record, field, attr_value) VALUES (NEW.id, adef.id, value);
        END IF;

    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.ingest_bib_marc() OWNER TO evergreen;

--
-- Name: import_item; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.import_item (
    id bigint NOT NULL,
    record bigint NOT NULL,
    definition bigint NOT NULL,
    owning_lib integer,
    circ_lib integer,
    call_number text,
    copy_number integer,
    status integer,
    location integer,
    circulate boolean,
    deposit boolean,
    deposit_amount numeric(8,2),
    ref boolean,
    holdable boolean,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    alert_message text,
    pub_note text,
    priv_note text,
    opac_visible boolean,
    import_error text,
    error_detail text,
    imported_as bigint,
    import_time timestamp with time zone,
    internal_id bigint,
    stat_cat_data text,
    parts_data text
);


ALTER TABLE vandelay.import_item OWNER TO evergreen;

--
-- Name: ingest_items(bigint, bigint); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.ingest_items(import_id bigint, attr_def_id bigint) RETURNS SETOF vandelay.import_item
    LANGUAGE plpgsql
    AS $$
DECLARE

    owning_lib      TEXT;
    circ_lib        TEXT;
    call_number     TEXT;
    copy_number     TEXT;
    status          TEXT;
    location        TEXT;
    circulate       TEXT;
    deposit         TEXT;
    deposit_amount  TEXT;
    ref             TEXT;
    holdable        TEXT;
    price           TEXT;
    barcode         TEXT;
    circ_modifier   TEXT;
    circ_as_type    TEXT;
    alert_message   TEXT;
    opac_visible    TEXT;
    pub_note        TEXT;
    priv_note       TEXT;
    internal_id     TEXT;
    stat_cat_data   TEXT;
    parts_data      TEXT;

    attr_def        RECORD;
    tmp_attr_set    RECORD;
    attr_set        vandelay.import_item%ROWTYPE;

    xpaths          TEXT[];
    tmp_str         TEXT;

BEGIN

    SELECT * INTO attr_def FROM vandelay.import_item_attr_definition WHERE id = attr_def_id;

    IF FOUND THEN

        attr_set.definition := attr_def.id;

        -- Build the combined XPath

        owning_lib :=
            CASE
                WHEN attr_def.owning_lib IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.owning_lib ) = 1 THEN '//*[@code="' || attr_def.owning_lib || '"]'
                ELSE '//*' || attr_def.owning_lib
            END;

        circ_lib :=
            CASE
                WHEN attr_def.circ_lib IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circ_lib ) = 1 THEN '//*[@code="' || attr_def.circ_lib || '"]'
                ELSE '//*' || attr_def.circ_lib
            END;

        call_number :=
            CASE
                WHEN attr_def.call_number IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.call_number ) = 1 THEN '//*[@code="' || attr_def.call_number || '"]'
                ELSE '//*' || attr_def.call_number
            END;

        copy_number :=
            CASE
                WHEN attr_def.copy_number IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.copy_number ) = 1 THEN '//*[@code="' || attr_def.copy_number || '"]'
                ELSE '//*' || attr_def.copy_number
            END;

        status :=
            CASE
                WHEN attr_def.status IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.status ) = 1 THEN '//*[@code="' || attr_def.status || '"]'
                ELSE '//*' || attr_def.status
            END;

        location :=
            CASE
                WHEN attr_def.location IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.location ) = 1 THEN '//*[@code="' || attr_def.location || '"]'
                ELSE '//*' || attr_def.location
            END;

        circulate :=
            CASE
                WHEN attr_def.circulate IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circulate ) = 1 THEN '//*[@code="' || attr_def.circulate || '"]'
                ELSE '//*' || attr_def.circulate
            END;

        deposit :=
            CASE
                WHEN attr_def.deposit IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.deposit ) = 1 THEN '//*[@code="' || attr_def.deposit || '"]'
                ELSE '//*' || attr_def.deposit
            END;

        deposit_amount :=
            CASE
                WHEN attr_def.deposit_amount IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.deposit_amount ) = 1 THEN '//*[@code="' || attr_def.deposit_amount || '"]'
                ELSE '//*' || attr_def.deposit_amount
            END;

        ref :=
            CASE
                WHEN attr_def.ref IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.ref ) = 1 THEN '//*[@code="' || attr_def.ref || '"]'
                ELSE '//*' || attr_def.ref
            END;

        holdable :=
            CASE
                WHEN attr_def.holdable IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.holdable ) = 1 THEN '//*[@code="' || attr_def.holdable || '"]'
                ELSE '//*' || attr_def.holdable
            END;

        price :=
            CASE
                WHEN attr_def.price IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.price ) = 1 THEN '//*[@code="' || attr_def.price || '"]'
                ELSE '//*' || attr_def.price
            END;

        barcode :=
            CASE
                WHEN attr_def.barcode IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.barcode ) = 1 THEN '//*[@code="' || attr_def.barcode || '"]'
                ELSE '//*' || attr_def.barcode
            END;

        circ_modifier :=
            CASE
                WHEN attr_def.circ_modifier IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circ_modifier ) = 1 THEN '//*[@code="' || attr_def.circ_modifier || '"]'
                ELSE '//*' || attr_def.circ_modifier
            END;

        circ_as_type :=
            CASE
                WHEN attr_def.circ_as_type IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.circ_as_type ) = 1 THEN '//*[@code="' || attr_def.circ_as_type || '"]'
                ELSE '//*' || attr_def.circ_as_type
            END;

        alert_message :=
            CASE
                WHEN attr_def.alert_message IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.alert_message ) = 1 THEN '//*[@code="' || attr_def.alert_message || '"]'
                ELSE '//*' || attr_def.alert_message
            END;

        opac_visible :=
            CASE
                WHEN attr_def.opac_visible IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.opac_visible ) = 1 THEN '//*[@code="' || attr_def.opac_visible || '"]'
                ELSE '//*' || attr_def.opac_visible
            END;

        pub_note :=
            CASE
                WHEN attr_def.pub_note IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.pub_note ) = 1 THEN '//*[@code="' || attr_def.pub_note || '"]'
                ELSE '//*' || attr_def.pub_note
            END;
        priv_note :=
            CASE
                WHEN attr_def.priv_note IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.priv_note ) = 1 THEN '//*[@code="' || attr_def.priv_note || '"]'
                ELSE '//*' || attr_def.priv_note
            END;

        internal_id :=
            CASE
                WHEN attr_def.internal_id IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.internal_id ) = 1 THEN '//*[@code="' || attr_def.internal_id || '"]'
                ELSE '//*' || attr_def.internal_id
            END;

        stat_cat_data :=
            CASE
                WHEN attr_def.stat_cat_data IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.stat_cat_data ) = 1 THEN '//*[@code="' || attr_def.stat_cat_data || '"]'
                ELSE '//*' || attr_def.stat_cat_data
            END;

        parts_data :=
            CASE
                WHEN attr_def.parts_data IS NULL THEN 'null()'
                WHEN LENGTH( attr_def.parts_data ) = 1 THEN '//*[@code="' || attr_def.parts_data || '"]'
                ELSE '//*' || attr_def.parts_data
            END;



        xpaths := ARRAY[owning_lib, circ_lib, call_number, copy_number, status, location, circulate,
                        deposit, deposit_amount, ref, holdable, price, barcode, circ_modifier, circ_as_type,
                        alert_message, pub_note, priv_note, internal_id, stat_cat_data, parts_data, opac_visible];

        FOR tmp_attr_set IN
                SELECT  *
                  FROM  oils_xpath_tag_to_table( (SELECT marc FROM vandelay.queued_bib_record WHERE id = import_id), attr_def.tag, xpaths)
                            AS t( ol TEXT, clib TEXT, cn TEXT, cnum TEXT, cs TEXT, cl TEXT, circ TEXT,
                                  dep TEXT, dep_amount TEXT, r TEXT, hold TEXT, pr TEXT, bc TEXT, circ_mod TEXT,
                                  circ_as TEXT, amessage TEXT, note TEXT, pnote TEXT, internal_id TEXT,
                                  stat_cat_data TEXT, parts_data TEXT, opac_vis TEXT )
        LOOP

            attr_set.import_error := NULL;
            attr_set.error_detail := NULL;
            attr_set.deposit_amount := NULL;
            attr_set.copy_number := NULL;
            attr_set.price := NULL;
            attr_set.circ_modifier := NULL;
            attr_set.location := NULL;
            attr_set.barcode := NULL;
            attr_set.call_number := NULL;

            IF tmp_attr_set.pr != '' THEN
                tmp_str = REGEXP_REPLACE(tmp_attr_set.pr, E'[^0-9\\.]', '', 'g');
                IF tmp_str = '' THEN
                    attr_set.import_error := 'import.item.invalid.price';
                    attr_set.error_detail := tmp_attr_set.pr; -- original value
                    RETURN NEXT attr_set; CONTINUE;
                END IF;
                attr_set.price := tmp_str::NUMERIC(8,2);
            END IF;

            IF tmp_attr_set.dep_amount != '' THEN
                tmp_str = REGEXP_REPLACE(tmp_attr_set.dep_amount, E'[^0-9\\.]', '', 'g');
                IF tmp_str = '' THEN
                    attr_set.import_error := 'import.item.invalid.deposit_amount';
                    attr_set.error_detail := tmp_attr_set.dep_amount;
                    RETURN NEXT attr_set; CONTINUE;
                END IF;
                attr_set.deposit_amount := tmp_str::NUMERIC(8,2);
            END IF;

            IF tmp_attr_set.cnum != '' THEN
                tmp_str = REGEXP_REPLACE(tmp_attr_set.cnum, E'[^0-9]', '', 'g');
                IF tmp_str = '' THEN
                    attr_set.import_error := 'import.item.invalid.copy_number';
                    attr_set.error_detail := tmp_attr_set.cnum;
                    RETURN NEXT attr_set; CONTINUE;
                END IF;
                attr_set.copy_number := tmp_str::INT;
            END IF;

            IF tmp_attr_set.ol != '' THEN
                SELECT id INTO attr_set.owning_lib FROM actor.org_unit WHERE shortname = UPPER(tmp_attr_set.ol); -- INT
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.owning_lib';
                    attr_set.error_detail := tmp_attr_set.ol;
                    RETURN NEXT attr_set; CONTINUE;
                END IF;
            END IF;

            IF tmp_attr_set.clib != '' THEN
                SELECT id INTO attr_set.circ_lib FROM actor.org_unit WHERE shortname = UPPER(tmp_attr_set.clib); -- INT
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.circ_lib';
                    attr_set.error_detail := tmp_attr_set.clib;
                    RETURN NEXT attr_set; CONTINUE;
                END IF;
            END IF;

            IF tmp_attr_set.cs != '' THEN
                SELECT id INTO attr_set.status FROM config.copy_status WHERE LOWER(name) = LOWER(tmp_attr_set.cs); -- INT
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.status';
                    attr_set.error_detail := tmp_attr_set.cs;
                    RETURN NEXT attr_set; CONTINUE;
                END IF;
            END IF;

            IF COALESCE(tmp_attr_set.circ_mod, '') = '' THEN

                -- no circ mod defined, see if we should apply a default
                SELECT INTO attr_set.circ_modifier TRIM(BOTH '"' FROM value)
                    FROM actor.org_unit_ancestor_setting(
                        'vandelay.item.circ_modifier.default',
                        attr_set.owning_lib
                    );

                -- make sure the value from the org setting is still valid
                PERFORM 1 FROM config.circ_modifier WHERE code = attr_set.circ_modifier;
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.circ_modifier';
                    attr_set.error_detail := tmp_attr_set.circ_mod;
                    RETURN NEXT attr_set; CONTINUE;
                END IF;

            ELSE

                SELECT code INTO attr_set.circ_modifier FROM config.circ_modifier WHERE code = tmp_attr_set.circ_mod;
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.circ_modifier';
                    attr_set.error_detail := tmp_attr_set.circ_mod;
                    RETURN NEXT attr_set; CONTINUE;
                END IF;
            END IF;

            IF tmp_attr_set.circ_as != '' THEN
                SELECT code INTO attr_set.circ_as_type FROM config.coded_value_map WHERE ctype = 'item_type' AND code = tmp_attr_set.circ_as;
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.circ_as_type';
                    attr_set.error_detail := tmp_attr_set.circ_as;
                    RETURN NEXT attr_set; CONTINUE;
                END IF;
            END IF;

            IF COALESCE(tmp_attr_set.cl, '') = '' THEN
                -- no location specified, see if we should apply a default

                SELECT INTO attr_set.location TRIM(BOTH '"' FROM value)
                    FROM actor.org_unit_ancestor_setting(
                        'vandelay.item.copy_location.default',
                        attr_set.owning_lib
                    );

                -- make sure the value from the org setting is still valid
                PERFORM 1 FROM asset.copy_location
                    WHERE id = attr_set.location AND NOT deleted;
                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.location';
                    attr_set.error_detail := tmp_attr_set.cs;
                    RETURN NEXT attr_set; CONTINUE;
                END IF;
            ELSE

                -- search up the org unit tree for a matching copy location
                WITH RECURSIVE anscestor_depth AS (
                    SELECT  ou.id,
                        out.depth AS depth,
                        ou.parent_ou
                    FROM  actor.org_unit ou
                        JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                    WHERE ou.id = COALESCE(attr_set.owning_lib, attr_set.circ_lib)
                        UNION ALL
                    SELECT  ou.id,
                        out.depth,
                        ou.parent_ou
                    FROM  actor.org_unit ou
                        JOIN actor.org_unit_type out ON (out.id = ou.ou_type)
                        JOIN anscestor_depth ot ON (ot.parent_ou = ou.id)
                ) SELECT  cpl.id INTO attr_set.location
                    FROM  anscestor_depth a
                        JOIN asset.copy_location cpl ON (cpl.owning_lib = a.id)
                    WHERE LOWER(cpl.name) = LOWER(tmp_attr_set.cl)
                        AND NOT cpl.deleted
                    ORDER BY a.depth DESC
                    LIMIT 1;

                IF NOT FOUND THEN
                    attr_set.import_error := 'import.item.invalid.location';
                    attr_set.error_detail := tmp_attr_set.cs;
                    RETURN NEXT attr_set; CONTINUE;
                END IF;
            END IF;

            attr_set.circulate      :=
                LOWER( SUBSTRING( tmp_attr_set.circ, 1, 1)) IN ('t','y','1')
                OR LOWER(tmp_attr_set.circ) = 'circulating'; -- BOOL

            attr_set.deposit        :=
                LOWER( SUBSTRING( tmp_attr_set.dep, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.dep) = 'deposit'; -- BOOL

            attr_set.holdable       :=
                LOWER( SUBSTRING( tmp_attr_set.hold, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.hold) = 'holdable'; -- BOOL

            attr_set.opac_visible   :=
                LOWER( SUBSTRING( tmp_attr_set.opac_vis, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.opac_vis) = 'visible'; -- BOOL

            attr_set.ref            :=
                LOWER( SUBSTRING( tmp_attr_set.r, 1, 1 ) ) IN ('t','y','1')
                OR LOWER(tmp_attr_set.r) = 'reference'; -- BOOL

            attr_set.call_number    := tmp_attr_set.cn; -- TEXT
            attr_set.barcode        := tmp_attr_set.bc; -- TEXT,
            attr_set.alert_message  := tmp_attr_set.amessage; -- TEXT,
            attr_set.pub_note       := tmp_attr_set.note; -- TEXT,
            attr_set.priv_note      := tmp_attr_set.pnote; -- TEXT,
            attr_set.alert_message  := tmp_attr_set.amessage; -- TEXT,
            attr_set.internal_id    := tmp_attr_set.internal_id::BIGINT;
            attr_set.stat_cat_data  := tmp_attr_set.stat_cat_data; -- TEXT,
            attr_set.parts_data     := tmp_attr_set.parts_data; -- TEXT,

            RETURN NEXT attr_set;

        END LOOP;

    END IF;

    RETURN;

END;
$$;


ALTER FUNCTION vandelay.ingest_items(import_id bigint, attr_def_id bigint) OWNER TO evergreen;

--
-- Name: marc21_extract_all_fixed_fields(text, boolean); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.marc21_extract_all_fixed_fields(marc text, use_default boolean DEFAULT false) RETURNS SETOF biblio.record_ff_map
    LANGUAGE plpgsql
    AS $$
DECLARE
    tag_data    TEXT;
    rtype       TEXT;
    ff_pos      RECORD;
    output      biblio.record_ff_map%ROWTYPE;
BEGIN
    rtype := (vandelay.marc21_record_type( marc )).code;

    FOR ff_pos IN SELECT * FROM config.marc21_ff_pos_map WHERE rec_type = rtype ORDER BY tag DESC LOOP
        output.ff_name  := ff_pos.fixed_field;
        output.ff_value := NULL;

        IF ff_pos.tag = 'ldr' THEN
            output.ff_value := oils_xpath_string('//*[local-name()="leader"]', marc);
            IF output.ff_value IS NOT NULL THEN
                output.ff_value := SUBSTRING( output.ff_value, ff_pos.start_pos + 1, ff_pos.length );
                RETURN NEXT output;
                output.ff_value := NULL;
            END IF;
        ELSE
            FOR tag_data IN SELECT value FROM UNNEST( oils_xpath( '//*[@tag="' || UPPER(ff_pos.tag) || '"]/text()', marc ) ) x(value) LOOP
                output.ff_value := SUBSTRING( tag_data, ff_pos.start_pos + 1, ff_pos.length );
                CONTINUE WHEN output.ff_value IS NULL AND NOT use_default;
                IF output.ff_value IS NULL THEN output.ff_value := REPEAT( ff_pos.default_val, ff_pos.length ); END IF;
                RETURN NEXT output;
                output.ff_value := NULL;
            END LOOP;
        END IF;

    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION vandelay.marc21_extract_all_fixed_fields(marc text, use_default boolean) OWNER TO evergreen;

--
-- Name: marc21_extract_fixed_field(text, text, boolean); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.marc21_extract_fixed_field(marc text, ff text, use_default boolean DEFAULT false) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    rtype       TEXT;
    ff_pos      RECORD;
    tag_data    RECORD;
    val         TEXT;
BEGIN
    rtype := (vandelay.marc21_record_type( marc )).code;
    FOR ff_pos IN SELECT * FROM config.marc21_ff_pos_map WHERE fixed_field = ff AND rec_type = rtype ORDER BY tag DESC LOOP
        IF ff_pos.tag = 'ldr' THEN
            val := oils_xpath_string('//*[local-name()="leader"]', marc);
            IF val IS NOT NULL THEN
                val := SUBSTRING( val, ff_pos.start_pos + 1, ff_pos.length );
                RETURN val;
            END IF;
        ELSE
            FOR tag_data IN SELECT value FROM UNNEST( oils_xpath( '//*[@tag="' || UPPER(ff_pos.tag) || '"]/text()', marc ) ) x(value) LOOP
                val := SUBSTRING( tag_data.value, ff_pos.start_pos + 1, ff_pos.length );
                RETURN val;
            END LOOP;
        END IF;
        CONTINUE WHEN NOT use_default;
        val := REPEAT( ff_pos.default_val, ff_pos.length );
        RETURN val;
    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION vandelay.marc21_extract_fixed_field(marc text, ff text, use_default boolean) OWNER TO evergreen;

--
-- Name: marc21_extract_fixed_field_list(text, text, boolean); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.marc21_extract_fixed_field_list(marc text, ff text, use_default boolean DEFAULT false) RETURNS text[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    rtype       TEXT;
    ff_pos      RECORD;
    tag_data    RECORD;
    val         TEXT;
    collection  TEXT[] := '{}'::TEXT[];
BEGIN
    rtype := (vandelay.marc21_record_type( marc )).code;
    FOR ff_pos IN SELECT * FROM config.marc21_ff_pos_map WHERE fixed_field = ff AND rec_type = rtype ORDER BY tag DESC LOOP
        IF ff_pos.tag = 'ldr' THEN
            val := oils_xpath_string('//*[local-name()="leader"]', marc);
            IF val IS NOT NULL THEN
                val := SUBSTRING( val, ff_pos.start_pos + 1, ff_pos.length );
                collection := collection || val;
            END IF;
        ELSE
            FOR tag_data IN SELECT value FROM UNNEST( oils_xpath( '//*[@tag="' || UPPER(ff_pos.tag) || '"]/text()', marc ) ) x(value) LOOP
                val := SUBSTRING( tag_data.value, ff_pos.start_pos + 1, ff_pos.length );
                collection := collection || val;
            END LOOP;
        END IF;
        CONTINUE WHEN NOT use_default;
        CONTINUE WHEN ARRAY_UPPER(collection, 1) > 0;
        val := REPEAT( ff_pos.default_val, ff_pos.length );
        collection := collection || val;
    END LOOP;

    RETURN collection;
END;
$$;


ALTER FUNCTION vandelay.marc21_extract_fixed_field_list(marc text, ff text, use_default boolean) OWNER TO evergreen;

--
-- Name: marc21_physical_characteristics(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.marc21_physical_characteristics(marc text) RETURNS SETOF biblio.marc21_physical_characteristics
    LANGUAGE plpgsql
    AS $$
DECLARE
    rowid   INT := 0;
    _007    TEXT;
    ptype   config.marc21_physical_characteristic_type_map%ROWTYPE;
    psf     config.marc21_physical_characteristic_subfield_map%ROWTYPE;
    pval    config.marc21_physical_characteristic_value_map%ROWTYPE;
    retval  biblio.marc21_physical_characteristics%ROWTYPE;
BEGIN

    FOR _007 IN SELECT oils_xpath_string('//*', value) FROM UNNEST(oils_xpath('//*[@tag="007"]', marc)) x(value) LOOP
        IF _007 IS NOT NULL AND _007 <> '' THEN
            SELECT * INTO ptype FROM config.marc21_physical_characteristic_type_map WHERE ptype_key = SUBSTRING( _007, 1, 1 );

            IF ptype.ptype_key IS NOT NULL THEN
                FOR psf IN SELECT * FROM config.marc21_physical_characteristic_subfield_map WHERE ptype_key = ptype.ptype_key LOOP
                    SELECT * INTO pval FROM config.marc21_physical_characteristic_value_map WHERE ptype_subfield = psf.id AND value = SUBSTRING( _007, psf.start_pos + 1, psf.length );

                    IF pval.id IS NOT NULL THEN
                        rowid := rowid + 1;
                        retval.id := rowid;
                        retval.ptype := ptype.ptype_key;
                        retval.subfield := psf.id;
                        retval.value := pval.id;
                        RETURN NEXT retval;
                    END IF;

                END LOOP;
            END IF;
        END IF;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION vandelay.marc21_physical_characteristics(marc text) OWNER TO evergreen;

--
-- Name: marc21_record_type(text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.marc21_record_type(marc text) RETURNS config.marc21_rec_type_map
    LANGUAGE plpgsql
    AS $$
DECLARE
    ldr         TEXT;
    tval        TEXT;
    tval_rec    RECORD;
    bval        TEXT;
    bval_rec    RECORD;
    retval      config.marc21_rec_type_map%ROWTYPE;
BEGIN
    ldr := oils_xpath_string( '//*[local-name()="leader"]', marc );

    IF ldr IS NULL OR ldr = '' THEN
        SELECT * INTO retval FROM config.marc21_rec_type_map WHERE code = 'BKS';
        RETURN retval;
    END IF;

    SELECT * INTO tval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'Type' LIMIT 1; -- They're all the same
    SELECT * INTO bval_rec FROM config.marc21_ff_pos_map WHERE fixed_field = 'BLvl' LIMIT 1; -- They're all the same


    tval := SUBSTRING( ldr, tval_rec.start_pos + 1, tval_rec.length );
    bval := SUBSTRING( ldr, bval_rec.start_pos + 1, bval_rec.length );

    -- RAISE NOTICE 'type %, blvl %, ldr %', tval, bval, ldr;

    SELECT * INTO retval FROM config.marc21_rec_type_map WHERE type_val LIKE '%' || tval || '%' AND blvl_val LIKE '%' || bval || '%';


    IF retval.code IS NULL THEN
        SELECT * INTO retval FROM config.marc21_rec_type_map WHERE code = 'BKS';
    END IF;

    RETURN retval;
END;
$$;


ALTER FUNCTION vandelay.marc21_record_type(marc text) OWNER TO evergreen;

--
-- Name: match_auth_record(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.match_auth_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    incoming_existing_id    TEXT;
    test_result             vandelay.match_set_test_result%ROWTYPE;
    tmp_rec                 BIGINT;
    match_set               INT;
BEGIN
    --ver1.0
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.authority_match WHERE queued_record = NEW.id;

    SELECT q.match_set INTO match_set FROM vandelay.authority_queue q WHERE q.id = NEW.queue;

    IF match_set IS NOT NULL THEN
        NEW.quality := vandelay.measure_record_quality( NEW.marc, match_set );
    END IF;

    -- Perfect matches on 901$c exit early with a match with high quality.
    incoming_existing_id :=
        oils_xpath_string('//*[@tag="901"]/*[@code="c"][1]', NEW.marc);

    IF incoming_existing_id IS NOT NULL AND incoming_existing_id != '' THEN
        SELECT id INTO tmp_rec FROM authority.record_entry WHERE id = incoming_existing_id::bigint;
        IF tmp_rec IS NOT NULL THEN
            INSERT INTO vandelay.authority_match (queued_record, eg_record, match_score, quality)
                SELECT
                    NEW.id,
                    b.id,
                    9999,
                    vandelay.measure_record_quality( b.marc, match_set )
                FROM authority.record_entry b
                WHERE id = incoming_existing_id::bigint;
        END IF;
    END IF;

    IF match_set IS NULL THEN
        RETURN NEW;
    END IF;

    FOR test_result IN SELECT * FROM
        vandelay.match_set_test_marcxml_auth(match_set, NEW.marc) LOOP

        INSERT INTO vandelay.authority_match ( queued_record, eg_record, match_score, quality )
            SELECT
                NEW.id,
                test_result.record,
                test_result.quality,
                vandelay.measure_record_quality( b.marc, match_set )
	        FROM  authority.record_entry b
	        WHERE id = test_result.record;

    END LOOP;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION vandelay.match_auth_record() OWNER TO evergreen;

--
-- Name: match_authority_record(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.match_authority_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    incoming_existing_id    TEXT;
    test_result             vandelay.match_set_test_result%ROWTYPE;
    tmp_rec                 BIGINT;
    match_set               INT;
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.authority_match WHERE queued_record = NEW.id;

    SELECT q.match_set INTO match_set FROM vandelay.authority_queue q WHERE q.id = NEW.queue;

    IF match_set IS NOT NULL THEN
        NEW.quality := vandelay.measure_auth_record_quality( NEW.marc, match_set );
    END IF;

    -- Perfect matches on 901$c exit early with a match with high quality.
    incoming_existing_id :=
        oils_xpath_string('//*[@tag="901"]/*[@code="c"][1]', NEW.marc);

    IF incoming_existing_id IS NOT NULL AND incoming_existing_id != '' THEN
        SELECT id INTO tmp_rec FROM authority.record_entry WHERE id = incoming_existing_id::bigint;
        IF tmp_rec IS NOT NULL THEN
            INSERT INTO vandelay.authority_match (queued_record, eg_record, match_score, quality) 
                SELECT
                    NEW.id, 
                    b.id,
                    9999,
                    -- note: no match_set means quality==0
                    vandelay.measure_auth_record_quality( b.marc, match_set )
                FROM authority.record_entry b
                WHERE id = incoming_existing_id::bigint;
        END IF;
    END IF;

    IF match_set IS NULL THEN
        RETURN NEW;
    END IF;

    FOR test_result IN SELECT * FROM
        vandelay.match_set_test_authxml(match_set, NEW.marc) LOOP

        INSERT INTO vandelay.authority_match ( queued_record, eg_record, match_score, quality )
            SELECT  
                NEW.id,
                test_result.record,
                test_result.quality,
                vandelay.measure_auth_record_quality( b.marc, match_set )
	        FROM  authority.record_entry b
	        WHERE id = test_result.record;

    END LOOP;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION vandelay.match_authority_record() OWNER TO evergreen;

--
-- Name: match_bib_record(); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.match_bib_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    incoming_existing_id    TEXT;
    test_result             vandelay.match_set_test_result%ROWTYPE;
    tmp_rec                 BIGINT;
    match_set               INT;
    match_bucket            INT;
BEGIN
    IF TG_OP IN ('INSERT','UPDATE') AND NEW.imported_as IS NOT NULL THEN
        RETURN NEW;
    END IF;

    DELETE FROM vandelay.bib_match WHERE queued_record = NEW.id;

    SELECT q.match_set INTO match_set FROM vandelay.bib_queue q WHERE q.id = NEW.queue;

    IF match_set IS NOT NULL THEN
        NEW.quality := vandelay.measure_record_quality( NEW.marc, match_set );
    END IF;

    -- Perfect matches on 901$c exit early with a match with high quality.
    incoming_existing_id :=
        oils_xpath_string('//*[@tag="901"]/*[@code="c"][1]', NEW.marc);

    IF incoming_existing_id IS NOT NULL AND incoming_existing_id != '' THEN
        SELECT id INTO tmp_rec FROM biblio.record_entry WHERE id = incoming_existing_id::bigint;
        IF tmp_rec IS NOT NULL THEN
            INSERT INTO vandelay.bib_match (queued_record, eg_record, match_score, quality) 
                SELECT
                    NEW.id, 
                    b.id,
                    9999,
                    -- note: no match_set means quality==0
                    vandelay.measure_record_quality( b.marc, match_set )
                FROM biblio.record_entry b
                WHERE id = incoming_existing_id::bigint;
        END IF;
    END IF;

    IF match_set IS NULL THEN
        RETURN NEW;
    END IF;

    SELECT q.match_bucket INTO match_bucket FROM vandelay.bib_queue q WHERE q.id = NEW.queue;

    FOR test_result IN SELECT * FROM
        vandelay.match_set_test_marcxml(match_set, NEW.marc, match_bucket) LOOP

        INSERT INTO vandelay.bib_match ( queued_record, eg_record, match_score, quality )
            SELECT  
                NEW.id,
                test_result.record,
                test_result.quality,
                vandelay.measure_record_quality( b.marc, match_set )
	        FROM  biblio.record_entry b
	        WHERE id = test_result.record;

    END LOOP;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION vandelay.match_bib_record() OWNER TO evergreen;

--
-- Name: match_set_test_authxml(integer, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.match_set_test_authxml(match_set_id integer, record_xml text) RETURNS SETOF vandelay.match_set_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    tags_rstore HSTORE;
    heading     TEXT;
    coal        TEXT;
    joins       TEXT;
    query_      TEXT;
    wq          TEXT;
    qvalue      INTEGER;
    rec         RECORD;
BEGIN
    tags_rstore := vandelay.flatten_marc_hstore(record_xml);

    SELECT normalize_heading INTO heading 
        FROM authority.normalize_heading(record_xml);

    CREATE TEMPORARY TABLE _vandelay_tmp_qrows (q INTEGER);
    CREATE TEMPORARY TABLE _vandelay_tmp_jrows (j TEXT);

    -- generate the where clause and return that directly (into wq), and as
    -- a side-effect, populate the _vandelay_tmp_[qj]rows tables.
    wq := vandelay.get_expr_from_match_set(
        match_set_id, tags_rstore, heading);

    query_ := 'SELECT DISTINCT(record), ';

    -- qrows table is for the quality bits we add to the SELECT clause
    SELECT STRING_AGG(
        'COALESCE(n' || q::TEXT || '.quality, 0)', ' + '
    ) INTO coal FROM _vandelay_tmp_qrows;

    -- our query string so far is the SELECT clause and the inital FROM.
    -- no JOINs yet nor the WHERE clause
    query_ := query_ || coal || ' AS quality ' || E'\n';

    -- jrows table is for the joins we must make (and the real text conditions)
    SELECT STRING_AGG(j, E'\n') INTO joins
        FROM _vandelay_tmp_jrows;

    -- add those joins and the where clause to our query.
    query_ := query_ || joins || E'\n';

    query_ := query_ || 'JOIN authority.record_entry are ON (are.id = record) ' 
        || 'WHERE ' || wq || ' AND not are.deleted';

    -- this will return rows of record,quality
    FOR rec IN EXECUTE query_ USING tags_rstore LOOP
        RETURN NEXT rec;
    END LOOP;

    DROP TABLE _vandelay_tmp_qrows;
    DROP TABLE _vandelay_tmp_jrows;
    RETURN;
END;
$$;


ALTER FUNCTION vandelay.match_set_test_authxml(match_set_id integer, record_xml text) OWNER TO evergreen;

--
-- Name: match_set_test_marcxml(integer, text, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.match_set_test_marcxml(match_set_id integer, record_xml text, bucket_id integer) RETURNS SETOF vandelay.match_set_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    tags_rstore HSTORE;
    svf_rstore  HSTORE;
    coal        TEXT;
    joins       TEXT;
    query_      TEXT;
    wq          TEXT;
    qvalue      INTEGER;
    rec         RECORD;
BEGIN
    tags_rstore := vandelay.flatten_marc_hstore(record_xml);
    svf_rstore := vandelay.extract_rec_attrs(record_xml);

    CREATE TEMPORARY TABLE _vandelay_tmp_qrows (q INTEGER);
    CREATE TEMPORARY TABLE _vandelay_tmp_jrows (j TEXT);

    -- generate the where clause and return that directly (into wq), and as
    -- a side-effect, populate the _vandelay_tmp_[qj]rows tables.
    wq := vandelay.get_expr_from_match_set(match_set_id, tags_rstore);

    query_ := 'SELECT DISTINCT(record), ';

    -- qrows table is for the quality bits we add to the SELECT clause
    SELECT STRING_AGG(
        'COALESCE(n' || q::TEXT || '.quality, 0)', ' + '
    ) INTO coal FROM _vandelay_tmp_qrows;

    -- our query string so far is the SELECT clause and the inital FROM.
    -- no JOINs yet nor the WHERE clause
    query_ := query_ || coal || ' AS quality ' || E'\n';

    -- jrows table is for the joins we must make (and the real text conditions)
    SELECT STRING_AGG(j, E'\n') INTO joins
        FROM _vandelay_tmp_jrows;

    -- add those joins and the where clause to our query.
    query_ := query_ || joins || E'\n';

    -- join the record bucket
    IF bucket_id IS NOT NULL THEN
        query_ := query_ || 'JOIN container.biblio_record_entry_bucket_item ' ||
            'brebi ON (brebi.target_biblio_record_entry = record ' ||
            'AND brebi.bucket = ' || bucket_id || E')\n';
    END IF;

    query_ := query_ || 'JOIN biblio.record_entry bre ON (bre.id = record) ' || 'WHERE ' || wq || ' AND not bre.deleted';

    -- this will return rows of record,quality
    FOR rec IN EXECUTE query_ USING tags_rstore, svf_rstore LOOP
        RETURN NEXT rec;
    END LOOP;

    DROP TABLE _vandelay_tmp_qrows;
    DROP TABLE _vandelay_tmp_jrows;
    RETURN;
END;
$$;


ALTER FUNCTION vandelay.match_set_test_marcxml(match_set_id integer, record_xml text, bucket_id integer) OWNER TO evergreen;

--
-- Name: match_set_test_marcxml_auth(integer, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.match_set_test_marcxml_auth(match_set_id integer, record_xml text) RETURNS SETOF vandelay.match_set_test_result
    LANGUAGE plpgsql
    AS $$
DECLARE
    tags_rstore HSTORE;
    svf_rstore  HSTORE;
    coal        TEXT;
    joins       TEXT;
    query_      TEXT;
    wq          TEXT;
    qvalue      INTEGER;
    rec         RECORD;
BEGIN
    --ver1.0
    tags_rstore := vandelay.flatten_marc_hstore(record_xml);
    svf_rstore := vandelay.extract_rec_attrs(record_xml);

    CREATE TEMPORARY TABLE _vandelay_tmp_qrows_auth (q INTEGER);
    CREATE TEMPORARY TABLE _vandelay_tmp_jrows_auth (j TEXT);

    -- generate the where clause and return that directly (into wq), and as
    -- a side-effect, populate the _vandelay_tmp_[qj]rows tables.
    wq := vandelay.get_expr_from_match_set_auth(match_set_id, tags_rstore);

    query_ := 'SELECT DISTINCT(record), ';

    -- qrows table is for the quality bits we add to the SELECT clause
    SELECT ARRAY_TO_STRING(
        array_agg('COALESCE(n' || q::TEXT || '.quality, 0)'), ' + '
    ) INTO coal FROM _vandelay_tmp_qrows_auth;

    -- our query string so far is the SELECT clause and the inital FROM.
    -- no JOINs yet nor the WHERE clause
    query_ := query_ || coal || ' AS quality ' || E'\n';

    -- jrows table is for the joins we must make (and the real text conditions)
    SELECT ARRAY_TO_STRING(array_agg(j), E'\n') INTO joins
        FROM _vandelay_tmp_jrows_auth;

    -- add those joins and the where clause to our query.
    query_ := query_ || joins || E'\n' || 'JOIN authority.record_entry bre ON (bre.id = record) ' || 'WHERE ' || wq || ' AND not bre.deleted';

    -- this will return rows of record,quality
    FOR rec IN EXECUTE query_ USING tags_rstore, svf_rstore LOOP
        RETURN NEXT rec;
    END LOOP;

    DROP TABLE _vandelay_tmp_qrows_auth;
    DROP TABLE _vandelay_tmp_jrows_auth;
    RETURN;
END;

$$;


ALTER FUNCTION vandelay.match_set_test_marcxml_auth(match_set_id integer, record_xml text) OWNER TO evergreen;

--
-- Name: measure_auth_record_quality(text, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.measure_auth_record_quality(xml text, match_set_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    out_q   INT := 0;
    rvalue  TEXT;
    test    vandelay.match_set_quality%ROWTYPE;
BEGIN

    FOR test IN SELECT * FROM vandelay.match_set_quality 
            WHERE match_set = match_set_id LOOP
        IF test.tag IS NOT NULL THEN
            FOR rvalue IN SELECT value FROM vandelay.flatten_marc( xml ) 
                WHERE tag = test.tag AND subfield = test.subfield LOOP
                IF test.value = rvalue THEN
                    out_q := out_q + test.quality;
                END IF;
            END LOOP;
        END IF;
    END LOOP;

    RETURN out_q;
END;
$$;


ALTER FUNCTION vandelay.measure_auth_record_quality(xml text, match_set_id integer) OWNER TO evergreen;

--
-- Name: measure_record_quality(text, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.measure_record_quality(xml text, match_set_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    out_q   INT := 0;
    rvalue  TEXT;
    test    vandelay.match_set_quality%ROWTYPE;
BEGIN

    FOR test IN SELECT * FROM vandelay.match_set_quality WHERE match_set = match_set_id LOOP
        IF test.tag IS NOT NULL THEN
            FOR rvalue IN SELECT value FROM vandelay.flatten_marc( xml ) WHERE tag = test.tag AND subfield = test.subfield LOOP
                IF test.value = rvalue THEN
                    out_q := out_q + test.quality;
                END IF;
            END LOOP;
        ELSE
            IF test.value = vandelay.extract_rec_attrs(xml, ARRAY[test.svf]) -> test.svf THEN
                out_q := out_q + test.quality;
            END IF;
        END IF;
    END LOOP;

    RETURN out_q;
END;
$$;


ALTER FUNCTION vandelay.measure_record_quality(xml text, match_set_id integer) OWNER TO evergreen;

--
-- Name: merge_record_xml(text, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.merge_record_xml(target_marc text, template_marc text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    replace_rule    TEXT;
    tmp_marc        TEXT;
    trgt_marc        TEXT;
    tmpl_marc        TEXT;
    match_count     INT;
BEGIN

    IF target_marc IS NULL OR template_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for target or template record';
        RETURN NULL;
    END IF;

    dyn_profile := vandelay.compile_profile( template_marc );

    IF dyn_profile.replace_rule <> '' AND dyn_profile.preserve_rule <> '' THEN
        -- RAISE NOTICE 'both replace [%] and preserve [%] specified', dyn_profile.replace_rule, dyn_profile.preserve_rule;
        RETURN NULL;
    END IF;

    IF dyn_profile.replace_rule = '' AND dyn_profile.preserve_rule = '' AND dyn_profile.add_rule = '' THEN
        --Since we have nothing to do, just return what we were given.
        RETURN target_marc;
    ELSIF dyn_profile.replace_rule <> '' THEN
        trgt_marc = target_marc;
        tmpl_marc = template_marc;
        replace_rule = dyn_profile.replace_rule;
    ELSE
        tmp_marc = target_marc;
        trgt_marc = template_marc;
        tmpl_marc = tmp_marc;
        replace_rule = dyn_profile.preserve_rule;
    END IF;

    RETURN vandelay.merge_record_xml( trgt_marc, tmpl_marc, dyn_profile.add_rule, replace_rule, dyn_profile.strip_rule );

END;
$$;


ALTER FUNCTION vandelay.merge_record_xml(target_marc text, template_marc text) OWNER TO evergreen;

--
-- Name: merge_record_xml(text, text, text, text, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.merge_record_xml(target_xml text, source_xml text, add_rule text, replace_preserve_rule text, strip_rule text) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT vandelay.replace_field( vandelay.add_field( vandelay.strip_field( $1, $5) , $2, $3 ), $2, $4);
$_$;


ALTER FUNCTION vandelay.merge_record_xml(target_xml text, source_xml text, add_rule text, replace_preserve_rule text, strip_rule text) OWNER TO evergreen;

--
-- Name: merge_record_xml_using_profile(text, text, bigint); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.merge_record_xml_using_profile(incoming_marc text, existing_marc text, merge_profile_id bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    merge_profile   vandelay.merge_profile%ROWTYPE;
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    target_marc     TEXT;
    source_marc     TEXT;
    replace_rule    TEXT;
    match_count     INT;
BEGIN

    IF existing_marc IS NULL OR incoming_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for source or target records';
        RETURN NULL;
    END IF;

    IF merge_profile_id IS NOT NULL THEN
        SELECT * INTO merge_profile FROM vandelay.merge_profile WHERE id = merge_profile_id;
        IF FOUND THEN
            dyn_profile.add_rule := COALESCE(merge_profile.add_spec,'');
            dyn_profile.strip_rule := COALESCE(merge_profile.strip_spec,'');
            dyn_profile.replace_rule := COALESCE(merge_profile.replace_spec,'');
            dyn_profile.preserve_rule := COALESCE(merge_profile.preserve_spec,'');
        ELSE
            -- RAISE NOTICE 'merge profile not found';
            RETURN NULL;
        END IF;
    ELSE
        -- RAISE NOTICE 'no merge profile specified';
        RETURN NULL;
    END IF;

    IF dyn_profile.replace_rule <> '' AND dyn_profile.preserve_rule <> '' THEN
        -- RAISE NOTICE 'both replace [%] and preserve [%] specified', dyn_profile.replace_rule, dyn_profile.preserve_rule;
        RETURN NULL;
    END IF;

    IF dyn_profile.replace_rule = '' AND dyn_profile.preserve_rule = '' AND dyn_profile.add_rule = '' AND dyn_profile.strip_rule = '' THEN
        -- Since we have nothing to do, just return a target record as is
        RETURN existing_marc;
    ELSIF dyn_profile.preserve_rule <> '' THEN
        source_marc = existing_marc;
        target_marc = incoming_marc;
        replace_rule = dyn_profile.preserve_rule;
    ELSE
        source_marc = incoming_marc;
        target_marc = existing_marc;
        replace_rule = dyn_profile.replace_rule;
    END IF;

    RETURN vandelay.merge_record_xml( target_marc, source_marc, dyn_profile.add_rule, replace_rule, dyn_profile.strip_rule );

END;
$$;


ALTER FUNCTION vandelay.merge_record_xml_using_profile(incoming_marc text, existing_marc text, merge_profile_id bigint) OWNER TO evergreen;

--
-- Name: overlay_authority_record(bigint, bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.overlay_authority_record(import_id bigint, eg_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    merge_profile   vandelay.merge_profile%ROWTYPE;
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    editor_string   TEXT;
    new_editor      INT;
    new_edit_date   TIMESTAMPTZ;
    source_marc     TEXT;
    target_marc     TEXT;
    eg_marc_row     authority.record_entry%ROWTYPE;
    eg_marc         TEXT;
    v_marc          TEXT;
    replace_rule    TEXT;
    match_count     INT;
    update_query    TEXT;
BEGIN

    SELECT  * INTO eg_marc_row
      FROM  authority.record_entry b
            JOIN vandelay.authority_match m ON (m.eg_record = b.id AND m.queued_record = import_id)
      LIMIT 1;

    SELECT  q.marc INTO v_marc
      FROM  vandelay.queued_record q
            JOIN vandelay.authority_match m ON (m.queued_record = q.id AND q.id = import_id)
      LIMIT 1;

    eg_marc := eg_marc_row.marc;

    IF eg_marc IS NULL OR v_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for vandelay or authority record';
        RETURN FALSE;
    END IF;

    -- Extract the editor string before any modification to the vandelay
    -- MARC occur.
    editor_string := 
        (oils_xpath('//*[@tag="905"]/*[@code="u"]/text()',v_marc))[1];

    -- If an editor value can be found, update the authority record
    -- editor and edit_date values.
    IF editor_string IS NOT NULL AND editor_string <> '' THEN

        -- Vandelay.pm sets the value to 'usrname' when needed.  
        SELECT id INTO new_editor
            FROM actor.usr WHERE usrname = editor_string;

        IF new_editor IS NULL THEN
            SELECT usr INTO new_editor
                FROM actor.card WHERE barcode = editor_string;
        END IF;

        IF new_editor IS NOT NULL THEN
            new_edit_date := NOW();
        ELSE -- No valid editor, use current values
            new_editor = eg_marc_row.editor;
            new_edit_date = eg_marc_row.edit_date;
        END IF;
    ELSE
        new_editor = eg_marc_row.editor;
        new_edit_date = eg_marc_row.edit_date;
    END IF;

    dyn_profile := vandelay.compile_profile( v_marc );

    IF merge_profile_id IS NOT NULL THEN
        SELECT * INTO merge_profile FROM vandelay.merge_profile WHERE id = merge_profile_id;
        IF FOUND THEN
            dyn_profile.add_rule := BTRIM( dyn_profile.add_rule || ',' || COALESCE(merge_profile.add_spec,''), ',');
            dyn_profile.strip_rule := BTRIM( dyn_profile.strip_rule || ',' || COALESCE(merge_profile.strip_spec,''), ',');
            dyn_profile.replace_rule := BTRIM( dyn_profile.replace_rule || ',' || COALESCE(merge_profile.replace_spec,''), ',');
            dyn_profile.preserve_rule := BTRIM( dyn_profile.preserve_rule || ',' || COALESCE(merge_profile.preserve_spec,''), ',');
        END IF;
    END IF;

    IF dyn_profile.replace_rule <> '' AND dyn_profile.preserve_rule <> '' THEN
        -- RAISE NOTICE 'both replace [%] and preserve [%] specified', dyn_profile.replace_rule, dyn_profile.preserve_rule;
        RETURN FALSE;
    END IF;

    IF dyn_profile.replace_rule = '' AND dyn_profile.preserve_rule = '' AND dyn_profile.add_rule = '' AND dyn_profile.strip_rule = '' THEN
        --Since we have nothing to do, just return a NOOP "we did it"
        RETURN TRUE;
    ELSIF dyn_profile.replace_rule <> '' THEN
        source_marc = v_marc;
        target_marc = eg_marc;
        replace_rule = dyn_profile.replace_rule;
    ELSE
        source_marc = eg_marc;
        target_marc = v_marc;
        replace_rule = dyn_profile.preserve_rule;
    END IF;

    UPDATE  authority.record_entry
      SET   marc = vandelay.merge_record_xml( target_marc, source_marc, dyn_profile.add_rule, replace_rule, dyn_profile.strip_rule ),
            editor = new_editor,
            edit_date = new_edit_date
      WHERE id = eg_id;

    IF NOT FOUND THEN 
        -- Import/merge failed.  Nothing left to do.
        RETURN FALSE;
    END IF;

    -- Authority record successfully merged / imported.

    -- Update the vandelay record to show the successful import.
    UPDATE  vandelay.queued_authority_record
      SET   imported_as = eg_id,
            import_time = NOW()
      WHERE id = import_id;

    RETURN TRUE;

END;
$$;


ALTER FUNCTION vandelay.overlay_authority_record(import_id bigint, eg_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: overlay_bib_record(bigint, bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.overlay_bib_record(import_id bigint, eg_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    editor_string   TEXT;
    editor_id       INT;
    v_marc          TEXT;
    v_bib_source    INT;
    update_fields   TEXT[];
    update_query    TEXT;
    update_bib_source BOOL;
    update_bib_editor BOOL;
BEGIN

    SELECT  q.marc, q.bib_source INTO v_marc, v_bib_source
      FROM  vandelay.queued_bib_record q
            JOIN vandelay.bib_match m ON (m.queued_record = q.id AND q.id = import_id)
      LIMIT 1;

    IF v_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for vandelay or bib record';
        RETURN FALSE;
    END IF;

    IF NOT vandelay.template_overlay_bib_record( v_marc, eg_id, merge_profile_id) THEN
        -- no update happened, get outta here.
        RETURN FALSE;
    END IF;

    UPDATE  vandelay.queued_bib_record
      SET   imported_as = eg_id,
            import_time = NOW()
      WHERE id = import_id;

    SELECT q.update_bib_source INTO update_bib_source 
        FROM vandelay.merge_profile q where q.id = merge_profile_Id;

    IF update_bib_source AND v_bib_source IS NOT NULL THEN
        update_fields := ARRAY_APPEND(update_fields, 'source = ' || v_bib_source);
    END IF;

    SELECT q.update_bib_editor INTO update_bib_editor 
        FROM vandelay.merge_profile q where q.id = merge_profile_Id;

    IF update_bib_editor THEN

        editor_string := (oils_xpath('//*[@tag="905"]/*[@code="u"]/text()',v_marc))[1];

        IF editor_string IS NOT NULL AND editor_string <> '' THEN
            SELECT usr INTO editor_id FROM actor.card WHERE barcode = editor_string;

            IF editor_id IS NULL THEN
                SELECT id INTO editor_id FROM actor.usr WHERE usrname = editor_string;
            END IF;

            IF editor_id IS NOT NULL THEN
                --only update the edit date if we have a valid editor
                update_fields := ARRAY_APPEND(
                    update_fields, 'editor = ' || editor_id || ', edit_date = NOW()');
            END IF;
        END IF;
    END IF;

    IF ARRAY_LENGTH(update_fields, 1) > 0 THEN
        update_query := 'UPDATE biblio.record_entry SET ' || 
            ARRAY_TO_STRING(update_fields, ',') || ' WHERE id = ' || eg_id || ';';
        EXECUTE update_query;
    END IF;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION vandelay.overlay_bib_record(import_id bigint, eg_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: replace_field(text, text, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.replace_field(target_xml text, source_xml text, field text) RETURNS text
    LANGUAGE plperlu
    AS $_X$

    use strict;
    use MARC::Record;
    use MARC::Field;
    use MARC::File::XML (BinaryEncoding => 'UTF-8');
    use MARC::Charset;

    MARC::Charset->assume_unicode(1);

    my $target_xml = shift;
    my $source_xml = shift;
    my $field_spec = shift;

    my $target_r = MARC::Record->new_from_xml($target_xml);
    my $source_r = MARC::Record->new_from_xml($source_xml);

    return $target_xml unless $target_r && $source_r;

    # Extract the field_spec components into MARC tags, subfields, 
    # and regex matches.  Copied wholesale from vandelay.strip_field()

    my @field_list = split(',', $field_spec);
    my %fields;
    for my $f (@field_list) {
        $f =~ s/^\s*//; $f =~ s/\s*$//;
        if ($f =~ /^(.{3})(\w*)(?:\[([^]]*)\])?$/) {
            my $field = $1;
            $field =~ s/\s+//;
            my $sf = $2;
            $sf =~ s/\s+//;
            my $match = $3;
            $match =~ s/^\s*//; $match =~ s/\s*$//;
            $fields{$field} = { sf => [ split('', $sf) ] };
            if ($match) {
                my ($msf,$mre) = split('~', $match);
                if (length($msf) > 0 and length($mre) > 0) {
                    $msf =~ s/^\s*//; $msf =~ s/\s*$//;
                    $mre =~ s/^\s*//; $mre =~ s/\s*$//;
                    $fields{$field}{match} = { sf => $msf, re => qr/$mre/ };
                }
            }
        }
    }

    # Returns a flat list of subfield (code, value, code, value, ...)
    # suitable for adding to a MARC::Field.
    sub generate_replacement_subfields {
        my ($source_field, $target_field, @controlled_subfields) = @_;

        # Performing a wholesale field replacment.  
        # Use the entire source field as-is.
        return map {$_->[0], $_->[1]} $source_field->subfields
            unless @controlled_subfields;

        my @new_subfields;

        # Iterate over all target field subfields:
        # 1. Keep uncontrolled subfields as is.
        # 2. Replace values for controlled subfields when a
        #    replacement value exists on the source record.
        # 3. Delete values for controlled subfields when no 
        #    replacement value exists on the source record.

        for my $target_sf ($target_field->subfields) {
            my $subfield = $target_sf->[0];
            my $target_val = $target_sf->[1];

            if (grep {$_ eq $subfield} @controlled_subfields) {
                if (my $source_val = $source_field->subfield($subfield)) {
                    # We have a replacement value
                    push(@new_subfields, $subfield, $source_val);
                } else {
                    # no replacement value for controlled subfield, drop it.
                }
            } else {
                # Field is not controlled.  Copy it over as-is.
                push(@new_subfields, $subfield, $target_val);
            }
        }

        # Iterate over all subfields in the source field and back-fill
        # any values that exist only in the source field.  Insert these
        # subfields in the same relative position they exist in the
        # source field.
                
        my @seen_subfields;
        for my $source_sf ($source_field->subfields) {
            my $subfield = $source_sf->[0];
            my $source_val = $source_sf->[1];
            push(@seen_subfields, $subfield);

            # target field already contains this subfield, 
            # so it would have been addressed above.
            next if $target_field->subfield($subfield);

            # Ignore uncontrolled subfields.
            next unless grep {$_ eq $subfield} @controlled_subfields;

            # Adding a new subfield.  Find its relative position and add
            # it to the list under construction.  Work backwards from
            # the list of already seen subfields to find the best slot.

            my $done = 0;
            for my $seen_sf (reverse(@seen_subfields)) {
                my $idx = @new_subfields;
                for my $new_sf (reverse(@new_subfields)) {
                    $idx--;
                    next if $idx % 2 == 1; # sf codes are in the even slots

                    if ($new_subfields[$idx] eq $seen_sf) {
                        splice(@new_subfields, $idx + 2, 0, $subfield, $source_val);
                        $done = 1;
                        last;
                    }
                }
                last if $done;
            }

            # if no slot was found, add to the end of the list.
            push(@new_subfields, $subfield, $source_val) unless $done;
        }

        return @new_subfields;
    }

    # MARC tag loop
    for my $f (keys %fields) {

        # Loop over affected tags in the target record
        my $tag_idx = -1;
        for my $target_field ($target_r->field($f)) {

            # field spec contains a regex for this field.  Confirm field on 
            # target record matches the specified regex before replacing.
            if (exists($fields{$f}{match})) {
                next unless (grep { $_ =~ $fields{$f}{match}{re} } 
                    $target_field->subfield($fields{$f}{match}{sf}));
            }

            my @new_subfields;
            my @controlled_subfields = @{$fields{$f}{sf}};

            # If the target record has multiple matching bib fields,
            # replace them from matching fields on the source record
            # in a predictable order to avoid replacing with them with
            # same source field repeatedly.
            my @source_fields = $source_r->field($f);
            my $source_field = $source_fields[++$tag_idx];

            if (!$source_field && @controlled_subfields) {
                # When there are more target fields than source fields
                # and we are replacing values for subfields and not
                # performing wholesale field replacment, use the last
                # available source field as the input for all remaining
                # target fields.
                $source_field = $source_fields[$#source_fields];
            }

            if (!$source_field) {
                # No source field exists.  Delete all affected target
                # data.  This is a little bit counterintuitive, but is
                # backwards compatible with the previous version of this
                # function which first deleted all affected data, then
                # replaced values where possible.
                if (@controlled_subfields) {
                    $target_field->delete_subfield($_) for @controlled_subfields;
                } else {
                    $target_r->delete_field($target_field);
                }
                next;
            }

            my @new_subfields = generate_replacement_subfields(
                $source_field, $target_field, @controlled_subfields);

            # Build the replacement field from scratch.  
            my $replacement_field = MARC::Field->new(
                $target_field->tag,
                $target_field->indicator(1),
                $target_field->indicator(2),
                @new_subfields
            );

            $target_field->replace_with($replacement_field);
        }

        # ---
        # Handle cases where there are more fields on the source
        # record than the target record.

        # Skip overflow fields when a regex is defined since there 
        # will be no target fields to compare the regex to.
        next if exists($fields{$f}{match});

        # Loop over affected tags in source record and copy any overlow
        # fields wholesale into the target record, regardless of whether
        # the replace rule specifies subfields.
        # Note insert_fields_ordered() will put the overflow fields
        # directly in front of any existing with the same tag.

        my @source_fields = $source_r->field($f);
        my @target_fields = $target_r->field($f);
        my $sf_count = scalar(@source_fields);
        my $tf_count = scalar(@target_fields);
        my $cp_index = $tf_count;
        while ($cp_index < $sf_count) {
            my $s_field = $source_fields[$cp_index];
            $target_r->insert_fields_ordered($s_field->clone);
            $cp_index++;
        }
    }

    $target_xml = $target_r->as_xml_record;
    $target_xml =~ s/^<\?.+?\?>$//mo;
    $target_xml =~ s/\n//sgo;
    $target_xml =~ s/>\s+</></sgo;

    return $target_xml;

$_X$;


ALTER FUNCTION vandelay.replace_field(target_xml text, source_xml text, field text) OWNER TO evergreen;

--
-- Name: strip_field(text, text); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.strip_field(xml text, field text) RETURNS text
    LANGUAGE plperlu
    AS $_X$

    use MARC::Record;
    use MARC::File::XML (BinaryEncoding => 'UTF-8');
    use MARC::Charset;
    use strict;

    MARC::Charset->assume_unicode(1);

    my $xml = shift;
    my $r = MARC::Record->new_from_xml( $xml );

    return $xml unless ($r);

    my $field_spec = shift;
    my @field_list = split(',', $field_spec);

    my %fields;
    for my $f (@field_list) {
        $f =~ s/^\s*//; $f =~ s/\s*$//;
        if ($f =~ /^(.{3})(\w*)(?:\[([^]]*)\])?$/) {
            my $field = $1;
            $field =~ s/\s+//;
            my $sf = $2;
            $sf =~ s/\s+//;
            my $matches = $3;
            $matches =~ s/^\s*//; $matches =~ s/\s*$//;
            $fields{$field} = { sf => [ split('', $sf) ] };
            if ($matches) {
                for my $match (split('&&', $matches)) {
                    $match =~ s/^\s*//; $match =~ s/\s*$//;
                    my ($msf,$mre) = split('~', $match);
                    if (length($msf) > 0 and length($mre) > 0) {
                        $msf =~ s/^\s*//; $msf =~ s/\s*$//;
                        $mre =~ s/^\s*//; $mre =~ s/\s*$//;
                        $fields{$field}{match}{$msf} = qr/$mre/;
                    }
                }
            }
        }
    }

    for my $f ( keys %fields) {
        for my $to_field ($r->field( $f )) {
            if (exists($fields{$f}{match})) {
                my @match_list = grep { $to_field->subfield($_) =~ $fields{$f}{match}{$_} } keys %{$fields{$f}{match}};
                next unless (scalar(@match_list) == scalar(keys %{$fields{$f}{match}}));
            }

            if ( @{$fields{$f}{sf}} ) {
                $to_field->delete_subfield(code => $fields{$f}{sf});
            } else {
                $r->delete_field( $to_field );
            }
        }
    }

    $xml = $r->as_xml_record;
    $xml =~ s/^<\?.+?\?>$//mo;
    $xml =~ s/\n//sgo;
    $xml =~ s/>\s+</></sgo;

    return $xml;

$_X$;


ALTER FUNCTION vandelay.strip_field(xml text, field text) OWNER TO evergreen;

--
-- Name: template_overlay_bib_record(text, bigint); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.template_overlay_bib_record(v_marc text, eg_id bigint) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT vandelay.template_overlay_bib_record( $1, $2, NULL);
$_$;


ALTER FUNCTION vandelay.template_overlay_bib_record(v_marc text, eg_id bigint) OWNER TO evergreen;

--
-- Name: template_overlay_bib_record(text, bigint, integer); Type: FUNCTION; Schema: vandelay; Owner: evergreen
--

CREATE FUNCTION vandelay.template_overlay_bib_record(v_marc text, eg_id bigint, merge_profile_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    merge_profile   vandelay.merge_profile%ROWTYPE;
    dyn_profile     vandelay.compile_profile%ROWTYPE;
    editor_string   TEXT;
    editor_id       INT;
    source_marc     TEXT;
    target_marc     TEXT;
    eg_marc         TEXT;
    replace_rule    TEXT;
    match_count     INT;
BEGIN

    SELECT  b.marc INTO eg_marc
      FROM  biblio.record_entry b
      WHERE b.id = eg_id
      LIMIT 1;

    IF eg_marc IS NULL OR v_marc IS NULL THEN
        -- RAISE NOTICE 'no marc for template or bib record';
        RETURN FALSE;
    END IF;

    dyn_profile := vandelay.compile_profile( v_marc );

    IF merge_profile_id IS NOT NULL THEN
        SELECT * INTO merge_profile FROM vandelay.merge_profile WHERE id = merge_profile_id;
        IF FOUND THEN
            dyn_profile.add_rule := BTRIM( dyn_profile.add_rule || ',' || COALESCE(merge_profile.add_spec,''), ',');
            dyn_profile.strip_rule := BTRIM( dyn_profile.strip_rule || ',' || COALESCE(merge_profile.strip_spec,''), ',');
            dyn_profile.replace_rule := BTRIM( dyn_profile.replace_rule || ',' || COALESCE(merge_profile.replace_spec,''), ',');
            dyn_profile.preserve_rule := BTRIM( dyn_profile.preserve_rule || ',' || COALESCE(merge_profile.preserve_spec,''), ',');
        END IF;
    END IF;

    IF dyn_profile.replace_rule <> '' AND dyn_profile.preserve_rule <> '' THEN
        -- RAISE NOTICE 'both replace [%] and preserve [%] specified', dyn_profile.replace_rule, dyn_profile.preserve_rule;
        RETURN FALSE;
    END IF;

    IF dyn_profile.replace_rule = '' AND dyn_profile.preserve_rule = '' AND dyn_profile.add_rule = '' AND dyn_profile.strip_rule = '' THEN
        --Since we have nothing to do, just return a NOOP "we did it"
        RETURN TRUE;
    ELSIF dyn_profile.replace_rule <> '' THEN
        source_marc = v_marc;
        target_marc = eg_marc;
        replace_rule = dyn_profile.replace_rule;
    ELSE
        source_marc = eg_marc;
        target_marc = v_marc;
        replace_rule = dyn_profile.preserve_rule;
    END IF;

    UPDATE  biblio.record_entry
      SET   marc = vandelay.merge_record_xml( target_marc, source_marc, dyn_profile.add_rule, replace_rule, dyn_profile.strip_rule )
      WHERE id = eg_id;

    IF NOT FOUND THEN
        -- RAISE NOTICE 'update of biblio.record_entry failed';
        RETURN FALSE;
    END IF;

    RETURN TRUE;

END;
$$;


ALTER FUNCTION vandelay.template_overlay_bib_record(v_marc text, eg_id bigint, merge_profile_id integer) OWNER TO evergreen;

--
-- Name: agg_text(text); Type: AGGREGATE; Schema: public; Owner: evergreen
--

CREATE AGGREGATE public.agg_text(text) (
    SFUNC = public.text_concat,
    STYPE = text
);


ALTER AGGREGATE public.agg_text(text) OWNER TO evergreen;

--
-- Name: agg_tsvector(tsvector); Type: AGGREGATE; Schema: public; Owner: evergreen
--

CREATE AGGREGATE public.agg_tsvector(tsvector) (
    SFUNC = public.tsvector_concat,
    STYPE = tsvector
);


ALTER AGGREGATE public.agg_tsvector(tsvector) OWNER TO evergreen;

--
-- Name: first(anyelement); Type: AGGREGATE; Schema: public; Owner: evergreen
--

CREATE AGGREGATE public.first(anyelement) (
    SFUNC = public.first_agg,
    STYPE = anyelement
);


ALTER AGGREGATE public.first(anyelement) OWNER TO evergreen;

--
-- Name: last(anyelement); Type: AGGREGATE; Schema: public; Owner: evergreen
--

CREATE AGGREGATE public.last(anyelement) (
    SFUNC = public.last_agg,
    STYPE = anyelement
);


ALTER AGGREGATE public.last(anyelement) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ean13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.isbn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.issn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.isbn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ismn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.issn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ean13,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.upc,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.issn,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.issn,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.issn, public.issn) OWNER TO evergreen;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.< (
    PROCEDURE = public.isnlt,
    LEFTARG = public.upc,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.upc, public.upc) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ean13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.isbn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.issn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.isbn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ismn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.issn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ean13,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.upc,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.issn,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.issn,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.issn, public.issn) OWNER TO evergreen;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.isnle,
    LEFTARG = public.upc,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.upc, public.upc) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ean13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.isbn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.issn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.isbn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ismn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.issn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ean13,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.upc,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.issn,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.issn,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.issn, public.issn) OWNER TO evergreen;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.isnne,
    LEFTARG = public.upc,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.upc, public.upc) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ean13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.isbn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.issn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.isbn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ismn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.issn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.upc,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ean13,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.issn,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.issn,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.issn, public.issn) OWNER TO evergreen;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.= (
    PROCEDURE = public.isneq,
    LEFTARG = public.upc,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.upc, public.upc) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ean13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.isbn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.issn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.isbn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ismn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.issn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.upc,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ean13,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.issn,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.issn,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.issn, public.issn) OWNER TO evergreen;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.> (
    PROCEDURE = public.isngt,
    LEFTARG = public.upc,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.upc, public.upc) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ean13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ean13, public.ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ean13, public.isbn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.isbn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.isbn13, public.ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ean13, public.ismn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ismn13, public.ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ean13, public.issn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.issn13,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.issn13, public.ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ean13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ean13, public.isbn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.isbn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.isbn, public.ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ean13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ean13, public.ismn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ismn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ismn, public.ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ean13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ean13, public.issn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.issn,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.issn, public.ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ean13,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ean13, public.upc) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.upc,
    RIGHTARG = public.ean13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.upc, public.ean13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.isbn13, public.isbn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.isbn13,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.isbn13, public.isbn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.isbn, public.isbn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.isbn,
    RIGHTARG = public.isbn,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.isbn, public.isbn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ismn13, public.ismn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ismn13,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ismn13, public.ismn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ismn, public.ismn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.ismn,
    RIGHTARG = public.ismn,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ismn, public.ismn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.issn13, public.issn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.issn13,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.issn13, public.issn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.issn,
    RIGHTARG = public.issn13,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.issn, public.issn13) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.issn,
    RIGHTARG = public.issn,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.issn, public.issn) OWNER TO evergreen;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: evergreen
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.isnge,
    LEFTARG = public.upc,
    RIGHTARG = public.upc,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.upc, public.upc) OWNER TO evergreen;

--
-- Name: isn_ops; Type: OPERATOR FAMILY; Schema: public; Owner: evergreen
--

CREATE OPERATOR FAMILY public.isn_ops USING btree;
ALTER OPERATOR FAMILY public.isn_ops USING btree ADD
    OPERATOR 1 public.<(public.ismn,public.ismn13) ,
    OPERATOR 1 public.<(public.ean13,public.isbn13) ,
    OPERATOR 1 public.<(public.upc,public.ean13) ,
    OPERATOR 1 public.<(public.issn13,public.issn) ,
    OPERATOR 1 public.<(public.issn13,public.ean13) ,
    OPERATOR 1 public.<(public.ean13,public.issn13) ,
    OPERATOR 1 public.<(public.ean13,public.isbn) ,
    OPERATOR 1 public.<(public.ean13,public.ismn) ,
    OPERATOR 1 public.<(public.ean13,public.issn) ,
    OPERATOR 1 public.<(public.ean13,public.upc) ,
    OPERATOR 1 public.<(public.isbn13,public.ean13) ,
    OPERATOR 1 public.<(public.ean13,public.ismn13) ,
    OPERATOR 1 public.<(public.isbn13,public.isbn) ,
    OPERATOR 1 public.<(public.issn,public.issn13) ,
    OPERATOR 1 public.<(public.issn,public.ean13) ,
    OPERATOR 1 public.<(public.isbn,public.ean13) ,
    OPERATOR 1 public.<(public.isbn,public.isbn13) ,
    OPERATOR 1 public.<(public.ismn13,public.ean13) ,
    OPERATOR 1 public.<(public.ismn13,public.ismn) ,
    OPERATOR 1 public.<(public.ismn,public.ean13) ,
    OPERATOR 2 public.<=(public.ean13,public.issn) ,
    OPERATOR 2 public.<=(public.ean13,public.isbn) ,
    OPERATOR 2 public.<=(public.ean13,public.ismn13) ,
    OPERATOR 2 public.<=(public.issn,public.ean13) ,
    OPERATOR 2 public.<=(public.upc,public.ean13) ,
    OPERATOR 2 public.<=(public.issn,public.issn13) ,
    OPERATOR 2 public.<=(public.issn13,public.issn) ,
    OPERATOR 2 public.<=(public.issn13,public.ean13) ,
    OPERATOR 2 public.<=(public.ismn,public.ismn13) ,
    OPERATOR 2 public.<=(public.ismn,public.ean13) ,
    OPERATOR 2 public.<=(public.ean13,public.ismn) ,
    OPERATOR 2 public.<=(public.ismn13,public.ismn) ,
    OPERATOR 2 public.<=(public.ean13,public.issn13) ,
    OPERATOR 2 public.<=(public.ismn13,public.ean13) ,
    OPERATOR 2 public.<=(public.ean13,public.isbn13) ,
    OPERATOR 2 public.<=(public.isbn,public.isbn13) ,
    OPERATOR 2 public.<=(public.isbn,public.ean13) ,
    OPERATOR 2 public.<=(public.isbn13,public.isbn) ,
    OPERATOR 2 public.<=(public.isbn13,public.ean13) ,
    OPERATOR 2 public.<=(public.ean13,public.upc) ,
    OPERATOR 3 public.=(public.ean13,public.upc) ,
    OPERATOR 3 public.=(public.isbn,public.isbn13) ,
    OPERATOR 3 public.=(public.isbn13,public.isbn) ,
    OPERATOR 3 public.=(public.ismn13,public.ean13) ,
    OPERATOR 3 public.=(public.issn13,public.issn) ,
    OPERATOR 3 public.=(public.ean13,public.ismn13) ,
    OPERATOR 3 public.=(public.ismn,public.ismn13) ,
    OPERATOR 3 public.=(public.ismn,public.ean13) ,
    OPERATOR 3 public.=(public.ean13,public.isbn13) ,
    OPERATOR 3 public.=(public.issn,public.issn13) ,
    OPERATOR 3 public.=(public.isbn,public.ean13) ,
    OPERATOR 3 public.=(public.ean13,public.issn) ,
    OPERATOR 3 public.=(public.ean13,public.ismn) ,
    OPERATOR 3 public.=(public.ean13,public.isbn) ,
    OPERATOR 3 public.=(public.issn,public.ean13) ,
    OPERATOR 3 public.=(public.ean13,public.issn13) ,
    OPERATOR 3 public.=(public.ismn13,public.ismn) ,
    OPERATOR 3 public.=(public.upc,public.ean13) ,
    OPERATOR 3 public.=(public.isbn13,public.ean13) ,
    OPERATOR 3 public.=(public.issn13,public.ean13) ,
    OPERATOR 4 public.>=(public.ismn,public.ean13) ,
    OPERATOR 4 public.>=(public.ismn13,public.ismn) ,
    OPERATOR 4 public.>=(public.ismn13,public.ean13) ,
    OPERATOR 4 public.>=(public.isbn,public.isbn13) ,
    OPERATOR 4 public.>=(public.issn,public.ean13) ,
    OPERATOR 4 public.>=(public.issn,public.issn13) ,
    OPERATOR 4 public.>=(public.issn13,public.ean13) ,
    OPERATOR 4 public.>=(public.issn13,public.issn) ,
    OPERATOR 4 public.>=(public.isbn,public.ean13) ,
    OPERATOR 4 public.>=(public.isbn13,public.isbn) ,
    OPERATOR 4 public.>=(public.isbn13,public.ean13) ,
    OPERATOR 4 public.>=(public.upc,public.ean13) ,
    OPERATOR 4 public.>=(public.ean13,public.upc) ,
    OPERATOR 4 public.>=(public.ean13,public.issn) ,
    OPERATOR 4 public.>=(public.ean13,public.ismn) ,
    OPERATOR 4 public.>=(public.ean13,public.isbn) ,
    OPERATOR 4 public.>=(public.ean13,public.issn13) ,
    OPERATOR 4 public.>=(public.ean13,public.ismn13) ,
    OPERATOR 4 public.>=(public.ean13,public.isbn13) ,
    OPERATOR 4 public.>=(public.ismn,public.ismn13) ,
    OPERATOR 5 public.>(public.issn,public.ean13) ,
    OPERATOR 5 public.>(public.isbn,public.ean13) ,
    OPERATOR 5 public.>(public.ismn13,public.ismn) ,
    OPERATOR 5 public.>(public.ean13,public.ismn) ,
    OPERATOR 5 public.>(public.ean13,public.issn) ,
    OPERATOR 5 public.>(public.ean13,public.upc) ,
    OPERATOR 5 public.>(public.upc,public.ean13) ,
    OPERATOR 5 public.>(public.isbn13,public.ean13) ,
    OPERATOR 5 public.>(public.ismn,public.ismn13) ,
    OPERATOR 5 public.>(public.ismn,public.ean13) ,
    OPERATOR 5 public.>(public.ismn13,public.ean13) ,
    OPERATOR 5 public.>(public.isbn,public.isbn13) ,
    OPERATOR 5 public.>(public.ean13,public.issn13) ,
    OPERATOR 5 public.>(public.ean13,public.ismn13) ,
    OPERATOR 5 public.>(public.ean13,public.isbn13) ,
    OPERATOR 5 public.>(public.isbn13,public.isbn) ,
    OPERATOR 5 public.>(public.issn13,public.issn) ,
    OPERATOR 5 public.>(public.issn13,public.ean13) ,
    OPERATOR 5 public.>(public.issn,public.issn13) ,
    OPERATOR 5 public.>(public.ean13,public.isbn) ,
    FUNCTION 1 (public.upc, public.ean13) public.btupccmp(public.upc,public.ean13) ,
    FUNCTION 1 (public.issn, public.issn13) public.btissncmp(public.issn,public.issn13) ,
    FUNCTION 1 (public.issn, public.ean13) public.btissncmp(public.issn,public.ean13) ,
    FUNCTION 1 (public.issn13, public.issn) public.btissn13cmp(public.issn13,public.issn) ,
    FUNCTION 1 (public.issn13, public.ean13) public.btissn13cmp(public.issn13,public.ean13) ,
    FUNCTION 1 (public.ismn, public.ismn13) public.btismncmp(public.ismn,public.ismn13) ,
    FUNCTION 1 (public.ismn, public.ean13) public.btismncmp(public.ismn,public.ean13) ,
    FUNCTION 1 (public.ismn13, public.ismn) public.btismn13cmp(public.ismn13,public.ismn) ,
    FUNCTION 1 (public.ismn13, public.ean13) public.btismn13cmp(public.ismn13,public.ean13) ,
    FUNCTION 1 (public.isbn, public.isbn13) public.btisbncmp(public.isbn,public.isbn13) ,
    FUNCTION 1 (public.isbn, public.ean13) public.btisbncmp(public.isbn,public.ean13) ,
    FUNCTION 1 (public.isbn13, public.isbn) public.btisbn13cmp(public.isbn13,public.isbn) ,
    FUNCTION 1 (public.isbn13, public.ean13) public.btisbn13cmp(public.isbn13,public.ean13) ,
    FUNCTION 1 (public.ean13, public.upc) public.btean13cmp(public.ean13,public.upc) ,
    FUNCTION 1 (public.ean13, public.issn) public.btean13cmp(public.ean13,public.issn) ,
    FUNCTION 1 (public.ean13, public.ismn) public.btean13cmp(public.ean13,public.ismn) ,
    FUNCTION 1 (public.ean13, public.isbn) public.btean13cmp(public.ean13,public.isbn) ,
    FUNCTION 1 (public.ean13, public.issn13) public.btean13cmp(public.ean13,public.issn13) ,
    FUNCTION 1 (public.ean13, public.ismn13) public.btean13cmp(public.ean13,public.ismn13) ,
    FUNCTION 1 (public.ean13, public.isbn13) public.btean13cmp(public.ean13,public.isbn13);


ALTER OPERATOR FAMILY public.isn_ops USING btree OWNER TO evergreen;

--
-- Name: ean13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.ean13_ops
    DEFAULT FOR TYPE public.ean13 USING btree FAMILY public.isn_ops AS
    OPERATOR 1 public.<(public.ean13,public.ean13) ,
    OPERATOR 2 public.<=(public.ean13,public.ean13) ,
    OPERATOR 3 public.=(public.ean13,public.ean13) ,
    OPERATOR 4 public.>=(public.ean13,public.ean13) ,
    OPERATOR 5 public.>(public.ean13,public.ean13) ,
    FUNCTION 1 (public.ean13, public.ean13) public.btean13cmp(public.ean13,public.ean13);


ALTER OPERATOR CLASS public.ean13_ops USING btree OWNER TO evergreen;

--
-- Name: isn_ops; Type: OPERATOR FAMILY; Schema: public; Owner: evergreen
--

CREATE OPERATOR FAMILY public.isn_ops USING hash;
ALTER OPERATOR FAMILY public.isn_ops USING hash ADD
    OPERATOR 1 public.=(public.ean13,public.isbn13) ,
    OPERATOR 1 public.=(public.ean13,public.ismn13) ,
    OPERATOR 1 public.=(public.ean13,public.issn13) ,
    OPERATOR 1 public.=(public.ean13,public.isbn) ,
    OPERATOR 1 public.=(public.ean13,public.ismn) ,
    OPERATOR 1 public.=(public.ean13,public.issn) ,
    OPERATOR 1 public.=(public.ean13,public.upc) ,
    OPERATOR 1 public.=(public.isbn13,public.ean13) ,
    OPERATOR 1 public.=(public.isbn13,public.isbn) ,
    OPERATOR 1 public.=(public.isbn,public.ean13) ,
    OPERATOR 1 public.=(public.isbn,public.isbn13) ,
    OPERATOR 1 public.=(public.ismn13,public.ean13) ,
    OPERATOR 1 public.=(public.ismn13,public.ismn) ,
    OPERATOR 1 public.=(public.ismn,public.ean13) ,
    OPERATOR 1 public.=(public.ismn,public.ismn13) ,
    OPERATOR 1 public.=(public.issn13,public.ean13) ,
    OPERATOR 1 public.=(public.issn13,public.issn) ,
    OPERATOR 1 public.=(public.issn,public.ean13) ,
    OPERATOR 1 public.=(public.issn,public.issn13) ,
    OPERATOR 1 public.=(public.upc,public.ean13);


ALTER OPERATOR FAMILY public.isn_ops USING hash OWNER TO evergreen;

--
-- Name: ean13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.ean13_ops
    DEFAULT FOR TYPE public.ean13 USING hash FAMILY public.isn_ops AS
    OPERATOR 1 public.=(public.ean13,public.ean13) ,
    FUNCTION 1 (public.ean13, public.ean13) public.hashean13(public.ean13);


ALTER OPERATOR CLASS public.ean13_ops USING hash OWNER TO evergreen;

--
-- Name: isbn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.isbn13_ops
    DEFAULT FOR TYPE public.isbn13 USING btree FAMILY public.isn_ops AS
    OPERATOR 1 public.<(public.isbn13,public.isbn13) ,
    OPERATOR 2 public.<=(public.isbn13,public.isbn13) ,
    OPERATOR 3 public.=(public.isbn13,public.isbn13) ,
    OPERATOR 4 public.>=(public.isbn13,public.isbn13) ,
    OPERATOR 5 public.>(public.isbn13,public.isbn13) ,
    FUNCTION 1 (public.isbn13, public.isbn13) public.btisbn13cmp(public.isbn13,public.isbn13);


ALTER OPERATOR CLASS public.isbn13_ops USING btree OWNER TO evergreen;

--
-- Name: isbn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.isbn13_ops
    DEFAULT FOR TYPE public.isbn13 USING hash FAMILY public.isn_ops AS
    OPERATOR 1 public.=(public.isbn13,public.isbn13) ,
    FUNCTION 1 (public.isbn13, public.isbn13) public.hashisbn13(public.isbn13);


ALTER OPERATOR CLASS public.isbn13_ops USING hash OWNER TO evergreen;

--
-- Name: isbn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.isbn_ops
    DEFAULT FOR TYPE public.isbn USING btree FAMILY public.isn_ops AS
    OPERATOR 1 public.<(public.isbn,public.isbn) ,
    OPERATOR 2 public.<=(public.isbn,public.isbn) ,
    OPERATOR 3 public.=(public.isbn,public.isbn) ,
    OPERATOR 4 public.>=(public.isbn,public.isbn) ,
    OPERATOR 5 public.>(public.isbn,public.isbn) ,
    FUNCTION 1 (public.isbn, public.isbn) public.btisbncmp(public.isbn,public.isbn);


ALTER OPERATOR CLASS public.isbn_ops USING btree OWNER TO evergreen;

--
-- Name: isbn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.isbn_ops
    DEFAULT FOR TYPE public.isbn USING hash FAMILY public.isn_ops AS
    OPERATOR 1 public.=(public.isbn,public.isbn) ,
    FUNCTION 1 (public.isbn, public.isbn) public.hashisbn(public.isbn);


ALTER OPERATOR CLASS public.isbn_ops USING hash OWNER TO evergreen;

--
-- Name: ismn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.ismn13_ops
    DEFAULT FOR TYPE public.ismn13 USING btree FAMILY public.isn_ops AS
    OPERATOR 1 public.<(public.ismn13,public.ismn13) ,
    OPERATOR 2 public.<=(public.ismn13,public.ismn13) ,
    OPERATOR 3 public.=(public.ismn13,public.ismn13) ,
    OPERATOR 4 public.>=(public.ismn13,public.ismn13) ,
    OPERATOR 5 public.>(public.ismn13,public.ismn13) ,
    FUNCTION 1 (public.ismn13, public.ismn13) public.btismn13cmp(public.ismn13,public.ismn13);


ALTER OPERATOR CLASS public.ismn13_ops USING btree OWNER TO evergreen;

--
-- Name: ismn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.ismn13_ops
    DEFAULT FOR TYPE public.ismn13 USING hash FAMILY public.isn_ops AS
    OPERATOR 1 public.=(public.ismn13,public.ismn13) ,
    FUNCTION 1 (public.ismn13, public.ismn13) public.hashismn13(public.ismn13);


ALTER OPERATOR CLASS public.ismn13_ops USING hash OWNER TO evergreen;

--
-- Name: ismn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.ismn_ops
    DEFAULT FOR TYPE public.ismn USING btree FAMILY public.isn_ops AS
    OPERATOR 1 public.<(public.ismn,public.ismn) ,
    OPERATOR 2 public.<=(public.ismn,public.ismn) ,
    OPERATOR 3 public.=(public.ismn,public.ismn) ,
    OPERATOR 4 public.>=(public.ismn,public.ismn) ,
    OPERATOR 5 public.>(public.ismn,public.ismn) ,
    FUNCTION 1 (public.ismn, public.ismn) public.btismncmp(public.ismn,public.ismn);


ALTER OPERATOR CLASS public.ismn_ops USING btree OWNER TO evergreen;

--
-- Name: ismn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.ismn_ops
    DEFAULT FOR TYPE public.ismn USING hash FAMILY public.isn_ops AS
    OPERATOR 1 public.=(public.ismn,public.ismn) ,
    FUNCTION 1 (public.ismn, public.ismn) public.hashismn(public.ismn);


ALTER OPERATOR CLASS public.ismn_ops USING hash OWNER TO evergreen;

--
-- Name: issn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.issn13_ops
    DEFAULT FOR TYPE public.issn13 USING btree FAMILY public.isn_ops AS
    OPERATOR 1 public.<(public.issn13,public.issn13) ,
    OPERATOR 2 public.<=(public.issn13,public.issn13) ,
    OPERATOR 3 public.=(public.issn13,public.issn13) ,
    OPERATOR 4 public.>=(public.issn13,public.issn13) ,
    OPERATOR 5 public.>(public.issn13,public.issn13) ,
    FUNCTION 1 (public.issn13, public.issn13) public.btissn13cmp(public.issn13,public.issn13);


ALTER OPERATOR CLASS public.issn13_ops USING btree OWNER TO evergreen;

--
-- Name: issn13_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.issn13_ops
    DEFAULT FOR TYPE public.issn13 USING hash FAMILY public.isn_ops AS
    OPERATOR 1 public.=(public.issn13,public.issn13) ,
    FUNCTION 1 (public.issn13, public.issn13) public.hashissn13(public.issn13);


ALTER OPERATOR CLASS public.issn13_ops USING hash OWNER TO evergreen;

--
-- Name: issn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.issn_ops
    DEFAULT FOR TYPE public.issn USING btree FAMILY public.isn_ops AS
    OPERATOR 1 public.<(public.issn,public.issn) ,
    OPERATOR 2 public.<=(public.issn,public.issn) ,
    OPERATOR 3 public.=(public.issn,public.issn) ,
    OPERATOR 4 public.>=(public.issn,public.issn) ,
    OPERATOR 5 public.>(public.issn,public.issn) ,
    FUNCTION 1 (public.issn, public.issn) public.btissncmp(public.issn,public.issn);


ALTER OPERATOR CLASS public.issn_ops USING btree OWNER TO evergreen;

--
-- Name: issn_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.issn_ops
    DEFAULT FOR TYPE public.issn USING hash FAMILY public.isn_ops AS
    OPERATOR 1 public.=(public.issn,public.issn) ,
    FUNCTION 1 (public.issn, public.issn) public.hashissn(public.issn);


ALTER OPERATOR CLASS public.issn_ops USING hash OWNER TO evergreen;

--
-- Name: upc_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.upc_ops
    DEFAULT FOR TYPE public.upc USING btree FAMILY public.isn_ops AS
    OPERATOR 1 public.<(public.upc,public.upc) ,
    OPERATOR 2 public.<=(public.upc,public.upc) ,
    OPERATOR 3 public.=(public.upc,public.upc) ,
    OPERATOR 4 public.>=(public.upc,public.upc) ,
    OPERATOR 5 public.>(public.upc,public.upc) ,
    FUNCTION 1 (public.upc, public.upc) public.btupccmp(public.upc,public.upc);


ALTER OPERATOR CLASS public.upc_ops USING btree OWNER TO evergreen;

--
-- Name: upc_ops; Type: OPERATOR CLASS; Schema: public; Owner: evergreen
--

CREATE OPERATOR CLASS public.upc_ops
    DEFAULT FOR TYPE public.upc USING hash FAMILY public.isn_ops AS
    OPERATOR 1 public.=(public.upc,public.upc) ,
    FUNCTION 1 (public.upc, public.upc) public.hashupc(public.upc);


ALTER OPERATOR CLASS public.upc_ops USING hash OWNER TO evergreen;

--
-- Name: danish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.danish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'danish' );


ALTER TEXT SEARCH DICTIONARY public.danish_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY danish_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.danish_nostop IS 'danish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: dutch_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.dutch_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'dutch' );


ALTER TEXT SEARCH DICTIONARY public.dutch_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY dutch_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.dutch_nostop IS 'dutch snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: english_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.english_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'english' );


ALTER TEXT SEARCH DICTIONARY public.english_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY english_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.english_nostop IS 'english snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: finnish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.finnish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'finnish' );


ALTER TEXT SEARCH DICTIONARY public.finnish_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY finnish_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.finnish_nostop IS 'finnish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: french_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.french_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'french' );


ALTER TEXT SEARCH DICTIONARY public.french_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY french_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.french_nostop IS 'french snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: german_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.german_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'german' );


ALTER TEXT SEARCH DICTIONARY public.german_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY german_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.german_nostop IS 'german snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: hungarian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.hungarian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'hungarian' );


ALTER TEXT SEARCH DICTIONARY public.hungarian_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY hungarian_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.hungarian_nostop IS 'hungarian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: italian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.italian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'italian' );


ALTER TEXT SEARCH DICTIONARY public.italian_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY italian_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.italian_nostop IS 'italian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: norwegian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.norwegian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'norwegian' );


ALTER TEXT SEARCH DICTIONARY public.norwegian_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY norwegian_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.norwegian_nostop IS 'norwegian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: portuguese_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.portuguese_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'portuguese' );


ALTER TEXT SEARCH DICTIONARY public.portuguese_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY portuguese_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.portuguese_nostop IS 'portuguese snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: romanian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.romanian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'romanian' );


ALTER TEXT SEARCH DICTIONARY public.romanian_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY romanian_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.romanian_nostop IS 'romanian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: russian_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.russian_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'russian' );


ALTER TEXT SEARCH DICTIONARY public.russian_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY russian_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.russian_nostop IS 'russian snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: spanish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.spanish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'spanish' );


ALTER TEXT SEARCH DICTIONARY public.spanish_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY spanish_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.spanish_nostop IS 'spanish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: swedish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.swedish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'swedish' );


ALTER TEXT SEARCH DICTIONARY public.swedish_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY swedish_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.swedish_nostop IS 'swedish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: turkish_nostop; Type: TEXT SEARCH DICTIONARY; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH DICTIONARY public.turkish_nostop (
    TEMPLATE = pg_catalog.snowball,
    language = 'turkish' );


ALTER TEXT SEARCH DICTIONARY public.turkish_nostop OWNER TO evergreen;

--
-- Name: TEXT SEARCH DICTIONARY turkish_nostop; Type: COMMENT; Schema: public; Owner: evergreen
--

COMMENT ON TEXT SEARCH DICTIONARY public.turkish_nostop IS 'turkish snowball stemmer with no stopwords for ASCII words only.';


--
-- Name: author; Type: TEXT SEARCH CONFIGURATION; Schema: evergreen; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION evergreen.author (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.author
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION evergreen.author OWNER TO evergreen;

--
-- Name: call_number; Type: TEXT SEARCH CONFIGURATION; Schema: evergreen; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION evergreen.call_number (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.call_number
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION evergreen.call_number OWNER TO evergreen;

--
-- Name: identifier; Type: TEXT SEARCH CONFIGURATION; Schema: evergreen; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION evergreen.identifier (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.identifier
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION evergreen.identifier OWNER TO evergreen;

--
-- Name: series; Type: TEXT SEARCH CONFIGURATION; Schema: evergreen; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION evergreen.series (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.series
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION evergreen.series OWNER TO evergreen;

--
-- Name: subject; Type: TEXT SEARCH CONFIGURATION; Schema: evergreen; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION evergreen.subject (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.subject
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION evergreen.subject OWNER TO evergreen;

--
-- Name: title; Type: TEXT SEARCH CONFIGURATION; Schema: evergreen; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION evergreen.title (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION evergreen.title
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION evergreen.title OWNER TO evergreen;

--
-- Name: author; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.author (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR asciiword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR hword_asciipart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR asciihword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.author
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.author OWNER TO evergreen;

--
-- Name: danish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.danish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR asciiword WITH public.danish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR hword_asciipart WITH public.danish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR asciihword WITH public.danish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.danish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.danish_nostop OWNER TO evergreen;

--
-- Name: default; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public."default" (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public."default"
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public."default" OWNER TO evergreen;

--
-- Name: dutch_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.dutch_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR asciiword WITH public.dutch_nostop;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR hword_asciipart WITH public.dutch_nostop;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR asciihword WITH public.dutch_nostop;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.dutch_nostop OWNER TO evergreen;

--
-- Name: english_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.english_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.english_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.english_nostop OWNER TO evergreen;

--
-- Name: finnish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.finnish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR asciiword WITH public.finnish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR hword_asciipart WITH public.finnish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR asciihword WITH public.finnish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.finnish_nostop OWNER TO evergreen;

--
-- Name: french_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.french_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR asciiword WITH public.french_nostop;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR hword_asciipart WITH public.french_nostop;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR asciihword WITH public.french_nostop;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.french_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.french_nostop OWNER TO evergreen;

--
-- Name: german_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.german_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR asciiword WITH public.german_nostop;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR hword_asciipart WITH public.german_nostop;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR asciihword WITH public.german_nostop;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.german_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.german_nostop OWNER TO evergreen;

--
-- Name: hungarian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.hungarian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR asciiword WITH public.hungarian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR hword_asciipart WITH public.hungarian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR asciihword WITH public.hungarian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.hungarian_nostop OWNER TO evergreen;

--
-- Name: italian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.italian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR asciiword WITH public.italian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR hword_asciipart WITH public.italian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR asciihword WITH public.italian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.italian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.italian_nostop OWNER TO evergreen;

--
-- Name: keyword; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.keyword (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR asciiword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR hword_asciipart WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR asciihword WITH public.english_nostop;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.keyword
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.keyword OWNER TO evergreen;

--
-- Name: norwegian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.norwegian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR asciiword WITH public.norwegian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR hword_asciipart WITH public.norwegian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR asciihword WITH public.norwegian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.norwegian_nostop OWNER TO evergreen;

--
-- Name: portuguese_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.portuguese_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR asciiword WITH public.portuguese_nostop;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR hword_asciipart WITH public.portuguese_nostop;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR asciihword WITH public.portuguese_nostop;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.portuguese_nostop OWNER TO evergreen;

--
-- Name: romanian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.romanian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR asciiword WITH public.romanian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR hword_asciipart WITH public.romanian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR asciihword WITH public.romanian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.romanian_nostop OWNER TO evergreen;

--
-- Name: russian_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.russian_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR asciiword WITH public.russian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR hword_asciipart WITH public.russian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR asciihword WITH public.russian_nostop;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.russian_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.russian_nostop OWNER TO evergreen;

--
-- Name: spanish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.spanish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR asciiword WITH public.spanish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR hword_asciipart WITH public.spanish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR asciihword WITH public.spanish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.spanish_nostop OWNER TO evergreen;

--
-- Name: subject; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.subject (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR asciiword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR hword_asciipart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR asciihword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.subject
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.subject OWNER TO evergreen;

--
-- Name: swedish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.swedish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR asciiword WITH public.swedish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR hword_asciipart WITH public.swedish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR asciihword WITH public.swedish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.swedish_nostop OWNER TO evergreen;

--
-- Name: title; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.title (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR asciiword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR hword_asciipart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR asciihword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.title
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.title OWNER TO evergreen;

--
-- Name: turkish_nostop; Type: TEXT SEARCH CONFIGURATION; Schema: public; Owner: evergreen
--

CREATE TEXT SEARCH CONFIGURATION public.turkish_nostop (
    PARSER = pg_catalog."default" );

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR asciiword WITH public.turkish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR word WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR numword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR email WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR url WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR host WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR sfloat WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR version WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR hword_numpart WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR hword_part WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR hword_asciipart WITH public.turkish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR numhword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR asciihword WITH public.turkish_nostop;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR hword WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR url_path WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR file WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR "float" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR "int" WITH simple;

ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop
    ADD MAPPING FOR uint WITH simple;


ALTER TEXT SEARCH CONFIGURATION public.turkish_nostop OWNER TO evergreen;

--
-- Name: acq_lineitem_history; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.acq_lineitem_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    selector integer NOT NULL,
    provider integer,
    purchase_order integer,
    picklist integer,
    expected_recv_time timestamp with time zone,
    create_time timestamp with time zone NOT NULL,
    edit_time timestamp with time zone NOT NULL,
    marc text NOT NULL,
    eg_bib_id bigint,
    source_label text,
    state text NOT NULL,
    cancel_reason integer,
    estimated_unit_price numeric,
    claim_policy integer,
    queued_record bigint
);


ALTER TABLE acq.acq_lineitem_history OWNER TO evergreen;

--
-- Name: lineitem; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.lineitem (
    id bigint NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    selector integer NOT NULL,
    provider integer,
    purchase_order integer,
    picklist integer,
    expected_recv_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    marc text NOT NULL,
    eg_bib_id bigint,
    source_label text,
    state text DEFAULT 'new'::text NOT NULL,
    cancel_reason integer,
    estimated_unit_price numeric,
    claim_policy integer,
    queued_record bigint,
    CONSTRAINT picklist_or_po CHECK (((picklist IS NOT NULL) OR (purchase_order IS NOT NULL)))
);


ALTER TABLE acq.lineitem OWNER TO evergreen;

--
-- Name: acq_lineitem_lifecycle; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.acq_lineitem_lifecycle AS
 SELECT '-1'::integer AS int4,
    now() AS audit_time,
    '-'::text AS audit_action,
    lineitem.id,
    lineitem.creator,
    lineitem.editor,
    lineitem.selector,
    lineitem.provider,
    lineitem.purchase_order,
    lineitem.picklist,
    lineitem.expected_recv_time,
    lineitem.create_time,
    lineitem.edit_time,
    lineitem.marc,
    lineitem.eg_bib_id,
    lineitem.source_label,
    lineitem.state,
    lineitem.cancel_reason,
    lineitem.estimated_unit_price,
    lineitem.claim_policy
   FROM acq.lineitem
UNION ALL
 SELECT acq_lineitem_history.audit_id AS int4,
    acq_lineitem_history.audit_time,
    acq_lineitem_history.audit_action,
    acq_lineitem_history.id,
    acq_lineitem_history.creator,
    acq_lineitem_history.editor,
    acq_lineitem_history.selector,
    acq_lineitem_history.provider,
    acq_lineitem_history.purchase_order,
    acq_lineitem_history.picklist,
    acq_lineitem_history.expected_recv_time,
    acq_lineitem_history.create_time,
    acq_lineitem_history.edit_time,
    acq_lineitem_history.marc,
    acq_lineitem_history.eg_bib_id,
    acq_lineitem_history.source_label,
    acq_lineitem_history.state,
    acq_lineitem_history.cancel_reason,
    acq_lineitem_history.estimated_unit_price,
    acq_lineitem_history.claim_policy
   FROM acq.acq_lineitem_history;


ALTER TABLE acq.acq_lineitem_lifecycle OWNER TO evergreen;

--
-- Name: acq_lineitem_pkey_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.acq_lineitem_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.acq_lineitem_pkey_seq OWNER TO evergreen;

--
-- Name: acq_purchase_order_history; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.acq_purchase_order_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    owner integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    ordering_agency integer NOT NULL,
    create_time timestamp with time zone NOT NULL,
    edit_time timestamp with time zone NOT NULL,
    provider integer NOT NULL,
    state text NOT NULL,
    order_date timestamp with time zone,
    name text NOT NULL,
    cancel_reason integer,
    prepayment_required boolean NOT NULL
);


ALTER TABLE acq.acq_purchase_order_history OWNER TO evergreen;

--
-- Name: purchase_order; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.purchase_order (
    id integer NOT NULL,
    owner integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    ordering_agency integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    provider integer NOT NULL,
    state text DEFAULT 'new'::text NOT NULL,
    order_date timestamp with time zone,
    name text NOT NULL,
    cancel_reason integer,
    prepayment_required boolean DEFAULT false NOT NULL,
    CONSTRAINT valid_po_state CHECK ((state = ANY (ARRAY['new'::text, 'pending'::text, 'on-order'::text, 'received'::text, 'cancelled'::text])))
);


ALTER TABLE acq.purchase_order OWNER TO evergreen;

--
-- Name: acq_purchase_order_lifecycle; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.acq_purchase_order_lifecycle AS
 SELECT '-1'::integer AS int4,
    now() AS audit_time,
    '-'::text AS audit_action,
    purchase_order.id,
    purchase_order.owner,
    purchase_order.creator,
    purchase_order.editor,
    purchase_order.ordering_agency,
    purchase_order.create_time,
    purchase_order.edit_time,
    purchase_order.provider,
    purchase_order.state,
    purchase_order.order_date,
    purchase_order.name,
    purchase_order.cancel_reason,
    purchase_order.prepayment_required
   FROM acq.purchase_order
UNION ALL
 SELECT acq_purchase_order_history.audit_id AS int4,
    acq_purchase_order_history.audit_time,
    acq_purchase_order_history.audit_action,
    acq_purchase_order_history.id,
    acq_purchase_order_history.owner,
    acq_purchase_order_history.creator,
    acq_purchase_order_history.editor,
    acq_purchase_order_history.ordering_agency,
    acq_purchase_order_history.create_time,
    acq_purchase_order_history.edit_time,
    acq_purchase_order_history.provider,
    acq_purchase_order_history.state,
    acq_purchase_order_history.order_date,
    acq_purchase_order_history.name,
    acq_purchase_order_history.cancel_reason,
    acq_purchase_order_history.prepayment_required
   FROM acq.acq_purchase_order_history;


ALTER TABLE acq.acq_purchase_order_lifecycle OWNER TO evergreen;

--
-- Name: acq_purchase_order_pkey_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.acq_purchase_order_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.acq_purchase_order_pkey_seq OWNER TO evergreen;

--
-- Name: fund; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.fund (
    id integer NOT NULL,
    org integer NOT NULL,
    name text NOT NULL,
    year integer DEFAULT date_part('year'::text, now()) NOT NULL,
    currency_type text NOT NULL,
    code text NOT NULL,
    rollover boolean DEFAULT false NOT NULL,
    propagate boolean DEFAULT true NOT NULL,
    active boolean DEFAULT true NOT NULL,
    balance_warning_percent integer,
    balance_stop_percent integer,
    CONSTRAINT acq_fund_rollover_implies_propagate CHECK ((propagate OR (NOT rollover)))
);


ALTER TABLE acq.fund OWNER TO evergreen;

--
-- Name: fund_allocation; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.fund_allocation (
    id integer NOT NULL,
    funding_source integer NOT NULL,
    fund integer NOT NULL,
    amount numeric NOT NULL,
    allocator integer NOT NULL,
    note text,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE acq.fund_allocation OWNER TO evergreen;

--
-- Name: funding_source; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.funding_source (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    currency_type text NOT NULL,
    code text NOT NULL,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE acq.funding_source OWNER TO evergreen;

--
-- Name: all_fund_allocation_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.all_fund_allocation_total AS
 SELECT f.id AS fund,
    COALESCE((sum((a.amount * acq.exchange_ratio(s.currency_type, f.currency_type))))::numeric(100,2), (0)::numeric) AS amount
   FROM ((acq.fund f
     LEFT JOIN acq.fund_allocation a ON ((a.fund = f.id)))
     LEFT JOIN acq.funding_source s ON ((a.funding_source = s.id)))
  GROUP BY f.id;


ALTER TABLE acq.all_fund_allocation_total OWNER TO evergreen;

--
-- Name: fund_debit; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.fund_debit (
    id integer NOT NULL,
    fund integer NOT NULL,
    origin_amount numeric NOT NULL,
    origin_currency_type text NOT NULL,
    amount numeric NOT NULL,
    encumbrance boolean DEFAULT true NOT NULL,
    debit_type text NOT NULL,
    xfer_destination integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    invoice_entry integer
);


ALTER TABLE acq.fund_debit OWNER TO evergreen;

--
-- Name: all_fund_combined_balance; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.all_fund_combined_balance AS
 SELECT a.fund,
    (a.amount - COALESCE(c.amount, (0)::numeric)) AS amount
   FROM (acq.all_fund_allocation_total a
     LEFT JOIN ( SELECT fund_debit.fund,
            sum(fund_debit.amount) AS amount
           FROM acq.fund_debit
          GROUP BY fund_debit.fund) c USING (fund));


ALTER TABLE acq.all_fund_combined_balance OWNER TO evergreen;

--
-- Name: all_fund_encumbrance_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.all_fund_encumbrance_total AS
 SELECT f.id AS fund,
    COALESCE(encumb.amount, (0)::numeric) AS amount
   FROM (acq.fund f
     LEFT JOIN ( SELECT fund_debit.fund,
            sum(fund_debit.amount) AS amount
           FROM acq.fund_debit
          WHERE fund_debit.encumbrance
          GROUP BY fund_debit.fund) encumb ON ((f.id = encumb.fund)));


ALTER TABLE acq.all_fund_encumbrance_total OWNER TO evergreen;

--
-- Name: all_fund_spent_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.all_fund_spent_total AS
 SELECT f.id AS fund,
    COALESCE(spent.amount, (0)::numeric) AS amount
   FROM (acq.fund f
     LEFT JOIN ( SELECT fund_debit.fund,
            sum(fund_debit.amount) AS amount
           FROM acq.fund_debit
          WHERE (NOT fund_debit.encumbrance)
          GROUP BY fund_debit.fund) spent ON ((f.id = spent.fund)));


ALTER TABLE acq.all_fund_spent_total OWNER TO evergreen;

--
-- Name: all_fund_spent_balance; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.all_fund_spent_balance AS
 SELECT c.fund,
    (c.amount - d.amount) AS amount
   FROM (acq.all_fund_allocation_total c
     LEFT JOIN acq.all_fund_spent_total d USING (fund));


ALTER TABLE acq.all_fund_spent_balance OWNER TO evergreen;

--
-- Name: cancel_reason; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.cancel_reason (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    label text NOT NULL,
    description text NOT NULL,
    keep_debits boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.cancel_reason OWNER TO evergreen;

--
-- Name: cancel_reason_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.cancel_reason_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.cancel_reason_id_seq OWNER TO evergreen;

--
-- Name: cancel_reason_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.cancel_reason_id_seq OWNED BY acq.cancel_reason.id;


--
-- Name: claim; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.claim (
    id integer NOT NULL,
    type integer NOT NULL,
    lineitem_detail bigint NOT NULL
);


ALTER TABLE acq.claim OWNER TO evergreen;

--
-- Name: claim_event; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.claim_event (
    id bigint NOT NULL,
    type integer NOT NULL,
    claim integer NOT NULL,
    event_date timestamp with time zone DEFAULT now() NOT NULL,
    creator integer NOT NULL,
    note text
);


ALTER TABLE acq.claim_event OWNER TO evergreen;

--
-- Name: claim_event_claim_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.claim_event_claim_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_event_claim_seq OWNER TO evergreen;

--
-- Name: claim_event_claim_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.claim_event_claim_seq OWNED BY acq.claim_event.claim;


--
-- Name: claim_event_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.claim_event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_event_id_seq OWNER TO evergreen;

--
-- Name: claim_event_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.claim_event_id_seq OWNED BY acq.claim_event.id;


--
-- Name: claim_event_type; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.claim_event_type (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    code text NOT NULL,
    description text NOT NULL,
    library_initiated boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.claim_event_type OWNER TO evergreen;

--
-- Name: claim_event_type_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.claim_event_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_event_type_id_seq OWNER TO evergreen;

--
-- Name: claim_event_type_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.claim_event_type_id_seq OWNED BY acq.claim_event_type.id;


--
-- Name: claim_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.claim_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_id_seq OWNER TO evergreen;

--
-- Name: claim_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.claim_id_seq OWNED BY acq.claim.id;


--
-- Name: claim_policy; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.claim_policy (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    name text NOT NULL,
    description text NOT NULL
);


ALTER TABLE acq.claim_policy OWNER TO evergreen;

--
-- Name: claim_policy_action; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.claim_policy_action (
    id integer NOT NULL,
    claim_policy integer NOT NULL,
    action_interval interval NOT NULL,
    action integer NOT NULL
);


ALTER TABLE acq.claim_policy_action OWNER TO evergreen;

--
-- Name: claim_policy_action_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.claim_policy_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_policy_action_id_seq OWNER TO evergreen;

--
-- Name: claim_policy_action_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.claim_policy_action_id_seq OWNED BY acq.claim_policy_action.id;


--
-- Name: claim_policy_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.claim_policy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_policy_id_seq OWNER TO evergreen;

--
-- Name: claim_policy_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.claim_policy_id_seq OWNED BY acq.claim_policy.id;


--
-- Name: claim_type; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.claim_type (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    code text NOT NULL,
    description text NOT NULL
);


ALTER TABLE acq.claim_type OWNER TO evergreen;

--
-- Name: claim_type_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.claim_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.claim_type_id_seq OWNER TO evergreen;

--
-- Name: claim_type_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.claim_type_id_seq OWNED BY acq.claim_type.id;


--
-- Name: currency_type; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.currency_type (
    code text NOT NULL,
    label text
);


ALTER TABLE acq.currency_type OWNER TO evergreen;

--
-- Name: debit_attribution; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.debit_attribution (
    id integer NOT NULL,
    fund_debit integer NOT NULL,
    debit_amount numeric NOT NULL,
    funding_source_credit integer,
    credit_amount numeric
);


ALTER TABLE acq.debit_attribution OWNER TO evergreen;

--
-- Name: distribution_formula; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.distribution_formula (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    skip_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE acq.distribution_formula OWNER TO evergreen;

--
-- Name: distribution_formula_application; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.distribution_formula_application (
    id bigint NOT NULL,
    creator integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    formula integer NOT NULL,
    lineitem integer NOT NULL
);


ALTER TABLE acq.distribution_formula_application OWNER TO evergreen;

--
-- Name: distribution_formula_application_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.distribution_formula_application_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.distribution_formula_application_id_seq OWNER TO evergreen;

--
-- Name: distribution_formula_application_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.distribution_formula_application_id_seq OWNED BY acq.distribution_formula_application.id;


--
-- Name: distribution_formula_entry; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.distribution_formula_entry (
    id integer NOT NULL,
    formula integer NOT NULL,
    "position" integer NOT NULL,
    item_count integer NOT NULL,
    owning_lib integer,
    location integer,
    fund integer,
    circ_modifier text,
    collection_code text,
    CONSTRAINT acqdfe_must_be_somewhere CHECK (((owning_lib IS NOT NULL) OR (location IS NOT NULL)))
);


ALTER TABLE acq.distribution_formula_entry OWNER TO evergreen;

--
-- Name: distribution_formula_entry_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.distribution_formula_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.distribution_formula_entry_id_seq OWNER TO evergreen;

--
-- Name: distribution_formula_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.distribution_formula_entry_id_seq OWNED BY acq.distribution_formula_entry.id;


--
-- Name: distribution_formula_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.distribution_formula_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.distribution_formula_id_seq OWNER TO evergreen;

--
-- Name: distribution_formula_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.distribution_formula_id_seq OWNED BY acq.distribution_formula.id;


--
-- Name: remote_account; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.remote_account (
    id integer NOT NULL,
    label text NOT NULL,
    host text NOT NULL,
    username text,
    password text,
    account text,
    path text,
    owner integer NOT NULL,
    last_activity timestamp with time zone
);


ALTER TABLE config.remote_account OWNER TO evergreen;

--
-- Name: remote_account_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.remote_account_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.remote_account_id_seq OWNER TO evergreen;

--
-- Name: remote_account_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.remote_account_id_seq OWNED BY config.remote_account.id;


--
-- Name: edi_account; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.edi_account (
    id integer DEFAULT nextval('config.remote_account_id_seq'::regclass),
    provider integer NOT NULL,
    in_dir text,
    vendcode text,
    vendacct text,
    attr_set integer,
    use_attrs boolean DEFAULT false NOT NULL
)
INHERITS (config.remote_account);


ALTER TABLE acq.edi_account OWNER TO evergreen;

--
-- Name: edi_attr; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.edi_attr (
    key text NOT NULL,
    label text NOT NULL
);


ALTER TABLE acq.edi_attr OWNER TO evergreen;

--
-- Name: edi_attr_set; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.edi_attr_set (
    id integer NOT NULL,
    label text NOT NULL
);


ALTER TABLE acq.edi_attr_set OWNER TO evergreen;

--
-- Name: edi_attr_set_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.edi_attr_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.edi_attr_set_id_seq OWNER TO evergreen;

--
-- Name: edi_attr_set_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.edi_attr_set_id_seq OWNED BY acq.edi_attr_set.id;


--
-- Name: edi_attr_set_map; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.edi_attr_set_map (
    id integer NOT NULL,
    attr_set integer NOT NULL,
    attr text NOT NULL
);


ALTER TABLE acq.edi_attr_set_map OWNER TO evergreen;

--
-- Name: edi_attr_set_map_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.edi_attr_set_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.edi_attr_set_map_id_seq OWNER TO evergreen;

--
-- Name: edi_attr_set_map_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.edi_attr_set_map_id_seq OWNED BY acq.edi_attr_set_map.id;


--
-- Name: edi_message; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.edi_message (
    id integer NOT NULL,
    account integer,
    remote_file text,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    translate_time timestamp with time zone,
    process_time timestamp with time zone,
    error_time timestamp with time zone,
    status text DEFAULT 'new'::text NOT NULL,
    edi text,
    jedi text,
    error text,
    purchase_order integer,
    message_type text NOT NULL,
    CONSTRAINT status_value CHECK ((status = ANY (ARRAY['new'::text, 'translated'::text, 'trans_error'::text, 'processed'::text, 'proc_error'::text, 'delete_error'::text, 'retry'::text, 'complete'::text]))),
    CONSTRAINT valid_message_type CHECK ((message_type = ANY (ARRAY['ORDERS'::text, 'ORDRSP'::text, 'INVOIC'::text, 'OSTENQ'::text, 'OSTRPT'::text, 'DESADV'::text])))
);


ALTER TABLE acq.edi_message OWNER TO evergreen;

--
-- Name: edi_message_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.edi_message_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.edi_message_id_seq OWNER TO evergreen;

--
-- Name: edi_message_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.edi_message_id_seq OWNED BY acq.edi_message.id;


--
-- Name: exchange_rate; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.exchange_rate (
    id integer NOT NULL,
    from_currency text NOT NULL,
    to_currency text NOT NULL,
    ratio numeric NOT NULL
);


ALTER TABLE acq.exchange_rate OWNER TO evergreen;

--
-- Name: exchange_rate_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.exchange_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.exchange_rate_id_seq OWNER TO evergreen;

--
-- Name: exchange_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.exchange_rate_id_seq OWNED BY acq.exchange_rate.id;


--
-- Name: fiscal_calendar; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.fiscal_calendar (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.fiscal_calendar OWNER TO evergreen;

--
-- Name: fiscal_calendar_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.fiscal_calendar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fiscal_calendar_id_seq OWNER TO evergreen;

--
-- Name: fiscal_calendar_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.fiscal_calendar_id_seq OWNED BY acq.fiscal_calendar.id;


--
-- Name: fiscal_year; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.fiscal_year (
    id integer NOT NULL,
    calendar integer NOT NULL,
    year integer NOT NULL,
    year_begin timestamp with time zone NOT NULL,
    year_end timestamp with time zone NOT NULL
);


ALTER TABLE acq.fiscal_year OWNER TO evergreen;

--
-- Name: fiscal_year_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.fiscal_year_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fiscal_year_id_seq OWNER TO evergreen;

--
-- Name: fiscal_year_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.fiscal_year_id_seq OWNED BY acq.fiscal_year.id;


--
-- Name: fund_allocation_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.fund_allocation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_allocation_id_seq OWNER TO evergreen;

--
-- Name: fund_allocation_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.fund_allocation_id_seq OWNED BY acq.fund_allocation.id;


--
-- Name: fund_allocation_percent; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.fund_allocation_percent (
    id integer NOT NULL,
    funding_source integer NOT NULL,
    org integer NOT NULL,
    fund_code text,
    percent numeric NOT NULL,
    allocator integer NOT NULL,
    note text,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT percentage_range CHECK (((percent >= (0)::numeric) AND (percent <= (100)::numeric)))
);


ALTER TABLE acq.fund_allocation_percent OWNER TO evergreen;

--
-- Name: fund_allocation_percent_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.fund_allocation_percent_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_allocation_percent_id_seq OWNER TO evergreen;

--
-- Name: fund_allocation_percent_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.fund_allocation_percent_id_seq OWNED BY acq.fund_allocation_percent.id;


--
-- Name: fund_allocation_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.fund_allocation_total AS
 SELECT a.fund,
    (sum((a.amount * acq.exchange_ratio(s.currency_type, f.currency_type))))::numeric(100,2) AS amount
   FROM ((acq.fund_allocation a
     JOIN acq.fund f ON ((a.fund = f.id)))
     JOIN acq.funding_source s ON ((a.funding_source = s.id)))
  GROUP BY a.fund;


ALTER TABLE acq.fund_allocation_total OWNER TO evergreen;

--
-- Name: fund_debit_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.fund_debit_total AS
 SELECT fund.id AS fund,
    fund_debit.encumbrance,
    sum(COALESCE(fund_debit.amount, (0)::numeric)) AS amount
   FROM (acq.fund fund
     LEFT JOIN acq.fund_debit fund_debit ON ((fund.id = fund_debit.fund)))
  GROUP BY fund.id, fund_debit.encumbrance;


ALTER TABLE acq.fund_debit_total OWNER TO evergreen;

--
-- Name: fund_combined_balance; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.fund_combined_balance AS
 SELECT c.fund,
    (c.amount - COALESCE(d.amount, 0.0)) AS amount
   FROM (acq.fund_allocation_total c
     LEFT JOIN acq.fund_debit_total d USING (fund));


ALTER TABLE acq.fund_combined_balance OWNER TO evergreen;

--
-- Name: fund_debit_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.fund_debit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_debit_id_seq OWNER TO evergreen;

--
-- Name: fund_debit_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.fund_debit_id_seq OWNED BY acq.fund_debit.id;


--
-- Name: fund_encumbrance_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.fund_encumbrance_total AS
 SELECT fund_debit_total.fund,
    sum(fund_debit_total.amount) AS amount
   FROM acq.fund_debit_total
  WHERE (fund_debit_total.encumbrance IS TRUE)
  GROUP BY fund_debit_total.fund;


ALTER TABLE acq.fund_encumbrance_total OWNER TO evergreen;

--
-- Name: fund_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.fund_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_id_seq OWNER TO evergreen;

--
-- Name: fund_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.fund_id_seq OWNED BY acq.fund.id;


--
-- Name: fund_spent_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.fund_spent_total AS
 SELECT fund_debit_total.fund,
    sum(fund_debit_total.amount) AS amount
   FROM acq.fund_debit_total
  WHERE (fund_debit_total.encumbrance IS FALSE)
  GROUP BY fund_debit_total.fund;


ALTER TABLE acq.fund_spent_total OWNER TO evergreen;

--
-- Name: fund_spent_balance; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.fund_spent_balance AS
 SELECT c.fund,
    (c.amount - COALESCE(d.amount, 0.0)) AS amount
   FROM (acq.fund_allocation_total c
     LEFT JOIN acq.fund_spent_total d USING (fund));


ALTER TABLE acq.fund_spent_balance OWNER TO evergreen;

--
-- Name: fund_tag; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.fund_tag (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.fund_tag OWNER TO evergreen;

--
-- Name: fund_tag_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.fund_tag_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_tag_id_seq OWNER TO evergreen;

--
-- Name: fund_tag_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.fund_tag_id_seq OWNED BY acq.fund_tag.id;


--
-- Name: fund_tag_map; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.fund_tag_map (
    id integer NOT NULL,
    fund integer NOT NULL,
    tag integer
);


ALTER TABLE acq.fund_tag_map OWNER TO evergreen;

--
-- Name: fund_tag_map_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.fund_tag_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_tag_map_id_seq OWNER TO evergreen;

--
-- Name: fund_tag_map_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.fund_tag_map_id_seq OWNED BY acq.fund_tag_map.id;


--
-- Name: fund_transfer; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.fund_transfer (
    id integer NOT NULL,
    src_fund integer NOT NULL,
    src_amount numeric NOT NULL,
    dest_fund integer NOT NULL,
    dest_amount numeric NOT NULL,
    transfer_time timestamp with time zone DEFAULT now() NOT NULL,
    transfer_user integer NOT NULL,
    note text,
    funding_source_credit integer NOT NULL
);


ALTER TABLE acq.fund_transfer OWNER TO evergreen;

--
-- Name: TABLE fund_transfer; Type: COMMENT; Schema: acq; Owner: evergreen
--

COMMENT ON TABLE acq.fund_transfer IS '
/*
 * Copyright (C) 2009  Georgia Public Library Service
 * Scott McKellar <scott@esilibrary.com>
 *
 * Fund Transfer
 *
 * Each row represents the transfer of money from a source fund
 * to a destination fund.  There should be corresponding entries
 * in acq.fund_allocation.  The purpose of acq.fund_transfer is
 * to record how much money moved from which fund to which other
 * fund.
 *
 * The presence of two amount fields, rather than one, reflects
 * the possibility that the two funds are denominated in different
 * currencies.  If they use the same currency type, the two
 * amounts should be the same.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: fund_transfer_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.fund_transfer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.fund_transfer_id_seq OWNER TO evergreen;

--
-- Name: fund_transfer_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.fund_transfer_id_seq OWNED BY acq.fund_transfer.id;


--
-- Name: funding_source_allocation_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.funding_source_allocation_total AS
 SELECT a.funding_source,
    (sum(a.amount))::numeric(100,2) AS amount
   FROM acq.fund_allocation a
  GROUP BY a.funding_source;


ALTER TABLE acq.funding_source_allocation_total OWNER TO evergreen;

--
-- Name: funding_source_credit; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.funding_source_credit (
    id integer NOT NULL,
    funding_source integer NOT NULL,
    amount numeric NOT NULL,
    note text,
    deadline_date timestamp with time zone,
    effective_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE acq.funding_source_credit OWNER TO evergreen;

--
-- Name: funding_source_credit_total; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.funding_source_credit_total AS
 SELECT funding_source_credit.funding_source,
    sum(funding_source_credit.amount) AS amount
   FROM acq.funding_source_credit
  GROUP BY funding_source_credit.funding_source;


ALTER TABLE acq.funding_source_credit_total OWNER TO evergreen;

--
-- Name: funding_source_balance; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.funding_source_balance AS
 SELECT COALESCE(c.funding_source, a.funding_source) AS funding_source,
    (sum((COALESCE(c.amount, 0.0) - COALESCE(a.amount, 0.0))))::numeric(100,2) AS amount
   FROM (acq.funding_source_credit_total c
     FULL JOIN acq.funding_source_allocation_total a USING (funding_source))
  GROUP BY COALESCE(c.funding_source, a.funding_source);


ALTER TABLE acq.funding_source_balance OWNER TO evergreen;

--
-- Name: funding_source_credit_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.funding_source_credit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.funding_source_credit_id_seq OWNER TO evergreen;

--
-- Name: funding_source_credit_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.funding_source_credit_id_seq OWNED BY acq.funding_source_credit.id;


--
-- Name: funding_source_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.funding_source_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.funding_source_id_seq OWNER TO evergreen;

--
-- Name: funding_source_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.funding_source_id_seq OWNED BY acq.funding_source.id;


--
-- Name: invoice; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.invoice (
    id integer NOT NULL,
    receiver integer NOT NULL,
    provider integer NOT NULL,
    shipper integer NOT NULL,
    recv_date timestamp with time zone DEFAULT now() NOT NULL,
    recv_method text DEFAULT 'EDI'::text NOT NULL,
    inv_type text,
    inv_ident text NOT NULL,
    payment_auth text,
    payment_method text,
    note text,
    close_date timestamp with time zone,
    erp_export_date timestamp with time zone,
    closed_by integer
);


ALTER TABLE acq.invoice OWNER TO evergreen;

--
-- Name: invoice_entry; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.invoice_entry (
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    lineitem integer,
    inv_item_count integer NOT NULL,
    phys_item_count integer,
    note text,
    billed_per_item boolean,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    amount_paid numeric(8,2)
);


ALTER TABLE acq.invoice_entry OWNER TO evergreen;

--
-- Name: invoice_entry_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.invoice_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.invoice_entry_id_seq OWNER TO evergreen;

--
-- Name: invoice_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.invoice_entry_id_seq OWNED BY acq.invoice_entry.id;


--
-- Name: invoice_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.invoice_id_seq OWNER TO evergreen;

--
-- Name: invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.invoice_id_seq OWNED BY acq.invoice.id;


--
-- Name: invoice_item; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.invoice_item (
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    fund_debit integer,
    inv_item_type text NOT NULL,
    title text,
    author text,
    note text,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    fund integer,
    amount_paid numeric(8,2),
    po_item integer,
    target bigint
);


ALTER TABLE acq.invoice_item OWNER TO evergreen;

--
-- Name: invoice_item_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.invoice_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.invoice_item_id_seq OWNER TO evergreen;

--
-- Name: invoice_item_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.invoice_item_id_seq OWNED BY acq.invoice_item.id;


--
-- Name: invoice_item_type; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.invoice_item_type (
    code text NOT NULL,
    name text NOT NULL,
    prorate boolean DEFAULT false NOT NULL,
    blanket boolean DEFAULT false NOT NULL,
    CONSTRAINT aiit_not_blanket_and_prorate CHECK (((blanket IS FALSE) OR (prorate IS FALSE)))
);


ALTER TABLE acq.invoice_item_type OWNER TO evergreen;

--
-- Name: invoice_method; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.invoice_method (
    code text NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.invoice_method OWNER TO evergreen;

--
-- Name: invoice_payment_method; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.invoice_payment_method (
    code text NOT NULL,
    name text NOT NULL
);


ALTER TABLE acq.invoice_payment_method OWNER TO evergreen;

--
-- Name: li_state_label; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.li_state_label AS
 SELECT t.id,
    t.label
   FROM ( VALUES ('new'::text,'New'::text), ('selector-ready'::text,'Selector-Ready'::text), ('order-ready'::text,'Order-Ready'::text), ('approved'::text,'Approved'::text), ('pending-order'::text,'Pending-Order'::text), ('on-order'::text,'On-Order'::text), ('received'::text,'Received'::text), ('cancelled'::text,'Cancelled'::text)) t(id, label);


ALTER TABLE acq.li_state_label OWNER TO evergreen;

--
-- Name: lineitem_alert_text; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.lineitem_alert_text (
    id integer NOT NULL,
    code text NOT NULL,
    description text,
    owning_lib integer NOT NULL
);


ALTER TABLE acq.lineitem_alert_text OWNER TO evergreen;

--
-- Name: lineitem_alert_text_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.lineitem_alert_text_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_alert_text_id_seq OWNER TO evergreen;

--
-- Name: lineitem_alert_text_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.lineitem_alert_text_id_seq OWNED BY acq.lineitem_alert_text.id;


--
-- Name: lineitem_attr; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.lineitem_attr (
    id bigint NOT NULL,
    definition bigint NOT NULL,
    lineitem bigint NOT NULL,
    attr_type text NOT NULL,
    attr_name text NOT NULL,
    attr_value text NOT NULL,
    order_ident boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.lineitem_attr OWNER TO evergreen;

--
-- Name: lineitem_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.lineitem_attr_definition (
    id bigint NOT NULL,
    code text NOT NULL,
    description text NOT NULL,
    remove text DEFAULT ''::text NOT NULL,
    ident boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.lineitem_attr_definition OWNER TO evergreen;

--
-- Name: lineitem_attr_definition_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.lineitem_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_attr_definition_id_seq OWNER TO evergreen;

--
-- Name: lineitem_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.lineitem_attr_definition_id_seq OWNED BY acq.lineitem_attr_definition.id;


--
-- Name: lineitem_attr_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.lineitem_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_attr_id_seq OWNER TO evergreen;

--
-- Name: lineitem_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.lineitem_attr_id_seq OWNED BY acq.lineitem_attr.id;


--
-- Name: lineitem_detail; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.lineitem_detail (
    id bigint NOT NULL,
    lineitem integer NOT NULL,
    fund integer,
    fund_debit integer,
    eg_copy_id bigint,
    barcode text,
    cn_label text,
    note text,
    collection_code text,
    circ_modifier text,
    owning_lib integer,
    location integer,
    recv_time timestamp with time zone,
    cancel_reason integer,
    receiver integer
);


ALTER TABLE acq.lineitem_detail OWNER TO evergreen;

--
-- Name: lineitem_detail_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.lineitem_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_detail_id_seq OWNER TO evergreen;

--
-- Name: lineitem_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.lineitem_detail_id_seq OWNED BY acq.lineitem_detail.id;


--
-- Name: lineitem_generated_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.lineitem_generated_attr_definition (
    id bigint DEFAULT nextval('acq.lineitem_attr_definition_id_seq'::regclass),
    xpath text NOT NULL
)
INHERITS (acq.lineitem_attr_definition);


ALTER TABLE acq.lineitem_generated_attr_definition OWNER TO evergreen;

--
-- Name: lineitem_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.lineitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_id_seq OWNER TO evergreen;

--
-- Name: lineitem_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.lineitem_id_seq OWNED BY acq.lineitem.id;


--
-- Name: lineitem_local_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.lineitem_local_attr_definition (
    id bigint DEFAULT nextval('acq.lineitem_attr_definition_id_seq'::regclass)
)
INHERITS (acq.lineitem_attr_definition);


ALTER TABLE acq.lineitem_local_attr_definition OWNER TO evergreen;

--
-- Name: lineitem_marc_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.lineitem_marc_attr_definition (
    id bigint DEFAULT nextval('acq.lineitem_attr_definition_id_seq'::regclass),
    xpath text NOT NULL,
    description_sortkey integer DEFAULT 1 NOT NULL
)
INHERITS (acq.lineitem_attr_definition);


ALTER TABLE acq.lineitem_marc_attr_definition OWNER TO evergreen;

--
-- Name: lineitem_note; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.lineitem_note (
    id integer NOT NULL,
    lineitem integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    value text NOT NULL,
    alert_text integer,
    vendor_public boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.lineitem_note OWNER TO evergreen;

--
-- Name: lineitem_note_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.lineitem_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.lineitem_note_id_seq OWNER TO evergreen;

--
-- Name: lineitem_note_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.lineitem_note_id_seq OWNED BY acq.lineitem_note.id;


--
-- Name: lineitem_provider_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.lineitem_provider_attr_definition (
    id bigint DEFAULT nextval('acq.lineitem_attr_definition_id_seq'::regclass),
    xpath text NOT NULL,
    provider integer NOT NULL
)
INHERITS (acq.lineitem_attr_definition);


ALTER TABLE acq.lineitem_provider_attr_definition OWNER TO evergreen;

--
-- Name: lineitem_summary; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.lineitem_summary AS
 SELECT li.id AS lineitem,
    ( SELECT count(lid.id) AS count
           FROM acq.lineitem_detail lid
          WHERE (lid.lineitem = li.id)) AS item_count,
    ( SELECT count(lid.id) AS count
           FROM acq.lineitem_detail lid
          WHERE ((lid.recv_time IS NOT NULL) AND (lid.lineitem = li.id))) AS recv_count,
    ( SELECT count(lid.id) AS count
           FROM (acq.lineitem_detail lid
             JOIN acq.cancel_reason acqcr ON ((acqcr.id = lid.cancel_reason)))
          WHERE ((acqcr.keep_debits IS FALSE) AND (lid.lineitem = li.id))) AS cancel_count,
    ( SELECT count(lid.id) AS count
           FROM (acq.lineitem_detail lid
             JOIN acq.cancel_reason acqcr ON ((acqcr.id = lid.cancel_reason)))
          WHERE ((acqcr.keep_debits IS TRUE) AND (lid.lineitem = li.id))) AS delay_count,
    ( SELECT count(lid.id) AS count
           FROM (acq.lineitem_detail lid
             JOIN acq.fund_debit debit ON ((lid.fund_debit = debit.id)))
          WHERE ((NOT debit.encumbrance) AND (lid.lineitem = li.id))) AS invoice_count,
    ( SELECT count(DISTINCT lid.id) AS count
           FROM (acq.lineitem_detail lid
             JOIN acq.claim claim ON ((claim.lineitem_detail = lid.id)))
          WHERE (lid.lineitem = li.id)) AS claim_count,
    ( SELECT (((count(lid.id))::numeric * li.estimated_unit_price))::numeric(8,2) AS "numeric"
           FROM acq.lineitem_detail lid
          WHERE ((lid.cancel_reason IS NULL) AND (lid.lineitem = li.id))) AS estimated_amount,
    ( SELECT (sum(debit.amount))::numeric(8,2) AS sum
           FROM (acq.lineitem_detail lid
             JOIN acq.fund_debit debit ON ((lid.fund_debit = debit.id)))
          WHERE (debit.encumbrance AND (lid.lineitem = li.id))) AS encumbrance_amount,
    ( SELECT (sum(debit.amount))::numeric(8,2) AS sum
           FROM (acq.lineitem_detail lid
             JOIN acq.fund_debit debit ON ((lid.fund_debit = debit.id)))
          WHERE ((NOT debit.encumbrance) AND (lid.lineitem = li.id))) AS paid_amount
   FROM acq.lineitem li;


ALTER TABLE acq.lineitem_summary OWNER TO evergreen;

--
-- Name: lineitem_usr_attr_definition; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.lineitem_usr_attr_definition (
    id bigint DEFAULT nextval('acq.lineitem_attr_definition_id_seq'::regclass),
    usr integer NOT NULL
)
INHERITS (acq.lineitem_attr_definition);


ALTER TABLE acq.lineitem_usr_attr_definition OWNER TO evergreen;

--
-- Name: ordered_funding_source_credit; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.ordered_funding_source_credit AS
 SELECT
        CASE
            WHEN (funding_source_credit.deadline_date IS NULL) THEN 2
            ELSE 1
        END AS sort_priority,
        CASE
            WHEN (funding_source_credit.deadline_date IS NULL) THEN funding_source_credit.effective_date
            ELSE funding_source_credit.deadline_date
        END AS sort_date,
    funding_source_credit.id,
    funding_source_credit.funding_source,
    funding_source_credit.amount,
    funding_source_credit.note
   FROM acq.funding_source_credit;


ALTER TABLE acq.ordered_funding_source_credit OWNER TO evergreen;

--
-- Name: VIEW ordered_funding_source_credit; Type: COMMENT; Schema: acq; Owner: evergreen
--

COMMENT ON VIEW acq.ordered_funding_source_credit IS '
/*
 * Copyright (C) 2009  Georgia Public Library Service
 * Scott McKellar <scott@gmail.com>
 *
 * The acq.ordered_funding_source_credit view is a prioritized
 * ordering of funding source credits.  When ordered by the first
 * three columns, this view defines the order in which the various
 * credits are to be tapped for spending, subject to the allocations
 * in the acq.fund_allocation table.
 *
 * The first column reflects the principle that we should spend
 * money with deadlines before spending money without deadlines.
 *
 * The second column reflects the principle that we should spend the
 * oldest money first.  For money with deadlines, that means that we
 * spend first from the credit with the earliest deadline.  For
 * money without deadlines, we spend first from the credit with the
 * earliest effective date.
 *
 * The third column is a tie breaker to ensure a consistent
 * ordering.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: picklist; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.picklist (
    id integer NOT NULL,
    owner integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    org_unit integer NOT NULL,
    name text NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE acq.picklist OWNER TO evergreen;

--
-- Name: picklist_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.picklist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.picklist_id_seq OWNER TO evergreen;

--
-- Name: picklist_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.picklist_id_seq OWNED BY acq.picklist.id;


--
-- Name: po_item; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.po_item (
    id integer NOT NULL,
    purchase_order integer,
    fund_debit integer,
    inv_item_type text NOT NULL,
    title text,
    author text,
    note text,
    estimated_cost numeric(8,2),
    fund integer,
    target bigint
);


ALTER TABLE acq.po_item OWNER TO evergreen;

--
-- Name: po_item_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.po_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.po_item_id_seq OWNER TO evergreen;

--
-- Name: po_item_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.po_item_id_seq OWNED BY acq.po_item.id;


--
-- Name: po_note; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.po_note (
    id integer NOT NULL,
    purchase_order integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    value text NOT NULL,
    vendor_public boolean DEFAULT false NOT NULL
);


ALTER TABLE acq.po_note OWNER TO evergreen;

--
-- Name: po_note_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.po_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.po_note_id_seq OWNER TO evergreen;

--
-- Name: po_note_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.po_note_id_seq OWNED BY acq.po_note.id;


--
-- Name: po_state_label; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.po_state_label AS
 SELECT t.id,
    t.label
   FROM ( VALUES ('new'::text,'New'::text), ('pending'::text,'Pending'::text), ('on-order'::text,'On-Order'::text), ('received'::text,'Received'::text), ('cancelled'::text,'Cancelled'::text)) t(id, label);


ALTER TABLE acq.po_state_label OWNER TO evergreen;

--
-- Name: provider; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.provider (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    currency_type text NOT NULL,
    code text NOT NULL,
    holding_tag text,
    san text,
    edi_default integer,
    active boolean DEFAULT true NOT NULL,
    prepayment_required boolean DEFAULT false NOT NULL,
    url text,
    email text,
    phone text,
    fax_phone text,
    default_claim_policy integer,
    default_copy_count integer DEFAULT 0 NOT NULL,
    buyer_san text,
    primary_contact integer
);


ALTER TABLE acq.provider OWNER TO evergreen;

--
-- Name: provider_address; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.provider_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    address_type text,
    provider integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    fax_phone text NOT NULL
);


ALTER TABLE acq.provider_address OWNER TO evergreen;

--
-- Name: provider_address_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.provider_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_address_id_seq OWNER TO evergreen;

--
-- Name: provider_address_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.provider_address_id_seq OWNED BY acq.provider_address.id;


--
-- Name: provider_contact; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.provider_contact (
    id integer NOT NULL,
    provider integer NOT NULL,
    name text NOT NULL,
    role text,
    email text,
    phone text
);


ALTER TABLE acq.provider_contact OWNER TO evergreen;

--
-- Name: provider_contact_address; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.provider_contact_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    address_type text,
    contact integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    fax_phone text
);


ALTER TABLE acq.provider_contact_address OWNER TO evergreen;

--
-- Name: provider_contact_address_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.provider_contact_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_contact_address_id_seq OWNER TO evergreen;

--
-- Name: provider_contact_address_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.provider_contact_address_id_seq OWNED BY acq.provider_contact_address.id;


--
-- Name: provider_contact_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.provider_contact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_contact_id_seq OWNER TO evergreen;

--
-- Name: provider_contact_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.provider_contact_id_seq OWNED BY acq.provider_contact.id;


--
-- Name: provider_holding_subfield_map; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.provider_holding_subfield_map (
    id integer NOT NULL,
    provider integer NOT NULL,
    name text NOT NULL,
    subfield text NOT NULL
);


ALTER TABLE acq.provider_holding_subfield_map OWNER TO evergreen;

--
-- Name: provider_holding_subfield_map_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.provider_holding_subfield_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_holding_subfield_map_id_seq OWNER TO evergreen;

--
-- Name: provider_holding_subfield_map_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.provider_holding_subfield_map_id_seq OWNED BY acq.provider_holding_subfield_map.id;


--
-- Name: provider_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.provider_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_id_seq OWNER TO evergreen;

--
-- Name: provider_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.provider_id_seq OWNED BY acq.provider.id;


--
-- Name: provider_note; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.provider_note (
    id integer NOT NULL,
    provider integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    value text NOT NULL
);


ALTER TABLE acq.provider_note OWNER TO evergreen;

--
-- Name: provider_note_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.provider_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.provider_note_id_seq OWNER TO evergreen;

--
-- Name: provider_note_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.provider_note_id_seq OWNED BY acq.provider_note.id;


--
-- Name: purchase_order_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.purchase_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.purchase_order_id_seq OWNER TO evergreen;

--
-- Name: purchase_order_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.purchase_order_id_seq OWNED BY acq.purchase_order.id;


--
-- Name: serial_claim; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.serial_claim (
    id integer NOT NULL,
    type integer NOT NULL,
    item bigint NOT NULL
);


ALTER TABLE acq.serial_claim OWNER TO evergreen;

--
-- Name: serial_claim_event; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.serial_claim_event (
    id bigint NOT NULL,
    type integer NOT NULL,
    claim integer NOT NULL,
    event_date timestamp with time zone DEFAULT now() NOT NULL,
    creator integer NOT NULL,
    note text
);


ALTER TABLE acq.serial_claim_event OWNER TO evergreen;

--
-- Name: serial_claim_event_claim_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.serial_claim_event_claim_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.serial_claim_event_claim_seq OWNER TO evergreen;

--
-- Name: serial_claim_event_claim_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.serial_claim_event_claim_seq OWNED BY acq.serial_claim_event.claim;


--
-- Name: serial_claim_event_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.serial_claim_event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.serial_claim_event_id_seq OWNER TO evergreen;

--
-- Name: serial_claim_event_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.serial_claim_event_id_seq OWNED BY acq.serial_claim_event.id;


--
-- Name: serial_claim_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.serial_claim_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.serial_claim_id_seq OWNER TO evergreen;

--
-- Name: serial_claim_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.serial_claim_id_seq OWNED BY acq.serial_claim.id;


--
-- Name: shipment_notification; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.shipment_notification (
    id integer NOT NULL,
    receiver integer NOT NULL,
    provider integer NOT NULL,
    shipper integer NOT NULL,
    recv_date timestamp with time zone DEFAULT now() NOT NULL,
    recv_method text DEFAULT 'EDI'::text NOT NULL,
    process_date timestamp with time zone,
    processed_by integer,
    container_code text NOT NULL,
    lading_number text,
    note text
);


ALTER TABLE acq.shipment_notification OWNER TO evergreen;

--
-- Name: shipment_notification_entry; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.shipment_notification_entry (
    id integer NOT NULL,
    shipment_notification integer NOT NULL,
    lineitem integer,
    item_count integer NOT NULL
);


ALTER TABLE acq.shipment_notification_entry OWNER TO evergreen;

--
-- Name: shipment_notification_entry_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.shipment_notification_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.shipment_notification_entry_id_seq OWNER TO evergreen;

--
-- Name: shipment_notification_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.shipment_notification_entry_id_seq OWNED BY acq.shipment_notification_entry.id;


--
-- Name: shipment_notification_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.shipment_notification_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.shipment_notification_id_seq OWNER TO evergreen;

--
-- Name: shipment_notification_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.shipment_notification_id_seq OWNED BY acq.shipment_notification.id;


--
-- Name: shipment_notification_summary; Type: VIEW; Schema: acq; Owner: evergreen
--

CREATE VIEW acq.shipment_notification_summary AS
 SELECT acqinv.id AS invoice,
    acqinv.inv_ident,
    acqinv.provider,
    acqinve.purchase_order,
    asn.id AS shipment_notification,
    asn.container_code,
    asne.lineitem,
    asne.item_count AS item_count_for_lineitem
   FROM (((acq.invoice acqinv
     JOIN acq.invoice_entry acqinve ON ((acqinve.invoice = acqinv.id)))
     JOIN acq.shipment_notification_entry asne ON ((asne.lineitem = acqinve.lineitem)))
     JOIN acq.shipment_notification asn ON ((asn.id = asne.shipment_notification)));


ALTER TABLE acq.shipment_notification_summary OWNER TO evergreen;

--
-- Name: user_request; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.user_request (
    id integer NOT NULL,
    usr integer NOT NULL,
    hold boolean DEFAULT true NOT NULL,
    pickup_lib integer NOT NULL,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    lineitem integer,
    eg_bib bigint,
    request_date timestamp with time zone DEFAULT now() NOT NULL,
    need_before timestamp with time zone,
    max_fee text,
    request_type integer NOT NULL,
    isxn text,
    title text,
    volume text,
    author text,
    article_title text,
    article_pages text,
    publisher text,
    location text,
    pubdate text,
    mentioned text,
    other_info text,
    cancel_reason integer,
    cancel_time timestamp with time zone,
    upc text
);


ALTER TABLE acq.user_request OWNER TO evergreen;

--
-- Name: user_request_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.user_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.user_request_id_seq OWNER TO evergreen;

--
-- Name: user_request_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.user_request_id_seq OWNED BY acq.user_request.id;


--
-- Name: user_request_status_type; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.user_request_status_type (
    id integer NOT NULL,
    label text
);


ALTER TABLE acq.user_request_status_type OWNER TO evergreen;

--
-- Name: user_request_status_type_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.user_request_status_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.user_request_status_type_id_seq OWNER TO evergreen;

--
-- Name: user_request_status_type_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.user_request_status_type_id_seq OWNED BY acq.user_request_status_type.id;


--
-- Name: user_request_type; Type: TABLE; Schema: acq; Owner: evergreen
--

CREATE TABLE acq.user_request_type (
    id integer NOT NULL,
    label text NOT NULL
);


ALTER TABLE acq.user_request_type OWNER TO evergreen;

--
-- Name: user_request_type_id_seq; Type: SEQUENCE; Schema: acq; Owner: evergreen
--

CREATE SEQUENCE acq.user_request_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acq.user_request_type_id_seq OWNER TO evergreen;

--
-- Name: user_request_type_id_seq; Type: SEQUENCE OWNED BY; Schema: acq; Owner: evergreen
--

ALTER SEQUENCE acq.user_request_type_id_seq OWNED BY acq.user_request_type.id;


--
-- Name: aged_hold_request; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.aged_hold_request (
    usr_post_code text,
    usr_home_ou integer NOT NULL,
    usr_profile integer NOT NULL,
    usr_birth_year integer,
    staff_placed boolean NOT NULL,
    id integer NOT NULL,
    request_time timestamp with time zone NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint NOT NULL,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer NOT NULL,
    selection_ou integer NOT NULL,
    selection_depth integer NOT NULL,
    pickup_lib integer NOT NULL,
    hold_type text NOT NULL,
    holdable_formats text,
    phone_notify boolean NOT NULL,
    email_notify boolean NOT NULL,
    frozen boolean NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean NOT NULL,
    shelf_expire_time timestamp with time zone,
    current_shelf_lib integer,
    sms_notify boolean NOT NULL
);


ALTER TABLE action.aged_hold_request OWNER TO evergreen;

--
-- Name: usr_address; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.usr_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text,
    country text NOT NULL,
    post_code text NOT NULL,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE actor.usr_address OWNER TO evergreen;

--
-- Name: call_number; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.call_number (
    id bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint NOT NULL,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint NOT NULL,
    label_sortkey text,
    prefix integer DEFAULT '-1'::integer NOT NULL,
    suffix integer DEFAULT '-1'::integer NOT NULL
);


ALTER TABLE asset.call_number OWNER TO evergreen;

--
-- Name: all_circulation; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW action.all_circulation AS
 SELECT aged_circulation.id,
    aged_circulation.usr_post_code,
    aged_circulation.usr_home_ou,
    aged_circulation.usr_profile,
    aged_circulation.usr_birth_year,
    aged_circulation.copy_call_number,
    aged_circulation.copy_location,
    aged_circulation.copy_owning_lib,
    aged_circulation.copy_circ_lib,
    aged_circulation.copy_bib_record,
    aged_circulation.xact_start,
    aged_circulation.xact_finish,
    aged_circulation.target_copy,
    aged_circulation.circ_lib,
    aged_circulation.circ_staff,
    aged_circulation.checkin_staff,
    aged_circulation.checkin_lib,
    aged_circulation.renewal_remaining,
    aged_circulation.grace_period,
    aged_circulation.due_date,
    aged_circulation.stop_fines_time,
    aged_circulation.checkin_time,
    aged_circulation.create_time,
    aged_circulation.duration,
    aged_circulation.fine_interval,
    aged_circulation.recurring_fine,
    aged_circulation.max_fine,
    aged_circulation.phone_renewal,
    aged_circulation.desk_renewal,
    aged_circulation.opac_renewal,
    aged_circulation.duration_rule,
    aged_circulation.recurring_fine_rule,
    aged_circulation.max_fine_rule,
    aged_circulation.stop_fines,
    aged_circulation.workstation,
    aged_circulation.checkin_workstation,
    aged_circulation.checkin_scan_time,
    aged_circulation.parent_circ,
    aged_circulation.auto_renewal,
    aged_circulation.auto_renewal_remaining,
    NULL::integer AS usr
   FROM action.aged_circulation
UNION ALL
 SELECT DISTINCT circ.id,
    COALESCE(a.post_code, b.post_code) AS usr_post_code,
    p.home_ou AS usr_home_ou,
    p.profile AS usr_profile,
    (date_part('year'::text, p.dob))::integer AS usr_birth_year,
    cp.call_number AS copy_call_number,
    circ.copy_location,
    cn.owning_lib AS copy_owning_lib,
    cp.circ_lib AS copy_circ_lib,
    cn.record AS copy_bib_record,
    circ.xact_start,
    circ.xact_finish,
    circ.target_copy,
    circ.circ_lib,
    circ.circ_staff,
    circ.checkin_staff,
    circ.checkin_lib,
    circ.renewal_remaining,
    circ.grace_period,
    circ.due_date,
    circ.stop_fines_time,
    circ.checkin_time,
    circ.create_time,
    circ.duration,
    circ.fine_interval,
    circ.recurring_fine,
    circ.max_fine,
    circ.phone_renewal,
    circ.desk_renewal,
    circ.opac_renewal,
    circ.duration_rule,
    circ.recurring_fine_rule,
    circ.max_fine_rule,
    circ.stop_fines,
    circ.workstation,
    circ.checkin_workstation,
    circ.checkin_scan_time,
    circ.parent_circ,
    circ.auto_renewal,
    circ.auto_renewal_remaining,
    circ.usr
   FROM (((((action.circulation circ
     JOIN asset.copy cp ON ((circ.target_copy = cp.id)))
     JOIN asset.call_number cn ON ((cp.call_number = cn.id)))
     JOIN actor.usr p ON ((circ.usr = p.id)))
     LEFT JOIN actor.usr_address a ON ((p.mailing_address = a.id)))
     LEFT JOIN actor.usr_address b ON ((p.billing_address = b.id)));


ALTER TABLE action.all_circulation OWNER TO evergreen;

--
-- Name: in_house_use; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.in_house_use (
    id integer NOT NULL,
    item bigint NOT NULL,
    staff integer NOT NULL,
    org_unit integer NOT NULL,
    use_time timestamp with time zone DEFAULT now() NOT NULL,
    workstation integer
);


ALTER TABLE action.in_house_use OWNER TO evergreen;

--
-- Name: non_cat_in_house_use; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.non_cat_in_house_use (
    id integer NOT NULL,
    item_type bigint NOT NULL,
    staff integer NOT NULL,
    org_unit integer NOT NULL,
    use_time timestamp with time zone DEFAULT now() NOT NULL,
    workstation integer
);


ALTER TABLE action.non_cat_in_house_use OWNER TO evergreen;

--
-- Name: non_cataloged_circulation; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.non_cataloged_circulation (
    id integer NOT NULL,
    patron integer NOT NULL,
    staff integer NOT NULL,
    circ_lib integer NOT NULL,
    item_type integer NOT NULL,
    circ_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.non_cataloged_circulation OWNER TO evergreen;

--
-- Name: non_cataloged_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.non_cataloged_type (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    name text NOT NULL,
    circ_duration interval DEFAULT '14 days'::interval NOT NULL,
    in_house boolean DEFAULT false NOT NULL
);


ALTER TABLE config.non_cataloged_type OWNER TO evergreen;

--
-- Name: TABLE non_cataloged_type; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.non_cataloged_type IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Types of valid non-cataloged items.
 *
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: all_circulation_combined_types; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW action.all_circulation_combined_types AS
 SELECT acirc.id,
    acirc.xact_start,
    acirc.circ_lib,
    acirc.circ_staff,
    acirc.create_time,
    ac_acirc.circ_modifier AS item_type,
    'regular_circ'::text AS circ_type
   FROM action.circulation acirc,
    asset.copy ac_acirc
  WHERE (acirc.target_copy = ac_acirc.id)
UNION ALL
 SELECT (ancc.id)::bigint AS id,
    ancc.circ_time AS xact_start,
    ancc.circ_lib,
    ancc.staff AS circ_staff,
    ancc.circ_time AS create_time,
    cnct_ancc.name AS item_type,
    'non-cat_circ'::text AS circ_type
   FROM action.non_cataloged_circulation ancc,
    config.non_cataloged_type cnct_ancc
  WHERE (ancc.item_type = cnct_ancc.id)
UNION ALL
 SELECT (aihu.id)::bigint AS id,
    aihu.use_time AS xact_start,
    aihu.org_unit AS circ_lib,
    aihu.staff AS circ_staff,
    aihu.use_time AS create_time,
    ac_aihu.circ_modifier AS item_type,
    'in-house_use'::text AS circ_type
   FROM action.in_house_use aihu,
    asset.copy ac_aihu
  WHERE (aihu.item = ac_aihu.id)
UNION ALL
 SELECT (ancihu.id)::bigint AS id,
    ancihu.use_time AS xact_start,
    ancihu.org_unit AS circ_lib,
    ancihu.staff AS circ_staff,
    ancihu.use_time AS create_time,
    cnct_ancihu.name AS item_type,
    'non-cat-in-house_use'::text AS circ_type
   FROM action.non_cat_in_house_use ancihu,
    config.non_cataloged_type cnct_ancihu
  WHERE (ancihu.item_type = cnct_ancihu.id)
UNION ALL
 SELECT aacirc.id,
    aacirc.xact_start,
    aacirc.circ_lib,
    aacirc.circ_staff,
    aacirc.create_time,
    ac_aacirc.circ_modifier AS item_type,
    'aged_circ'::text AS circ_type
   FROM action.aged_circulation aacirc,
    asset.copy ac_aacirc
  WHERE (aacirc.target_copy = ac_aacirc.id);


ALTER TABLE action.all_circulation_combined_types OWNER TO evergreen;

--
-- Name: all_hold_request; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW action.all_hold_request AS
 SELECT DISTINCT COALESCE(a.post_code, b.post_code) AS usr_post_code,
    p.home_ou AS usr_home_ou,
    p.profile AS usr_profile,
    (date_part('year'::text, p.dob))::integer AS usr_birth_year,
    (ahr.requestor <> ahr.usr) AS staff_placed,
    ahr.id,
    ahr.request_time,
    ahr.capture_time,
    ahr.fulfillment_time,
    ahr.checkin_time,
    ahr.return_time,
    ahr.prev_check_time,
    ahr.expire_time,
    ahr.cancel_time,
    ahr.cancel_cause,
    ahr.cancel_note,
    ahr.target,
    ahr.current_copy,
    ahr.fulfillment_staff,
    ahr.fulfillment_lib,
    ahr.request_lib,
    ahr.selection_ou,
    ahr.selection_depth,
    ahr.pickup_lib,
    ahr.hold_type,
    ahr.holdable_formats,
        CASE
            WHEN (ahr.phone_notify IS NULL) THEN false
            WHEN (ahr.phone_notify = ''::text) THEN false
            ELSE true
        END AS phone_notify,
    ahr.email_notify,
        CASE
            WHEN (ahr.sms_notify IS NULL) THEN false
            WHEN (ahr.sms_notify = ''::text) THEN false
            ELSE true
        END AS sms_notify,
    ahr.frozen,
    ahr.thaw_date,
    ahr.shelf_time,
    ahr.cut_in_line,
    ahr.mint_condition,
    ahr.shelf_expire_time,
    ahr.current_shelf_lib
   FROM (((action.hold_request ahr
     JOIN actor.usr p ON ((ahr.usr = p.id)))
     LEFT JOIN actor.usr_address a ON ((p.mailing_address = a.id)))
     LEFT JOIN actor.usr_address b ON ((p.billing_address = b.id)))
UNION ALL
 SELECT aged_hold_request.usr_post_code,
    aged_hold_request.usr_home_ou,
    aged_hold_request.usr_profile,
    aged_hold_request.usr_birth_year,
    aged_hold_request.staff_placed,
    aged_hold_request.id,
    aged_hold_request.request_time,
    aged_hold_request.capture_time,
    aged_hold_request.fulfillment_time,
    aged_hold_request.checkin_time,
    aged_hold_request.return_time,
    aged_hold_request.prev_check_time,
    aged_hold_request.expire_time,
    aged_hold_request.cancel_time,
    aged_hold_request.cancel_cause,
    aged_hold_request.cancel_note,
    aged_hold_request.target,
    aged_hold_request.current_copy,
    aged_hold_request.fulfillment_staff,
    aged_hold_request.fulfillment_lib,
    aged_hold_request.request_lib,
    aged_hold_request.selection_ou,
    aged_hold_request.selection_depth,
    aged_hold_request.pickup_lib,
    aged_hold_request.hold_type,
    aged_hold_request.holdable_formats,
    aged_hold_request.phone_notify,
    aged_hold_request.email_notify,
    aged_hold_request.sms_notify,
    aged_hold_request.frozen,
    aged_hold_request.thaw_date,
    aged_hold_request.shelf_time,
    aged_hold_request.cut_in_line,
    aged_hold_request.mint_condition,
    aged_hold_request.shelf_expire_time,
    aged_hold_request.current_shelf_lib
   FROM action.aged_hold_request;


ALTER TABLE action.all_hold_request OWNER TO evergreen;

--
-- Name: archive_actor_stat_cat; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archive_actor_stat_cat (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    stat_cat integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE action.archive_actor_stat_cat OWNER TO evergreen;

--
-- Name: archive_actor_stat_cat_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.archive_actor_stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.archive_actor_stat_cat_id_seq OWNER TO evergreen;

--
-- Name: archive_actor_stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.archive_actor_stat_cat_id_seq OWNED BY action.archive_actor_stat_cat.id;


--
-- Name: archive_asset_stat_cat; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archive_asset_stat_cat (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    stat_cat integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE action.archive_asset_stat_cat OWNER TO evergreen;

--
-- Name: archive_asset_stat_cat_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.archive_asset_stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.archive_asset_stat_cat_id_seq OWNER TO evergreen;

--
-- Name: archive_asset_stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.archive_asset_stat_cat_id_seq OWNED BY action.archive_asset_stat_cat.id;


--
-- Name: archived_hold_request; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archived_hold_request (
    id integer NOT NULL,
    request_time timestamp with time zone NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint NOT NULL,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer NOT NULL,
    requestor integer NOT NULL,
    usr integer NOT NULL,
    selection_ou integer NOT NULL,
    selection_depth integer NOT NULL,
    pickup_lib integer NOT NULL,
    hold_type text NOT NULL,
    holdable_formats text,
    phone_notify text,
    email_notify boolean NOT NULL,
    frozen boolean NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean NOT NULL,
    shelf_expire_time timestamp with time zone,
    current_shelf_lib integer,
    sms_notify text,
    sms_carrier integer
);


ALTER TABLE action.archived_hold_request OWNER TO evergreen;

--
-- Name: archived_hold_request_2005; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archived_hold_request_2005 (
    CONSTRAINT archived_hold_request_2005_request_time_check CHECK (((request_time >= '2005-01-01 03:00:00-05'::timestamp with time zone) AND (request_time < '2006-01-01 03:00:00-05'::timestamp with time zone)))
)
INHERITS (action.archived_hold_request);


ALTER TABLE action.archived_hold_request_2005 OWNER TO evergreen;

--
-- Name: archived_hold_request_2006; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archived_hold_request_2006 (
    CONSTRAINT archived_hold_request_2006_request_time_check CHECK (((request_time >= '2006-01-01 03:00:00-05'::timestamp with time zone) AND (request_time < '2007-01-01 03:00:00-05'::timestamp with time zone)))
)
INHERITS (action.archived_hold_request);


ALTER TABLE action.archived_hold_request_2006 OWNER TO evergreen;

--
-- Name: archived_hold_request_2007; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archived_hold_request_2007 (
    CONSTRAINT archived_hold_request_2007_request_time_check CHECK (((request_time >= '2007-01-01 03:00:00-05'::timestamp with time zone) AND (request_time < '2008-01-01 03:00:00-05'::timestamp with time zone)))
)
INHERITS (action.archived_hold_request);


ALTER TABLE action.archived_hold_request_2007 OWNER TO evergreen;

--
-- Name: archived_hold_request_2008; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archived_hold_request_2008 (
    CONSTRAINT archived_hold_request_2008_request_time_check CHECK (((request_time >= '2008-01-01 03:00:00-05'::timestamp with time zone) AND (request_time < '2009-01-01 03:00:00-05'::timestamp with time zone)))
)
INHERITS (action.archived_hold_request);


ALTER TABLE action.archived_hold_request_2008 OWNER TO evergreen;

--
-- Name: archived_hold_request_2009; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archived_hold_request_2009 (
    CONSTRAINT archived_hold_request_2009_request_time_check CHECK (((request_time >= '2009-01-01 03:00:00-05'::timestamp with time zone) AND (request_time < '2010-01-01 03:00:00-05'::timestamp with time zone)))
)
INHERITS (action.archived_hold_request);


ALTER TABLE action.archived_hold_request_2009 OWNER TO evergreen;

--
-- Name: archived_hold_request_2010; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archived_hold_request_2010 (
    CONSTRAINT archived_hold_request_2010_request_time_check CHECK (((request_time >= '2010-01-01 03:00:00-05'::timestamp with time zone) AND (request_time < '2011-01-01 03:00:00-05'::timestamp with time zone)))
)
INHERITS (action.archived_hold_request);


ALTER TABLE action.archived_hold_request_2010 OWNER TO evergreen;

--
-- Name: archived_hold_request_2011; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archived_hold_request_2011 (
    CONSTRAINT archived_hold_request_2011_request_time_check CHECK (((request_time >= '2011-01-01 03:00:00-05'::timestamp with time zone) AND (request_time < '2012-01-01 03:00:00-05'::timestamp with time zone)))
)
INHERITS (action.archived_hold_request);


ALTER TABLE action.archived_hold_request_2011 OWNER TO evergreen;

--
-- Name: archived_hold_request_2012; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archived_hold_request_2012 (
    CONSTRAINT archived_hold_request_2012_request_time_check CHECK (((request_time >= '2012-01-01 03:00:00-05'::timestamp with time zone) AND (request_time < '2013-01-01 03:00:00-05'::timestamp with time zone)))
)
INHERITS (action.archived_hold_request);


ALTER TABLE action.archived_hold_request_2012 OWNER TO evergreen;

--
-- Name: archived_hold_request_2013; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.archived_hold_request_2013 (
    CONSTRAINT archived_hold_request_2013_request_time_check CHECK (((request_time >= '2013-01-01 03:00:00-05'::timestamp with time zone) AND (request_time < '2014-01-01 03:00:00-05'::timestamp with time zone)))
)
INHERITS (action.archived_hold_request);


ALTER TABLE action.archived_hold_request_2013 OWNER TO evergreen;

--
-- Name: batch_hold_event; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.batch_hold_event (
    id integer NOT NULL,
    staff integer NOT NULL,
    bucket integer NOT NULL,
    target integer NOT NULL,
    hold_type text DEFAULT 'T'::text NOT NULL,
    run_date timestamp with time zone DEFAULT now() NOT NULL,
    cancelled timestamp with time zone
);


ALTER TABLE action.batch_hold_event OWNER TO evergreen;

--
-- Name: batch_hold_event_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.batch_hold_event_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.batch_hold_event_id_seq OWNER TO evergreen;

--
-- Name: batch_hold_event_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.batch_hold_event_id_seq OWNED BY action.batch_hold_event.id;


--
-- Name: batch_hold_event_map; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.batch_hold_event_map (
    id integer NOT NULL,
    batch_hold_event integer NOT NULL,
    hold integer NOT NULL
);


ALTER TABLE action.batch_hold_event_map OWNER TO evergreen;

--
-- Name: batch_hold_event_map_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.batch_hold_event_map_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.batch_hold_event_map_id_seq OWNER TO evergreen;

--
-- Name: batch_hold_event_map_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.batch_hold_event_map_id_seq OWNED BY action.batch_hold_event_map.id;


--
-- Name: billable_circulations; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW action.billable_circulations AS
 SELECT circulation.id,
    circulation.usr,
    circulation.xact_start,
    circulation.xact_finish,
    circulation.unrecovered,
    circulation.target_copy,
    circulation.circ_lib,
    circulation.circ_staff,
    circulation.checkin_staff,
    circulation.checkin_lib,
    circulation.renewal_remaining,
    circulation.due_date,
    circulation.stop_fines_time,
    circulation.checkin_time,
    circulation.create_time,
    circulation.duration,
    circulation.fine_interval,
    circulation.recurring_fine,
    circulation.max_fine,
    circulation.phone_renewal,
    circulation.desk_renewal,
    circulation.opac_renewal,
    circulation.duration_rule,
    circulation.recurring_fine_rule,
    circulation.max_fine_rule,
    circulation.stop_fines,
    circulation.workstation,
    circulation.checkin_workstation,
    circulation.checkin_scan_time,
    circulation.parent_circ,
    circulation.grace_period,
    circulation.copy_location,
    circulation.auto_renewal,
    circulation.auto_renewal_remaining
   FROM action.circulation
  WHERE (circulation.xact_finish IS NULL);


ALTER TABLE action.billable_circulations OWNER TO evergreen;

--
-- Name: circulation_limit_group_map; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.circulation_limit_group_map (
    circ bigint NOT NULL,
    limit_group integer NOT NULL
);


ALTER TABLE action.circulation_limit_group_map OWNER TO evergreen;

--
-- Name: curbside; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.curbside (
    id integer NOT NULL,
    patron integer NOT NULL,
    org integer NOT NULL,
    slot timestamp with time zone,
    staged timestamp with time zone,
    stage_staff integer,
    arrival timestamp with time zone,
    delivered timestamp with time zone,
    delivery_staff integer,
    notes text
);


ALTER TABLE action.curbside OWNER TO evergreen;

--
-- Name: curbside_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.curbside_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.curbside_id_seq OWNER TO evergreen;

--
-- Name: curbside_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.curbside_id_seq OWNED BY action.curbside.id;


--
-- Name: emergency_closing; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.emergency_closing (
    id integer NOT NULL,
    creator integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    process_start_time timestamp with time zone,
    process_end_time timestamp with time zone,
    last_update_time timestamp with time zone
);


ALTER TABLE action.emergency_closing OWNER TO evergreen;

--
-- Name: emergency_closing_circulation; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.emergency_closing_circulation (
    id bigint NOT NULL,
    emergency_closing integer NOT NULL,
    circulation integer NOT NULL,
    original_due_date timestamp with time zone,
    process_time timestamp with time zone
);


ALTER TABLE action.emergency_closing_circulation OWNER TO evergreen;

--
-- Name: emergency_closing_circulation_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.emergency_closing_circulation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.emergency_closing_circulation_id_seq OWNER TO evergreen;

--
-- Name: emergency_closing_circulation_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.emergency_closing_circulation_id_seq OWNED BY action.emergency_closing_circulation.id;


--
-- Name: emergency_closing_hold; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.emergency_closing_hold (
    id bigint NOT NULL,
    emergency_closing integer NOT NULL,
    hold integer NOT NULL,
    original_shelf_expire_time timestamp with time zone,
    process_time timestamp with time zone
);


ALTER TABLE action.emergency_closing_hold OWNER TO evergreen;

--
-- Name: emergency_closing_hold_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.emergency_closing_hold_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.emergency_closing_hold_id_seq OWNER TO evergreen;

--
-- Name: emergency_closing_hold_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.emergency_closing_hold_id_seq OWNED BY action.emergency_closing_hold.id;


--
-- Name: emergency_closing_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.emergency_closing_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.emergency_closing_id_seq OWNER TO evergreen;

--
-- Name: emergency_closing_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.emergency_closing_id_seq OWNED BY action.emergency_closing.id;


--
-- Name: emergency_closing_reservation; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.emergency_closing_reservation (
    id bigint NOT NULL,
    emergency_closing integer NOT NULL,
    reservation integer NOT NULL,
    original_end_time timestamp with time zone,
    process_time timestamp with time zone
);


ALTER TABLE action.emergency_closing_reservation OWNER TO evergreen;

--
-- Name: emergency_closing_reservation_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.emergency_closing_reservation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.emergency_closing_reservation_id_seq OWNER TO evergreen;

--
-- Name: emergency_closing_reservation_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.emergency_closing_reservation_id_seq OWNED BY action.emergency_closing_reservation.id;


--
-- Name: emergency_closing_status; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW action.emergency_closing_status AS
 SELECT e.id,
    e.creator,
    e.create_time,
    e.process_start_time,
    e.process_end_time,
    e.last_update_time,
    COALESCE(c.count, (0)::bigint) AS circulations,
    COALESCE(c.completed, (0)::bigint) AS circulations_complete,
    COALESCE(b.count, (0)::bigint) AS reservations,
    COALESCE(b.completed, (0)::bigint) AS reservations_complete,
    COALESCE(h.count, (0)::bigint) AS holds,
    COALESCE(h.completed, (0)::bigint) AS holds_complete
   FROM (((action.emergency_closing e
     LEFT JOIN ( SELECT emergency_closing_circulation.emergency_closing,
            count(*) AS count,
            sum(((emergency_closing_circulation.process_time IS NOT NULL))::integer) AS completed
           FROM action.emergency_closing_circulation
          GROUP BY emergency_closing_circulation.emergency_closing) c ON ((c.emergency_closing = e.id)))
     LEFT JOIN ( SELECT emergency_closing_reservation.emergency_closing,
            count(*) AS count,
            sum(((emergency_closing_reservation.process_time IS NOT NULL))::integer) AS completed
           FROM action.emergency_closing_reservation
          GROUP BY emergency_closing_reservation.emergency_closing) b ON ((b.emergency_closing = e.id)))
     LEFT JOIN ( SELECT emergency_closing_hold.emergency_closing,
            count(*) AS count,
            sum(((emergency_closing_hold.process_time IS NOT NULL))::integer) AS completed
           FROM action.emergency_closing_hold
          GROUP BY emergency_closing_hold.emergency_closing) h ON ((h.emergency_closing = e.id)));


ALTER TABLE action.emergency_closing_status OWNER TO evergreen;

--
-- Name: fieldset; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.fieldset (
    id integer NOT NULL,
    owner integer NOT NULL,
    owning_lib integer NOT NULL,
    status text NOT NULL,
    creation_time timestamp with time zone DEFAULT now() NOT NULL,
    scheduled_time timestamp with time zone,
    applied_time timestamp with time zone,
    classname text NOT NULL,
    name text NOT NULL,
    stored_query integer,
    pkey_value text,
    fieldset_group integer,
    error_msg text,
    CONSTRAINT fieldset_one_or_the_other CHECK ((((stored_query IS NOT NULL) AND (pkey_value IS NULL)) OR ((pkey_value IS NOT NULL) AND (stored_query IS NULL)))),
    CONSTRAINT valid_status CHECK ((status = ANY (ARRAY['PENDING'::text, 'APPLIED'::text, 'ERROR'::text])))
);


ALTER TABLE action.fieldset OWNER TO evergreen;

--
-- Name: fieldset_col_val; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.fieldset_col_val (
    id integer NOT NULL,
    fieldset integer NOT NULL,
    col text NOT NULL,
    val text
);


ALTER TABLE action.fieldset_col_val OWNER TO evergreen;

--
-- Name: fieldset_col_val_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.fieldset_col_val_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.fieldset_col_val_id_seq OWNER TO evergreen;

--
-- Name: fieldset_col_val_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.fieldset_col_val_id_seq OWNED BY action.fieldset_col_val.id;


--
-- Name: fieldset_group; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.fieldset_group (
    id integer NOT NULL,
    name text NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    complete_time timestamp with time zone,
    container integer,
    container_type text,
    can_rollback boolean DEFAULT true,
    rollback_group integer,
    rollback_time timestamp with time zone,
    creator integer NOT NULL,
    owning_lib integer NOT NULL
);


ALTER TABLE action.fieldset_group OWNER TO evergreen;

--
-- Name: fieldset_group_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.fieldset_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.fieldset_group_id_seq OWNER TO evergreen;

--
-- Name: fieldset_group_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.fieldset_group_id_seq OWNED BY action.fieldset_group.id;


--
-- Name: fieldset_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.fieldset_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.fieldset_id_seq OWNER TO evergreen;

--
-- Name: fieldset_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.fieldset_id_seq OWNED BY action.fieldset.id;


--
-- Name: hold_copy_map; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.hold_copy_map (
    id bigint NOT NULL,
    hold integer NOT NULL,
    target_copy bigint NOT NULL,
    proximity numeric
)
WITH (autovacuum_enabled='true', autovacuum_vacuum_cost_delay='5', toast.autovacuum_enabled='true');
ALTER TABLE ONLY action.hold_copy_map ALTER COLUMN hold SET STATISTICS 500;
ALTER TABLE ONLY action.hold_copy_map ALTER COLUMN target_copy SET STATISTICS 500;


ALTER TABLE action.hold_copy_map OWNER TO evergreen;

--
-- Name: hold_copy_map_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.hold_copy_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_copy_map_id_seq OWNER TO evergreen;

--
-- Name: hold_copy_map_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.hold_copy_map_id_seq OWNED BY action.hold_copy_map.id;


--
-- Name: hold_notification; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.hold_notification (
    id integer NOT NULL,
    hold integer NOT NULL,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text NOT NULL,
    note text
);


ALTER TABLE action.hold_notification OWNER TO evergreen;

--
-- Name: hold_notification_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.hold_notification_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_notification_id_seq OWNER TO evergreen;

--
-- Name: hold_notification_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.hold_notification_id_seq OWNED BY action.hold_notification.id;


--
-- Name: hold_request_back; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.hold_request_back (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone,
    current_shelf_lib integer,
    sms_notify text,
    sms_carrier integer
);


ALTER TABLE action.hold_request_back OWNER TO evergreen;

--
-- Name: hold_request_cancel_cause; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.hold_request_cancel_cause (
    id integer NOT NULL,
    label text
);


ALTER TABLE action.hold_request_cancel_cause OWNER TO evergreen;

--
-- Name: hold_request_cancel_cause_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.hold_request_cancel_cause_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_request_cancel_cause_id_seq OWNER TO evergreen;

--
-- Name: hold_request_cancel_cause_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.hold_request_cancel_cause_id_seq OWNED BY action.hold_request_cancel_cause.id;


--
-- Name: hold_request_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.hold_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_request_id_seq OWNER TO evergreen;

--
-- Name: hold_request_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.hold_request_id_seq OWNED BY action.hold_request.id;


--
-- Name: hold_request_note; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.hold_request_note (
    id bigint NOT NULL,
    hold bigint NOT NULL,
    title text NOT NULL,
    body text NOT NULL,
    slip boolean DEFAULT false NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    staff boolean DEFAULT false NOT NULL
);


ALTER TABLE action.hold_request_note OWNER TO evergreen;

--
-- Name: hold_request_note_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.hold_request_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.hold_request_note_id_seq OWNER TO evergreen;

--
-- Name: hold_request_note_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.hold_request_note_id_seq OWNED BY action.hold_request_note.id;


--
-- Name: transit_copy; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.transit_copy (
    id integer NOT NULL,
    source_send_time timestamp with time zone,
    dest_recv_time timestamp with time zone,
    target_copy bigint NOT NULL,
    source integer NOT NULL,
    dest integer NOT NULL,
    prev_hop integer,
    copy_status integer NOT NULL,
    persistant_transfer boolean DEFAULT false NOT NULL,
    prev_dest integer,
    cancel_time timestamp with time zone
);


ALTER TABLE action.transit_copy OWNER TO evergreen;

--
-- Name: hold_transit_copy; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.hold_transit_copy (
    hold integer
)
INHERITS (action.transit_copy);


ALTER TABLE action.hold_transit_copy OWNER TO evergreen;

--
-- Name: in_house_use_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.in_house_use_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.in_house_use_id_seq OWNER TO evergreen;

--
-- Name: in_house_use_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.in_house_use_id_seq OWNED BY action.in_house_use.id;


--
-- Name: non_cat_in_house_use_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.non_cat_in_house_use_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.non_cat_in_house_use_id_seq OWNER TO evergreen;

--
-- Name: non_cat_in_house_use_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.non_cat_in_house_use_id_seq OWNED BY action.non_cat_in_house_use.id;


--
-- Name: non_cataloged_circulation_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.non_cataloged_circulation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.non_cataloged_circulation_id_seq OWNER TO evergreen;

--
-- Name: non_cataloged_circulation_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.non_cataloged_circulation_id_seq OWNED BY action.non_cataloged_circulation.id;


--
-- Name: open_circulation; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW action.open_circulation AS
 SELECT circulation.id,
    circulation.usr,
    circulation.xact_start,
    circulation.xact_finish,
    circulation.unrecovered,
    circulation.target_copy,
    circulation.circ_lib,
    circulation.circ_staff,
    circulation.checkin_staff,
    circulation.checkin_lib,
    circulation.renewal_remaining,
    circulation.due_date,
    circulation.stop_fines_time,
    circulation.checkin_time,
    circulation.create_time,
    circulation.duration,
    circulation.fine_interval,
    circulation.recurring_fine,
    circulation.max_fine,
    circulation.phone_renewal,
    circulation.desk_renewal,
    circulation.opac_renewal,
    circulation.duration_rule,
    circulation.recurring_fine_rule,
    circulation.max_fine_rule,
    circulation.stop_fines,
    circulation.workstation,
    circulation.checkin_workstation,
    circulation.checkin_scan_time,
    circulation.parent_circ,
    circulation.grace_period,
    circulation.copy_location,
    circulation.auto_renewal,
    circulation.auto_renewal_remaining
   FROM action.circulation
  WHERE (circulation.checkin_time IS NULL)
  ORDER BY circulation.due_date;


ALTER TABLE action.open_circulation OWNER TO evergreen;

--
-- Name: reservation_transit_copy; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.reservation_transit_copy (
    reservation integer
)
INHERITS (action.transit_copy);


ALTER TABLE action.reservation_transit_copy OWNER TO evergreen;

--
-- Name: survey; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.survey (
    id integer NOT NULL,
    owner integer NOT NULL,
    start_date timestamp with time zone DEFAULT now() NOT NULL,
    end_date timestamp with time zone DEFAULT (now() + '10 years'::interval) NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL,
    opac boolean DEFAULT false NOT NULL,
    poll boolean DEFAULT false NOT NULL,
    required boolean DEFAULT false NOT NULL,
    name text NOT NULL,
    description text NOT NULL
);


ALTER TABLE action.survey OWNER TO evergreen;

--
-- Name: survey_answer; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.survey_answer (
    id integer NOT NULL,
    question integer NOT NULL,
    answer text NOT NULL
);


ALTER TABLE action.survey_answer OWNER TO evergreen;

--
-- Name: survey_answer_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.survey_answer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_answer_id_seq OWNER TO evergreen;

--
-- Name: survey_answer_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.survey_answer_id_seq OWNED BY action.survey_answer.id;


--
-- Name: survey_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.survey_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_id_seq OWNER TO evergreen;

--
-- Name: survey_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.survey_id_seq OWNED BY action.survey.id;


--
-- Name: survey_question; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.survey_question (
    id integer NOT NULL,
    survey integer NOT NULL,
    question text NOT NULL
);


ALTER TABLE action.survey_question OWNER TO evergreen;

--
-- Name: survey_question_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.survey_question_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_question_id_seq OWNER TO evergreen;

--
-- Name: survey_question_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.survey_question_id_seq OWNED BY action.survey_question.id;


--
-- Name: survey_response; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.survey_response (
    id bigint NOT NULL,
    response_group_id integer,
    usr integer,
    survey integer NOT NULL,
    question integer NOT NULL,
    answer integer NOT NULL,
    answer_date timestamp with time zone,
    effective_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.survey_response OWNER TO evergreen;

--
-- Name: survey_response_group_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.survey_response_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_response_group_id_seq OWNER TO evergreen;

--
-- Name: survey_response_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.survey_response_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.survey_response_id_seq OWNER TO evergreen;

--
-- Name: survey_response_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.survey_response_id_seq OWNED BY action.survey_response.id;


--
-- Name: transit_copy_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.transit_copy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.transit_copy_id_seq OWNER TO evergreen;

--
-- Name: transit_copy_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.transit_copy_id_seq OWNED BY action.transit_copy.id;


--
-- Name: unfulfilled_hold_list; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.unfulfilled_hold_list (
    id bigint NOT NULL,
    current_copy bigint NOT NULL,
    hold integer NOT NULL,
    circ_lib integer NOT NULL,
    fail_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE action.unfulfilled_hold_list OWNER TO evergreen;

--
-- Name: unfulfilled_hold_loops; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW action.unfulfilled_hold_loops AS
 SELECT u.hold,
    c.circ_lib,
    count(*) AS count
   FROM (action.unfulfilled_hold_list u
     JOIN asset.copy c ON ((c.id = u.current_copy)))
  GROUP BY u.hold, c.circ_lib;


ALTER TABLE action.unfulfilled_hold_loops OWNER TO evergreen;

--
-- Name: unfulfilled_hold_min_loop; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW action.unfulfilled_hold_min_loop AS
 SELECT unfulfilled_hold_loops.hold,
    min(unfulfilled_hold_loops.count) AS min
   FROM action.unfulfilled_hold_loops
  GROUP BY unfulfilled_hold_loops.hold;


ALTER TABLE action.unfulfilled_hold_min_loop OWNER TO evergreen;

--
-- Name: unfulfilled_hold_innermost_loop; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW action.unfulfilled_hold_innermost_loop AS
 SELECT DISTINCT l.hold,
    l.circ_lib,
    l.count
   FROM (action.unfulfilled_hold_loops l
     JOIN action.unfulfilled_hold_min_loop m USING (hold))
  WHERE (l.count = m.min);


ALTER TABLE action.unfulfilled_hold_innermost_loop OWNER TO evergreen;

--
-- Name: unfulfilled_hold_list_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.unfulfilled_hold_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.unfulfilled_hold_list_id_seq OWNER TO evergreen;

--
-- Name: unfulfilled_hold_list_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.unfulfilled_hold_list_id_seq OWNED BY action.unfulfilled_hold_list.id;


--
-- Name: unfulfilled_hold_max_loop; Type: VIEW; Schema: action; Owner: evergreen
--

CREATE VIEW action.unfulfilled_hold_max_loop AS
 SELECT unfulfilled_hold_loops.hold,
    max(unfulfilled_hold_loops.count) AS max
   FROM action.unfulfilled_hold_loops
  GROUP BY unfulfilled_hold_loops.hold;


ALTER TABLE action.unfulfilled_hold_max_loop OWNER TO evergreen;

--
-- Name: usr_circ_history; Type: TABLE; Schema: action; Owner: evergreen
--

CREATE TABLE action.usr_circ_history (
    id bigint NOT NULL,
    usr integer NOT NULL,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    target_copy bigint NOT NULL,
    due_date timestamp with time zone NOT NULL,
    checkin_time timestamp with time zone,
    source_circ bigint
);


ALTER TABLE action.usr_circ_history OWNER TO evergreen;

--
-- Name: usr_circ_history_id_seq; Type: SEQUENCE; Schema: action; Owner: evergreen
--

CREATE SEQUENCE action.usr_circ_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action.usr_circ_history_id_seq OWNER TO evergreen;

--
-- Name: usr_circ_history_id_seq; Type: SEQUENCE OWNED BY; Schema: action; Owner: evergreen
--

ALTER SEQUENCE action.usr_circ_history_id_seq OWNED BY action.usr_circ_history.id;


--
-- Name: action_circulation; Type: TABLE; Schema: action_log; Owner: evergreen
--

CREATE TABLE action_log.action_circulation (
    id bigint NOT NULL,
    audit_time timestamp with time zone DEFAULT now() NOT NULL,
    audit_action character(1)
);


ALTER TABLE action_log.action_circulation OWNER TO evergreen;

--
-- Name: alternate_template; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.alternate_template (
    id integer NOT NULL,
    event_def integer,
    template text,
    active boolean DEFAULT true,
    message_title text,
    message_template text,
    locale text
);


ALTER TABLE action_trigger.alternate_template OWNER TO evergreen;

--
-- Name: alternate_template_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE action_trigger.alternate_template_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.alternate_template_id_seq OWNER TO evergreen;

--
-- Name: alternate_template_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE action_trigger.alternate_template_id_seq OWNED BY action_trigger.alternate_template.id;


--
-- Name: cleanup; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.cleanup (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.cleanup OWNER TO evergreen;

--
-- Name: collector; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.collector (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.collector OWNER TO evergreen;

--
-- Name: environment; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.environment (
    id integer NOT NULL,
    event_def integer NOT NULL,
    path text,
    collector text,
    label text,
    CONSTRAINT environment_label_check CHECK ((label <> ALL (ARRAY['result'::text, 'target'::text, 'event'::text])))
);


ALTER TABLE action_trigger.environment OWNER TO evergreen;

--
-- Name: environment_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE action_trigger.environment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.environment_id_seq OWNER TO evergreen;

--
-- Name: environment_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE action_trigger.environment_id_seq OWNED BY action_trigger.environment.id;


--
-- Name: event; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.event (
    id bigint NOT NULL,
    target bigint NOT NULL,
    event_def integer,
    add_time timestamp with time zone DEFAULT now() NOT NULL,
    run_time timestamp with time zone NOT NULL,
    start_time timestamp with time zone,
    update_time timestamp with time zone,
    complete_time timestamp with time zone,
    update_process integer,
    state text DEFAULT 'pending'::text NOT NULL,
    user_data text,
    template_output bigint,
    error_output bigint,
    async_output bigint,
    context_user integer,
    context_library integer,
    context_bib bigint,
    context_item bigint,
    CONSTRAINT event_state_check CHECK ((state = ANY (ARRAY['pending'::text, 'invalid'::text, 'found'::text, 'collecting'::text, 'collected'::text, 'validating'::text, 'valid'::text, 'reacting'::text, 'reacted'::text, 'cleaning'::text, 'complete'::text, 'error'::text]))),
    CONSTRAINT event_user_data_check CHECK (((user_data IS NULL) OR evergreen.is_json(user_data)))
);


ALTER TABLE action_trigger.event OWNER TO evergreen;

--
-- Name: event_def_group; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.event_def_group (
    id integer NOT NULL,
    owner integer NOT NULL,
    hook text NOT NULL,
    active boolean DEFAULT true NOT NULL,
    name text NOT NULL
);


ALTER TABLE action_trigger.event_def_group OWNER TO evergreen;

--
-- Name: event_def_group_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE action_trigger.event_def_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_def_group_id_seq OWNER TO evergreen;

--
-- Name: event_def_group_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE action_trigger.event_def_group_id_seq OWNED BY action_trigger.event_def_group.id;


--
-- Name: event_def_group_member; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.event_def_group_member (
    id integer NOT NULL,
    grp integer NOT NULL,
    event_def integer NOT NULL,
    sortable boolean DEFAULT true NOT NULL,
    holdings boolean DEFAULT false NOT NULL,
    external boolean DEFAULT false NOT NULL,
    name text NOT NULL
);


ALTER TABLE action_trigger.event_def_group_member OWNER TO evergreen;

--
-- Name: event_def_group_member_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE action_trigger.event_def_group_member_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_def_group_member_id_seq OWNER TO evergreen;

--
-- Name: event_def_group_member_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE action_trigger.event_def_group_member_id_seq OWNED BY action_trigger.event_def_group_member.id;


--
-- Name: event_definition; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.event_definition (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    hook text NOT NULL,
    validator text NOT NULL,
    reactor text NOT NULL,
    cleanup_success text,
    cleanup_failure text,
    delay interval DEFAULT '00:05:00'::interval NOT NULL,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text,
    repeat_delay interval,
    message_template text,
    message_usr_path text,
    message_library_path text,
    message_title text,
    retention_interval interval,
    context_usr_path text,
    context_library_path text,
    context_bib_path text,
    context_item_path text
);


ALTER TABLE action_trigger.event_definition OWNER TO evergreen;

--
-- Name: event_definition_backup; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.event_definition_backup (
    id integer,
    active boolean,
    owner integer,
    name text,
    hook text,
    validator text,
    reactor text,
    cleanup_success text,
    cleanup_failure text,
    delay interval,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text
);


ALTER TABLE action_trigger.event_definition_backup OWNER TO evergreen;

--
-- Name: event_definition_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE action_trigger.event_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_definition_id_seq OWNER TO evergreen;

--
-- Name: event_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE action_trigger.event_definition_id_seq OWNED BY action_trigger.event_definition.id;


--
-- Name: event_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE action_trigger.event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_id_seq OWNER TO evergreen;

--
-- Name: event_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE action_trigger.event_id_seq OWNED BY action_trigger.event.id;


--
-- Name: event_output; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.event_output (
    id bigint NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    is_error boolean DEFAULT false NOT NULL,
    data text NOT NULL,
    locale text
);


ALTER TABLE action_trigger.event_output OWNER TO evergreen;

--
-- Name: event_output_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE action_trigger.event_output_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_output_id_seq OWNER TO evergreen;

--
-- Name: event_output_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE action_trigger.event_output_id_seq OWNED BY action_trigger.event_output.id;


--
-- Name: event_params; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.event_params (
    id bigint NOT NULL,
    event_def integer NOT NULL,
    param text NOT NULL,
    value text NOT NULL
);


ALTER TABLE action_trigger.event_params OWNER TO evergreen;

--
-- Name: event_params_id_seq; Type: SEQUENCE; Schema: action_trigger; Owner: evergreen
--

CREATE SEQUENCE action_trigger.event_params_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE action_trigger.event_params_id_seq OWNER TO evergreen;

--
-- Name: event_params_id_seq; Type: SEQUENCE OWNED BY; Schema: action_trigger; Owner: evergreen
--

ALTER SEQUENCE action_trigger.event_params_id_seq OWNED BY action_trigger.event_params.id;


--
-- Name: hook; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.hook (
    key text NOT NULL,
    core_type text NOT NULL,
    description text,
    passive boolean DEFAULT false NOT NULL
);


ALTER TABLE action_trigger.hook OWNER TO evergreen;

--
-- Name: reactor; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.reactor (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.reactor OWNER TO evergreen;

--
-- Name: validator; Type: TABLE; Schema: action_trigger; Owner: evergreen
--

CREATE TABLE action_trigger.validator (
    module text NOT NULL,
    description text
);


ALTER TABLE action_trigger.validator OWNER TO evergreen;

--
-- Name: ada_request; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.ada_request (
    id integer NOT NULL,
    usr integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    approve_time timestamp with time zone,
    approved_by integer,
    rejected_by integer,
    reject_time timestamp with time zone,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    post_code text NOT NULL,
    phone text,
    email text,
    guardian text,
    rationale text NOT NULL,
    staff_note text
);


ALTER TABLE actor.ada_request OWNER TO evergreen;

--
-- Name: ada_request_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.ada_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.ada_request_id_seq OWNER TO evergreen;

--
-- Name: ada_request_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.ada_request_id_seq OWNED BY actor.ada_request.id;


--
-- Name: address_alert_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.address_alert_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.address_alert_id_seq OWNER TO evergreen;

--
-- Name: address_alert_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.address_alert_id_seq OWNED BY actor.address_alert.id;


--
-- Name: auto_barcode_ecard_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.auto_barcode_ecard_seq
    START WITH 100
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999
    CACHE 1;


ALTER TABLE actor.auto_barcode_ecard_seq OWNER TO evergreen;

--
-- Name: card; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.card (
    id integer NOT NULL,
    usr integer NOT NULL,
    barcode text NOT NULL,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE actor.card OWNER TO evergreen;

--
-- Name: TABLE card; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.card IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Library Cards
 *
 * Each User has one or more library cards.  The current "main"
 * card is linked to here from the actor.usr table, and it is up
 * to the consortium policy whether more than one card can be
 * active for any one user at a given time.
 *
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: card_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.card_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.card_id_seq OWNER TO evergreen;

--
-- Name: card_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.card_id_seq OWNED BY actor.card.id;


--
-- Name: copy_alert_suppress; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.copy_alert_suppress (
    id integer NOT NULL,
    org integer NOT NULL,
    alert_type integer NOT NULL
);


ALTER TABLE actor.copy_alert_suppress OWNER TO evergreen;

--
-- Name: copy_alert_suppress_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.copy_alert_suppress_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.copy_alert_suppress_id_seq OWNER TO evergreen;

--
-- Name: copy_alert_suppress_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.copy_alert_suppress_id_seq OWNED BY actor.copy_alert_suppress.id;


--
-- Name: hours_of_operation; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.hours_of_operation (
    id integer NOT NULL,
    dow_0_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_0_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_1_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_1_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_2_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_2_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_3_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_3_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_4_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_4_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_5_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_5_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,
    dow_6_open time without time zone DEFAULT '09:00:00'::time without time zone NOT NULL,
    dow_6_close time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL
);


ALTER TABLE actor.hours_of_operation OWNER TO evergreen;

--
-- Name: TABLE hours_of_operation; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.hours_of_operation IS '
When does this org_unit usually open and close?  (Variations
are expressed in the actor.org_unit_closed table.)
';


--
-- Name: COLUMN hours_of_operation.dow_0_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_0_open IS '
When does this org_unit open on Monday?
';


--
-- Name: COLUMN hours_of_operation.dow_0_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_0_close IS '
When does this org_unit close on Monday?
';


--
-- Name: COLUMN hours_of_operation.dow_1_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_1_open IS '
When does this org_unit open on Tuesday?
';


--
-- Name: COLUMN hours_of_operation.dow_1_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_1_close IS '
When does this org_unit close on Tuesday?
';


--
-- Name: COLUMN hours_of_operation.dow_2_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_2_open IS '
When does this org_unit open on Wednesday?
';


--
-- Name: COLUMN hours_of_operation.dow_2_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_2_close IS '
When does this org_unit close on Wednesday?
';


--
-- Name: COLUMN hours_of_operation.dow_3_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_3_open IS '
When does this org_unit open on Thursday?
';


--
-- Name: COLUMN hours_of_operation.dow_3_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_3_close IS '
When does this org_unit close on Thursday?
';


--
-- Name: COLUMN hours_of_operation.dow_4_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_4_open IS '
When does this org_unit open on Friday?
';


--
-- Name: COLUMN hours_of_operation.dow_4_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_4_close IS '
When does this org_unit close on Friday?
';


--
-- Name: COLUMN hours_of_operation.dow_5_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_5_open IS '
When does this org_unit open on Saturday?
';


--
-- Name: COLUMN hours_of_operation.dow_5_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_5_close IS '
When does this org_unit close on Saturday?
';


--
-- Name: COLUMN hours_of_operation.dow_6_open; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_6_open IS '
When does this org_unit open on Sunday?
';


--
-- Name: COLUMN hours_of_operation.dow_6_close; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON COLUMN actor.hours_of_operation.dow_6_close IS '
When does this org_unit close on Sunday?
';


--
-- Name: org_address; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.org_address (
    id integer NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    org_unit integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text,
    country text NOT NULL,
    post_code text NOT NULL,
    san text,
    latitude double precision,
    longitude double precision
);


ALTER TABLE actor.org_address OWNER TO evergreen;

--
-- Name: org_address_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.org_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_address_id_seq OWNER TO evergreen;

--
-- Name: org_address_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.org_address_id_seq OWNED BY actor.org_address.id;


--
-- Name: org_lasso; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.org_lasso (
    id integer NOT NULL,
    name text,
    global boolean DEFAULT false NOT NULL
);


ALTER TABLE actor.org_lasso OWNER TO evergreen;

--
-- Name: org_lasso_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.org_lasso_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_lasso_id_seq OWNER TO evergreen;

--
-- Name: org_lasso_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.org_lasso_id_seq OWNED BY actor.org_lasso.id;


--
-- Name: org_lasso_map; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.org_lasso_map (
    id integer NOT NULL,
    lasso integer NOT NULL,
    org_unit integer NOT NULL
);


ALTER TABLE actor.org_lasso_map OWNER TO evergreen;

--
-- Name: org_lasso_map_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.org_lasso_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_lasso_map_id_seq OWNER TO evergreen;

--
-- Name: org_lasso_map_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.org_lasso_map_id_seq OWNED BY actor.org_lasso_map.id;


--
-- Name: org_unit_closed; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.org_unit_closed (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    close_start timestamp with time zone NOT NULL,
    close_end timestamp with time zone NOT NULL,
    reason text,
    full_day boolean DEFAULT false,
    multi_day boolean DEFAULT false,
    emergency_closing integer
);


ALTER TABLE actor.org_unit_closed OWNER TO evergreen;

--
-- Name: org_unit_closed_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.org_unit_closed_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_closed_id_seq OWNER TO evergreen;

--
-- Name: org_unit_closed_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.org_unit_closed_id_seq OWNED BY actor.org_unit_closed.id;


--
-- Name: org_unit_custom_tree; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.org_unit_custom_tree (
    id integer NOT NULL,
    active boolean DEFAULT false,
    purpose actor.org_unit_custom_tree_purpose DEFAULT 'opac'::actor.org_unit_custom_tree_purpose NOT NULL
);


ALTER TABLE actor.org_unit_custom_tree OWNER TO evergreen;

--
-- Name: org_unit_custom_tree_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.org_unit_custom_tree_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_custom_tree_id_seq OWNER TO evergreen;

--
-- Name: org_unit_custom_tree_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.org_unit_custom_tree_id_seq OWNED BY actor.org_unit_custom_tree.id;


--
-- Name: org_unit_custom_tree_node; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.org_unit_custom_tree_node (
    id integer NOT NULL,
    tree integer,
    org_unit integer NOT NULL,
    parent_node integer,
    sibling_order integer DEFAULT 0 NOT NULL
);


ALTER TABLE actor.org_unit_custom_tree_node OWNER TO evergreen;

--
-- Name: org_unit_custom_tree_node_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.org_unit_custom_tree_node_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_custom_tree_node_id_seq OWNER TO evergreen;

--
-- Name: org_unit_custom_tree_node_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.org_unit_custom_tree_node_id_seq OWNED BY actor.org_unit_custom_tree_node.id;


--
-- Name: org_unit_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.org_unit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_id_seq OWNER TO evergreen;

--
-- Name: org_unit_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.org_unit_id_seq OWNED BY actor.org_unit.id;


--
-- Name: org_unit_proximity; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.org_unit_proximity (
    id bigint NOT NULL,
    from_org integer,
    to_org integer,
    prox integer
);


ALTER TABLE actor.org_unit_proximity OWNER TO evergreen;

--
-- Name: org_unit_proximity_adjustment; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.org_unit_proximity_adjustment (
    id integer NOT NULL,
    item_circ_lib integer,
    item_owning_lib integer,
    copy_location integer,
    hold_pickup_lib integer,
    hold_request_lib integer,
    pos integer DEFAULT 0 NOT NULL,
    absolute_adjustment boolean DEFAULT false NOT NULL,
    prox_adjustment numeric,
    circ_mod text,
    CONSTRAINT prox_adj_criterium CHECK ((COALESCE((item_circ_lib)::text, (item_owning_lib)::text, (copy_location)::text, (hold_pickup_lib)::text, (hold_request_lib)::text, circ_mod) IS NOT NULL))
);


ALTER TABLE actor.org_unit_proximity_adjustment OWNER TO evergreen;

--
-- Name: org_unit_proximity_adjustment_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.org_unit_proximity_adjustment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_proximity_adjustment_id_seq OWNER TO evergreen;

--
-- Name: org_unit_proximity_adjustment_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.org_unit_proximity_adjustment_id_seq OWNED BY actor.org_unit_proximity_adjustment.id;


--
-- Name: org_unit_proximity_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.org_unit_proximity_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_proximity_id_seq OWNER TO evergreen;

--
-- Name: org_unit_proximity_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.org_unit_proximity_id_seq OWNED BY actor.org_unit_proximity.id;


--
-- Name: org_unit_setting_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.org_unit_setting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_setting_id_seq OWNER TO evergreen;

--
-- Name: org_unit_setting_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.org_unit_setting_id_seq OWNED BY actor.org_unit_setting.id;


--
-- Name: org_unit_type; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.org_unit_type (
    id integer NOT NULL,
    name text NOT NULL,
    opac_label text NOT NULL,
    depth integer NOT NULL,
    parent integer,
    can_have_vols boolean DEFAULT true NOT NULL,
    can_have_users boolean DEFAULT true NOT NULL
);


ALTER TABLE actor.org_unit_type OWNER TO evergreen;

--
-- Name: org_unit_type_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.org_unit_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.org_unit_type_id_seq OWNER TO evergreen;

--
-- Name: org_unit_type_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.org_unit_type_id_seq OWNED BY actor.org_unit_type.id;


--
-- Name: passwd; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.passwd (
    id integer NOT NULL,
    usr integer NOT NULL,
    salt text,
    passwd text NOT NULL,
    passwd_type text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE actor.passwd OWNER TO evergreen;

--
-- Name: passwd_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.passwd_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.passwd_id_seq OWNER TO evergreen;

--
-- Name: passwd_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.passwd_id_seq OWNED BY actor.passwd.id;


--
-- Name: passwd_type; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.passwd_type (
    code text NOT NULL,
    name text NOT NULL,
    login boolean DEFAULT false NOT NULL,
    regex text,
    crypt_algo text,
    iter_count integer,
    CONSTRAINT passwd_type_iter_count_check CHECK (((iter_count IS NULL) OR (iter_count > 0)))
);


ALTER TABLE actor.passwd_type OWNER TO evergreen;

--
-- Name: search_filter_group; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.search_filter_group (
    id integer NOT NULL,
    owner integer NOT NULL,
    code text NOT NULL,
    label text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE actor.search_filter_group OWNER TO evergreen;

--
-- Name: search_filter_group_entry; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.search_filter_group_entry (
    id integer NOT NULL,
    grp integer NOT NULL,
    pos integer DEFAULT 0 NOT NULL,
    query integer NOT NULL
);


ALTER TABLE actor.search_filter_group_entry OWNER TO evergreen;

--
-- Name: search_filter_group_entry_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.search_filter_group_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.search_filter_group_entry_id_seq OWNER TO evergreen;

--
-- Name: search_filter_group_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.search_filter_group_entry_id_seq OWNED BY actor.search_filter_group_entry.id;


--
-- Name: search_filter_group_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.search_filter_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.search_filter_group_id_seq OWNER TO evergreen;

--
-- Name: search_filter_group_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.search_filter_group_id_seq OWNED BY actor.search_filter_group.id;


--
-- Name: search_query; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.search_query (
    id integer NOT NULL,
    label text NOT NULL,
    query_text text NOT NULL
);


ALTER TABLE actor.search_query OWNER TO evergreen;

--
-- Name: search_query_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.search_query_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.search_query_id_seq OWNER TO evergreen;

--
-- Name: search_query_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.search_query_id_seq OWNED BY actor.search_query.id;


--
-- Name: stat_cat; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.stat_cat (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL,
    sip_field character(2),
    sip_format text,
    checkout_archive boolean DEFAULT false NOT NULL,
    required boolean DEFAULT false NOT NULL,
    allow_freetext boolean DEFAULT true NOT NULL
);


ALTER TABLE actor.stat_cat OWNER TO evergreen;

--
-- Name: TABLE stat_cat; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.stat_cat IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * User Statistical Catagories
 *
 * Local data collected about Users is placed into a Statistical
 * Catagory.  Here''s where those catagories are defined.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: stat_cat_entry; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.stat_cat_entry (
    id integer NOT NULL,
    stat_cat integer NOT NULL,
    owner integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE actor.stat_cat_entry OWNER TO evergreen;

--
-- Name: TABLE stat_cat_entry; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.stat_cat_entry IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * User Statistical Catagory Entries
 *
 * Local data collected about Users is placed into a Statistical
 * Catagory.  Each library can create entries into any of its own
 * stat_cats, its ancestors'' stat_cats, or its descendants'' stat_cats.
 *
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: stat_cat_entry_default; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.stat_cat_entry_default (
    id integer NOT NULL,
    stat_cat_entry integer NOT NULL,
    stat_cat integer NOT NULL,
    owner integer NOT NULL
);


ALTER TABLE actor.stat_cat_entry_default OWNER TO evergreen;

--
-- Name: TABLE stat_cat_entry_default; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.stat_cat_entry_default IS '
User Statistical Category Default Entry

A library may choose one of the stat_cat entries to be the
default entry.
';


--
-- Name: stat_cat_entry_default_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.stat_cat_entry_default_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_entry_default_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_default_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.stat_cat_entry_default_id_seq OWNED BY actor.stat_cat_entry_default.id;


--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.stat_cat_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_entry_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.stat_cat_entry_id_seq OWNED BY actor.stat_cat_entry.id;


--
-- Name: stat_cat_entry_usr_map; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.stat_cat_entry_usr_map (
    id bigint NOT NULL,
    stat_cat_entry text NOT NULL,
    stat_cat integer NOT NULL,
    target_usr integer NOT NULL
);


ALTER TABLE actor.stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: TABLE stat_cat_entry_usr_map; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.stat_cat_entry_usr_map IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Statistical Catagory Entry to User map
 *
 * Records the stat_cat entries for each user.
 *
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: stat_cat_entry_usr_map_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.stat_cat_entry_usr_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_entry_usr_map_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_usr_map_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.stat_cat_entry_usr_map_id_seq OWNED BY actor.stat_cat_entry_usr_map.id;


--
-- Name: stat_cat_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.stat_cat_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.stat_cat_id_seq OWNED BY actor.stat_cat.id;


--
-- Name: stat_cat_sip_fields; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.stat_cat_sip_fields (
    field character(2) NOT NULL,
    name text NOT NULL,
    one_only boolean DEFAULT false NOT NULL
);


ALTER TABLE actor.stat_cat_sip_fields OWNER TO evergreen;

--
-- Name: TABLE stat_cat_sip_fields; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.stat_cat_sip_fields IS '
Actor Statistical Category SIP Fields

Contains the list of valid SIP Field identifiers for
Statistical Categories.
';


--
-- Name: toolbar; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.toolbar (
    id bigint NOT NULL,
    ws integer,
    org integer,
    usr integer,
    label text NOT NULL,
    layout text NOT NULL,
    CONSTRAINT layout_must_be_json CHECK (evergreen.is_json(layout)),
    CONSTRAINT only_one_type CHECK ((((ws IS NOT NULL) AND (COALESCE(org, usr) IS NULL)) OR ((org IS NOT NULL) AND (COALESCE(ws, usr) IS NULL)) OR ((usr IS NOT NULL) AND (COALESCE(org, ws) IS NULL))))
);


ALTER TABLE actor.toolbar OWNER TO evergreen;

--
-- Name: toolbar_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.toolbar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.toolbar_id_seq OWNER TO evergreen;

--
-- Name: toolbar_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.toolbar_id_seq OWNED BY actor.toolbar.id;


--
-- Name: usr_activity_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.usr_activity_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_activity_id_seq OWNER TO evergreen;

--
-- Name: usr_activity_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.usr_activity_id_seq OWNED BY actor.usr_activity.id;


--
-- Name: usr_address_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.usr_address_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_address_id_seq OWNER TO evergreen;

--
-- Name: usr_address_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.usr_address_id_seq OWNED BY actor.usr_address.id;


--
-- Name: usr_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.usr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_id_seq OWNER TO evergreen;

--
-- Name: usr_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.usr_id_seq OWNED BY actor.usr.id;


--
-- Name: usr_message_limited; Type: VIEW; Schema: actor; Owner: evergreen
--

CREATE VIEW actor.usr_message_limited AS
 SELECT usr_message.id,
    usr_message.usr,
    usr_message.title,
    usr_message.message,
    usr_message.create_date,
    usr_message.deleted,
    usr_message.read_date,
    usr_message.sending_lib,
    usr_message.pub,
    usr_message.stop_date,
    usr_message.editor,
    usr_message.edit_date
   FROM actor.usr_message
  WHERE (usr_message.pub AND (NOT usr_message.deleted));


ALTER TABLE actor.usr_message_limited OWNER TO evergreen;

--
-- Name: usr_message_penalty; Type: VIEW; Schema: actor; Owner: evergreen
--

CREATE VIEW actor.usr_message_penalty AS
 SELECT ausp.id,
    ausp.id AS ausp_id,
    aum.id AS aum_id,
    ausp.org_unit,
    ausp.org_unit AS ausp_org_unit,
    aum.sending_lib AS aum_sending_lib,
    ausp.usr,
    ausp.usr AS ausp_usr,
    aum.usr AS aum_usr,
    ausp.standing_penalty,
    ausp.staff,
    ausp.set_date AS create_date,
    ausp.set_date AS ausp_set_date,
    aum.create_date AS aum_create_date,
    ausp.stop_date,
    ausp.stop_date AS ausp_stop_date,
    aum.stop_date AS aum_stop_date,
    ausp.usr_message AS ausp_usr_message,
    aum.title,
    aum.message,
    aum.deleted,
    aum.read_date,
    aum.pub,
    aum.editor,
    aum.edit_date
   FROM (actor.usr_standing_penalty ausp
     LEFT JOIN actor.usr_message aum ON ((ausp.usr_message = aum.id)))
UNION ALL
 SELECT aum.id,
    NULL::integer AS ausp_id,
    aum.id AS aum_id,
    aum.sending_lib AS org_unit,
    NULL::integer AS ausp_org_unit,
    aum.sending_lib AS aum_sending_lib,
    aum.usr,
    NULL::integer AS ausp_usr,
    aum.usr AS aum_usr,
    NULL::integer AS standing_penalty,
    NULL::integer AS staff,
    aum.create_date,
    NULL::timestamp with time zone AS ausp_set_date,
    aum.create_date AS aum_create_date,
    aum.stop_date,
    NULL::timestamp with time zone AS ausp_stop_date,
    aum.stop_date AS aum_stop_date,
    NULL::integer AS ausp_usr_message,
    aum.title,
    aum.message,
    aum.deleted,
    aum.read_date,
    aum.pub,
    aum.editor,
    aum.edit_date
   FROM (actor.usr_message aum
     LEFT JOIN actor.usr_standing_penalty ausp ON ((ausp.usr_message = aum.id)))
  WHERE ((NOT aum.deleted) AND (ausp.id IS NULL));


ALTER TABLE actor.usr_message_penalty OWNER TO evergreen;

--
-- Name: usr_org_unit_opt_in; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.usr_org_unit_opt_in (
    id integer NOT NULL,
    org_unit integer NOT NULL,
    usr integer NOT NULL,
    staff integer NOT NULL,
    opt_in_ts timestamp with time zone DEFAULT now() NOT NULL,
    opt_in_ws integer NOT NULL
);


ALTER TABLE actor.usr_org_unit_opt_in OWNER TO evergreen;

--
-- Name: usr_org_unit_opt_in_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.usr_org_unit_opt_in_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_org_unit_opt_in_id_seq OWNER TO evergreen;

--
-- Name: usr_org_unit_opt_in_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.usr_org_unit_opt_in_id_seq OWNED BY actor.usr_org_unit_opt_in.id;


--
-- Name: usr_password_reset; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.usr_password_reset (
    id integer NOT NULL,
    uuid text NOT NULL,
    usr bigint NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    has_been_reset boolean DEFAULT false NOT NULL
);


ALTER TABLE actor.usr_password_reset OWNER TO evergreen;

--
-- Name: TABLE usr_password_reset; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.usr_password_reset IS '
/*
 * Copyright (C) 2010 Laurentian University
 * Dan Scott <dscott@laurentian.ca>
 *
 * Self-serve password reset requests
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: usr_password_reset_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.usr_password_reset_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_password_reset_id_seq OWNER TO evergreen;

--
-- Name: usr_password_reset_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.usr_password_reset_id_seq OWNED BY actor.usr_password_reset.id;


--
-- Name: usr_privacy_waiver; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.usr_privacy_waiver (
    id bigint NOT NULL,
    usr bigint NOT NULL,
    name text NOT NULL,
    place_holds boolean DEFAULT false,
    pickup_holds boolean DEFAULT false,
    view_history boolean DEFAULT false,
    checkout_items boolean DEFAULT false
);


ALTER TABLE actor.usr_privacy_waiver OWNER TO evergreen;

--
-- Name: usr_privacy_waiver_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.usr_privacy_waiver_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_privacy_waiver_id_seq OWNER TO evergreen;

--
-- Name: usr_privacy_waiver_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.usr_privacy_waiver_id_seq OWNED BY actor.usr_privacy_waiver.id;


--
-- Name: usr_saved_search; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.usr_saved_search (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    query_text text NOT NULL,
    query_type text DEFAULT 'URL'::text NOT NULL,
    target text NOT NULL,
    CONSTRAINT valid_query_text CHECK ((query_type = 'URL'::text)),
    CONSTRAINT valid_target CHECK ((target = ANY (ARRAY['record'::text, 'metarecord'::text, 'callnumber'::text])))
);


ALTER TABLE actor.usr_saved_search OWNER TO evergreen;

--
-- Name: usr_saved_search_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.usr_saved_search_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_saved_search_id_seq OWNER TO evergreen;

--
-- Name: usr_saved_search_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.usr_saved_search_id_seq OWNED BY actor.usr_saved_search.id;


--
-- Name: usr_setting; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.usr_setting (
    id bigint NOT NULL,
    usr integer NOT NULL,
    name text NOT NULL,
    value text NOT NULL
);


ALTER TABLE actor.usr_setting OWNER TO evergreen;

--
-- Name: TABLE usr_setting; Type: COMMENT; Schema: actor; Owner: evergreen
--

COMMENT ON TABLE actor.usr_setting IS '
/*
 * Copyright (C) 2005-2008  Equinox Software, Inc. / Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * User settings
 *
 * This table contains any arbitrary settings that a client
 * program would like to save for a user.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: usr_setting_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.usr_setting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_setting_id_seq OWNER TO evergreen;

--
-- Name: usr_setting_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.usr_setting_id_seq OWNED BY actor.usr_setting.id;


--
-- Name: usr_standing_penalty_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.usr_standing_penalty_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_standing_penalty_id_seq OWNER TO evergreen;

--
-- Name: usr_standing_penalty_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.usr_standing_penalty_id_seq OWNED BY actor.usr_standing_penalty.id;


--
-- Name: usr_usrgroup_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.usr_usrgroup_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.usr_usrgroup_seq OWNER TO evergreen;

--
-- Name: usr_usrgroup_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.usr_usrgroup_seq OWNED BY actor.usr.usrgroup;


--
-- Name: workstation; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.workstation (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL
);


ALTER TABLE actor.workstation OWNER TO evergreen;

--
-- Name: workstation_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.workstation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.workstation_id_seq OWNER TO evergreen;

--
-- Name: workstation_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.workstation_id_seq OWNED BY actor.workstation.id;


--
-- Name: workstation_setting; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.workstation_setting (
    id integer NOT NULL,
    workstation integer NOT NULL,
    name text NOT NULL,
    value json NOT NULL
);


ALTER TABLE actor.workstation_setting OWNER TO evergreen;

--
-- Name: workstation_setting_id_seq; Type: SEQUENCE; Schema: actor; Owner: evergreen
--

CREATE SEQUENCE actor.workstation_setting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actor.workstation_setting_id_seq OWNER TO evergreen;

--
-- Name: workstation_setting_id_seq; Type: SEQUENCE OWNED BY; Schema: actor; Owner: evergreen
--

ALTER SEQUENCE actor.workstation_setting_id_seq OWNED BY actor.workstation_setting.id;


--
-- Name: xxxx_note_and_message_consolidation; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.xxxx_note_and_message_consolidation (
    id integer,
    home_ou integer,
    alert_message text
);


ALTER TABLE actor.xxxx_note_and_message_consolidation OWNER TO evergreen;

--
-- Name: xxxx_penalty_notes; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.xxxx_penalty_notes (
    id integer,
    usr integer,
    org_unit integer,
    set_date timestamp with time zone,
    note text
);


ALTER TABLE actor.xxxx_penalty_notes OWNER TO evergreen;

--
-- Name: xxxx_usr_message; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.xxxx_usr_message (
    id integer DEFAULT nextval('actor.usr_message_id_seq'::regclass) NOT NULL,
    usr integer NOT NULL,
    title text,
    message text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    read_date timestamp with time zone,
    sending_lib integer NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    stop_date timestamp with time zone,
    editor bigint,
    edit_date timestamp with time zone
);


ALTER TABLE actor.xxxx_usr_message OWNER TO evergreen;

--
-- Name: xxxx_usr_message_for_penalty_notes; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.xxxx_usr_message_for_penalty_notes (
    id integer DEFAULT nextval('actor.usr_message_id_seq'::regclass) NOT NULL,
    usr integer NOT NULL,
    title text,
    message text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    read_date timestamp with time zone,
    sending_lib integer NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    stop_date timestamp with time zone,
    editor bigint,
    edit_date timestamp with time zone
);


ALTER TABLE actor.xxxx_usr_message_for_penalty_notes OWNER TO evergreen;

--
-- Name: xxxx_usr_message_for_private_notes; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.xxxx_usr_message_for_private_notes (
    id integer DEFAULT nextval('actor.usr_message_id_seq'::regclass) NOT NULL,
    usr integer NOT NULL,
    title text,
    message text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    read_date timestamp with time zone,
    sending_lib integer NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    stop_date timestamp with time zone,
    editor bigint,
    edit_date timestamp with time zone,
    orig_id bigint
);


ALTER TABLE actor.xxxx_usr_message_for_private_notes OWNER TO evergreen;

--
-- Name: xxxx_usr_message_for_unmatched_public_notes; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.xxxx_usr_message_for_unmatched_public_notes (
    id integer DEFAULT nextval('actor.usr_message_id_seq'::regclass) NOT NULL,
    usr integer NOT NULL,
    title text,
    message text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    read_date timestamp with time zone,
    sending_lib integer NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    stop_date timestamp with time zone,
    editor bigint,
    edit_date timestamp with time zone,
    orig_id bigint
);


ALTER TABLE actor.xxxx_usr_message_for_unmatched_public_notes OWNER TO evergreen;

--
-- Name: xxxx_usr_standing_penalties_for_notes; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.xxxx_usr_standing_penalties_for_notes (
    id integer DEFAULT nextval('actor.usr_message_id_seq'::regclass) NOT NULL,
    org_unit integer NOT NULL,
    usr integer NOT NULL,
    standing_penalty integer NOT NULL,
    staff integer,
    set_date timestamp with time zone DEFAULT now(),
    stop_date timestamp with time zone,
    usr_message bigint
);


ALTER TABLE actor.xxxx_usr_standing_penalties_for_notes OWNER TO evergreen;

--
-- Name: xxxx_usr_standing_penalty; Type: TABLE; Schema: actor; Owner: evergreen
--

CREATE TABLE actor.xxxx_usr_standing_penalty (
    id integer DEFAULT nextval('actor.usr_message_id_seq'::regclass) NOT NULL,
    org_unit integer NOT NULL,
    usr integer NOT NULL,
    standing_penalty integer NOT NULL,
    staff integer,
    set_date timestamp with time zone DEFAULT now(),
    stop_date timestamp with time zone,
    usr_message bigint
);


ALTER TABLE actor.xxxx_usr_standing_penalty OWNER TO evergreen;

--
-- Name: copy_alert; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_alert (
    id bigint NOT NULL,
    alert_type integer NOT NULL,
    copy bigint NOT NULL,
    temp boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    create_staff bigint NOT NULL,
    note text,
    ack_time timestamp with time zone,
    ack_staff bigint
);


ALTER TABLE asset.copy_alert OWNER TO evergreen;

--
-- Name: active_copy_alert; Type: VIEW; Schema: asset; Owner: evergreen
--

CREATE VIEW asset.active_copy_alert AS
 SELECT copy_alert.id,
    copy_alert.alert_type,
    copy_alert.copy,
    copy_alert.temp,
    copy_alert.create_time,
    copy_alert.create_staff,
    copy_alert.note,
    copy_alert.ack_time,
    copy_alert.ack_staff
   FROM asset.copy_alert
  WHERE (copy_alert.ack_time IS NULL);


ALTER TABLE asset.active_copy_alert OWNER TO evergreen;

--
-- Name: call_number_class; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.call_number_class (
    id bigint NOT NULL,
    name text NOT NULL,
    normalizer text DEFAULT 'asset.normalize_generic'::text NOT NULL,
    field text DEFAULT '050ab,055ab,060ab,070ab,080ab,082ab,086ab,088ab,090,092,096,098,099'::text NOT NULL
);


ALTER TABLE asset.call_number_class OWNER TO evergreen;

--
-- Name: TABLE call_number_class; Type: COMMENT; Schema: asset; Owner: evergreen
--

COMMENT ON TABLE asset.call_number_class IS '
Defines the call number normalization database functions in the "normalizer"
column and the tag/subfield combinations to use to lookup the call number in
the "field" column for a given classification scheme. Tag/subfield combinations
are delimited by commas.
';


--
-- Name: call_number_class_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.call_number_class_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_class_id_seq OWNER TO evergreen;

--
-- Name: call_number_class_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.call_number_class_id_seq OWNED BY asset.call_number_class.id;


--
-- Name: call_number_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.call_number_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_id_seq OWNER TO evergreen;

--
-- Name: call_number_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.call_number_id_seq OWNED BY asset.call_number.id;


--
-- Name: call_number_note; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.call_number_note (
    id bigint NOT NULL,
    call_number bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE asset.call_number_note OWNER TO evergreen;

--
-- Name: call_number_note_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.call_number_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_note_id_seq OWNER TO evergreen;

--
-- Name: call_number_note_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.call_number_note_id_seq OWNED BY asset.call_number_note.id;


--
-- Name: call_number_prefix; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.call_number_prefix (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    label_sortkey text
);


ALTER TABLE asset.call_number_prefix OWNER TO evergreen;

--
-- Name: call_number_prefix_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.call_number_prefix_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_prefix_id_seq OWNER TO evergreen;

--
-- Name: call_number_prefix_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.call_number_prefix_id_seq OWNED BY asset.call_number_prefix.id;


--
-- Name: call_number_suffix; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.call_number_suffix (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    label_sortkey text
);


ALTER TABLE asset.call_number_suffix OWNER TO evergreen;

--
-- Name: call_number_suffix_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.call_number_suffix_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.call_number_suffix_id_seq OWNER TO evergreen;

--
-- Name: call_number_suffix_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.call_number_suffix_id_seq OWNED BY asset.call_number_suffix.id;


--
-- Name: copy_alert_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_alert_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_alert_id_seq OWNER TO evergreen;

--
-- Name: copy_alert_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_alert_id_seq OWNED BY asset.copy_alert.id;


--
-- Name: copy_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_id_seq OWNER TO evergreen;

--
-- Name: copy_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_id_seq OWNED BY asset.copy.id;


--
-- Name: copy_inventory; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_inventory (
    id integer NOT NULL,
    inventory_workstation integer,
    inventory_date timestamp with time zone DEFAULT now() NOT NULL,
    copy bigint NOT NULL
);


ALTER TABLE asset.copy_inventory OWNER TO evergreen;

--
-- Name: copy_inventory_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_inventory_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_inventory_id_seq OWNER TO evergreen;

--
-- Name: copy_inventory_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_inventory_id_seq OWNED BY asset.copy_inventory.id;


--
-- Name: copy_location; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_location (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text,
    checkin_alert boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    url text
);


ALTER TABLE asset.copy_location OWNER TO evergreen;

--
-- Name: copy_location_group; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_location_group (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    pos integer DEFAULT 0 NOT NULL,
    top boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL
);


ALTER TABLE asset.copy_location_group OWNER TO evergreen;

--
-- Name: copy_location_group_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_location_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_group_id_seq OWNER TO evergreen;

--
-- Name: copy_location_group_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_location_group_id_seq OWNED BY asset.copy_location_group.id;


--
-- Name: copy_location_group_map; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_location_group_map (
    id integer NOT NULL,
    location integer NOT NULL,
    lgroup integer NOT NULL
);


ALTER TABLE asset.copy_location_group_map OWNER TO evergreen;

--
-- Name: copy_location_group_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_location_group_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_group_map_id_seq OWNER TO evergreen;

--
-- Name: copy_location_group_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_location_group_map_id_seq OWNED BY asset.copy_location_group_map.id;


--
-- Name: copy_location_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_location_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_id_seq OWNER TO evergreen;

--
-- Name: copy_location_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_location_id_seq OWNED BY asset.copy_location.id;


--
-- Name: copy_location_order; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_location_order (
    id integer NOT NULL,
    location integer NOT NULL,
    org integer NOT NULL,
    "position" integer DEFAULT 0 NOT NULL
);


ALTER TABLE asset.copy_location_order OWNER TO evergreen;

--
-- Name: copy_location_order_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_location_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_location_order_id_seq OWNER TO evergreen;

--
-- Name: copy_location_order_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_location_order_id_seq OWNED BY asset.copy_location_order.id;


--
-- Name: copy_note; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_note (
    id bigint NOT NULL,
    owning_copy bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL
);


ALTER TABLE asset.copy_note OWNER TO evergreen;

--
-- Name: copy_note_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_note_id_seq OWNER TO evergreen;

--
-- Name: copy_note_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_note_id_seq OWNED BY asset.copy_note.id;


--
-- Name: copy_part_map; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_part_map (
    id integer NOT NULL,
    target_copy bigint NOT NULL,
    part integer NOT NULL
);


ALTER TABLE asset.copy_part_map OWNER TO evergreen;

--
-- Name: copy_part_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_part_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_part_map_id_seq OWNER TO evergreen;

--
-- Name: copy_part_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_part_map_id_seq OWNED BY asset.copy_part_map.id;


--
-- Name: copy_tag; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_tag (
    id integer NOT NULL,
    tag_type text,
    label text NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL,
    staff_note text,
    pub boolean DEFAULT true,
    owner integer NOT NULL,
    url text
);


ALTER TABLE asset.copy_tag OWNER TO evergreen;

--
-- Name: copy_tag_copy_map; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_tag_copy_map (
    id bigint NOT NULL,
    copy bigint,
    tag integer
);


ALTER TABLE asset.copy_tag_copy_map OWNER TO evergreen;

--
-- Name: copy_tag_copy_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_tag_copy_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_tag_copy_map_id_seq OWNER TO evergreen;

--
-- Name: copy_tag_copy_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_tag_copy_map_id_seq OWNED BY asset.copy_tag_copy_map.id;


--
-- Name: copy_tag_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_tag_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_tag_id_seq OWNER TO evergreen;

--
-- Name: copy_tag_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_tag_id_seq OWNED BY asset.copy_tag.id;


--
-- Name: copy_template; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_template (
    id integer NOT NULL,
    owning_lib integer NOT NULL,
    creator bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    name text NOT NULL,
    circ_lib integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    circ_modifier text,
    circ_as_type text,
    alert_message text,
    opac_visible boolean,
    floating integer,
    mint_condition boolean,
    CONSTRAINT valid_fine_level CHECK (((fine_level IS NULL) OR (loan_duration = ANY (ARRAY[1, 2, 3])))),
    CONSTRAINT valid_loan_duration CHECK (((loan_duration IS NULL) OR (loan_duration = ANY (ARRAY[1, 2, 3]))))
);


ALTER TABLE asset.copy_template OWNER TO evergreen;

--
-- Name: copy_template_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_template_id_seq OWNER TO evergreen;

--
-- Name: copy_template_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_template_id_seq OWNED BY asset.copy_template.id;


--
-- Name: copy_vis_attr_cache; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.copy_vis_attr_cache (
    id bigint NOT NULL,
    record bigint NOT NULL,
    target_copy bigint NOT NULL,
    vis_attr_vector integer[]
);


ALTER TABLE asset.copy_vis_attr_cache OWNER TO evergreen;

--
-- Name: copy_vis_attr_cache_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.copy_vis_attr_cache_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.copy_vis_attr_cache_id_seq OWNER TO evergreen;

--
-- Name: copy_vis_attr_cache_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.copy_vis_attr_cache_id_seq OWNED BY asset.copy_vis_attr_cache.id;


--
-- Name: course_module_course; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.course_module_course (
    id integer NOT NULL,
    name text NOT NULL,
    course_number text NOT NULL,
    section_number text,
    owning_lib integer,
    is_archived boolean DEFAULT false NOT NULL
);


ALTER TABLE asset.course_module_course OWNER TO evergreen;

--
-- Name: course_module_course_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.course_module_course_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.course_module_course_id_seq OWNER TO evergreen;

--
-- Name: course_module_course_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.course_module_course_id_seq OWNED BY asset.course_module_course.id;


--
-- Name: course_module_course_materials; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.course_module_course_materials (
    id integer NOT NULL,
    course integer NOT NULL,
    item integer,
    relationship text,
    record integer,
    temporary_record boolean,
    original_location integer,
    original_status integer,
    original_circ_modifier text,
    original_callnumber integer,
    original_circ_lib integer
);


ALTER TABLE asset.course_module_course_materials OWNER TO evergreen;

--
-- Name: course_module_course_materials_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.course_module_course_materials_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.course_module_course_materials_id_seq OWNER TO evergreen;

--
-- Name: course_module_course_materials_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.course_module_course_materials_id_seq OWNED BY asset.course_module_course_materials.id;


--
-- Name: course_module_course_users; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.course_module_course_users (
    id integer NOT NULL,
    course integer NOT NULL,
    usr integer NOT NULL,
    usr_role integer
);


ALTER TABLE asset.course_module_course_users OWNER TO evergreen;

--
-- Name: course_module_course_users_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.course_module_course_users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.course_module_course_users_id_seq OWNER TO evergreen;

--
-- Name: course_module_course_users_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.course_module_course_users_id_seq OWNED BY asset.course_module_course_users.id;


--
-- Name: course_module_role; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.course_module_role (
    id integer NOT NULL,
    name text NOT NULL,
    is_public boolean DEFAULT false NOT NULL
);


ALTER TABLE asset.course_module_role OWNER TO evergreen;

--
-- Name: course_module_role_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.course_module_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.course_module_role_id_seq OWNER TO evergreen;

--
-- Name: course_module_role_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.course_module_role_id_seq OWNED BY asset.course_module_role.id;


--
-- Name: course_module_term; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.course_module_term (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer,
    start_date timestamp with time zone,
    end_date timestamp with time zone
);


ALTER TABLE asset.course_module_term OWNER TO evergreen;

--
-- Name: course_module_term_course_map; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.course_module_term_course_map (
    id bigint NOT NULL,
    term integer NOT NULL,
    course integer NOT NULL
);


ALTER TABLE asset.course_module_term_course_map OWNER TO evergreen;

--
-- Name: course_module_term_course_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.course_module_term_course_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.course_module_term_course_map_id_seq OWNER TO evergreen;

--
-- Name: course_module_term_course_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.course_module_term_course_map_id_seq OWNED BY asset.course_module_term_course_map.id;


--
-- Name: course_module_term_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.course_module_term_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.course_module_term_id_seq OWNER TO evergreen;

--
-- Name: course_module_term_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.course_module_term_id_seq OWNED BY asset.course_module_term.id;


--
-- Name: latest_inventory; Type: VIEW; Schema: asset; Owner: evergreen
--

CREATE VIEW asset.latest_inventory AS
 SELECT DISTINCT ON (copy_inventory.copy) copy_inventory.id,
    copy_inventory.inventory_workstation,
    copy_inventory.inventory_date,
    copy_inventory.copy
   FROM asset.copy_inventory
  ORDER BY copy_inventory.copy, copy_inventory.inventory_date DESC;


ALTER TABLE asset.latest_inventory OWNER TO evergreen;

--
-- Name: stat_cat; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.stat_cat (
    id integer NOT NULL,
    owner integer NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    name text NOT NULL,
    required boolean DEFAULT false NOT NULL,
    sip_field character(2),
    sip_format text,
    checkout_archive boolean DEFAULT false NOT NULL
);


ALTER TABLE asset.stat_cat OWNER TO evergreen;

--
-- Name: stat_cat_entry; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.stat_cat_entry (
    id integer NOT NULL,
    stat_cat integer NOT NULL,
    owner integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE asset.stat_cat_entry OWNER TO evergreen;

--
-- Name: stat_cat_entry_copy_map; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.stat_cat_entry_copy_map (
    id bigint NOT NULL,
    stat_cat integer NOT NULL,
    stat_cat_entry integer NOT NULL,
    owning_copy bigint NOT NULL
);


ALTER TABLE asset.stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: stat_cat_entry_copy_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.stat_cat_entry_copy_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_entry_copy_map_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_copy_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.stat_cat_entry_copy_map_id_seq OWNED BY asset.stat_cat_entry_copy_map.id;


--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.stat_cat_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_entry_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.stat_cat_entry_id_seq OWNED BY asset.stat_cat_entry.id;


--
-- Name: stat_cat_entry_transparency_map; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.stat_cat_entry_transparency_map (
    id bigint NOT NULL,
    stat_cat integer NOT NULL,
    stat_cat_entry integer NOT NULL,
    owning_transparency integer NOT NULL
);


ALTER TABLE asset.stat_cat_entry_transparency_map OWNER TO evergreen;

--
-- Name: stat_cat_entry_transparency_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.stat_cat_entry_transparency_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_entry_transparency_map_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_entry_transparency_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.stat_cat_entry_transparency_map_id_seq OWNED BY asset.stat_cat_entry_transparency_map.id;


--
-- Name: stat_cat_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.stat_cat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.stat_cat_id_seq OWNER TO evergreen;

--
-- Name: stat_cat_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.stat_cat_id_seq OWNED BY asset.stat_cat.id;


--
-- Name: stat_cat_sip_fields; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.stat_cat_sip_fields (
    field character(2) NOT NULL,
    name text NOT NULL,
    one_only boolean DEFAULT false NOT NULL
);


ALTER TABLE asset.stat_cat_sip_fields OWNER TO evergreen;

--
-- Name: TABLE stat_cat_sip_fields; Type: COMMENT; Schema: asset; Owner: evergreen
--

COMMENT ON TABLE asset.stat_cat_sip_fields IS '
Asset Statistical Category SIP Fields

Contains the list of valid SIP Field identifiers for
Statistical Categories.
';


--
-- Name: uri_call_number_map; Type: TABLE; Schema: asset; Owner: evergreen
--

CREATE TABLE asset.uri_call_number_map (
    id bigint NOT NULL,
    uri integer NOT NULL,
    call_number integer NOT NULL
);


ALTER TABLE asset.uri_call_number_map OWNER TO evergreen;

--
-- Name: uri_call_number_map_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.uri_call_number_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.uri_call_number_map_id_seq OWNER TO evergreen;

--
-- Name: uri_call_number_map_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.uri_call_number_map_id_seq OWNED BY asset.uri_call_number_map.id;


--
-- Name: uri_id_seq; Type: SEQUENCE; Schema: asset; Owner: evergreen
--

CREATE SEQUENCE asset.uri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE asset.uri_id_seq OWNER TO evergreen;

--
-- Name: uri_id_seq; Type: SEQUENCE OWNED BY; Schema: asset; Owner: evergreen
--

ALTER SEQUENCE asset.uri_id_seq OWNED BY asset.uri.id;


--
-- Name: acq_fund_debit_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.acq_fund_debit_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    fund integer NOT NULL,
    origin_amount numeric NOT NULL,
    origin_currency_type text NOT NULL,
    amount numeric NOT NULL,
    encumbrance boolean NOT NULL,
    debit_type text NOT NULL,
    xfer_destination integer,
    create_time timestamp with time zone NOT NULL,
    audit_ws integer,
    audit_user integer,
    invoice_entry integer
);


ALTER TABLE auditor.acq_fund_debit_history OWNER TO evergreen;

--
-- Name: acq_fund_debit_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.acq_fund_debit_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    fund_debit.id,
    fund_debit.fund,
    fund_debit.origin_amount,
    fund_debit.origin_currency_type,
    fund_debit.amount,
    fund_debit.encumbrance,
    fund_debit.debit_type,
    fund_debit.xfer_destination,
    fund_debit.create_time,
    fund_debit.invoice_entry
   FROM acq.fund_debit
UNION ALL
 SELECT acq_fund_debit_history.audit_id,
    acq_fund_debit_history.audit_time,
    acq_fund_debit_history.audit_action,
    acq_fund_debit_history.audit_user,
    acq_fund_debit_history.audit_ws,
    acq_fund_debit_history.id,
    acq_fund_debit_history.fund,
    acq_fund_debit_history.origin_amount,
    acq_fund_debit_history.origin_currency_type,
    acq_fund_debit_history.amount,
    acq_fund_debit_history.encumbrance,
    acq_fund_debit_history.debit_type,
    acq_fund_debit_history.xfer_destination,
    acq_fund_debit_history.create_time,
    acq_fund_debit_history.invoice_entry
   FROM auditor.acq_fund_debit_history;


ALTER TABLE auditor.acq_fund_debit_lifecycle OWNER TO evergreen;

--
-- Name: acq_fund_debit_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.acq_fund_debit_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_fund_debit_pkey_seq OWNER TO evergreen;

--
-- Name: acq_invoice_entry_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.acq_invoice_entry_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    lineitem integer,
    inv_item_count integer NOT NULL,
    phys_item_count integer,
    note text,
    billed_per_item boolean,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    amount_paid numeric(8,2),
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.acq_invoice_entry_history OWNER TO evergreen;

--
-- Name: acq_invoice_entry_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.acq_invoice_entry_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    invoice_entry.id,
    invoice_entry.invoice,
    invoice_entry.purchase_order,
    invoice_entry.lineitem,
    invoice_entry.inv_item_count,
    invoice_entry.phys_item_count,
    invoice_entry.note,
    invoice_entry.billed_per_item,
    invoice_entry.cost_billed,
    invoice_entry.actual_cost,
    invoice_entry.amount_paid
   FROM acq.invoice_entry
UNION ALL
 SELECT acq_invoice_entry_history.audit_id,
    acq_invoice_entry_history.audit_time,
    acq_invoice_entry_history.audit_action,
    acq_invoice_entry_history.audit_user,
    acq_invoice_entry_history.audit_ws,
    acq_invoice_entry_history.id,
    acq_invoice_entry_history.invoice,
    acq_invoice_entry_history.purchase_order,
    acq_invoice_entry_history.lineitem,
    acq_invoice_entry_history.inv_item_count,
    acq_invoice_entry_history.phys_item_count,
    acq_invoice_entry_history.note,
    acq_invoice_entry_history.billed_per_item,
    acq_invoice_entry_history.cost_billed,
    acq_invoice_entry_history.actual_cost,
    acq_invoice_entry_history.amount_paid
   FROM auditor.acq_invoice_entry_history;


ALTER TABLE auditor.acq_invoice_entry_lifecycle OWNER TO evergreen;

--
-- Name: acq_invoice_entry_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.acq_invoice_entry_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_invoice_entry_pkey_seq OWNER TO evergreen;

--
-- Name: acq_invoice_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.acq_invoice_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    receiver integer NOT NULL,
    provider integer NOT NULL,
    shipper integer NOT NULL,
    recv_date timestamp with time zone NOT NULL,
    recv_method text NOT NULL,
    inv_type text,
    inv_ident text NOT NULL,
    payment_auth text,
    payment_method text,
    note text,
    audit_ws integer,
    audit_user integer,
    close_date timestamp with time zone,
    erp_export_date timestamp with time zone,
    closed_by integer
);


ALTER TABLE auditor.acq_invoice_history OWNER TO evergreen;

--
-- Name: acq_invoice_item_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.acq_invoice_item_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    invoice integer NOT NULL,
    purchase_order integer,
    fund_debit integer,
    inv_item_type text NOT NULL,
    title text,
    author text,
    note text,
    cost_billed numeric(8,2),
    actual_cost numeric(8,2),
    fund integer,
    amount_paid numeric(8,2),
    po_item integer,
    target bigint,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.acq_invoice_item_history OWNER TO evergreen;

--
-- Name: acq_invoice_item_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.acq_invoice_item_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    invoice_item.id,
    invoice_item.invoice,
    invoice_item.purchase_order,
    invoice_item.fund_debit,
    invoice_item.inv_item_type,
    invoice_item.title,
    invoice_item.author,
    invoice_item.note,
    invoice_item.cost_billed,
    invoice_item.actual_cost,
    invoice_item.fund,
    invoice_item.amount_paid,
    invoice_item.po_item,
    invoice_item.target
   FROM acq.invoice_item
UNION ALL
 SELECT acq_invoice_item_history.audit_id,
    acq_invoice_item_history.audit_time,
    acq_invoice_item_history.audit_action,
    acq_invoice_item_history.audit_user,
    acq_invoice_item_history.audit_ws,
    acq_invoice_item_history.id,
    acq_invoice_item_history.invoice,
    acq_invoice_item_history.purchase_order,
    acq_invoice_item_history.fund_debit,
    acq_invoice_item_history.inv_item_type,
    acq_invoice_item_history.title,
    acq_invoice_item_history.author,
    acq_invoice_item_history.note,
    acq_invoice_item_history.cost_billed,
    acq_invoice_item_history.actual_cost,
    acq_invoice_item_history.fund,
    acq_invoice_item_history.amount_paid,
    acq_invoice_item_history.po_item,
    acq_invoice_item_history.target
   FROM auditor.acq_invoice_item_history;


ALTER TABLE auditor.acq_invoice_item_lifecycle OWNER TO evergreen;

--
-- Name: acq_invoice_item_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.acq_invoice_item_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_invoice_item_pkey_seq OWNER TO evergreen;

--
-- Name: acq_invoice_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.acq_invoice_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    invoice.id,
    invoice.receiver,
    invoice.provider,
    invoice.shipper,
    invoice.recv_date,
    invoice.recv_method,
    invoice.inv_type,
    invoice.inv_ident,
    invoice.payment_auth,
    invoice.payment_method,
    invoice.note,
    invoice.close_date,
    invoice.erp_export_date,
    invoice.closed_by
   FROM acq.invoice
UNION ALL
 SELECT acq_invoice_history.audit_id,
    acq_invoice_history.audit_time,
    acq_invoice_history.audit_action,
    acq_invoice_history.audit_user,
    acq_invoice_history.audit_ws,
    acq_invoice_history.id,
    acq_invoice_history.receiver,
    acq_invoice_history.provider,
    acq_invoice_history.shipper,
    acq_invoice_history.recv_date,
    acq_invoice_history.recv_method,
    acq_invoice_history.inv_type,
    acq_invoice_history.inv_ident,
    acq_invoice_history.payment_auth,
    acq_invoice_history.payment_method,
    acq_invoice_history.note,
    acq_invoice_history.close_date,
    acq_invoice_history.erp_export_date,
    acq_invoice_history.closed_by
   FROM auditor.acq_invoice_history;


ALTER TABLE auditor.acq_invoice_lifecycle OWNER TO evergreen;

--
-- Name: acq_invoice_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.acq_invoice_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_invoice_pkey_seq OWNER TO evergreen;

--
-- Name: acq_lineitem_detail_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.acq_lineitem_detail_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    lineitem integer NOT NULL,
    fund integer,
    fund_debit integer,
    eg_copy_id bigint,
    barcode text,
    cn_label text,
    note text,
    collection_code text,
    circ_modifier text,
    owning_lib integer,
    location integer,
    recv_time timestamp with time zone,
    cancel_reason integer,
    receiver integer,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.acq_lineitem_detail_history OWNER TO evergreen;

--
-- Name: acq_lineitem_detail_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.acq_lineitem_detail_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    lineitem_detail.id,
    lineitem_detail.lineitem,
    lineitem_detail.fund,
    lineitem_detail.fund_debit,
    lineitem_detail.eg_copy_id,
    lineitem_detail.barcode,
    lineitem_detail.cn_label,
    lineitem_detail.note,
    lineitem_detail.collection_code,
    lineitem_detail.circ_modifier,
    lineitem_detail.owning_lib,
    lineitem_detail.location,
    lineitem_detail.recv_time,
    lineitem_detail.cancel_reason,
    lineitem_detail.receiver
   FROM acq.lineitem_detail
UNION ALL
 SELECT acq_lineitem_detail_history.audit_id,
    acq_lineitem_detail_history.audit_time,
    acq_lineitem_detail_history.audit_action,
    acq_lineitem_detail_history.audit_user,
    acq_lineitem_detail_history.audit_ws,
    acq_lineitem_detail_history.id,
    acq_lineitem_detail_history.lineitem,
    acq_lineitem_detail_history.fund,
    acq_lineitem_detail_history.fund_debit,
    acq_lineitem_detail_history.eg_copy_id,
    acq_lineitem_detail_history.barcode,
    acq_lineitem_detail_history.cn_label,
    acq_lineitem_detail_history.note,
    acq_lineitem_detail_history.collection_code,
    acq_lineitem_detail_history.circ_modifier,
    acq_lineitem_detail_history.owning_lib,
    acq_lineitem_detail_history.location,
    acq_lineitem_detail_history.recv_time,
    acq_lineitem_detail_history.cancel_reason,
    acq_lineitem_detail_history.receiver
   FROM auditor.acq_lineitem_detail_history;


ALTER TABLE auditor.acq_lineitem_detail_lifecycle OWNER TO evergreen;

--
-- Name: acq_lineitem_detail_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.acq_lineitem_detail_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.acq_lineitem_detail_pkey_seq OWNER TO evergreen;

--
-- Name: action_trigger_event_definition_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.action_trigger_event_definition_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    active boolean NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    hook text NOT NULL,
    validator text NOT NULL,
    reactor text NOT NULL,
    cleanup_success text,
    cleanup_failure text,
    delay interval NOT NULL,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text,
    audit_ws integer,
    audit_user integer,
    repeat_delay interval,
    message_library_path text,
    message_template text,
    message_title text,
    message_usr_path text,
    retention_interval interval,
    context_bib_path text,
    context_item_path text,
    context_library_path text,
    context_usr_path text
);


ALTER TABLE auditor.action_trigger_event_definition_history OWNER TO evergreen;

--
-- Name: action_trigger_event_definition_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.action_trigger_event_definition_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    event_definition.id,
    event_definition.active,
    event_definition.owner,
    event_definition.name,
    event_definition.hook,
    event_definition.validator,
    event_definition.reactor,
    event_definition.cleanup_success,
    event_definition.cleanup_failure,
    event_definition.delay,
    event_definition.max_delay,
    event_definition.usr_field,
    event_definition.opt_in_setting,
    event_definition.delay_field,
    event_definition.group_field,
    event_definition.template,
    event_definition.granularity,
    event_definition.repeat_delay,
    event_definition.message_template,
    event_definition.message_usr_path,
    event_definition.message_library_path,
    event_definition.message_title,
    event_definition.retention_interval,
    event_definition.context_usr_path,
    event_definition.context_library_path,
    event_definition.context_bib_path,
    event_definition.context_item_path
   FROM action_trigger.event_definition
UNION ALL
 SELECT action_trigger_event_definition_history.audit_id,
    action_trigger_event_definition_history.audit_time,
    action_trigger_event_definition_history.audit_action,
    action_trigger_event_definition_history.audit_user,
    action_trigger_event_definition_history.audit_ws,
    action_trigger_event_definition_history.id,
    action_trigger_event_definition_history.active,
    action_trigger_event_definition_history.owner,
    action_trigger_event_definition_history.name,
    action_trigger_event_definition_history.hook,
    action_trigger_event_definition_history.validator,
    action_trigger_event_definition_history.reactor,
    action_trigger_event_definition_history.cleanup_success,
    action_trigger_event_definition_history.cleanup_failure,
    action_trigger_event_definition_history.delay,
    action_trigger_event_definition_history.max_delay,
    action_trigger_event_definition_history.usr_field,
    action_trigger_event_definition_history.opt_in_setting,
    action_trigger_event_definition_history.delay_field,
    action_trigger_event_definition_history.group_field,
    action_trigger_event_definition_history.template,
    action_trigger_event_definition_history.granularity,
    action_trigger_event_definition_history.repeat_delay,
    action_trigger_event_definition_history.message_template,
    action_trigger_event_definition_history.message_usr_path,
    action_trigger_event_definition_history.message_library_path,
    action_trigger_event_definition_history.message_title,
    action_trigger_event_definition_history.retention_interval,
    action_trigger_event_definition_history.context_usr_path,
    action_trigger_event_definition_history.context_library_path,
    action_trigger_event_definition_history.context_bib_path,
    action_trigger_event_definition_history.context_item_path
   FROM auditor.action_trigger_event_definition_history;


ALTER TABLE auditor.action_trigger_event_definition_lifecycle OWNER TO evergreen;

--
-- Name: action_trigger_event_definition_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.action_trigger_event_definition_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.action_trigger_event_definition_pkey_seq OWNER TO evergreen;

--
-- Name: actor_org_unit_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.actor_org_unit_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    parent_ou integer,
    ou_type integer NOT NULL,
    ill_address integer,
    holds_address integer,
    mailing_address integer,
    billing_address integer,
    shortname text NOT NULL,
    name text NOT NULL,
    email text,
    phone text,
    opac_visible boolean NOT NULL,
    fiscal_calendar integer NOT NULL,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.actor_org_unit_history OWNER TO evergreen;

--
-- Name: actor_org_unit_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.actor_org_unit_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    org_unit.id,
    org_unit.parent_ou,
    org_unit.ou_type,
    org_unit.ill_address,
    org_unit.holds_address,
    org_unit.mailing_address,
    org_unit.billing_address,
    org_unit.shortname,
    org_unit.name,
    org_unit.email,
    org_unit.phone,
    org_unit.opac_visible,
    org_unit.fiscal_calendar
   FROM actor.org_unit
UNION ALL
 SELECT actor_org_unit_history.audit_id,
    actor_org_unit_history.audit_time,
    actor_org_unit_history.audit_action,
    actor_org_unit_history.audit_user,
    actor_org_unit_history.audit_ws,
    actor_org_unit_history.id,
    actor_org_unit_history.parent_ou,
    actor_org_unit_history.ou_type,
    actor_org_unit_history.ill_address,
    actor_org_unit_history.holds_address,
    actor_org_unit_history.mailing_address,
    actor_org_unit_history.billing_address,
    actor_org_unit_history.shortname,
    actor_org_unit_history.name,
    actor_org_unit_history.email,
    actor_org_unit_history.phone,
    actor_org_unit_history.opac_visible,
    actor_org_unit_history.fiscal_calendar
   FROM auditor.actor_org_unit_history;


ALTER TABLE auditor.actor_org_unit_lifecycle OWNER TO evergreen;

--
-- Name: actor_org_unit_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.actor_org_unit_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.actor_org_unit_pkey_seq OWNER TO evergreen;

--
-- Name: actor_usr_address_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.actor_usr_address_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    valid boolean NOT NULL,
    within_city_limits boolean NOT NULL,
    address_type text NOT NULL,
    usr integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text,
    country text NOT NULL,
    post_code text NOT NULL,
    pending boolean NOT NULL,
    replaces integer,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.actor_usr_address_history OWNER TO evergreen;

--
-- Name: actor_usr_address_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.actor_usr_address_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    usr_address.id,
    usr_address.valid,
    usr_address.within_city_limits,
    usr_address.address_type,
    usr_address.usr,
    usr_address.street1,
    usr_address.street2,
    usr_address.city,
    usr_address.county,
    usr_address.state,
    usr_address.country,
    usr_address.post_code,
    usr_address.pending,
    usr_address.replaces
   FROM actor.usr_address
UNION ALL
 SELECT actor_usr_address_history.audit_id,
    actor_usr_address_history.audit_time,
    actor_usr_address_history.audit_action,
    actor_usr_address_history.audit_user,
    actor_usr_address_history.audit_ws,
    actor_usr_address_history.id,
    actor_usr_address_history.valid,
    actor_usr_address_history.within_city_limits,
    actor_usr_address_history.address_type,
    actor_usr_address_history.usr,
    actor_usr_address_history.street1,
    actor_usr_address_history.street2,
    actor_usr_address_history.city,
    actor_usr_address_history.county,
    actor_usr_address_history.state,
    actor_usr_address_history.country,
    actor_usr_address_history.post_code,
    actor_usr_address_history.pending,
    actor_usr_address_history.replaces
   FROM auditor.actor_usr_address_history;


ALTER TABLE auditor.actor_usr_address_lifecycle OWNER TO evergreen;

--
-- Name: actor_usr_address_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.actor_usr_address_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.actor_usr_address_pkey_seq OWNER TO evergreen;

--
-- Name: actor_usr_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.actor_usr_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id integer NOT NULL,
    card integer,
    profile integer NOT NULL,
    usrname text NOT NULL,
    email text,
    passwd text NOT NULL,
    standing integer NOT NULL,
    ident_type integer NOT NULL,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text NOT NULL,
    second_given_name text,
    family_name text NOT NULL,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer NOT NULL,
    dob date,
    active boolean NOT NULL,
    master_account boolean NOT NULL,
    super_user boolean NOT NULL,
    barred boolean NOT NULL,
    deleted boolean NOT NULL,
    juvenile boolean NOT NULL,
    usrgroup integer NOT NULL,
    claims_returned_count integer NOT NULL,
    credit_forward_balance numeric(6,2) NOT NULL,
    last_xact_id text NOT NULL,
    create_date timestamp with time zone NOT NULL,
    expire_date timestamp with time zone NOT NULL,
    claims_never_checked_out_count integer NOT NULL,
    last_update_time timestamp with time zone,
    audit_ws integer,
    audit_user integer,
    guardian text,
    name_keywords text,
    name_kw_tsvector tsvector,
    pref_family_name text,
    pref_first_given_name text,
    pref_prefix text,
    pref_second_given_name text,
    pref_suffix text
);


ALTER TABLE auditor.actor_usr_history OWNER TO evergreen;

--
-- Name: actor_usr_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.actor_usr_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    usr.id,
    usr.card,
    usr.profile,
    usr.usrname,
    usr.email,
    usr.passwd,
    usr.standing,
    usr.ident_type,
    usr.ident_value,
    usr.ident_type2,
    usr.ident_value2,
    usr.net_access_level,
    usr.photo_url,
    usr.prefix,
    usr.first_given_name,
    usr.second_given_name,
    usr.family_name,
    usr.suffix,
    usr.alias,
    usr.day_phone,
    usr.evening_phone,
    usr.other_phone,
    usr.mailing_address,
    usr.billing_address,
    usr.home_ou,
    usr.dob,
    usr.active,
    usr.master_account,
    usr.super_user,
    usr.barred,
    usr.deleted,
    usr.juvenile,
    usr.usrgroup,
    usr.claims_returned_count,
    usr.credit_forward_balance,
    usr.last_xact_id,
    usr.create_date,
    usr.expire_date,
    usr.claims_never_checked_out_count,
    usr.last_update_time,
    usr.pref_prefix,
    usr.pref_first_given_name,
    usr.pref_second_given_name,
    usr.pref_family_name,
    usr.pref_suffix,
    usr.name_keywords,
    usr.name_kw_tsvector,
    usr.guardian
   FROM actor.usr
UNION ALL
 SELECT actor_usr_history.audit_id,
    actor_usr_history.audit_time,
    actor_usr_history.audit_action,
    actor_usr_history.audit_user,
    actor_usr_history.audit_ws,
    actor_usr_history.id,
    actor_usr_history.card,
    actor_usr_history.profile,
    actor_usr_history.usrname,
    actor_usr_history.email,
    actor_usr_history.passwd,
    actor_usr_history.standing,
    actor_usr_history.ident_type,
    actor_usr_history.ident_value,
    actor_usr_history.ident_type2,
    actor_usr_history.ident_value2,
    actor_usr_history.net_access_level,
    actor_usr_history.photo_url,
    actor_usr_history.prefix,
    actor_usr_history.first_given_name,
    actor_usr_history.second_given_name,
    actor_usr_history.family_name,
    actor_usr_history.suffix,
    actor_usr_history.alias,
    actor_usr_history.day_phone,
    actor_usr_history.evening_phone,
    actor_usr_history.other_phone,
    actor_usr_history.mailing_address,
    actor_usr_history.billing_address,
    actor_usr_history.home_ou,
    actor_usr_history.dob,
    actor_usr_history.active,
    actor_usr_history.master_account,
    actor_usr_history.super_user,
    actor_usr_history.barred,
    actor_usr_history.deleted,
    actor_usr_history.juvenile,
    actor_usr_history.usrgroup,
    actor_usr_history.claims_returned_count,
    actor_usr_history.credit_forward_balance,
    actor_usr_history.last_xact_id,
    actor_usr_history.create_date,
    actor_usr_history.expire_date,
    actor_usr_history.claims_never_checked_out_count,
    actor_usr_history.last_update_time,
    actor_usr_history.pref_prefix,
    actor_usr_history.pref_first_given_name,
    actor_usr_history.pref_second_given_name,
    actor_usr_history.pref_family_name,
    actor_usr_history.pref_suffix,
    actor_usr_history.name_keywords,
    actor_usr_history.name_kw_tsvector,
    actor_usr_history.guardian
   FROM auditor.actor_usr_history;


ALTER TABLE auditor.actor_usr_lifecycle OWNER TO evergreen;

--
-- Name: actor_usr_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.actor_usr_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.actor_usr_pkey_seq OWNER TO evergreen;

--
-- Name: actor_usr_setting_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.actor_usr_setting_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    usr integer NOT NULL,
    name text NOT NULL,
    value text NOT NULL,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.actor_usr_setting_history OWNER TO evergreen;

--
-- Name: actor_usr_setting_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.actor_usr_setting_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    usr_setting.id,
    usr_setting.usr,
    usr_setting.name,
    usr_setting.value
   FROM actor.usr_setting
UNION ALL
 SELECT actor_usr_setting_history.audit_id,
    actor_usr_setting_history.audit_time,
    actor_usr_setting_history.audit_action,
    actor_usr_setting_history.audit_user,
    actor_usr_setting_history.audit_ws,
    actor_usr_setting_history.id,
    actor_usr_setting_history.usr,
    actor_usr_setting_history.name,
    actor_usr_setting_history.value
   FROM auditor.actor_usr_setting_history;


ALTER TABLE auditor.actor_usr_setting_lifecycle OWNER TO evergreen;

--
-- Name: actor_usr_setting_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.actor_usr_setting_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.actor_usr_setting_pkey_seq OWNER TO evergreen;

--
-- Name: asset_call_number_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.asset_call_number_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    creator bigint NOT NULL,
    create_date timestamp with time zone,
    editor bigint NOT NULL,
    edit_date timestamp with time zone,
    record bigint NOT NULL,
    owning_lib integer NOT NULL,
    label text NOT NULL,
    deleted boolean NOT NULL,
    label_class bigint,
    label_sortkey text,
    prefix integer DEFAULT '-1'::integer NOT NULL,
    suffix integer DEFAULT '-1'::integer NOT NULL,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.asset_call_number_history OWNER TO evergreen;

--
-- Name: asset_call_number_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.asset_call_number_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    call_number.id,
    call_number.creator,
    call_number.create_date,
    call_number.editor,
    call_number.edit_date,
    call_number.record,
    call_number.owning_lib,
    call_number.label,
    call_number.deleted,
    call_number.label_class,
    call_number.label_sortkey,
    call_number.prefix,
    call_number.suffix
   FROM asset.call_number
UNION ALL
 SELECT asset_call_number_history.audit_id,
    asset_call_number_history.audit_time,
    asset_call_number_history.audit_action,
    asset_call_number_history.audit_user,
    asset_call_number_history.audit_ws,
    asset_call_number_history.id,
    asset_call_number_history.creator,
    asset_call_number_history.create_date,
    asset_call_number_history.editor,
    asset_call_number_history.edit_date,
    asset_call_number_history.record,
    asset_call_number_history.owning_lib,
    asset_call_number_history.label,
    asset_call_number_history.deleted,
    asset_call_number_history.label_class,
    asset_call_number_history.label_sortkey,
    asset_call_number_history.prefix,
    asset_call_number_history.suffix
   FROM auditor.asset_call_number_history;


ALTER TABLE auditor.asset_call_number_lifecycle OWNER TO evergreen;

--
-- Name: asset_call_number_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.asset_call_number_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.asset_call_number_pkey_seq OWNER TO evergreen;

--
-- Name: asset_copy_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.asset_copy_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    circ_lib integer NOT NULL,
    creator bigint NOT NULL,
    call_number bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer NOT NULL,
    location integer NOT NULL,
    loan_duration integer NOT NULL,
    fine_level integer NOT NULL,
    age_protect integer,
    circulate boolean NOT NULL,
    deposit boolean NOT NULL,
    ref boolean NOT NULL,
    holdable boolean NOT NULL,
    deposit_amount numeric(6,2) NOT NULL,
    price numeric(8,2),
    barcode text NOT NULL,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean NOT NULL,
    deleted boolean NOT NULL,
    floating integer,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean NOT NULL,
    cost numeric(8,2),
    active_date timestamp with time zone,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.asset_copy_history OWNER TO evergreen;

--
-- Name: asset_copy_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.asset_copy_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    copy.id,
    copy.circ_lib,
    copy.creator,
    copy.call_number,
    copy.editor,
    copy.create_date,
    copy.edit_date,
    copy.copy_number,
    copy.status,
    copy.location,
    copy.loan_duration,
    copy.fine_level,
    copy.age_protect,
    copy.circulate,
    copy.deposit,
    copy.ref,
    copy.holdable,
    copy.deposit_amount,
    copy.price,
    copy.barcode,
    copy.circ_modifier,
    copy.circ_as_type,
    copy.dummy_title,
    copy.dummy_author,
    copy.alert_message,
    copy.opac_visible,
    copy.deleted,
    copy.floating,
    copy.dummy_isbn,
    copy.status_changed_time,
    copy.mint_condition,
    copy.cost,
    copy.active_date
   FROM asset.copy
UNION ALL
 SELECT asset_copy_history.audit_id,
    asset_copy_history.audit_time,
    asset_copy_history.audit_action,
    asset_copy_history.audit_user,
    asset_copy_history.audit_ws,
    asset_copy_history.id,
    asset_copy_history.circ_lib,
    asset_copy_history.creator,
    asset_copy_history.call_number,
    asset_copy_history.editor,
    asset_copy_history.create_date,
    asset_copy_history.edit_date,
    asset_copy_history.copy_number,
    asset_copy_history.status,
    asset_copy_history.location,
    asset_copy_history.loan_duration,
    asset_copy_history.fine_level,
    asset_copy_history.age_protect,
    asset_copy_history.circulate,
    asset_copy_history.deposit,
    asset_copy_history.ref,
    asset_copy_history.holdable,
    asset_copy_history.deposit_amount,
    asset_copy_history.price,
    asset_copy_history.barcode,
    asset_copy_history.circ_modifier,
    asset_copy_history.circ_as_type,
    asset_copy_history.dummy_title,
    asset_copy_history.dummy_author,
    asset_copy_history.alert_message,
    asset_copy_history.opac_visible,
    asset_copy_history.deleted,
    asset_copy_history.floating,
    asset_copy_history.dummy_isbn,
    asset_copy_history.status_changed_time,
    asset_copy_history.mint_condition,
    asset_copy_history.cost,
    asset_copy_history.active_date
   FROM auditor.asset_copy_history;


ALTER TABLE auditor.asset_copy_lifecycle OWNER TO evergreen;

--
-- Name: asset_copy_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.asset_copy_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.asset_copy_pkey_seq OWNER TO evergreen;

--
-- Name: biblio_record_entry_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.biblio_record_entry_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    source integer,
    quality integer,
    create_date timestamp with time zone NOT NULL,
    edit_date timestamp with time zone NOT NULL,
    active boolean NOT NULL,
    deleted boolean NOT NULL,
    fingerprint text,
    tcn_source text NOT NULL,
    tcn_value text NOT NULL,
    marc text NOT NULL,
    last_xact_id text NOT NULL,
    owner integer,
    share_depth integer,
    audit_ws integer,
    audit_user integer,
    cataloging_date timestamp with time zone,
    merge_date timestamp with time zone,
    merged_to bigint,
    vis_attr_vector integer[]
);


ALTER TABLE auditor.biblio_record_entry_history OWNER TO evergreen;

--
-- Name: record_entry; Type: TABLE; Schema: biblio; Owner: evergreen
--

CREATE TABLE biblio.record_entry (
    id bigint NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    source integer,
    quality integer,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    active boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    fingerprint text,
    tcn_source text DEFAULT 'AUTOGEN'::text NOT NULL,
    tcn_value text DEFAULT biblio.next_autogen_tcn_value() NOT NULL,
    marc text NOT NULL,
    last_xact_id text NOT NULL,
    owner integer,
    share_depth integer,
    cataloging_date timestamp with time zone,
    merge_date timestamp with time zone,
    merged_to bigint,
    vis_attr_vector integer[]
);


ALTER TABLE biblio.record_entry OWNER TO evergreen;

--
-- Name: biblio_record_entry_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.biblio_record_entry_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    record_entry.id,
    record_entry.creator,
    record_entry.editor,
    record_entry.source,
    record_entry.quality,
    record_entry.create_date,
    record_entry.edit_date,
    record_entry.active,
    record_entry.deleted,
    record_entry.fingerprint,
    record_entry.tcn_source,
    record_entry.tcn_value,
    record_entry.marc,
    record_entry.last_xact_id,
    record_entry.owner,
    record_entry.share_depth,
    record_entry.cataloging_date,
    record_entry.merge_date,
    record_entry.merged_to,
    record_entry.vis_attr_vector
   FROM biblio.record_entry
UNION ALL
 SELECT biblio_record_entry_history.audit_id,
    biblio_record_entry_history.audit_time,
    biblio_record_entry_history.audit_action,
    biblio_record_entry_history.audit_user,
    biblio_record_entry_history.audit_ws,
    biblio_record_entry_history.id,
    biblio_record_entry_history.creator,
    biblio_record_entry_history.editor,
    biblio_record_entry_history.source,
    biblio_record_entry_history.quality,
    biblio_record_entry_history.create_date,
    biblio_record_entry_history.edit_date,
    biblio_record_entry_history.active,
    biblio_record_entry_history.deleted,
    biblio_record_entry_history.fingerprint,
    biblio_record_entry_history.tcn_source,
    biblio_record_entry_history.tcn_value,
    biblio_record_entry_history.marc,
    biblio_record_entry_history.last_xact_id,
    biblio_record_entry_history.owner,
    biblio_record_entry_history.share_depth,
    biblio_record_entry_history.cataloging_date,
    biblio_record_entry_history.merge_date,
    biblio_record_entry_history.merged_to,
    biblio_record_entry_history.vis_attr_vector
   FROM auditor.biblio_record_entry_history;


ALTER TABLE auditor.biblio_record_entry_lifecycle OWNER TO evergreen;

--
-- Name: biblio_record_entry_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.biblio_record_entry_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.biblio_record_entry_pkey_seq OWNER TO evergreen;

--
-- Name: serial_unit_history; Type: TABLE; Schema: auditor; Owner: evergreen
--

CREATE TABLE auditor.serial_unit_history (
    audit_id bigint NOT NULL,
    audit_time timestamp with time zone NOT NULL,
    audit_action text NOT NULL,
    id bigint NOT NULL,
    circ_lib integer NOT NULL,
    creator bigint NOT NULL,
    call_number bigint NOT NULL,
    editor bigint NOT NULL,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer NOT NULL,
    location integer NOT NULL,
    loan_duration integer NOT NULL,
    fine_level integer NOT NULL,
    age_protect integer,
    circulate boolean NOT NULL,
    deposit boolean NOT NULL,
    ref boolean NOT NULL,
    holdable boolean NOT NULL,
    deposit_amount numeric(6,2) NOT NULL,
    price numeric(8,2),
    barcode text NOT NULL,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean NOT NULL,
    deleted boolean NOT NULL,
    floating integer,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean NOT NULL,
    cost numeric(8,2),
    sort_key text,
    detailed_contents text NOT NULL,
    summary_contents text NOT NULL,
    active_date timestamp with time zone,
    audit_ws integer,
    audit_user integer
);


ALTER TABLE auditor.serial_unit_history OWNER TO evergreen;

--
-- Name: unit; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.unit (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass),
    sort_key text,
    detailed_contents text NOT NULL,
    summary_contents text NOT NULL
)
INHERITS (asset.copy);


ALTER TABLE serial.unit OWNER TO evergreen;

--
-- Name: serial_unit_lifecycle; Type: VIEW; Schema: auditor; Owner: evergreen
--

CREATE VIEW auditor.serial_unit_lifecycle AS
 SELECT '-1'::integer AS audit_id,
    now() AS audit_time,
    '-'::text AS audit_action,
    '-1'::integer AS audit_user,
    '-1'::integer AS audit_ws,
    unit.id,
    unit.circ_lib,
    unit.creator,
    unit.call_number,
    unit.editor,
    unit.create_date,
    unit.edit_date,
    unit.copy_number,
    unit.status,
    unit.location,
    unit.loan_duration,
    unit.fine_level,
    unit.age_protect,
    unit.circulate,
    unit.deposit,
    unit.ref,
    unit.holdable,
    unit.deposit_amount,
    unit.price,
    unit.barcode,
    unit.circ_modifier,
    unit.circ_as_type,
    unit.dummy_title,
    unit.dummy_author,
    unit.alert_message,
    unit.opac_visible,
    unit.deleted,
    unit.floating,
    unit.dummy_isbn,
    unit.status_changed_time,
    unit.mint_condition,
    unit.cost,
    unit.active_date,
    unit.sort_key,
    unit.detailed_contents,
    unit.summary_contents
   FROM serial.unit
UNION ALL
 SELECT serial_unit_history.audit_id,
    serial_unit_history.audit_time,
    serial_unit_history.audit_action,
    serial_unit_history.audit_user,
    serial_unit_history.audit_ws,
    serial_unit_history.id,
    serial_unit_history.circ_lib,
    serial_unit_history.creator,
    serial_unit_history.call_number,
    serial_unit_history.editor,
    serial_unit_history.create_date,
    serial_unit_history.edit_date,
    serial_unit_history.copy_number,
    serial_unit_history.status,
    serial_unit_history.location,
    serial_unit_history.loan_duration,
    serial_unit_history.fine_level,
    serial_unit_history.age_protect,
    serial_unit_history.circulate,
    serial_unit_history.deposit,
    serial_unit_history.ref,
    serial_unit_history.holdable,
    serial_unit_history.deposit_amount,
    serial_unit_history.price,
    serial_unit_history.barcode,
    serial_unit_history.circ_modifier,
    serial_unit_history.circ_as_type,
    serial_unit_history.dummy_title,
    serial_unit_history.dummy_author,
    serial_unit_history.alert_message,
    serial_unit_history.opac_visible,
    serial_unit_history.deleted,
    serial_unit_history.floating,
    serial_unit_history.dummy_isbn,
    serial_unit_history.status_changed_time,
    serial_unit_history.mint_condition,
    serial_unit_history.cost,
    serial_unit_history.active_date,
    serial_unit_history.sort_key,
    serial_unit_history.detailed_contents,
    serial_unit_history.summary_contents
   FROM auditor.serial_unit_history;


ALTER TABLE auditor.serial_unit_lifecycle OWNER TO evergreen;

--
-- Name: serial_unit_pkey_seq; Type: SEQUENCE; Schema: auditor; Owner: evergreen
--

CREATE SEQUENCE auditor.serial_unit_pkey_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE auditor.serial_unit_pkey_seq OWNER TO evergreen;

--
-- Name: authority_linking_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.authority_linking_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.authority_linking_id_seq OWNER TO evergreen;

--
-- Name: authority_linking_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.authority_linking_id_seq OWNED BY authority.authority_linking.id;


--
-- Name: bib_linking; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.bib_linking (
    id bigint NOT NULL,
    bib bigint NOT NULL,
    authority bigint NOT NULL
);


ALTER TABLE authority.bib_linking OWNER TO evergreen;

--
-- Name: bib_linking_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.bib_linking_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.bib_linking_id_seq OWNER TO evergreen;

--
-- Name: bib_linking_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.bib_linking_id_seq OWNED BY authority.bib_linking.id;


--
-- Name: browse_axis; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.browse_axis (
    code text NOT NULL,
    name text NOT NULL,
    sorter text,
    description text
);


ALTER TABLE authority.browse_axis OWNER TO evergreen;

--
-- Name: browse_axis_authority_field_map; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.browse_axis_authority_field_map (
    id integer NOT NULL,
    axis text NOT NULL,
    field integer NOT NULL
);


ALTER TABLE authority.browse_axis_authority_field_map OWNER TO evergreen;

--
-- Name: browse_axis_authority_field_map_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.browse_axis_authority_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.browse_axis_authority_field_map_id_seq OWNER TO evergreen;

--
-- Name: browse_axis_authority_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.browse_axis_authority_field_map_id_seq OWNED BY authority.browse_axis_authority_field_map.id;


--
-- Name: control_set; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.control_set (
    id integer NOT NULL,
    name text NOT NULL,
    description text
);


ALTER TABLE authority.control_set OWNER TO evergreen;

--
-- Name: control_set_bib_field; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.control_set_bib_field (
    id integer NOT NULL,
    authority_field integer NOT NULL,
    tag character(3) NOT NULL
);


ALTER TABLE authority.control_set_bib_field OWNER TO evergreen;

--
-- Name: control_set_bib_field_metabib_field_map; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.control_set_bib_field_metabib_field_map (
    id integer NOT NULL,
    bib_field integer NOT NULL,
    metabib_field integer NOT NULL
);


ALTER TABLE authority.control_set_bib_field_metabib_field_map OWNER TO evergreen;

--
-- Name: control_set_auth_field_metabib_field_map_main; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW authority.control_set_auth_field_metabib_field_map_main AS
 SELECT DISTINCT b.authority_field,
    m.metabib_field
   FROM (authority.control_set_bib_field_metabib_field_map m
     JOIN authority.control_set_bib_field b ON ((b.id = m.bib_field)));


ALTER TABLE authority.control_set_auth_field_metabib_field_map_main OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_main; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW authority.control_set_auth_field_metabib_field_map_main IS 'metabib fields for main entry auth fields';


--
-- Name: control_set_authority_field; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.control_set_authority_field (
    id integer NOT NULL,
    main_entry integer,
    control_set integer NOT NULL,
    tag character(3) NOT NULL,
    nfi character(1),
    sf_list text NOT NULL,
    name text NOT NULL,
    description text,
    linking_subfield character(1),
    display_sf_list text NOT NULL,
    joiner text,
    heading_field integer
);


ALTER TABLE authority.control_set_authority_field OWNER TO evergreen;

--
-- Name: control_set_auth_field_metabib_field_map_blind_main; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW authority.control_set_auth_field_metabib_field_map_blind_main AS
 SELECT r.authority_field,
    r.metabib_field
   FROM (authority.control_set_auth_field_metabib_field_map_main r
     JOIN authority.control_set_authority_field a ON ((r.authority_field = a.id)))
  WHERE (a.linking_subfield IS NULL);


ALTER TABLE authority.control_set_auth_field_metabib_field_map_blind_main OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_blind_main; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW authority.control_set_auth_field_metabib_field_map_blind_main IS 'metabib fields for main entry auth fields that can''t be linked to other records';


--
-- Name: control_set_auth_field_metabib_field_map_refs_only; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW authority.control_set_auth_field_metabib_field_map_refs_only AS
 SELECT DISTINCT a.id AS authority_field,
    m.metabib_field
   FROM ((((authority.control_set_authority_field a
     JOIN authority.control_set_authority_field ame ON ((a.main_entry = ame.id)))
     JOIN authority.control_set_bib_field b ON ((b.authority_field = ame.id)))
     JOIN authority.control_set_bib_field_metabib_field_map mf ON ((mf.bib_field = b.id)))
     JOIN authority.control_set_auth_field_metabib_field_map_main m ON ((ame.id = m.authority_field)));


ALTER TABLE authority.control_set_auth_field_metabib_field_map_refs_only OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_refs_only; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW authority.control_set_auth_field_metabib_field_map_refs_only IS 'metabib fields for NON-main entry auth fields';


--
-- Name: control_set_auth_field_metabib_field_map_refs; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW authority.control_set_auth_field_metabib_field_map_refs AS
 SELECT control_set_auth_field_metabib_field_map_main.authority_field,
    control_set_auth_field_metabib_field_map_main.metabib_field
   FROM authority.control_set_auth_field_metabib_field_map_main
UNION
 SELECT control_set_auth_field_metabib_field_map_refs_only.authority_field,
    control_set_auth_field_metabib_field_map_refs_only.metabib_field
   FROM authority.control_set_auth_field_metabib_field_map_refs_only;


ALTER TABLE authority.control_set_auth_field_metabib_field_map_refs OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_refs; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW authority.control_set_auth_field_metabib_field_map_refs IS 'metabib fields for all auth fields';


--
-- Name: control_set_auth_field_metabib_field_map_blind_refs; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW authority.control_set_auth_field_metabib_field_map_blind_refs AS
 SELECT r.authority_field,
    r.metabib_field
   FROM (authority.control_set_auth_field_metabib_field_map_refs r
     JOIN authority.control_set_authority_field a ON ((r.authority_field = a.id)))
  WHERE (a.linking_subfield IS NULL);


ALTER TABLE authority.control_set_auth_field_metabib_field_map_blind_refs OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_blind_refs; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW authority.control_set_auth_field_metabib_field_map_blind_refs IS 'metabib fields for all auth fields that can''t be linked to other records';


--
-- Name: control_set_auth_field_metabib_field_map_blind_refs_only; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW authority.control_set_auth_field_metabib_field_map_blind_refs_only AS
 SELECT r.authority_field,
    r.metabib_field
   FROM (authority.control_set_auth_field_metabib_field_map_refs_only r
     JOIN authority.control_set_authority_field a ON ((r.authority_field = a.id)))
  WHERE (a.linking_subfield IS NULL);


ALTER TABLE authority.control_set_auth_field_metabib_field_map_blind_refs_only OWNER TO evergreen;

--
-- Name: VIEW control_set_auth_field_metabib_field_map_blind_refs_only; Type: COMMENT; Schema: authority; Owner: evergreen
--

COMMENT ON VIEW authority.control_set_auth_field_metabib_field_map_blind_refs_only IS 'metabib fields for NON-main entry auth fields that can''t be linked to other records';


--
-- Name: control_set_authority_field_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.control_set_authority_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.control_set_authority_field_id_seq OWNER TO evergreen;

--
-- Name: control_set_authority_field_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.control_set_authority_field_id_seq OWNED BY authority.control_set_authority_field.id;


--
-- Name: control_set_bib_field_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.control_set_bib_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.control_set_bib_field_id_seq OWNER TO evergreen;

--
-- Name: control_set_bib_field_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.control_set_bib_field_id_seq OWNED BY authority.control_set_bib_field.id;


--
-- Name: control_set_bib_field_metabib_field_map_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.control_set_bib_field_metabib_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.control_set_bib_field_metabib_field_map_id_seq OWNER TO evergreen;

--
-- Name: control_set_bib_field_metabib_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.control_set_bib_field_metabib_field_map_id_seq OWNED BY authority.control_set_bib_field_metabib_field_map.id;


--
-- Name: control_set_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.control_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.control_set_id_seq OWNER TO evergreen;

--
-- Name: control_set_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.control_set_id_seq OWNED BY authority.control_set.id;


--
-- Name: display_5xx_headings; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.display_5xx_headings (
    id integer NOT NULL,
    w_subfield_0 character(1),
    w_subfield_1 character(1),
    w_subfield_2 character(1),
    w_subfield_3 character(1),
    heading text
);


ALTER TABLE authority.display_5xx_headings OWNER TO evergreen;

--
-- Name: display_5xx_headings_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.display_5xx_headings_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.display_5xx_headings_id_seq OWNER TO evergreen;

--
-- Name: display_5xx_headings_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.display_5xx_headings_id_seq OWNED BY authority.display_5xx_headings.id;


--
-- Name: full_rec_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.full_rec_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.full_rec_id_seq OWNER TO evergreen;

--
-- Name: full_rec_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.full_rec_id_seq OWNED BY authority.full_rec.id;


--
-- Name: heading_field; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.heading_field (
    id integer NOT NULL,
    heading_type authority.heading_type NOT NULL,
    heading_purpose authority.heading_purpose NOT NULL,
    label text NOT NULL,
    format text DEFAULT 'mads21'::text NOT NULL,
    heading_xpath text NOT NULL,
    component_xpath text NOT NULL,
    type_xpath text,
    thesaurus_xpath text,
    thesaurus_override_xpath text,
    joiner text
);


ALTER TABLE authority.heading_field OWNER TO evergreen;

--
-- Name: heading_field_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.heading_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.heading_field_id_seq OWNER TO evergreen;

--
-- Name: heading_field_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.heading_field_id_seq OWNED BY authority.heading_field.id;


--
-- Name: heading_field_norm_map; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.heading_field_norm_map (
    id integer NOT NULL,
    field integer NOT NULL,
    norm integer NOT NULL,
    params text,
    pos integer DEFAULT 0 NOT NULL
);


ALTER TABLE authority.heading_field_norm_map OWNER TO evergreen;

--
-- Name: heading_field_norm_map_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.heading_field_norm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.heading_field_norm_map_id_seq OWNER TO evergreen;

--
-- Name: heading_field_norm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.heading_field_norm_map_id_seq OWNED BY authority.heading_field_norm_map.id;


--
-- Name: rec_descriptor; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.rec_descriptor (
    id bigint NOT NULL,
    record bigint,
    record_status text,
    encoding_level text,
    thesaurus text
);


ALTER TABLE authority.rec_descriptor OWNER TO evergreen;

--
-- Name: rec_descriptor_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.rec_descriptor_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.rec_descriptor_id_seq OWNER TO evergreen;

--
-- Name: rec_descriptor_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.rec_descriptor_id_seq OWNED BY authority.rec_descriptor.id;


--
-- Name: record_entry; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.record_entry (
    id bigint NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    active boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    source integer,
    marc text NOT NULL,
    last_xact_id text NOT NULL,
    owner integer,
    control_set integer,
    heading text,
    simple_heading text
);


ALTER TABLE authority.record_entry OWNER TO evergreen;

--
-- Name: record_entry_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.record_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.record_entry_id_seq OWNER TO evergreen;

--
-- Name: record_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.record_entry_id_seq OWNED BY authority.record_entry.id;


--
-- Name: record_note; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.record_note (
    id bigint NOT NULL,
    record bigint NOT NULL,
    value text NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE authority.record_note OWNER TO evergreen;

--
-- Name: record_note_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.record_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.record_note_id_seq OWNER TO evergreen;

--
-- Name: record_note_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.record_note_id_seq OWNED BY authority.record_note.id;


--
-- Name: simple_heading_id_seq; Type: SEQUENCE; Schema: authority; Owner: evergreen
--

CREATE SEQUENCE authority.simple_heading_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE authority.simple_heading_id_seq OWNER TO evergreen;

--
-- Name: simple_heading_id_seq; Type: SEQUENCE OWNED BY; Schema: authority; Owner: evergreen
--

ALTER SEQUENCE authority.simple_heading_id_seq OWNED BY authority.simple_heading.id;


--
-- Name: thesaurus; Type: TABLE; Schema: authority; Owner: evergreen
--

CREATE TABLE authority.thesaurus (
    code text NOT NULL,
    control_set integer,
    name text NOT NULL,
    description text,
    short_code text,
    uri text
);


ALTER TABLE authority.thesaurus OWNER TO evergreen;

--
-- Name: tracing_links; Type: VIEW; Schema: authority; Owner: evergreen
--

CREATE VIEW authority.tracing_links AS
 SELECT main.record,
    main.id AS main_id,
    main.tag AS main_tag,
    evergreen.oils_xpath_string((('//*[@tag="'::text || (main.tag)::text) || '"]/*[local-name()="subfield"]'::text), are.marc) AS main_value,
    substr(link.value, 1, 1) AS relationship,
    substr(link.value, 2, 1) AS use_restriction,
    substr(link.value, 3, 1) AS deprecation,
    substr(link.value, 4, 1) AS display_restriction,
    link.id AS link_id,
    link.tag AS link_tag,
    evergreen.oils_xpath_string((('//*[@tag="'::text || (link.tag)::text) || '"]/*[local-name()="subfield"]'::text), are.marc) AS link_value,
    authority.normalize_heading(are.marc) AS normalized_main_value
   FROM ((((authority.full_rec main
     JOIN authority.record_entry are ON ((main.record = are.id)))
     JOIN authority.control_set_authority_field main_entry ON (((main_entry.tag = main.tag) AND (main_entry.main_entry IS NULL) AND (main.subfield = 'a'::text))))
     JOIN authority.control_set_authority_field sub_entry ON ((main_entry.id = sub_entry.main_entry)))
     JOIN authority.full_rec link ON (((link.record = main.record) AND (link.tag = sub_entry.tag) AND (link.subfield = 'w'::text))));


ALTER TABLE authority.tracing_links OWNER TO evergreen;

--
-- Name: autogen_tcn_value_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE biblio.autogen_tcn_value_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.autogen_tcn_value_seq OWNER TO evergreen;

--
-- Name: monograph_part; Type: TABLE; Schema: biblio; Owner: evergreen
--

CREATE TABLE biblio.monograph_part (
    id integer NOT NULL,
    record bigint NOT NULL,
    label text NOT NULL,
    label_sortkey text NOT NULL,
    deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE biblio.monograph_part OWNER TO evergreen;

--
-- Name: monograph_part_id_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE biblio.monograph_part_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.monograph_part_id_seq OWNER TO evergreen;

--
-- Name: monograph_part_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: evergreen
--

ALTER SEQUENCE biblio.monograph_part_id_seq OWNED BY biblio.monograph_part.id;


--
-- Name: peer_bib_copy_map; Type: TABLE; Schema: biblio; Owner: evergreen
--

CREATE TABLE biblio.peer_bib_copy_map (
    id integer NOT NULL,
    peer_type integer NOT NULL,
    peer_record bigint NOT NULL,
    target_copy bigint NOT NULL
);


ALTER TABLE biblio.peer_bib_copy_map OWNER TO evergreen;

--
-- Name: peer_bib_copy_map_id_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE biblio.peer_bib_copy_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.peer_bib_copy_map_id_seq OWNER TO evergreen;

--
-- Name: peer_bib_copy_map_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: evergreen
--

ALTER SEQUENCE biblio.peer_bib_copy_map_id_seq OWNED BY biblio.peer_bib_copy_map.id;


--
-- Name: peer_type; Type: TABLE; Schema: biblio; Owner: evergreen
--

CREATE TABLE biblio.peer_type (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE biblio.peer_type OWNER TO evergreen;

--
-- Name: peer_type_id_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE biblio.peer_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.peer_type_id_seq OWNER TO evergreen;

--
-- Name: peer_type_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: evergreen
--

ALTER SEQUENCE biblio.peer_type_id_seq OWNED BY biblio.peer_type.id;


--
-- Name: record_entry_id_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE biblio.record_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.record_entry_id_seq OWNER TO evergreen;

--
-- Name: record_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: evergreen
--

ALTER SEQUENCE biblio.record_entry_id_seq OWNED BY biblio.record_entry.id;


--
-- Name: record_note; Type: TABLE; Schema: biblio; Owner: evergreen
--

CREATE TABLE biblio.record_note (
    id bigint NOT NULL,
    record bigint NOT NULL,
    value text NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    deleted boolean DEFAULT false
);


ALTER TABLE biblio.record_note OWNER TO evergreen;

--
-- Name: record_note_id_seq; Type: SEQUENCE; Schema: biblio; Owner: evergreen
--

CREATE SEQUENCE biblio.record_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE biblio.record_note_id_seq OWNER TO evergreen;

--
-- Name: record_note_id_seq; Type: SEQUENCE OWNED BY; Schema: biblio; Owner: evergreen
--

ALTER SEQUENCE biblio.record_note_id_seq OWNED BY biblio.record_note.id;


--
-- Name: reservation; Type: TABLE; Schema: booking; Owner: evergreen
--

CREATE TABLE booking.reservation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass),
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    capture_time timestamp with time zone,
    cancel_time timestamp with time zone,
    pickup_time timestamp with time zone,
    return_time timestamp with time zone,
    booking_interval interval,
    fine_interval interval,
    fine_amount numeric(8,2),
    max_fine numeric(8,2),
    target_resource_type integer NOT NULL,
    target_resource integer,
    current_resource integer,
    request_lib integer NOT NULL,
    pickup_lib integer,
    capture_staff integer,
    email_notify boolean DEFAULT false NOT NULL,
    note text
)
INHERITS (money.billable_xact);


ALTER TABLE booking.reservation OWNER TO evergreen;

--
-- Name: reservation_attr_value_map; Type: TABLE; Schema: booking; Owner: evergreen
--

CREATE TABLE booking.reservation_attr_value_map (
    id integer NOT NULL,
    reservation integer NOT NULL,
    attr_value integer NOT NULL
);


ALTER TABLE booking.reservation_attr_value_map OWNER TO evergreen;

--
-- Name: reservation_attr_value_map_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE booking.reservation_attr_value_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.reservation_attr_value_map_id_seq OWNER TO evergreen;

--
-- Name: reservation_attr_value_map_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE booking.reservation_attr_value_map_id_seq OWNED BY booking.reservation_attr_value_map.id;


--
-- Name: resource; Type: TABLE; Schema: booking; Owner: evergreen
--

CREATE TABLE booking.resource (
    id integer NOT NULL,
    owner integer NOT NULL,
    type integer NOT NULL,
    overbook boolean DEFAULT false NOT NULL,
    barcode text NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    deposit_amount numeric(8,2) DEFAULT 0.00 NOT NULL,
    user_fee numeric(8,2) DEFAULT 0.00 NOT NULL
);


ALTER TABLE booking.resource OWNER TO evergreen;

--
-- Name: resource_attr; Type: TABLE; Schema: booking; Owner: evergreen
--

CREATE TABLE booking.resource_attr (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    resource_type integer NOT NULL,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE booking.resource_attr OWNER TO evergreen;

--
-- Name: resource_attr_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE booking.resource_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_attr_id_seq OWNER TO evergreen;

--
-- Name: resource_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE booking.resource_attr_id_seq OWNED BY booking.resource_attr.id;


--
-- Name: resource_attr_map; Type: TABLE; Schema: booking; Owner: evergreen
--

CREATE TABLE booking.resource_attr_map (
    id integer NOT NULL,
    resource integer NOT NULL,
    resource_attr integer NOT NULL,
    value integer NOT NULL
);


ALTER TABLE booking.resource_attr_map OWNER TO evergreen;

--
-- Name: resource_attr_map_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE booking.resource_attr_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_attr_map_id_seq OWNER TO evergreen;

--
-- Name: resource_attr_map_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE booking.resource_attr_map_id_seq OWNED BY booking.resource_attr_map.id;


--
-- Name: resource_attr_value; Type: TABLE; Schema: booking; Owner: evergreen
--

CREATE TABLE booking.resource_attr_value (
    id integer NOT NULL,
    owner integer NOT NULL,
    attr integer NOT NULL,
    valid_value text NOT NULL
);


ALTER TABLE booking.resource_attr_value OWNER TO evergreen;

--
-- Name: resource_attr_value_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE booking.resource_attr_value_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_attr_value_id_seq OWNER TO evergreen;

--
-- Name: resource_attr_value_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE booking.resource_attr_value_id_seq OWNED BY booking.resource_attr_value.id;


--
-- Name: resource_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE booking.resource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_id_seq OWNER TO evergreen;

--
-- Name: resource_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE booking.resource_id_seq OWNED BY booking.resource.id;


--
-- Name: resource_type; Type: TABLE; Schema: booking; Owner: evergreen
--

CREATE TABLE booking.resource_type (
    id integer NOT NULL,
    name text NOT NULL,
    elbow_room interval,
    fine_interval interval,
    fine_amount numeric(8,2) DEFAULT 0 NOT NULL,
    max_fine numeric(8,2),
    owner integer NOT NULL,
    catalog_item boolean DEFAULT false NOT NULL,
    transferable boolean DEFAULT false NOT NULL,
    record bigint
);


ALTER TABLE booking.resource_type OWNER TO evergreen;

--
-- Name: resource_type_id_seq; Type: SEQUENCE; Schema: booking; Owner: evergreen
--

CREATE SEQUENCE booking.resource_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE booking.resource_type_id_seq OWNER TO evergreen;

--
-- Name: resource_type_id_seq; Type: SEQUENCE OWNED BY; Schema: booking; Owner: evergreen
--

ALTER SEQUENCE booking.resource_type_id_seq OWNED BY booking.resource_type.id;


--
-- Name: unused_indexes; Type: TABLE; Schema: cmd; Owner: postgres
--

CREATE TABLE cmd.unused_indexes (
    fqindexname text,
    total_size text,
    raw_size bigint
);


ALTER TABLE cmd.unused_indexes OWNER TO postgres;

--
-- Name: coded_value_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.coded_value_map (
    id integer NOT NULL,
    ctype text NOT NULL,
    code text NOT NULL,
    value text NOT NULL,
    description text,
    opac_visible boolean DEFAULT true NOT NULL,
    search_label text,
    is_simple boolean DEFAULT false NOT NULL,
    concept_uri text
);


ALTER TABLE config.coded_value_map OWNER TO evergreen;

--
-- Name: audience_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW config.audience_map AS
 SELECT coded_value_map.code,
    coded_value_map.value,
    coded_value_map.description
   FROM config.coded_value_map
  WHERE (coded_value_map.ctype = 'audience'::text);


ALTER TABLE config.audience_map OWNER TO evergreen;

--
-- Name: backup_circ_limit_set; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.backup_circ_limit_set (
    id integer,
    name text,
    owning_lib integer,
    items_out integer,
    depth integer,
    global boolean,
    description text
);


ALTER TABLE config.backup_circ_limit_set OWNER TO evergreen;

--
-- Name: backup_circ_limit_set_circ_mod_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.backup_circ_limit_set_circ_mod_map (
    id integer,
    limit_set integer,
    circ_mod text
);


ALTER TABLE config.backup_circ_limit_set_circ_mod_map OWNER TO evergreen;

--
-- Name: backup_circ_limit_set_group_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.backup_circ_limit_set_group_map (
    id integer,
    limit_set integer,
    limit_group integer,
    check_only boolean
);


ALTER TABLE config.backup_circ_limit_set_group_map OWNER TO evergreen;

--
-- Name: backup_circ_matrix_limit_set_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.backup_circ_matrix_limit_set_map (
    id integer,
    matchpoint integer,
    limit_set integer,
    fallthrough boolean,
    active boolean
);


ALTER TABLE config.backup_circ_matrix_limit_set_map OWNER TO evergreen;

--
-- Name: backup_circ_matrix_matchpoint; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.backup_circ_matrix_matchpoint (
    id integer,
    active boolean,
    org_unit integer,
    grp integer,
    circ_modifier text,
    marc_type text,
    marc_form text,
    marc_vr_format text,
    ref_flag boolean,
    juvenile_flag boolean,
    is_renewal boolean,
    usr_age_lower_bound interval,
    usr_age_upper_bound interval,
    circulate boolean,
    duration_rule integer,
    recurring_fine_rule integer,
    max_fine_rule integer,
    script_test text,
    total_copy_hold_ratio double precision,
    available_copy_hold_ratio double precision,
    copy_circ_lib integer,
    copy_owning_lib integer,
    hard_due_date integer,
    renewals integer,
    user_home_ou integer,
    grace_period interval,
    marc_bib_level text,
    item_age interval
);


ALTER TABLE config.backup_circ_matrix_matchpoint OWNER TO evergreen;

--
-- Name: barcode_completion; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.barcode_completion (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    org_unit integer NOT NULL,
    prefix text,
    suffix text,
    length integer DEFAULT 0 NOT NULL,
    padding text,
    padding_end boolean DEFAULT false NOT NULL,
    asset boolean DEFAULT true NOT NULL,
    actor boolean DEFAULT true NOT NULL
);


ALTER TABLE config.barcode_completion OWNER TO evergreen;

--
-- Name: barcode_completion_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.barcode_completion_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.barcode_completion_id_seq OWNER TO evergreen;

--
-- Name: barcode_completion_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.barcode_completion_id_seq OWNED BY config.barcode_completion.id;


--
-- Name: best_hold_order; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.best_hold_order (
    id integer NOT NULL,
    name text,
    pprox integer,
    hprox integer,
    aprox integer,
    approx integer,
    priority integer,
    cut integer,
    depth integer,
    htime integer,
    rtime integer,
    shtime integer,
    owning_lib_to_home_lib_prox integer,
    CONSTRAINT best_hold_order_check CHECK (((pprox IS NOT NULL) OR (hprox IS NOT NULL) OR (owning_lib_to_home_lib_prox IS NOT NULL) OR (aprox IS NOT NULL) OR (priority IS NOT NULL) OR (cut IS NOT NULL) OR (depth IS NOT NULL) OR (htime IS NOT NULL) OR (rtime IS NOT NULL)))
);


ALTER TABLE config.best_hold_order OWNER TO evergreen;

--
-- Name: best_hold_order_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.best_hold_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.best_hold_order_id_seq OWNER TO evergreen;

--
-- Name: best_hold_order_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.best_hold_order_id_seq OWNED BY config.best_hold_order.id;


--
-- Name: bib_level_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW config.bib_level_map AS
 SELECT coded_value_map.code,
    coded_value_map.value
   FROM config.coded_value_map
  WHERE (coded_value_map.ctype = 'bib_level'::text);


ALTER TABLE config.bib_level_map OWNER TO evergreen;

--
-- Name: bib_source; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.bib_source (
    id integer NOT NULL,
    quality integer,
    source text NOT NULL,
    transcendant boolean DEFAULT false NOT NULL,
    can_have_copies boolean DEFAULT true NOT NULL,
    CONSTRAINT bib_source_quality_check CHECK (((quality >= 0) AND (quality <= 100)))
);


ALTER TABLE config.bib_source OWNER TO evergreen;

--
-- Name: TABLE bib_source; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.bib_source IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Valid sources of MARC records
 *
 * This is table is used to set up the relative "quality" of each
 * MARC source, such as OCLC.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: bib_source_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.bib_source_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.bib_source_id_seq OWNER TO evergreen;

--
-- Name: bib_source_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.bib_source_id_seq OWNED BY config.bib_source.id;


--
-- Name: biblio_fingerprint; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.biblio_fingerprint (
    id integer NOT NULL,
    name text NOT NULL,
    xpath text NOT NULL,
    first_word boolean DEFAULT false NOT NULL,
    format text DEFAULT 'marcxml'::text NOT NULL
);


ALTER TABLE config.biblio_fingerprint OWNER TO evergreen;

--
-- Name: biblio_fingerprint_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.biblio_fingerprint_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.biblio_fingerprint_id_seq OWNER TO evergreen;

--
-- Name: biblio_fingerprint_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.biblio_fingerprint_id_seq OWNED BY config.biblio_fingerprint.id;


--
-- Name: billing_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.billing_type (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    default_price numeric(6,2)
);


ALTER TABLE config.billing_type OWNER TO evergreen;

--
-- Name: billing_type_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.billing_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.billing_type_id_seq OWNER TO evergreen;

--
-- Name: billing_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.billing_type_id_seq OWNED BY config.billing_type.id;


--
-- Name: carousel_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.carousel_type (
    id integer NOT NULL,
    name text NOT NULL,
    automatic boolean DEFAULT true NOT NULL,
    filter_by_age boolean DEFAULT false NOT NULL,
    filter_by_copy_owning_lib boolean DEFAULT false NOT NULL,
    filter_by_copy_location boolean DEFAULT false NOT NULL
);


ALTER TABLE config.carousel_type OWNER TO evergreen;

--
-- Name: carousel_type_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.carousel_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.carousel_type_id_seq OWNER TO evergreen;

--
-- Name: carousel_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.carousel_type_id_seq OWNED BY config.carousel_type.id;


--
-- Name: circ_limit_group; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.circ_limit_group (
    id integer NOT NULL,
    name text NOT NULL,
    description text
);


ALTER TABLE config.circ_limit_group OWNER TO evergreen;

--
-- Name: circ_limit_group_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.circ_limit_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_group_id_seq OWNER TO evergreen;

--
-- Name: circ_limit_group_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.circ_limit_group_id_seq OWNED BY config.circ_limit_group.id;


--
-- Name: circ_limit_set; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.circ_limit_set (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    items_out integer NOT NULL,
    depth integer DEFAULT 0 NOT NULL,
    global boolean DEFAULT false NOT NULL,
    description text
);


ALTER TABLE config.circ_limit_set OWNER TO evergreen;

--
-- Name: circ_limit_set_circ_mod_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.circ_limit_set_circ_mod_map (
    id integer NOT NULL,
    limit_set integer NOT NULL,
    circ_mod text NOT NULL
);


ALTER TABLE config.circ_limit_set_circ_mod_map OWNER TO evergreen;

--
-- Name: circ_limit_set_circ_mod_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.circ_limit_set_circ_mod_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_circ_mod_map_id_seq OWNER TO evergreen;

--
-- Name: circ_limit_set_circ_mod_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.circ_limit_set_circ_mod_map_id_seq OWNED BY config.circ_limit_set_circ_mod_map.id;


--
-- Name: circ_limit_set_copy_loc_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.circ_limit_set_copy_loc_map (
    id integer NOT NULL,
    limit_set integer NOT NULL,
    copy_loc integer NOT NULL
);


ALTER TABLE config.circ_limit_set_copy_loc_map OWNER TO evergreen;

--
-- Name: circ_limit_set_copy_loc_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.circ_limit_set_copy_loc_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_copy_loc_map_id_seq OWNER TO evergreen;

--
-- Name: circ_limit_set_copy_loc_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.circ_limit_set_copy_loc_map_id_seq OWNED BY config.circ_limit_set_copy_loc_map.id;


--
-- Name: circ_limit_set_group_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.circ_limit_set_group_map (
    id integer NOT NULL,
    limit_set integer NOT NULL,
    limit_group integer NOT NULL,
    check_only boolean DEFAULT false NOT NULL
);


ALTER TABLE config.circ_limit_set_group_map OWNER TO evergreen;

--
-- Name: circ_limit_set_group_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.circ_limit_set_group_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_group_map_id_seq OWNER TO evergreen;

--
-- Name: circ_limit_set_group_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.circ_limit_set_group_map_id_seq OWNED BY config.circ_limit_set_group_map.id;


--
-- Name: circ_limit_set_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.circ_limit_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_limit_set_id_seq OWNER TO evergreen;

--
-- Name: circ_limit_set_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.circ_limit_set_id_seq OWNED BY config.circ_limit_set.id;


--
-- Name: circ_matrix_circ_mod_test; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.circ_matrix_circ_mod_test (
    id integer NOT NULL,
    matchpoint integer NOT NULL,
    items_out integer NOT NULL
);


ALTER TABLE config.circ_matrix_circ_mod_test OWNER TO evergreen;

--
-- Name: circ_matrix_circ_mod_test_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.circ_matrix_circ_mod_test_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_circ_mod_test_id_seq OWNER TO evergreen;

--
-- Name: circ_matrix_circ_mod_test_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.circ_matrix_circ_mod_test_id_seq OWNED BY config.circ_matrix_circ_mod_test.id;


--
-- Name: circ_matrix_circ_mod_test_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.circ_matrix_circ_mod_test_map (
    id integer NOT NULL,
    circ_mod_test integer NOT NULL,
    circ_mod text NOT NULL
);


ALTER TABLE config.circ_matrix_circ_mod_test_map OWNER TO evergreen;

--
-- Name: circ_matrix_circ_mod_test_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.circ_matrix_circ_mod_test_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_circ_mod_test_map_id_seq OWNER TO evergreen;

--
-- Name: circ_matrix_circ_mod_test_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.circ_matrix_circ_mod_test_map_id_seq OWNED BY config.circ_matrix_circ_mod_test_map.id;


--
-- Name: circ_matrix_limit_set_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.circ_matrix_limit_set_map (
    id integer NOT NULL,
    matchpoint integer NOT NULL,
    limit_set integer NOT NULL,
    fallthrough boolean DEFAULT false NOT NULL,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE config.circ_matrix_limit_set_map OWNER TO evergreen;

--
-- Name: circ_matrix_limit_set_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.circ_matrix_limit_set_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_limit_set_map_id_seq OWNER TO evergreen;

--
-- Name: circ_matrix_limit_set_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.circ_matrix_limit_set_map_id_seq OWNED BY config.circ_matrix_limit_set_map.id;


--
-- Name: circ_matrix_matchpoint_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.circ_matrix_matchpoint_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_matchpoint_id_seq OWNER TO evergreen;

--
-- Name: circ_matrix_matchpoint_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.circ_matrix_matchpoint_id_seq OWNED BY config.circ_matrix_matchpoint.id;


--
-- Name: circ_matrix_weights; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.circ_matrix_weights (
    id integer NOT NULL,
    name text NOT NULL,
    org_unit numeric(6,2) NOT NULL,
    grp numeric(6,2) NOT NULL,
    circ_modifier numeric(6,2) NOT NULL,
    marc_type numeric(6,2) NOT NULL,
    marc_form numeric(6,2) NOT NULL,
    marc_vr_format numeric(6,2) NOT NULL,
    copy_circ_lib numeric(6,2) NOT NULL,
    copy_owning_lib numeric(6,2) NOT NULL,
    user_home_ou numeric(6,2) NOT NULL,
    ref_flag numeric(6,2) NOT NULL,
    juvenile_flag numeric(6,2) NOT NULL,
    is_renewal numeric(6,2) NOT NULL,
    usr_age_lower_bound numeric(6,2) NOT NULL,
    usr_age_upper_bound numeric(6,2) NOT NULL,
    marc_bib_level numeric(6,2) NOT NULL,
    item_age numeric(6,2) NOT NULL,
    copy_location numeric(6,2) NOT NULL
);


ALTER TABLE config.circ_matrix_weights OWNER TO evergreen;

--
-- Name: circ_matrix_weights_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.circ_matrix_weights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.circ_matrix_weights_id_seq OWNER TO evergreen;

--
-- Name: circ_matrix_weights_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.circ_matrix_weights_id_seq OWNED BY config.circ_matrix_weights.id;


--
-- Name: circ_modifier; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.circ_modifier (
    code text NOT NULL,
    name text NOT NULL,
    description text NOT NULL,
    sip2_media_type text NOT NULL,
    magnetic_media boolean DEFAULT true NOT NULL,
    avg_wait_time interval
);


ALTER TABLE config.circ_modifier OWNER TO evergreen;

--
-- Name: coded_value_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.coded_value_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.coded_value_map_id_seq OWNER TO evergreen;

--
-- Name: coded_value_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.coded_value_map_id_seq OWNED BY config.coded_value_map.id;


--
-- Name: composite_attr_entry_definition; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.composite_attr_entry_definition (
    coded_value integer NOT NULL,
    definition text NOT NULL
);


ALTER TABLE config.composite_attr_entry_definition OWNER TO evergreen;

--
-- Name: copy_alert_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.copy_alert_type (
    id integer NOT NULL,
    scope_org integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    name text NOT NULL,
    state config.copy_alert_type_state,
    event config.copy_alert_type_event,
    in_renew boolean,
    invert_location boolean DEFAULT false NOT NULL,
    at_circ boolean,
    at_owning boolean,
    next_status integer[]
);


ALTER TABLE config.copy_alert_type OWNER TO evergreen;

--
-- Name: copy_alert_type_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.copy_alert_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.copy_alert_type_id_seq OWNER TO evergreen;

--
-- Name: copy_alert_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.copy_alert_type_id_seq OWNED BY config.copy_alert_type.id;


--
-- Name: copy_status; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.copy_status (
    id integer NOT NULL,
    name text NOT NULL,
    holdable boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    copy_active boolean DEFAULT false NOT NULL,
    restrict_copy_delete boolean DEFAULT false NOT NULL,
    checkout_ok boolean DEFAULT false NOT NULL,
    is_available boolean DEFAULT false NOT NULL,
    hold_ratio_avail boolean DEFAULT false NOT NULL,
    hopeless_prone boolean DEFAULT false NOT NULL
);


ALTER TABLE config.copy_status OWNER TO evergreen;

--
-- Name: TABLE copy_status; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.copy_status IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Copy Statuses
 *
 * The available copy statuses, and whether a copy in that
 * status is available for hold request capture.  0 (zero) is
 * the only special number in this set, meaning that the item
 * is available for immediate checkout, and is counted as available
 * in the OPAC.
 *
 * Statuses with an ID below 100 are not removable, and have special
 * meaning in the code.  Do not change them except to translate the
 * textual name.
 *
 * You may add and remove statuses above 100, and these can be used
 * to remove items from normal circulation without affecting the rest
 * of the copy''s values or its location.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: copy_status_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.copy_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.copy_status_id_seq OWNER TO evergreen;

--
-- Name: copy_status_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.copy_status_id_seq OWNED BY config.copy_status.id;


--
-- Name: copy_tag_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.copy_tag_type (
    code text NOT NULL,
    label text NOT NULL,
    owner integer NOT NULL
);


ALTER TABLE config.copy_tag_type OWNER TO evergreen;

--
-- Name: db_patch_dependencies; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.db_patch_dependencies (
    db_patch text NOT NULL,
    supersedes text[],
    deprecates text[]
);


ALTER TABLE config.db_patch_dependencies OWNER TO evergreen;

--
-- Name: display_field_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.display_field_map (
    name text NOT NULL,
    field integer,
    multi boolean DEFAULT false
);


ALTER TABLE config.display_field_map OWNER TO evergreen;

--
-- Name: filter_dialog_filter_set; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.filter_dialog_filter_set (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    creator integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    interface text NOT NULL,
    filters text NOT NULL,
    CONSTRAINT filter_dialog_filter_set_filters_check CHECK (evergreen.is_json(filters))
);


ALTER TABLE config.filter_dialog_filter_set OWNER TO evergreen;

--
-- Name: filter_dialog_filter_set_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.filter_dialog_filter_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.filter_dialog_filter_set_id_seq OWNER TO evergreen;

--
-- Name: filter_dialog_filter_set_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.filter_dialog_filter_set_id_seq OWNED BY config.filter_dialog_filter_set.id;


--
-- Name: filter_dialog_interface; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.filter_dialog_interface (
    key text NOT NULL,
    description text
);


ALTER TABLE config.filter_dialog_interface OWNER TO evergreen;

--
-- Name: floating_group; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.floating_group (
    id integer NOT NULL,
    name text NOT NULL,
    manual boolean DEFAULT false NOT NULL
);


ALTER TABLE config.floating_group OWNER TO evergreen;

--
-- Name: floating_group_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.floating_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.floating_group_id_seq OWNER TO evergreen;

--
-- Name: floating_group_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.floating_group_id_seq OWNED BY config.floating_group.id;


--
-- Name: floating_group_member; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.floating_group_member (
    id integer NOT NULL,
    floating_group integer NOT NULL,
    org_unit integer NOT NULL,
    stop_depth integer DEFAULT 0 NOT NULL,
    max_depth integer,
    exclude boolean DEFAULT false NOT NULL
);


ALTER TABLE config.floating_group_member OWNER TO evergreen;

--
-- Name: floating_group_member_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.floating_group_member_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.floating_group_member_id_seq OWNER TO evergreen;

--
-- Name: floating_group_member_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.floating_group_member_id_seq OWNED BY config.floating_group_member.id;


--
-- Name: geolocation_service; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.geolocation_service (
    id integer NOT NULL,
    active boolean,
    owner integer NOT NULL,
    name text,
    service_code text,
    api_key text
);


ALTER TABLE config.geolocation_service OWNER TO evergreen;

--
-- Name: geolocation_service_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.geolocation_service_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.geolocation_service_id_seq OWNER TO evergreen;

--
-- Name: geolocation_service_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.geolocation_service_id_seq OWNED BY config.geolocation_service.id;


--
-- Name: internal_flag; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.internal_flag (
    name text NOT NULL,
    value text,
    enabled boolean DEFAULT false NOT NULL
);


ALTER TABLE config.internal_flag OWNER TO evergreen;

--
-- Name: global_flag; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.global_flag (
    label text NOT NULL
)
INHERITS (config.internal_flag);


ALTER TABLE config.global_flag OWNER TO evergreen;

--
-- Name: hard_due_date; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.hard_due_date (
    id integer NOT NULL,
    name text NOT NULL,
    ceiling_date timestamp with time zone NOT NULL,
    forceto boolean NOT NULL,
    owner integer NOT NULL
);


ALTER TABLE config.hard_due_date OWNER TO evergreen;

--
-- Name: hard_due_date_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.hard_due_date_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hard_due_date_id_seq OWNER TO evergreen;

--
-- Name: hard_due_date_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.hard_due_date_id_seq OWNED BY config.hard_due_date.id;


--
-- Name: hard_due_date_values; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.hard_due_date_values (
    id integer NOT NULL,
    hard_due_date integer NOT NULL,
    ceiling_date timestamp with time zone NOT NULL,
    active_date timestamp with time zone NOT NULL
);


ALTER TABLE config.hard_due_date_values OWNER TO evergreen;

--
-- Name: hard_due_date_values_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.hard_due_date_values_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hard_due_date_values_id_seq OWNER TO evergreen;

--
-- Name: hard_due_date_values_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.hard_due_date_values_id_seq OWNED BY config.hard_due_date_values.id;


--
-- Name: hold_matrix_matchpoint; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.hold_matrix_matchpoint (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    user_home_ou integer,
    request_ou integer,
    pickup_ou integer,
    item_owning_ou integer,
    item_circ_ou integer,
    usr_grp integer,
    requestor_grp integer NOT NULL,
    circ_modifier text,
    marc_type text,
    marc_form text,
    marc_vr_format text,
    juvenile_flag boolean,
    ref_flag boolean,
    holdable boolean DEFAULT true NOT NULL,
    distance_is_from_owner boolean DEFAULT false NOT NULL,
    transit_range integer,
    max_holds integer,
    include_frozen_holds boolean DEFAULT true NOT NULL,
    stop_blocked_user boolean DEFAULT false NOT NULL,
    age_hold_protect_rule integer,
    strict_ou_match boolean DEFAULT false NOT NULL,
    marc_bib_level text,
    item_age interval,
    description text
);


ALTER TABLE config.hold_matrix_matchpoint OWNER TO evergreen;

--
-- Name: hold_matrix_matchpoint_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.hold_matrix_matchpoint_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hold_matrix_matchpoint_id_seq OWNER TO evergreen;

--
-- Name: hold_matrix_matchpoint_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.hold_matrix_matchpoint_id_seq OWNED BY config.hold_matrix_matchpoint.id;


--
-- Name: hold_matrix_weights; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.hold_matrix_weights (
    id integer NOT NULL,
    name text NOT NULL,
    user_home_ou numeric(6,2) NOT NULL,
    request_ou numeric(6,2) NOT NULL,
    pickup_ou numeric(6,2) NOT NULL,
    item_owning_ou numeric(6,2) NOT NULL,
    item_circ_ou numeric(6,2) NOT NULL,
    usr_grp numeric(6,2) NOT NULL,
    requestor_grp numeric(6,2) NOT NULL,
    circ_modifier numeric(6,2) NOT NULL,
    marc_type numeric(6,2) NOT NULL,
    marc_form numeric(6,2) NOT NULL,
    marc_vr_format numeric(6,2) NOT NULL,
    juvenile_flag numeric(6,2) NOT NULL,
    ref_flag numeric(6,2) NOT NULL,
    marc_bib_level numeric(6,2) NOT NULL,
    item_age numeric(6,2) NOT NULL
);


ALTER TABLE config.hold_matrix_weights OWNER TO evergreen;

--
-- Name: hold_matrix_weights_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.hold_matrix_weights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hold_matrix_weights_id_seq OWNER TO evergreen;

--
-- Name: hold_matrix_weights_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.hold_matrix_weights_id_seq OWNED BY config.hold_matrix_weights.id;


--
-- Name: hold_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.hold_type (
    id integer NOT NULL,
    hold_type text,
    description text
);


ALTER TABLE config.hold_type OWNER TO evergreen;

--
-- Name: hold_type_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.hold_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.hold_type_id_seq OWNER TO evergreen;

--
-- Name: hold_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.hold_type_id_seq OWNED BY config.hold_type.id;


--
-- Name: i18n_core; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.i18n_core (
    id bigint NOT NULL,
    fq_field text NOT NULL,
    identity_value text NOT NULL,
    translation text NOT NULL,
    string text NOT NULL
);


ALTER TABLE config.i18n_core OWNER TO evergreen;

--
-- Name: i18n_core_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.i18n_core_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.i18n_core_id_seq OWNER TO evergreen;

--
-- Name: i18n_core_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.i18n_core_id_seq OWNED BY config.i18n_core.id;


--
-- Name: i18n_locale; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.i18n_locale (
    code text NOT NULL,
    marc_code text NOT NULL,
    name text NOT NULL,
    description text,
    rtl boolean DEFAULT false NOT NULL
);


ALTER TABLE config.i18n_locale OWNER TO evergreen;

--
-- Name: identification_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.identification_type (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE config.identification_type OWNER TO evergreen;

--
-- Name: TABLE identification_type; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.identification_type IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Types of valid patron identification.
 *
 * Each patron must display at least one valid form of identification
 * in order to get a library card.  This table lists those forms.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: identification_type_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.identification_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.identification_type_id_seq OWNER TO evergreen;

--
-- Name: identification_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.identification_type_id_seq OWNED BY config.identification_type.id;


--
-- Name: idl_field_doc; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.idl_field_doc (
    id bigint NOT NULL,
    fm_class text NOT NULL,
    field text NOT NULL,
    owner integer NOT NULL,
    string text NOT NULL
);


ALTER TABLE config.idl_field_doc OWNER TO evergreen;

--
-- Name: idl_field_doc_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.idl_field_doc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.idl_field_doc_id_seq OWNER TO evergreen;

--
-- Name: idl_field_doc_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.idl_field_doc_id_seq OWNED BY config.idl_field_doc.id;


--
-- Name: index_normalizer; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.index_normalizer (
    id integer NOT NULL,
    name text NOT NULL,
    description text,
    func text NOT NULL,
    param_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.index_normalizer OWNER TO evergreen;

--
-- Name: index_normalizer_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.index_normalizer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.index_normalizer_id_seq OWNER TO evergreen;

--
-- Name: index_normalizer_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.index_normalizer_id_seq OWNED BY config.index_normalizer.id;


--
-- Name: item_form_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW config.item_form_map AS
 SELECT coded_value_map.code,
    coded_value_map.value
   FROM config.coded_value_map
  WHERE (coded_value_map.ctype = 'item_form'::text);


ALTER TABLE config.item_form_map OWNER TO evergreen;

--
-- Name: item_type_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW config.item_type_map AS
 SELECT coded_value_map.code,
    coded_value_map.value
   FROM config.coded_value_map
  WHERE (coded_value_map.ctype = 'item_type'::text);


ALTER TABLE config.item_type_map OWNER TO evergreen;

--
-- Name: language_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW config.language_map AS
 SELECT coded_value_map.code,
    coded_value_map.value
   FROM config.coded_value_map
  WHERE (coded_value_map.ctype = 'item_lang'::text);


ALTER TABLE config.language_map OWNER TO evergreen;

--
-- Name: lit_form_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW config.lit_form_map AS
 SELECT coded_value_map.code,
    coded_value_map.value,
    coded_value_map.description
   FROM config.coded_value_map
  WHERE (coded_value_map.ctype = 'lit_form'::text);


ALTER TABLE config.lit_form_map OWNER TO evergreen;

--
-- Name: marc21_ff_pos_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.marc21_ff_pos_map (
    id integer NOT NULL,
    fixed_field text NOT NULL,
    tag text NOT NULL,
    rec_type text NOT NULL,
    start_pos integer NOT NULL,
    length integer NOT NULL,
    default_val text DEFAULT ' '::text NOT NULL
);


ALTER TABLE config.marc21_ff_pos_map OWNER TO evergreen;

--
-- Name: marc21_ff_pos_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.marc21_ff_pos_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc21_ff_pos_map_id_seq OWNER TO evergreen;

--
-- Name: marc21_ff_pos_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.marc21_ff_pos_map_id_seq OWNED BY config.marc21_ff_pos_map.id;


--
-- Name: marc21_physical_characteristic_subfield_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.marc21_physical_characteristic_subfield_map (
    id integer NOT NULL,
    ptype_key text NOT NULL,
    subfield text NOT NULL,
    start_pos integer NOT NULL,
    length integer NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.marc21_physical_characteristic_subfield_map OWNER TO evergreen;

--
-- Name: marc21_physical_characteristic_subfield_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.marc21_physical_characteristic_subfield_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc21_physical_characteristic_subfield_map_id_seq OWNER TO evergreen;

--
-- Name: marc21_physical_characteristic_subfield_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.marc21_physical_characteristic_subfield_map_id_seq OWNED BY config.marc21_physical_characteristic_subfield_map.id;


--
-- Name: marc21_physical_characteristic_type_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.marc21_physical_characteristic_type_map (
    ptype_key text NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.marc21_physical_characteristic_type_map OWNER TO evergreen;

--
-- Name: marc21_physical_characteristic_value_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.marc21_physical_characteristic_value_map (
    id integer NOT NULL,
    value text NOT NULL,
    ptype_subfield integer NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.marc21_physical_characteristic_value_map OWNER TO evergreen;

--
-- Name: marc21_physical_characteristic_value_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.marc21_physical_characteristic_value_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc21_physical_characteristic_value_map_id_seq OWNER TO evergreen;

--
-- Name: marc21_physical_characteristic_value_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.marc21_physical_characteristic_value_map_id_seq OWNED BY config.marc21_physical_characteristic_value_map.id;


--
-- Name: marc_field_for_ou; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW config.marc_field_for_ou AS
 WITH RECURSIVE ou_marc_fields(id, marc_format, marc_record_type, tag, name, description, fixed_field, repeatable, mandatory, hidden, owner, depth) AS (
         SELECT marc_field.id,
            marc_field.marc_format,
            marc_field.marc_record_type,
            marc_field.tag,
            marc_field.name,
            marc_field.description,
            marc_field.fixed_field,
            marc_field.repeatable,
            marc_field.mandatory,
            marc_field.hidden,
            marc_field.owner,
            0 AS "?column?"
           FROM config.marc_field
          WHERE (marc_field.owner IS NULL)
        UNION
         SELECT marc_field.id,
            marc_field.marc_format,
            marc_field.marc_record_type,
            marc_field.tag,
            marc_field.name,
            marc_field.description,
            marc_field.fixed_field,
            marc_field.repeatable,
            marc_field.mandatory,
            marc_field.hidden,
            marc_field.owner,
            0
           FROM config.marc_field
          WHERE (NOT (ARRAY[(marc_field.marc_format)::text, (marc_field.marc_record_type)::text, (marc_field.tag)::text] IN ( SELECT ARRAY[(marc_field_1.marc_format)::text, (marc_field_1.marc_record_type)::text, (marc_field_1.tag)::text] AS "array"
                   FROM config.marc_field marc_field_1
                  WHERE (marc_field_1.owner IS NULL))))
        UNION
         SELECT c.id,
            c.marc_format,
            c.marc_record_type,
            c.tag,
            COALESCE(c.name, p.name) AS "coalesce",
            COALESCE(c.description, p.description) AS "coalesce",
            COALESCE(c.fixed_field, p.fixed_field) AS "coalesce",
            COALESCE(c.repeatable, p.repeatable) AS "coalesce",
            COALESCE(c.mandatory, p.mandatory) AS "coalesce",
            COALESCE(c.hidden, p.hidden) AS "coalesce",
            c.owner,
            (p.depth + 1)
           FROM ((config.marc_field c
             JOIN ou_marc_fields p USING (marc_format, marc_record_type, tag))
             JOIN actor.org_unit aou ON ((c.owner = aou.id)))
          WHERE ((aou.parent_ou = p.owner) OR ((aou.parent_ou IS NULL) AND (p.owner IS NULL)))
        )
 SELECT ou_marc_fields.id,
    ou_marc_fields.marc_format,
    ou_marc_fields.marc_record_type,
    ou_marc_fields.tag,
    ou_marc_fields.name,
    ou_marc_fields.description,
    ou_marc_fields.fixed_field,
    ou_marc_fields.repeatable,
    ou_marc_fields.mandatory,
    ou_marc_fields.hidden,
    ou_marc_fields.owner,
    ou_marc_fields.depth
   FROM ou_marc_fields;


ALTER TABLE config.marc_field_for_ou OWNER TO evergreen;

--
-- Name: marc_field_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.marc_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc_field_id_seq OWNER TO evergreen;

--
-- Name: marc_field_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.marc_field_id_seq OWNED BY config.marc_field.id;


--
-- Name: marc_format; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.marc_format (
    id integer NOT NULL,
    code text NOT NULL,
    name text NOT NULL
);


ALTER TABLE config.marc_format OWNER TO evergreen;

--
-- Name: TABLE marc_format; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.marc_format IS '
List of MARC formats supported by this Evergreen
database. This exists primarily as a hook for future
support of UNIMARC, though whether that will ever
happen remains to be seen.
';


--
-- Name: marc_format_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.marc_format_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc_format_id_seq OWNER TO evergreen;

--
-- Name: marc_format_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.marc_format_id_seq OWNED BY config.marc_format.id;


--
-- Name: marc_subfield_for_ou; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW config.marc_subfield_for_ou AS
 WITH RECURSIVE ou_marc_subfields(id, marc_format, marc_record_type, tag, code, description, repeatable, mandatory, hidden, value_ctype, owner, depth) AS (
         SELECT marc_subfield.id,
            marc_subfield.marc_format,
            marc_subfield.marc_record_type,
            marc_subfield.tag,
            marc_subfield.code,
            marc_subfield.description,
            marc_subfield.repeatable,
            marc_subfield.mandatory,
            marc_subfield.hidden,
            marc_subfield.value_ctype,
            marc_subfield.owner,
            0 AS "?column?"
           FROM config.marc_subfield
          WHERE (marc_subfield.owner IS NULL)
        UNION
         SELECT marc_subfield.id,
            marc_subfield.marc_format,
            marc_subfield.marc_record_type,
            marc_subfield.tag,
            marc_subfield.code,
            marc_subfield.description,
            marc_subfield.repeatable,
            marc_subfield.mandatory,
            marc_subfield.hidden,
            marc_subfield.value_ctype,
            marc_subfield.owner,
            0
           FROM config.marc_subfield
          WHERE (NOT (ARRAY[(marc_subfield.marc_format)::text, (marc_subfield.marc_record_type)::text, (marc_subfield.tag)::text, (marc_subfield.code)::text] IN ( SELECT ARRAY[(marc_subfield_1.marc_format)::text, (marc_subfield_1.marc_record_type)::text, (marc_subfield_1.tag)::text, (marc_subfield_1.code)::text] AS "array"
                   FROM config.marc_subfield marc_subfield_1
                  WHERE (marc_subfield_1.owner IS NULL))))
        UNION
         SELECT c.id,
            c.marc_format,
            c.marc_record_type,
            c.tag,
            c.code,
            COALESCE(c.description, p.description) AS "coalesce",
            COALESCE(c.repeatable, p.repeatable) AS "coalesce",
            COALESCE(c.mandatory, p.mandatory) AS "coalesce",
            COALESCE(c.hidden, p.hidden) AS "coalesce",
            COALESCE(c.value_ctype, p.value_ctype) AS "coalesce",
            c.owner,
            (p.depth + 1)
           FROM ((config.marc_subfield c
             JOIN ou_marc_subfields p USING (marc_format, marc_record_type, tag, code))
             JOIN actor.org_unit aou ON ((c.owner = aou.id)))
          WHERE ((aou.parent_ou = p.owner) OR ((aou.parent_ou IS NULL) AND (p.owner IS NULL)))
        )
 SELECT ou_marc_subfields.id,
    ou_marc_subfields.marc_format,
    ou_marc_subfields.marc_record_type,
    ou_marc_subfields.tag,
    ou_marc_subfields.code,
    ou_marc_subfields.description,
    ou_marc_subfields.repeatable,
    ou_marc_subfields.mandatory,
    ou_marc_subfields.hidden,
    ou_marc_subfields.value_ctype,
    ou_marc_subfields.owner,
    ou_marc_subfields.depth
   FROM ou_marc_subfields;


ALTER TABLE config.marc_subfield_for_ou OWNER TO evergreen;

--
-- Name: marc_subfield_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.marc_subfield_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.marc_subfield_id_seq OWNER TO evergreen;

--
-- Name: marc_subfield_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.marc_subfield_id_seq OWNED BY config.marc_subfield.id;


--
-- Name: metabib_class; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.metabib_class (
    name text NOT NULL,
    label text NOT NULL,
    restrict boolean DEFAULT false NOT NULL,
    buoyant boolean DEFAULT false NOT NULL,
    a_weight numeric DEFAULT 1.0 NOT NULL,
    b_weight numeric DEFAULT 0.4 NOT NULL,
    c_weight numeric DEFAULT 0.2 NOT NULL,
    d_weight numeric DEFAULT 0.1 NOT NULL,
    combined boolean DEFAULT false NOT NULL
);


ALTER TABLE config.metabib_class OWNER TO evergreen;

--
-- Name: metabib_class_ts_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.metabib_class_ts_map (
    id integer NOT NULL,
    field_class text NOT NULL,
    ts_config text NOT NULL,
    active boolean DEFAULT true NOT NULL,
    index_weight character(1) DEFAULT 'C'::bpchar NOT NULL,
    index_lang text,
    search_lang text,
    always boolean DEFAULT true NOT NULL,
    CONSTRAINT metabib_class_ts_map_index_weight_check CHECK ((index_weight = ANY (ARRAY['A'::bpchar, 'B'::bpchar, 'C'::bpchar, 'D'::bpchar])))
);


ALTER TABLE config.metabib_class_ts_map OWNER TO evergreen;

--
-- Name: TABLE metabib_class_ts_map; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.metabib_class_ts_map IS '
Text Search Configs for metabib class indexing

This table contains text search config definitions for
storing index_vector values.
';


--
-- Name: metabib_class_ts_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.metabib_class_ts_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_class_ts_map_id_seq OWNER TO evergreen;

--
-- Name: metabib_class_ts_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.metabib_class_ts_map_id_seq OWNED BY config.metabib_class_ts_map.id;


--
-- Name: metabib_field; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.metabib_field (
    id integer NOT NULL,
    field_class text NOT NULL,
    name text NOT NULL,
    label text NOT NULL,
    xpath text,
    weight integer DEFAULT 1 NOT NULL,
    format text DEFAULT 'mods33'::text NOT NULL,
    search_field boolean DEFAULT true NOT NULL,
    facet_field boolean DEFAULT false NOT NULL,
    facet_xpath text,
    browse_field boolean DEFAULT true NOT NULL,
    browse_xpath text,
    restrict boolean DEFAULT false NOT NULL,
    authority_xpath text,
    browse_sort_xpath text,
    joiner text,
    display_xpath text,
    display_field boolean DEFAULT false NOT NULL,
    browse_nocase boolean DEFAULT false NOT NULL
);


ALTER TABLE config.metabib_field OWNER TO evergreen;

--
-- Name: TABLE metabib_field; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.metabib_field IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * XPath used for record indexing ingest
 *
 * This table contains the XPath used to chop up MODS into its
 * indexable parts.  Each XPath entry is named and assigned to
 * a "class" of either title, subject, author, keyword or series.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: metabib_field_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.metabib_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_field_id_seq OWNER TO evergreen;

--
-- Name: metabib_field_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.metabib_field_id_seq OWNED BY config.metabib_field.id;


--
-- Name: metabib_field_index_norm_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.metabib_field_index_norm_map (
    id integer NOT NULL,
    field integer NOT NULL,
    norm integer NOT NULL,
    params text,
    pos integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.metabib_field_index_norm_map OWNER TO evergreen;

--
-- Name: metabib_field_index_norm_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.metabib_field_index_norm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_field_index_norm_map_id_seq OWNER TO evergreen;

--
-- Name: metabib_field_index_norm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.metabib_field_index_norm_map_id_seq OWNED BY config.metabib_field_index_norm_map.id;


--
-- Name: metabib_field_ts_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.metabib_field_ts_map (
    id integer NOT NULL,
    metabib_field integer NOT NULL,
    ts_config text NOT NULL,
    active boolean DEFAULT true NOT NULL,
    index_weight character(1) DEFAULT 'C'::bpchar NOT NULL,
    index_lang text,
    search_lang text,
    CONSTRAINT metabib_field_ts_map_index_weight_check CHECK ((index_weight = ANY (ARRAY['A'::bpchar, 'B'::bpchar, 'C'::bpchar, 'D'::bpchar])))
);


ALTER TABLE config.metabib_field_ts_map OWNER TO evergreen;

--
-- Name: TABLE metabib_field_ts_map; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.metabib_field_ts_map IS '
Text Search Configs for metabib field indexing

This table contains text search config definitions for
storing index_vector values.
';


--
-- Name: metabib_field_ts_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.metabib_field_ts_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_field_ts_map_id_seq OWNER TO evergreen;

--
-- Name: metabib_field_ts_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.metabib_field_ts_map_id_seq OWNED BY config.metabib_field_ts_map.id;


--
-- Name: metabib_field_virtual_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.metabib_field_virtual_map (
    id integer NOT NULL,
    "real" integer NOT NULL,
    virtual integer NOT NULL,
    weight integer DEFAULT 1 NOT NULL
);


ALTER TABLE config.metabib_field_virtual_map OWNER TO evergreen;

--
-- Name: TABLE metabib_field_virtual_map; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.metabib_field_virtual_map IS '
Maps between real (physically extracted) index definitions
and virtual (target sync, no required extraction of its own)
index definitions.

The virtual side may not extract any data of its own, but
will collect data from all of the real fields.  This reduces
extraction (ingest) overhead by eliminating duplcated extraction,
and allows for searching across novel combinations of fields, such
as names used as either subjects or authors.  By preserving this
mapping rather than defining duplicate extractions, information
about the originating, "real" index definitions can be used
in interesting ways, such as highlighting in search results.
';


--
-- Name: metabib_field_virtual_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.metabib_field_virtual_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.metabib_field_virtual_map_id_seq OWNER TO evergreen;

--
-- Name: metabib_field_virtual_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.metabib_field_virtual_map_id_seq OWNED BY config.metabib_field_virtual_map.id;


--
-- Name: metabib_search_alias; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.metabib_search_alias (
    alias text NOT NULL,
    field_class text NOT NULL,
    field integer
);


ALTER TABLE config.metabib_search_alias OWNER TO evergreen;

--
-- Name: net_access_level; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.net_access_level (
    id integer NOT NULL,
    name text NOT NULL
);


ALTER TABLE config.net_access_level OWNER TO evergreen;

--
-- Name: TABLE net_access_level; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.net_access_level IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Patron Network Access level
 *
 * This will be used to inform the in-library firewall of how much
 * internet access the using patron should be allowed.
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: net_access_level_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.net_access_level_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.net_access_level_id_seq OWNER TO evergreen;

--
-- Name: net_access_level_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.net_access_level_id_seq OWNED BY config.net_access_level.id;


--
-- Name: non_cataloged_type_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.non_cataloged_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.non_cataloged_type_id_seq OWNER TO evergreen;

--
-- Name: non_cataloged_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.non_cataloged_type_id_seq OWNED BY config.non_cataloged_type.id;


--
-- Name: org_unit_setting_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.org_unit_setting_type (
    name text NOT NULL,
    label text NOT NULL,
    description text,
    datatype text DEFAULT 'string'::text NOT NULL,
    fm_class text,
    view_perm integer,
    update_perm integer,
    grp text,
    CONSTRAINT coust_no_empty_link CHECK ((((datatype = 'link'::text) AND (fm_class IS NOT NULL)) OR ((datatype <> 'link'::text) AND (fm_class IS NULL)))),
    CONSTRAINT coust_valid_datatype CHECK ((datatype = ANY (ARRAY['bool'::text, 'integer'::text, 'float'::text, 'currency'::text, 'interval'::text, 'date'::text, 'string'::text, 'object'::text, 'array'::text, 'link'::text])))
);


ALTER TABLE config.org_unit_setting_type OWNER TO evergreen;

--
-- Name: org_unit_setting_type_log; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.org_unit_setting_type_log (
    id bigint NOT NULL,
    date_applied timestamp with time zone DEFAULT now() NOT NULL,
    org integer,
    original_value text,
    new_value text,
    field_name text
);


ALTER TABLE config.org_unit_setting_type_log OWNER TO evergreen;

--
-- Name: org_unit_setting_type_log_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.org_unit_setting_type_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.org_unit_setting_type_log_id_seq OWNER TO evergreen;

--
-- Name: org_unit_setting_type_log_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.org_unit_setting_type_log_id_seq OWNED BY config.org_unit_setting_type_log.id;


--
-- Name: patron_message; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.patron_message (
    id integer NOT NULL,
    message text NOT NULL,
    weight integer DEFAULT 0
);


ALTER TABLE config.patron_message OWNER TO evergreen;

--
-- Name: patron_message_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.patron_message_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.patron_message_id_seq OWNER TO evergreen;

--
-- Name: patron_message_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.patron_message_id_seq OWNED BY config.patron_message.id;


--
-- Name: print_template; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.print_template (
    id integer NOT NULL,
    name text NOT NULL,
    label text NOT NULL,
    owner integer NOT NULL,
    active boolean DEFAULT false NOT NULL,
    locale text,
    content_type text DEFAULT 'text/html'::text NOT NULL,
    template text NOT NULL
);


ALTER TABLE config.print_template OWNER TO evergreen;

--
-- Name: print_template_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.print_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.print_template_id_seq OWNER TO evergreen;

--
-- Name: print_template_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.print_template_id_seq OWNED BY config.print_template.id;


--
-- Name: record_attr_definition; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.record_attr_definition (
    name text NOT NULL,
    label text NOT NULL,
    description text,
    filter boolean DEFAULT true NOT NULL,
    sorter boolean DEFAULT false NOT NULL,
    tag text,
    sf_list text,
    joiner text,
    xpath text,
    format text,
    start_pos integer,
    string_len integer,
    fixed_field text,
    phys_char_sf integer,
    multi boolean DEFAULT true NOT NULL,
    composite boolean DEFAULT false NOT NULL,
    vocabulary text
);


ALTER TABLE config.record_attr_definition OWNER TO evergreen;

--
-- Name: record_attr_index_norm_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.record_attr_index_norm_map (
    id integer NOT NULL,
    attr text NOT NULL,
    norm integer NOT NULL,
    params text,
    pos integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.record_attr_index_norm_map OWNER TO evergreen;

--
-- Name: record_attr_index_norm_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.record_attr_index_norm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.record_attr_index_norm_map_id_seq OWNER TO evergreen;

--
-- Name: record_attr_index_norm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.record_attr_index_norm_map_id_seq OWNED BY config.record_attr_index_norm_map.id;


--
-- Name: remoteauth_profile; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.remoteauth_profile (
    name text NOT NULL,
    description text,
    context_org integer NOT NULL,
    enabled boolean DEFAULT false NOT NULL,
    perm integer NOT NULL,
    restrict_to_org boolean DEFAULT true NOT NULL,
    allow_inactive boolean DEFAULT false NOT NULL,
    allow_expired boolean DEFAULT false NOT NULL,
    block_list text,
    usr_activity_type integer
);


ALTER TABLE config.remoteauth_profile OWNER TO evergreen;

--
-- Name: rule_age_hold_protect; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.rule_age_hold_protect (
    id integer NOT NULL,
    name text NOT NULL,
    age interval NOT NULL,
    prox integer NOT NULL,
    CONSTRAINT rule_age_hold_protect_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_age_hold_protect OWNER TO evergreen;

--
-- Name: TABLE rule_age_hold_protect; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.rule_age_hold_protect IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Hold Item Age Protection rules
 *
 * A hold request can only capture new(ish) items when they are
 * within a particular proximity of the home_ou of the requesting
 * user.  The proximity (''prox'' column) is calculated by counting
 * the number of tree edges between the user''s home_ou and the owning_lib
 * of the copy that could fulfill the hold.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: rule_age_hold_protect_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.rule_age_hold_protect_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_age_hold_protect_id_seq OWNER TO evergreen;

--
-- Name: rule_age_hold_protect_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.rule_age_hold_protect_id_seq OWNED BY config.rule_age_hold_protect.id;


--
-- Name: rule_circ_duration; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.rule_circ_duration (
    id integer NOT NULL,
    name text NOT NULL,
    extended interval NOT NULL,
    normal interval NOT NULL,
    shrt interval NOT NULL,
    max_renewals integer NOT NULL,
    max_auto_renewals integer,
    CONSTRAINT rule_circ_duration_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_circ_duration OWNER TO evergreen;

--
-- Name: TABLE rule_circ_duration; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.rule_circ_duration IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Circulation Duration rules
 *
 * Each circulation is given a duration based on one of these rules.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: rule_circ_duration_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.rule_circ_duration_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_circ_duration_id_seq OWNER TO evergreen;

--
-- Name: rule_circ_duration_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.rule_circ_duration_id_seq OWNED BY config.rule_circ_duration.id;


--
-- Name: rule_max_fine; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.rule_max_fine (
    id integer NOT NULL,
    name text NOT NULL,
    amount numeric(6,2) NOT NULL,
    is_percent boolean DEFAULT false NOT NULL,
    CONSTRAINT rule_max_fine_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_max_fine OWNER TO evergreen;

--
-- Name: TABLE rule_max_fine; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.rule_max_fine IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Circulation Max Fine rules
 *
 * Each circulation is given a maximum fine based on one of
 * these rules.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: rule_max_fine_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.rule_max_fine_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_max_fine_id_seq OWNER TO evergreen;

--
-- Name: rule_max_fine_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.rule_max_fine_id_seq OWNED BY config.rule_max_fine.id;


--
-- Name: rule_recurring_fine; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.rule_recurring_fine (
    id integer NOT NULL,
    name text NOT NULL,
    high numeric(6,2) NOT NULL,
    normal numeric(6,2) NOT NULL,
    low numeric(6,2) NOT NULL,
    recurrence_interval interval DEFAULT '1 day'::interval NOT NULL,
    grace_period interval DEFAULT '1 day'::interval NOT NULL,
    CONSTRAINT rule_recurring_fine_name_check CHECK ((name ~ '^\w+$'::text))
);


ALTER TABLE config.rule_recurring_fine OWNER TO evergreen;

--
-- Name: TABLE rule_recurring_fine; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.rule_recurring_fine IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Circulation Recurring Fine rules
 *
 * Each circulation is given a recurring fine amount based on one of
 * these rules.  The recurrence_interval should not be any shorter
 * than the interval between runs of the fine_processor.pl script
 * (which is run from CRON), or you could miss fines.
 * 
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: rule_recurring_fine_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.rule_recurring_fine_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.rule_recurring_fine_id_seq OWNER TO evergreen;

--
-- Name: rule_recurring_fine_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.rule_recurring_fine_id_seq OWNED BY config.rule_recurring_fine.id;


--
-- Name: settings_group; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.settings_group (
    name text NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.settings_group OWNER TO evergreen;

--
-- Name: sms_carrier; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.sms_carrier (
    id integer NOT NULL,
    region text,
    name text,
    email_gateway text,
    active boolean DEFAULT true
);


ALTER TABLE config.sms_carrier OWNER TO evergreen;

--
-- Name: sms_carrier_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.sms_carrier_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.sms_carrier_id_seq OWNER TO evergreen;

--
-- Name: sms_carrier_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.sms_carrier_id_seq OWNED BY config.sms_carrier.id;


--
-- Name: standing; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.standing (
    id integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE config.standing OWNER TO evergreen;

--
-- Name: TABLE standing; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.standing IS '
/*
 * Copyright (C) 2005  Georgia Public Library Service 
 * Mike Rylander <mrylander@gmail.com>
 *
 * Patron Standings
 *
 * This table contains the values that can be applied to a patron
 * by a staff member.  These values should not be changed, other
 * than for translation, as the ID column is currently a "magic
 * number" in the source. :(
 *
 * ****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
';


--
-- Name: standing_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.standing_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.standing_id_seq OWNER TO evergreen;

--
-- Name: standing_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.standing_id_seq OWNED BY config.standing.id;


--
-- Name: standing_penalty; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.standing_penalty (
    id integer NOT NULL,
    name text NOT NULL,
    label text NOT NULL,
    block_list text,
    org_depth integer,
    staff_alert boolean DEFAULT false NOT NULL,
    ignore_proximity integer
);


ALTER TABLE config.standing_penalty OWNER TO evergreen;

--
-- Name: standing_penalty_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.standing_penalty_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.standing_penalty_id_seq OWNER TO evergreen;

--
-- Name: standing_penalty_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.standing_penalty_id_seq OWNED BY config.standing_penalty.id;


--
-- Name: ts_config_list; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.ts_config_list (
    id text NOT NULL,
    name text NOT NULL
);


ALTER TABLE config.ts_config_list OWNER TO evergreen;

--
-- Name: TABLE ts_config_list; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.ts_config_list IS '
Full Text Configs

A list of full text configs with names and descriptions.
';


--
-- Name: ui_staff_portal_page_entry; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.ui_staff_portal_page_entry (
    id integer NOT NULL,
    page_col integer NOT NULL,
    col_pos integer NOT NULL,
    entry_type text NOT NULL,
    label text,
    image_url text,
    target_url text,
    entry_text text,
    owner integer NOT NULL
);


ALTER TABLE config.ui_staff_portal_page_entry OWNER TO evergreen;

--
-- Name: ui_staff_portal_page_entry_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.ui_staff_portal_page_entry_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.ui_staff_portal_page_entry_id_seq OWNER TO evergreen;

--
-- Name: ui_staff_portal_page_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.ui_staff_portal_page_entry_id_seq OWNED BY config.ui_staff_portal_page_entry.id;


--
-- Name: ui_staff_portal_page_entry_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.ui_staff_portal_page_entry_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE config.ui_staff_portal_page_entry_type OWNER TO evergreen;

--
-- Name: upgrade_log; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.upgrade_log (
    version text NOT NULL,
    install_date timestamp with time zone DEFAULT now() NOT NULL,
    applied_to text
);


ALTER TABLE config.upgrade_log OWNER TO evergreen;

--
-- Name: usr_activity_type_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.usr_activity_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.usr_activity_type_id_seq OWNER TO evergreen;

--
-- Name: usr_activity_type_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.usr_activity_type_id_seq OWNED BY config.usr_activity_type.id;


--
-- Name: usr_setting_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.usr_setting_type (
    name text NOT NULL,
    opac_visible boolean DEFAULT false NOT NULL,
    label text NOT NULL,
    description text,
    datatype text DEFAULT 'string'::text NOT NULL,
    fm_class text,
    grp text,
    reg_default text,
    CONSTRAINT coust_no_empty_link CHECK ((((datatype = 'link'::text) AND (fm_class IS NOT NULL)) OR ((datatype <> 'link'::text) AND (fm_class IS NULL)))),
    CONSTRAINT coust_valid_datatype CHECK ((datatype = ANY (ARRAY['bool'::text, 'integer'::text, 'float'::text, 'currency'::text, 'interval'::text, 'date'::text, 'string'::text, 'object'::text, 'array'::text, 'link'::text])))
);


ALTER TABLE config.usr_setting_type OWNER TO evergreen;

--
-- Name: videorecording_format_map; Type: VIEW; Schema: config; Owner: evergreen
--

CREATE VIEW config.videorecording_format_map AS
 SELECT coded_value_map.code,
    coded_value_map.value
   FROM config.coded_value_map
  WHERE (coded_value_map.ctype = 'vr_format'::text);


ALTER TABLE config.videorecording_format_map OWNER TO evergreen;

--
-- Name: weight_assoc; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.weight_assoc (
    id integer NOT NULL,
    active boolean NOT NULL,
    org_unit integer NOT NULL,
    circ_weights integer,
    hold_weights integer
);


ALTER TABLE config.weight_assoc OWNER TO evergreen;

--
-- Name: weight_assoc_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.weight_assoc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.weight_assoc_id_seq OWNER TO evergreen;

--
-- Name: weight_assoc_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.weight_assoc_id_seq OWNED BY config.weight_assoc.id;


--
-- Name: workstation_setting_type; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.workstation_setting_type (
    name text NOT NULL,
    label text NOT NULL,
    grp text,
    description text,
    datatype text DEFAULT 'string'::text NOT NULL,
    fm_class text,
    CONSTRAINT cwst_no_empty_link CHECK ((((datatype = 'link'::text) AND (fm_class IS NOT NULL)) OR ((datatype <> 'link'::text) AND (fm_class IS NULL)))),
    CONSTRAINT cwst_valid_datatype CHECK ((datatype = ANY (ARRAY['bool'::text, 'integer'::text, 'float'::text, 'currency'::text, 'interval'::text, 'date'::text, 'string'::text, 'object'::text, 'array'::text, 'link'::text])))
);


ALTER TABLE config.workstation_setting_type OWNER TO evergreen;

--
-- Name: xml_transform; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.xml_transform (
    name text NOT NULL,
    namespace_uri text NOT NULL,
    prefix text NOT NULL,
    xslt text NOT NULL
);


ALTER TABLE config.xml_transform OWNER TO evergreen;

--
-- Name: xml_transform_back; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.xml_transform_back (
    name text,
    namespace_uri text,
    prefix text,
    xslt text
);


ALTER TABLE config.xml_transform_back OWNER TO evergreen;

--
-- Name: z3950_attr; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.z3950_attr (
    id integer NOT NULL,
    source text NOT NULL,
    name text NOT NULL,
    label text NOT NULL,
    code integer NOT NULL,
    format integer NOT NULL,
    truncation integer DEFAULT 0 NOT NULL
);


ALTER TABLE config.z3950_attr OWNER TO evergreen;

--
-- Name: z3950_attr_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.z3950_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.z3950_attr_id_seq OWNER TO evergreen;

--
-- Name: z3950_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.z3950_attr_id_seq OWNED BY config.z3950_attr.id;


--
-- Name: z3950_index_field_map; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.z3950_index_field_map (
    id integer NOT NULL,
    label text NOT NULL,
    metabib_field integer,
    record_attr text,
    z3950_attr integer,
    z3950_attr_type text,
    CONSTRAINT attr_or_attr_type CHECK (((z3950_attr IS NOT NULL) OR (z3950_attr_type IS NOT NULL))),
    CONSTRAINT metabib_field_or_record_attr CHECK (((metabib_field IS NOT NULL) OR (record_attr IS NOT NULL)))
);


ALTER TABLE config.z3950_index_field_map OWNER TO evergreen;

--
-- Name: z3950_index_field_map_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.z3950_index_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.z3950_index_field_map_id_seq OWNER TO evergreen;

--
-- Name: z3950_index_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.z3950_index_field_map_id_seq OWNED BY config.z3950_index_field_map.id;


--
-- Name: z3950_source; Type: TABLE; Schema: config; Owner: evergreen
--

CREATE TABLE config.z3950_source (
    name text NOT NULL,
    label text NOT NULL,
    host text NOT NULL,
    port integer NOT NULL,
    db text NOT NULL,
    record_format text DEFAULT 'FI'::text NOT NULL,
    transmission_format text DEFAULT 'usmarc'::text NOT NULL,
    auth boolean DEFAULT true NOT NULL,
    use_perm integer
);


ALTER TABLE config.z3950_source OWNER TO evergreen;

--
-- Name: TABLE z3950_source; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON TABLE config.z3950_source IS '
Z39.50 Sources

Each row in this table represents a database searchable via Z39.50.
';


--
-- Name: COLUMN z3950_source.record_format; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON COLUMN config.z3950_source.record_format IS '
Z39.50 element set.
';


--
-- Name: COLUMN z3950_source.transmission_format; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON COLUMN config.z3950_source.transmission_format IS '
Z39.50 preferred record syntax..
';


--
-- Name: COLUMN z3950_source.use_perm; Type: COMMENT; Schema: config; Owner: evergreen
--

COMMENT ON COLUMN config.z3950_source.use_perm IS '
If set, this permission is required for the source to be listed in the staff
client Z39.50 interface.  Similar to permission.grp_tree.application_perm.
';


--
-- Name: z3950_source_credentials_id_seq; Type: SEQUENCE; Schema: config; Owner: evergreen
--

CREATE SEQUENCE config.z3950_source_credentials_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE config.z3950_source_credentials_id_seq OWNER TO evergreen;

--
-- Name: z3950_source_credentials_id_seq; Type: SEQUENCE OWNED BY; Schema: config; Owner: evergreen
--

ALTER SEQUENCE config.z3950_source_credentials_id_seq OWNED BY config.z3950_source_credentials.id;


--
-- Name: biblio_record_entry_bucket; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.biblio_record_entry_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    description text,
    owning_lib integer
);


ALTER TABLE container.biblio_record_entry_bucket OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.biblio_record_entry_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_id_seq OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.biblio_record_entry_bucket_id_seq OWNED BY container.biblio_record_entry_bucket.id;


--
-- Name: biblio_record_entry_bucket_item; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.biblio_record_entry_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_biblio_record_entry bigint NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_item OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.biblio_record_entry_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_item_id_seq OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.biblio_record_entry_bucket_item_id_seq OWNED BY container.biblio_record_entry_bucket_item.id;


--
-- Name: biblio_record_entry_bucket_item_note; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.biblio_record_entry_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_item_note OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.biblio_record_entry_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_item_note_id_seq OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.biblio_record_entry_bucket_item_note_id_seq OWNED BY container.biblio_record_entry_bucket_item_note.id;


--
-- Name: biblio_record_entry_bucket_note; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.biblio_record_entry_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_note OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.biblio_record_entry_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.biblio_record_entry_bucket_note_id_seq OWNER TO evergreen;

--
-- Name: biblio_record_entry_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.biblio_record_entry_bucket_note_id_seq OWNED BY container.biblio_record_entry_bucket_note.id;


--
-- Name: biblio_record_entry_bucket_type; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.biblio_record_entry_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.biblio_record_entry_bucket_type OWNER TO evergreen;

--
-- Name: call_number_bucket; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.call_number_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    description text,
    owning_lib integer
);


ALTER TABLE container.call_number_bucket OWNER TO evergreen;

--
-- Name: call_number_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.call_number_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_id_seq OWNER TO evergreen;

--
-- Name: call_number_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.call_number_bucket_id_seq OWNED BY container.call_number_bucket.id;


--
-- Name: call_number_bucket_item; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.call_number_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_call_number integer NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.call_number_bucket_item OWNER TO evergreen;

--
-- Name: call_number_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.call_number_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_item_id_seq OWNER TO evergreen;

--
-- Name: call_number_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.call_number_bucket_item_id_seq OWNED BY container.call_number_bucket_item.id;


--
-- Name: call_number_bucket_item_note; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.call_number_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.call_number_bucket_item_note OWNER TO evergreen;

--
-- Name: call_number_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.call_number_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_item_note_id_seq OWNER TO evergreen;

--
-- Name: call_number_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.call_number_bucket_item_note_id_seq OWNED BY container.call_number_bucket_item_note.id;


--
-- Name: call_number_bucket_note; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.call_number_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.call_number_bucket_note OWNER TO evergreen;

--
-- Name: call_number_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.call_number_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.call_number_bucket_note_id_seq OWNER TO evergreen;

--
-- Name: call_number_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.call_number_bucket_note_id_seq OWNED BY container.call_number_bucket_note.id;


--
-- Name: call_number_bucket_type; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.call_number_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.call_number_bucket_type OWNER TO evergreen;

--
-- Name: carousel; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.carousel (
    id integer NOT NULL,
    type integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    bucket integer,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    edit_time timestamp with time zone DEFAULT now() NOT NULL,
    age_filter interval,
    owning_lib_filter integer[],
    copy_location_filter integer[],
    last_refresh_time timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    max_items integer NOT NULL
);


ALTER TABLE container.carousel OWNER TO evergreen;

--
-- Name: carousel_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.carousel_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.carousel_id_seq OWNER TO evergreen;

--
-- Name: carousel_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.carousel_id_seq OWNED BY container.carousel.id;


--
-- Name: carousel_org_unit; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.carousel_org_unit (
    id integer NOT NULL,
    carousel integer NOT NULL,
    override_name text,
    org_unit integer NOT NULL,
    seq integer NOT NULL
);


ALTER TABLE container.carousel_org_unit OWNER TO evergreen;

--
-- Name: carousel_org_unit_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.carousel_org_unit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.carousel_org_unit_id_seq OWNER TO evergreen;

--
-- Name: carousel_org_unit_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.carousel_org_unit_id_seq OWNED BY container.carousel_org_unit.id;


--
-- Name: copy_bucket; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.copy_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    description text,
    owning_lib integer
);


ALTER TABLE container.copy_bucket OWNER TO evergreen;

--
-- Name: copy_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.copy_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_id_seq OWNER TO evergreen;

--
-- Name: copy_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.copy_bucket_id_seq OWNED BY container.copy_bucket.id;


--
-- Name: copy_bucket_item; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.copy_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_copy integer NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.copy_bucket_item OWNER TO evergreen;

--
-- Name: copy_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.copy_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_item_id_seq OWNER TO evergreen;

--
-- Name: copy_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.copy_bucket_item_id_seq OWNED BY container.copy_bucket_item.id;


--
-- Name: copy_bucket_item_note; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.copy_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.copy_bucket_item_note OWNER TO evergreen;

--
-- Name: copy_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.copy_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_item_note_id_seq OWNER TO evergreen;

--
-- Name: copy_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.copy_bucket_item_note_id_seq OWNED BY container.copy_bucket_item_note.id;


--
-- Name: copy_bucket_note; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.copy_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.copy_bucket_note OWNER TO evergreen;

--
-- Name: copy_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.copy_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.copy_bucket_note_id_seq OWNER TO evergreen;

--
-- Name: copy_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.copy_bucket_note_id_seq OWNED BY container.copy_bucket_note.id;


--
-- Name: copy_bucket_type; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.copy_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.copy_bucket_type OWNER TO evergreen;

--
-- Name: user_bucket; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.user_bucket (
    id integer NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    btype text DEFAULT 'misc'::text NOT NULL,
    pub boolean DEFAULT false NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    description text,
    owning_lib integer
);


ALTER TABLE container.user_bucket OWNER TO evergreen;

--
-- Name: user_bucket_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.user_bucket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_id_seq OWNER TO evergreen;

--
-- Name: user_bucket_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.user_bucket_id_seq OWNED BY container.user_bucket.id;


--
-- Name: user_bucket_item; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.user_bucket_item (
    id integer NOT NULL,
    bucket integer NOT NULL,
    target_user integer NOT NULL,
    pos integer,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE container.user_bucket_item OWNER TO evergreen;

--
-- Name: user_bucket_item_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.user_bucket_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_item_id_seq OWNER TO evergreen;

--
-- Name: user_bucket_item_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.user_bucket_item_id_seq OWNED BY container.user_bucket_item.id;


--
-- Name: user_bucket_item_note; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.user_bucket_item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.user_bucket_item_note OWNER TO evergreen;

--
-- Name: user_bucket_item_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.user_bucket_item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_item_note_id_seq OWNER TO evergreen;

--
-- Name: user_bucket_item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.user_bucket_item_note_id_seq OWNED BY container.user_bucket_item_note.id;


--
-- Name: user_bucket_note; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.user_bucket_note (
    id integer NOT NULL,
    bucket integer NOT NULL,
    note text NOT NULL
);


ALTER TABLE container.user_bucket_note OWNER TO evergreen;

--
-- Name: user_bucket_note_id_seq; Type: SEQUENCE; Schema: container; Owner: evergreen
--

CREATE SEQUENCE container.user_bucket_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE container.user_bucket_note_id_seq OWNER TO evergreen;

--
-- Name: user_bucket_note_id_seq; Type: SEQUENCE OWNED BY; Schema: container; Owner: evergreen
--

ALTER SEQUENCE container.user_bucket_note_id_seq OWNED BY container.user_bucket_note.id;


--
-- Name: user_bucket_type; Type: TABLE; Schema: container; Owner: evergreen
--

CREATE TABLE container.user_bucket_type (
    code text NOT NULL,
    label text NOT NULL
);


ALTER TABLE container.user_bucket_type OWNER TO evergreen;

--
-- Name: cluster; Type: TABLE; Schema: elastic; Owner: evergreen
--

CREATE TABLE elastic.cluster (
    code text DEFAULT 'main'::text NOT NULL,
    label text NOT NULL
);


ALTER TABLE elastic.cluster OWNER TO evergreen;

--
-- Name: node; Type: TABLE; Schema: elastic; Owner: evergreen
--

CREATE TABLE elastic.node (
    id integer NOT NULL,
    label text NOT NULL,
    host text NOT NULL,
    proto text NOT NULL,
    port integer NOT NULL,
    path text DEFAULT '/'::text NOT NULL,
    active boolean DEFAULT false NOT NULL,
    cluster text NOT NULL
);


ALTER TABLE elastic.node OWNER TO evergreen;

--
-- Name: node_id_seq; Type: SEQUENCE; Schema: elastic; Owner: evergreen
--

CREATE SEQUENCE elastic.node_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE elastic.node_id_seq OWNER TO evergreen;

--
-- Name: node_id_seq; Type: SEQUENCE OWNED BY; Schema: elastic; Owner: evergreen
--

ALTER SEQUENCE elastic.node_id_seq OWNED BY elastic.node.id;


--
-- Name: users_made_no_access; Type: TABLE; Schema: envisionware; Owner: evergreen
--

CREATE TABLE envisionware.users_made_no_access (
    id integer,
    original_net_access_level integer,
    date_changed timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE envisionware.users_made_no_access OWNER TO evergreen;

--
-- Name: action_circulation_hs22978; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.action_circulation_hs22978 (
    id bigint,
    usr integer,
    xact_start timestamp with time zone,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone,
    duration interval,
    fine_interval interval,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean,
    desk_renewal boolean,
    opac_renewal boolean,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval,
    copy_location integer
);


ALTER TABLE esi.action_circulation_hs22978 OWNER TO evergreen;

--
-- Name: backroom_items; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.backroom_items (
    barcode text,
    id bigint,
    status integer
);


ALTER TABLE esi.backroom_items OWNER TO evergreen;

--
-- Name: bad_hold_transit_copy; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.bad_hold_transit_copy (
    id integer,
    source_send_time timestamp with time zone,
    dest_recv_time timestamp with time zone,
    target_copy bigint,
    source integer,
    dest integer,
    prev_hop integer,
    copy_status integer,
    persistant_transfer boolean,
    prev_dest integer,
    hold integer
);


ALTER TABLE esi.bad_hold_transit_copy OWNER TO evergreen;

--
-- Name: bibs_to_reingest_hs21524; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.bibs_to_reingest_hs21524 (
    id bigint
);


ALTER TABLE esi.bibs_to_reingest_hs21524 OWNER TO evergreen;

--
-- Name: bibstodelete19187; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.bibstodelete19187 (
    record bigint,
    tag character(3),
    count bigint,
    title text,
    author text,
    isbn text[],
    value text
);


ALTER TABLE esi.bibstodelete19187 OWNER TO evergreen;

--
-- Name: chartest; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.chartest (
    marc text
);


ALTER TABLE esi.chartest OWNER TO evergreen;

--
-- Name: cleanupvolumes1; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.cleanupvolumes1 (
    volume_id bigint
);


ALTER TABLE esi.cleanupvolumes1 OWNER TO evergreen;

--
-- Name: cleanupvolumes18552; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.cleanupvolumes18552 (
    volume_id bigint
);


ALTER TABLE esi.cleanupvolumes18552 OWNER TO evergreen;

--
-- Name: cleanupvolumes2; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.cleanupvolumes2 (
    volume_id bigint
);


ALTER TABLE esi.cleanupvolumes2 OWNER TO evergreen;

--
-- Name: deletedfunds18487; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.deletedfunds18487 (
    id integer,
    fund integer,
    origin_amount numeric,
    origin_currency_type text,
    amount numeric,
    encumbrance boolean,
    debit_type text,
    xfer_destination integer,
    create_time timestamp with time zone
);


ALTER TABLE esi.deletedfunds18487 OWNER TO evergreen;

--
-- Name: fundstodelete; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.fundstodelete (
    id integer
);


ALTER TABLE esi.fundstodelete OWNER TO evergreen;

--
-- Name: fundstodelete2; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.fundstodelete2 (
    id integer,
    fund integer,
    origin_amount numeric,
    origin_currency_type text,
    amount numeric,
    encumbrance boolean,
    debit_type text,
    xfer_destination integer,
    create_time timestamp with time zone
);


ALTER TABLE esi.fundstodelete2 OWNER TO evergreen;

--
-- Name: headings; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.headings (
    id integer
);


ALTER TABLE esi.headings OWNER TO evergreen;

--
-- Name: hold_request_hs20783; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.hold_request_hs20783 (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE esi.hold_request_hs20783 OWNER TO evergreen;

--
-- Name: hold_request_hs20783_2nd_file; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.hold_request_hs20783_2nd_file (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE esi.hold_request_hs20783_2nd_file OWNER TO evergreen;

--
-- Name: hs17295_edi_message; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.hs17295_edi_message (
    id integer,
    account integer,
    remote_file text,
    create_time timestamp with time zone,
    translate_time timestamp with time zone,
    process_time timestamp with time zone,
    error_time timestamp with time zone,
    status text,
    edi text,
    jedi text,
    error text,
    purchase_order integer,
    message_type text
);


ALTER TABLE esi.hs17295_edi_message OWNER TO evergreen;

--
-- Name: needsoverduephone; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.needsoverduephone (
    id integer
);


ALTER TABLE esi.needsoverduephone OWNER TO evergreen;

--
-- Name: offline_script_hs20920; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.offline_script_hs20920 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE esi.offline_script_hs20920 OWNER TO evergreen;

--
-- Name: offline_session_hs20920; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.offline_session_hs20920 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE esi.offline_session_hs20920 OWNER TO evergreen;

--
-- Name: old_notice_events; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.old_notice_events (
    id bigint,
    target bigint,
    event_def integer,
    add_time timestamp with time zone,
    run_time timestamp with time zone,
    start_time timestamp with time zone,
    update_time timestamp with time zone,
    complete_time timestamp with time zone,
    update_process integer,
    state text,
    user_data text,
    template_output bigint,
    error_output bigint,
    async_output bigint
);


ALTER TABLE esi.old_notice_events OWNER TO evergreen;

--
-- Name: phasefx16756_xacts; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.phasefx16756_xacts (
    id bigint
);


ALTER TABLE esi.phasefx16756_xacts OWNER TO evergreen;

--
-- Name: saved_inactive_patron_cards; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.saved_inactive_patron_cards (
    id integer,
    usr integer,
    barcode text,
    active boolean
);


ALTER TABLE esi.saved_inactive_patron_cards OWNER TO evergreen;

--
-- Name: statuschange17802; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.statuschange17802 (
    id bigint,
    status integer
);


ALTER TABLE esi.statuschange17802 OWNER TO evergreen;

--
-- Name: steve092711oldholdnotices; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steve092711oldholdnotices (
    id bigint,
    target bigint,
    event_def integer,
    add_time timestamp with time zone,
    run_time timestamp with time zone,
    start_time timestamp with time zone,
    update_time timestamp with time zone,
    complete_time timestamp with time zone,
    update_process integer,
    state text,
    user_data text,
    template_output bigint,
    error_output bigint,
    async_output bigint
);


ALTER TABLE esi.steve092711oldholdnotices OWNER TO evergreen;

--
-- Name: steve17090funddebit; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steve17090funddebit (
    id integer,
    fund integer,
    origin_amount numeric,
    origin_currency_type text,
    amount numeric,
    encumbrance boolean,
    debit_type text,
    xfer_destination integer,
    create_time timestamp with time zone
);


ALTER TABLE esi.steve17090funddebit OWNER TO evergreen;

--
-- Name: steve17090lineitems; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steve17090lineitems (
    id bigint,
    creator integer,
    editor integer,
    selector integer,
    provider integer,
    purchase_order integer,
    picklist integer,
    expected_recv_time timestamp with time zone,
    create_time timestamp with time zone,
    edit_time timestamp with time zone,
    marc text,
    eg_bib_id bigint,
    source_label text,
    state text,
    cancel_reason integer,
    estimated_unit_price numeric,
    claim_policy integer
);


ALTER TABLE esi.steve17090lineitems OWNER TO evergreen;

--
-- Name: steve17090lineitemsdetails; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steve17090lineitemsdetails (
    id bigint,
    lineitem integer,
    fund integer,
    fund_debit integer,
    eg_copy_id bigint,
    barcode text,
    cn_label text,
    note text,
    collection_code text,
    circ_modifier text,
    owning_lib integer,
    location integer,
    recv_time timestamp with time zone,
    cancel_reason integer
);


ALTER TABLE esi.steve17090lineitemsdetails OWNER TO evergreen;

--
-- Name: steve2371665holds; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steve2371665holds (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE esi.steve2371665holds OWNER TO evergreen;

--
-- Name: steve2759532holds; Type: TABLE; Schema: esi; Owner: postgres
--

CREATE TABLE esi.steve2759532holds (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE esi.steve2759532holds OWNER TO postgres;

--
-- Name: steve_reshelving_fix18027; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steve_reshelving_fix18027 (
    id bigint
);


ALTER TABLE esi.steve_reshelving_fix18027 OWNER TO evergreen;

--
-- Name: steve_reshelving_fix180271; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steve_reshelving_fix180271 (
    id bigint
);


ALTER TABLE esi.steve_reshelving_fix180271 OWNER TO evergreen;

--
-- Name: steveacqedimessagebackup18700; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveacqedimessagebackup18700 (
    id integer,
    account integer,
    remote_file text,
    create_time timestamp with time zone,
    translate_time timestamp with time zone,
    process_time timestamp with time zone,
    error_time timestamp with time zone,
    status text,
    edi text,
    jedi text,
    error text,
    purchase_order integer,
    message_type text
);


ALTER TABLE esi.steveacqedimessagebackup18700 OWNER TO evergreen;

--
-- Name: steveaction_collector; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveaction_collector (
    module text,
    description text
);


ALTER TABLE esi.steveaction_collector OWNER TO evergreen;

--
-- Name: steveaction_def; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveaction_def (
    id integer,
    active boolean,
    owner integer,
    name text,
    hook text,
    validator text,
    reactor text,
    cleanup_success text,
    cleanup_failure text,
    delay interval,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text
);


ALTER TABLE esi.steveaction_def OWNER TO evergreen;

--
-- Name: steveaction_environment; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveaction_environment (
    id integer,
    event_def integer,
    path text,
    collector text,
    label text
);


ALTER TABLE esi.steveaction_environment OWNER TO evergreen;

--
-- Name: steveaction_hook; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveaction_hook (
    key text,
    core_type text,
    description text,
    passive boolean
);


ALTER TABLE esi.steveaction_hook OWNER TO evergreen;

--
-- Name: steveaction_params; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveaction_params (
    id bigint,
    event_def integer,
    param text,
    value text
);


ALTER TABLE esi.steveaction_params OWNER TO evergreen;

--
-- Name: steveaction_reactor; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveaction_reactor (
    module text,
    description text
);


ALTER TABLE esi.steveaction_reactor OWNER TO evergreen;

--
-- Name: steveaction_validator; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveaction_validator (
    module text,
    description text
);


ALTER TABLE esi.steveaction_validator OWNER TO evergreen;

--
-- Name: stevebackupdef23; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevebackupdef23 (
    id integer,
    active boolean,
    owner integer,
    name text,
    hook text,
    validator text,
    reactor text,
    cleanup_success text,
    cleanup_failure text,
    delay interval,
    max_delay interval,
    usr_field text,
    opt_in_setting text,
    delay_field text,
    group_field text,
    template text,
    granularity text
);


ALTER TABLE esi.stevebackupdef23 OWNER TO evergreen;

--
-- Name: stevecheckingvolumes; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevecheckingvolumes (
    volume_id bigint
);


ALTER TABLE esi.stevecheckingvolumes OWNER TO evergreen;

--
-- Name: stevecheckmissing; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevecheckmissing (
    id bigint,
    max timestamp with time zone,
    deleted boolean
);


ALTER TABLE esi.stevecheckmissing OWNER TO evergreen;

--
-- Name: stevecheckreshelv; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevecheckreshelv (
    id bigint,
    "Max Checkin Time" timestamp with time zone,
    "Max Dest Time" timestamp with time zone
);


ALTER TABLE esi.stevecheckreshelv OWNER TO evergreen;

--
-- Name: stevecopydelete; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevecopydelete (
    id bigint
);


ALTER TABLE esi.stevecopydelete OWNER TO evergreen;

--
-- Name: steveholdprintingorig; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveholdprintingorig (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveholdprintingorig OWNER TO evergreen;

--
-- Name: steveholdprintingorigtakeone; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveholdprintingorigtakeone (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveholdprintingorigtakeone OWNER TO evergreen;

--
-- Name: steveholdprintingorigtakethree; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveholdprintingorigtakethree (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveholdprintingorigtakethree OWNER TO evergreen;

--
-- Name: steveholdprintingorigtaketwo; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveholdprintingorigtaketwo (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveholdprintingorigtaketwo OWNER TO evergreen;

--
-- Name: steveholdprintingorigtesting; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveholdprintingorigtesting (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveholdprintingorigtesting OWNER TO evergreen;

--
-- Name: stevelongmissingitemsdelete; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevelongmissingitemsdelete (
    id bigint
);


ALTER TABLE esi.stevelongmissingitemsdelete OWNER TO evergreen;

--
-- Name: steveofflinescript18148; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveofflinescript18148 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE esi.steveofflinescript18148 OWNER TO evergreen;

--
-- Name: steveofflinescript18148_2; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveofflinescript18148_2 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE esi.steveofflinescript18148_2 OWNER TO evergreen;

--
-- Name: steveofflinescript18148_3; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveofflinescript18148_3 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE esi.steveofflinescript18148_3 OWNER TO evergreen;

--
-- Name: steveofflinescript21783; Type: TABLE; Schema: esi; Owner: postgres
--

CREATE TABLE esi.steveofflinescript21783 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE esi.steveofflinescript21783 OWNER TO postgres;

--
-- Name: steveofflinesession18148; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveofflinesession18148 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE esi.steveofflinesession18148 OWNER TO evergreen;

--
-- Name: steveofflinesession18148_2; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveofflinesession18148_2 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE esi.steveofflinesession18148_2 OWNER TO evergreen;

--
-- Name: steveofflinesession18148_3; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveofflinesession18148_3 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE esi.steveofflinesession18148_3 OWNER TO evergreen;

--
-- Name: steveofflinesession21783; Type: TABLE; Schema: esi; Owner: postgres
--

CREATE TABLE esi.steveofflinesession21783 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE esi.steveofflinesession21783 OWNER TO postgres;

--
-- Name: steveoverdueprintorig; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveoverdueprintorig (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveoverdueprintorig OWNER TO evergreen;

--
-- Name: steveoverdueprintorigtesting; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveoverdueprintorigtesting (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveoverdueprintorigtesting OWNER TO evergreen;

--
-- Name: stevepenalties14512; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevepenalties14512 (
    id integer,
    org_unit integer,
    usr integer,
    standing_penalty integer,
    staff integer,
    set_date timestamp with time zone,
    stop_date timestamp with time zone,
    note text
);


ALTER TABLE esi.stevepenalties14512 OWNER TO evergreen;

--
-- Name: stevestandingorg14512; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevestandingorg14512 (
    id integer,
    org_unit integer,
    usr integer,
    standing_penalty integer,
    staff integer,
    set_date timestamp with time zone,
    stop_date timestamp with time zone,
    note text
);


ALTER TABLE esi.stevestandingorg14512 OWNER TO evergreen;

--
-- Name: stevestopfines17480; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevestopfines17480 (
    id bigint,
    usr integer,
    xact_start timestamp with time zone,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone,
    duration interval,
    fine_interval interval,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean,
    desk_renewal boolean,
    opac_renewal boolean,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval
);


ALTER TABLE esi.stevestopfines17480 OWNER TO evergreen;

--
-- Name: stevesupetransitcleanup; Type: TABLE; Schema: esi; Owner: postgres
--

CREATE TABLE esi.stevesupetransitcleanup (
    target_copy bigint
);


ALTER TABLE esi.stevesupetransitcleanup OWNER TO postgres;

--
-- Name: stevetestadd; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevetestadd (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.stevetestadd OWNER TO evergreen;

--
-- Name: stevetestsettings; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevetestsettings (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.stevetestsettings OWNER TO evergreen;

--
-- Name: stevetransitupdate; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevetransitupdate (
    id integer,
    source_send_time timestamp with time zone,
    dest_recv_time timestamp with time zone,
    target_copy bigint,
    source integer,
    dest integer,
    prev_hop integer,
    copy_status integer,
    persistant_transfer boolean,
    prev_dest integer
);


ALTER TABLE esi.stevetransitupdate OWNER TO evergreen;

--
-- Name: stevetransitupdate2; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.stevetransitupdate2 (
    id integer,
    source_send_time timestamp with time zone,
    dest_recv_time timestamp with time zone,
    target_copy bigint,
    source integer,
    dest integer,
    prev_hop integer,
    copy_status integer,
    persistant_transfer boolean,
    prev_dest integer
);


ALTER TABLE esi.stevetransitupdate2 OWNER TO evergreen;

--
-- Name: steveusrsettingbackup; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.steveusrsettingbackup (
    id bigint,
    usr integer,
    name text,
    value text
);


ALTER TABLE esi.steveusrsettingbackup OWNER TO evergreen;

--
-- Name: templatestoconvert; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.templatestoconvert (
    id integer,
    owner integer,
    create_time timestamp with time zone,
    name text,
    description text,
    data text,
    folder integer
);


ALTER TABLE esi.templatestoconvert OWNER TO evergreen;

--
-- Name: to_keep; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.to_keep (
    barcode text
);


ALTER TABLE esi.to_keep OWNER TO evergreen;

--
-- Name: toclose; Type: TABLE; Schema: esi; Owner: evergreen
--

CREATE TABLE esi.toclose (
    id bigint
);


ALTER TABLE esi.toclose OWNER TO evergreen;

--
-- Name: transitclear; Type: TABLE; Schema: esi; Owner: postgres
--

CREATE TABLE esi.transitclear (
    first integer,
    target_copy bigint
);


ALTER TABLE esi.transitclear OWNER TO postgres;

--
-- Name: actor_card; Type: TABLE; Schema: esi16538; Owner: evergreen
--

CREATE TABLE esi16538.actor_card (
    id integer,
    usr integer,
    barcode text,
    active boolean
);


ALTER TABLE esi16538.actor_card OWNER TO evergreen;

--
-- Name: fw_items; Type: TABLE; Schema: esi_14812; Owner: evergreen
--

CREATE TABLE esi_14812.fw_items (
    item_id bigint,
    circ_lib integer,
    barcode text,
    orig_status integer,
    orig_status_date timestamp without time zone,
    done boolean DEFAULT false,
    to_fix boolean DEFAULT false
);


ALTER TABLE esi_14812.fw_items OWNER TO evergreen;

--
-- Name: nw_items_changed; Type: TABLE; Schema: esi_14812; Owner: evergreen
--

CREATE TABLE esi_14812.nw_items_changed (
    id bigint,
    status integer
);


ALTER TABLE esi_14812.nw_items_changed OWNER TO evergreen;

--
-- Name: rn_dvds; Type: TABLE; Schema: esi_14812; Owner: evergreen
--

CREATE TABLE esi_14812.rn_dvds (
    id bigint,
    holdable boolean,
    opac_visible boolean
);


ALTER TABLE esi_14812.rn_dvds OWNER TO evergreen;

--
-- Name: rn_missing_items; Type: TABLE; Schema: esi_14812; Owner: evergreen
--

CREATE TABLE esi_14812.rn_missing_items (
    item_id bigint,
    circ_lib integer,
    barcode text,
    orig_status integer,
    orig_status_date timestamp without time zone,
    done boolean DEFAULT false,
    to_fix boolean DEFAULT false
);


ALTER TABLE esi_14812.rn_missing_items OWNER TO evergreen;

--
-- Name: unused_indexes; Type: VIEW; Schema: evergreen; Owner: postgres
--

CREATE VIEW evergreen.unused_indexes AS
 SELECT (((pg_stat_user_indexes.schemaname)::text || '.'::text) || (pg_stat_user_indexes.indexrelname)::text) AS fqindexname,
    pg_size_pretty(pg_relation_size((pg_stat_user_indexes.indexrelid)::regclass)) AS total_size,
    pg_relation_size((pg_stat_user_indexes.indexrelid)::regclass) AS raw_size
   FROM (pg_stat_user_indexes
     JOIN pg_index USING (indexrelid))
  WHERE ((pg_stat_user_indexes.idx_scan = 0) AND (pg_stat_user_indexes.idx_tup_read = 0) AND (pg_stat_user_indexes.idx_tup_fetch = 0) AND (NOT pg_index.indisprimary) AND (NOT pg_index.indisunique) AND (NOT pg_index.indisexclusion) AND pg_index.indisvalid AND pg_index.indisready AND (pg_relation_size((pg_stat_user_indexes.indexrelid)::regclass) > 8192))
  ORDER BY (pg_relation_size((pg_stat_user_indexes.indexrelid)::regclass)) DESC;


ALTER TABLE evergreen.unused_indexes OWNER TO postgres;

--
-- Name: archived_hold_notification; Type: TABLE; Schema: extend_reporter; Owner: evergreen
--

CREATE TABLE extend_reporter.archived_hold_notification (
    id integer,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone,
    method text,
    note text
);


ALTER TABLE extend_reporter.archived_hold_notification OWNER TO evergreen;

--
-- Name: archived_hold_request; Type: TABLE; Schema: extend_reporter; Owner: evergreen
--

CREATE TABLE extend_reporter.archived_hold_request (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE extend_reporter.archived_hold_request OWNER TO evergreen;

--
-- Name: archived_hold_transit_copy; Type: TABLE; Schema: extend_reporter; Owner: evergreen
--

CREATE TABLE extend_reporter.archived_hold_transit_copy (
    id integer,
    source_send_time timestamp with time zone,
    dest_recv_time timestamp with time zone,
    target_copy bigint,
    source integer,
    dest integer,
    prev_hop integer,
    copy_status integer,
    persistant_transfer boolean,
    prev_dest integer,
    hold integer
);


ALTER TABLE extend_reporter.archived_hold_transit_copy OWNER TO evergreen;

--
-- Name: cdr; Type: VIEW; Schema: extend_reporter; Owner: postgres
--

CREATE VIEW extend_reporter.cdr AS
 SELECT t.calldate,
    t.clid,
    t.src,
    t.dst,
    t.dcontext,
    t.channel,
    t.dstchannel,
    t.lastapp,
    t.lastdata,
    t.duration,
    t.billsec,
    t.disposition,
    t.amaflags,
    t.accountcode,
    t.uniqueid,
    t.userfield
   FROM evergreen.dblink('dbname=asterisk user=asterisk password=w@ts0n1n33du'::text, 'select * from cdr'::text) t(calldate timestamp with time zone, clid character varying(80), src character varying(80), dst character varying(80), dcontext character varying(80), channel character varying(80), dstchannel character varying(80), lastapp character varying(80), lastdata character varying(80), duration bigint, billsec bigint, disposition character varying(45), amaflags bigint, accountcode text, uniqueid character varying(32), userfield character varying(255));


ALTER TABLE extend_reporter.cdr OWNER TO postgres;

--
-- Name: copy_count_per_org; Type: VIEW; Schema: extend_reporter; Owner: evergreen
--

CREATE VIEW extend_reporter.copy_count_per_org AS
 SELECT acn.record AS bibid,
    ac.circ_lib,
    acn.owning_lib,
    max(ac.edit_date) AS last_edit_time,
    min((ac.deleted)::integer) AS has_only_deleted_copies,
    count(
        CASE
            WHEN ac.deleted THEN ac.id
            ELSE NULL::bigint
        END) AS deleted_count,
    count(
        CASE
            WHEN (NOT ac.deleted) THEN ac.id
            ELSE NULL::bigint
        END) AS visible_count,
    count(*) AS total_count
   FROM asset.call_number acn,
    asset.copy ac
  WHERE (ac.call_number = acn.id)
  GROUP BY acn.record, acn.owning_lib, ac.circ_lib;


ALTER TABLE extend_reporter.copy_count_per_org OWNER TO evergreen;

--
-- Name: legacy_circ_count; Type: TABLE; Schema: extend_reporter; Owner: evergreen
--

CREATE TABLE extend_reporter.legacy_circ_count (
    id bigint NOT NULL,
    circ_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE extend_reporter.legacy_circ_count OWNER TO evergreen;

--
-- Name: full_circ_count; Type: VIEW; Schema: extend_reporter; Owner: evergreen
--

CREATE VIEW extend_reporter.full_circ_count AS
 SELECT cp.id,
    ((COALESCE(( SELECT legacy_circ_count.circ_count
           FROM extend_reporter.legacy_circ_count
          WHERE (legacy_circ_count.id = cp.id)), 0) + ( SELECT count(*) AS count
           FROM action.circulation
          WHERE (circulation.target_copy = cp.id))) + ( SELECT count(*) AS count
           FROM action.aged_circulation
          WHERE (aged_circulation.target_copy = cp.id))) AS circ_count
   FROM asset.copy cp;


ALTER TABLE extend_reporter.full_circ_count OWNER TO evergreen;

--
-- Name: global_bibs_by_holding_update; Type: VIEW; Schema: extend_reporter; Owner: evergreen
--

CREATE VIEW extend_reporter.global_bibs_by_holding_update AS
 SELECT DISTINCT ON (x.id) x.id,
    x.holding_update,
    x.update_type
   FROM ( SELECT b.id,
            public.last(cp.create_date) AS holding_update,
            'add'::text AS update_type
           FROM ((biblio.record_entry b
             JOIN asset.call_number cn ON ((cn.record = b.id)))
             JOIN asset.copy cp ON ((cp.call_number = cn.id)))
          WHERE ((NOT cp.deleted) AND (b.id > 0))
          GROUP BY b.id
        UNION
         SELECT b.id,
            public.last(cp.edit_date) AS holding_update,
            'delete'::text AS update_type
           FROM ((biblio.record_entry b
             JOIN asset.call_number cn ON ((cn.record = b.id)))
             JOIN asset.copy cp ON ((cp.call_number = cn.id)))
          WHERE (cp.deleted AND (b.id > 0))
          GROUP BY b.id) x
  ORDER BY x.id, x.holding_update;


ALTER TABLE extend_reporter.global_bibs_by_holding_update OWNER TO evergreen;

--
-- Name: action_circulation; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval
);


ALTER TABLE m_enum.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_enum.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT false NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_enum.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_enum.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_enum.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_enum.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.actor_stat_cat_entry_map (
    id integer NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    org_id integer,
    l_library text,
    name text,
    legacy_field1 text,
    legacy_value1 text,
    entry text
);


ALTER TABLE m_enum.actor_stat_cat_entry_map OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE m_enum.actor_stat_cat_entry_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.actor_stat_cat_entry_map_id_seq OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE m_enum.actor_stat_cat_entry_map_id_seq OWNED BY m_enum.actor_stat_cat_entry_map.id;


--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_enum.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_stat_cat_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.actor_stat_cat_map (
    id integer NOT NULL,
    stat_cat integer,
    org_id integer,
    l_library text,
    name text
);


ALTER TABLE m_enum.actor_stat_cat_map OWNER TO evergreen;

--
-- Name: actor_stat_cat_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE m_enum.actor_stat_cat_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.actor_stat_cat_map_id_seq OWNER TO evergreen;

--
-- Name: actor_stat_cat_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE m_enum.actor_stat_cat_map_id_seq OWNED BY m_enum.actor_stat_cat_map.id;


--
-- Name: actor_usr; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_enum.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_enum.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_legacy; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.actor_usr_legacy (
    l_borrower_borrower text,
    l_borrower_location text,
    l_borrower_btype text,
    l_borrower_second_id text,
    l_borrower_name text,
    l_borrower_name_reconstructed text,
    l_borrower_birth_date text,
    l_borrower_backlink text,
    l_borrower_last_cko_date text,
    l_borrower_n_ckos text,
    l_borrower_registration_date text,
    l_borrower_expiration_date text,
    l_borrower_creation_date text,
    l_borrower_last_update_date text,
    l_borrower_borrower_note text,
    l_borrower_source text,
    l_borrower_language text,
    l_borrower_pin text,
    l_borrower_last_authentication_date text,
    l_borrower_self_registered text,
    l_borrower_approved_status text,
    l_borrower_homeroom text,
    l_borrower_grade text,
    l_borrower_teacher text,
    l_borrower_parent_guardian text,
    l_borrower_note1 text,
    l_borrower_note2 text,
    l_borrower_note3 text,
    l_borrower_dynix_pkey text,
    l_borrower_id text,
    l_borrower_internet_permission text,
    l_borrower_approved_borrowers text,
    l_borrower_keep_circ_history text,
    l_borrower_last_alert_date text,
    l_borrower_borr_ldap_dn text,
    l_borrower_use_guardian text,
    l_borrower_address_1__ord text,
    l_borrower_address_1__address_type text,
    l_borrower_address_1__mail_sort_type text,
    l_borrower_address_1__send_notice_by text,
    l_borrower_address_1__valid_from_date text,
    l_borrower_address_1__valid_to_date text,
    l_borrower_address_1__address1 text,
    l_borrower_address_1__address2 text,
    l_borrower_address_1__address3 text,
    l_borrower_address_1__address4 text,
    l_borrower_address_1__postal_code text,
    l_borrower_address_1__city_st text,
    l_borrower_address_1__email_name text,
    l_borrower_address_1__email_address text,
    l_borrower_address_1__send_preoverdue text,
    l_borrower_address_2__ord text,
    l_borrower_address_2__address_type text,
    l_borrower_address_2__mail_sort_type text,
    l_borrower_address_2__send_notice_by text,
    l_borrower_address_2__valid_from_date text,
    l_borrower_address_2__valid_to_date text,
    l_borrower_address_2__address1 text,
    l_borrower_address_2__address2 text,
    l_borrower_address_2__address3 text,
    l_borrower_address_2__address4 text,
    l_borrower_address_2__postal_code text,
    l_borrower_address_2__city_st text,
    l_borrower_address_2__email_name text,
    l_borrower_address_2__email_address text,
    l_borrower_address_2__send_preoverdue text,
    l_borrower_address_3__ord text,
    l_borrower_address_3__address_type text,
    l_borrower_address_3__mail_sort_type text,
    l_borrower_address_3__send_notice_by text,
    l_borrower_address_3__valid_from_date text,
    l_borrower_address_3__valid_to_date text,
    l_borrower_address_3__address1 text,
    l_borrower_address_3__address2 text,
    l_borrower_address_3__address3 text,
    l_borrower_address_3__address4 text,
    l_borrower_address_3__postal_code text,
    l_borrower_address_3__city_st text,
    l_borrower_address_3__email_name text,
    l_borrower_address_3__email_address text,
    l_borrower_address_3__send_preoverdue text,
    l_borrower_phone_1__ord text,
    l_borrower_phone_1__phone_no text,
    l_borrower_phone_1__phone_type text,
    l_borrower_phone_2__ord text,
    l_borrower_phone_2__phone_no text,
    l_borrower_phone_2__phone_type text,
    l_borrower_phone_3__ord text,
    l_borrower_phone_3__phone_no text,
    l_borrower_phone_3__phone_type text,
    l_borrower_bstat_1__bstat text,
    l_borrower_bstat_2__bstat text,
    l_borrower_bstat_3__bstat text,
    l_borrower_barcode_1__ord text,
    l_borrower_barcode_1__bbarcode text,
    l_borrower_barcode_1__barcode_type text,
    l_borrower_barcode_1__lost_date text,
    l_borrower_barcode_1__proxy_borrower text,
    l_borrower_barcode_1__proxy_expiration_date text,
    l_borrower_barcode_2__ord text,
    l_borrower_barcode_2__bbarcode text,
    l_borrower_barcode_2__barcode_type text,
    l_borrower_barcode_2__lost_date text,
    l_borrower_barcode_2__proxy_borrower text,
    l_borrower_barcode_2__proxy_expiration_date text,
    l_borrower_barcode_3__ord text,
    l_borrower_barcode_3__bbarcode text,
    l_borrower_barcode_3__barcode_type text,
    l_borrower_barcode_3__lost_date text,
    l_borrower_barcode_3__proxy_borrower text,
    l_borrower_barcode_3__proxy_expiration_date text,
    l_borrower_barcode_4__ord text,
    l_borrower_barcode_4__bbarcode text,
    l_borrower_barcode_4__barcode_type text,
    l_borrower_barcode_4__lost_date text,
    l_borrower_barcode_4__proxy_borrower text,
    l_borrower_barcode_4__proxy_expiration_date text,
    l_borrower_barcode_5__ord text,
    l_borrower_barcode_5__bbarcode text,
    l_borrower_barcode_5__barcode_type text,
    l_borrower_barcode_5__lost_date text,
    l_borrower_barcode_5__proxy_borrower text,
    l_borrower_barcode_5__proxy_expiration_date text,
    l_borrower_barcode_6__ord text,
    l_borrower_barcode_6__bbarcode text,
    l_borrower_barcode_6__barcode_type text,
    l_borrower_barcode_6__lost_date text,
    l_borrower_barcode_6__proxy_borrower text,
    l_borrower_barcode_6__proxy_expiration_date text,
    l_borrower_barcode_7__ord text,
    l_borrower_barcode_7__bbarcode text,
    l_borrower_barcode_7__barcode_type text,
    l_borrower_barcode_7__lost_date text,
    l_borrower_barcode_7__proxy_borrower text,
    l_borrower_barcode_7__proxy_expiration_date text,
    l_borrowerextradata_symphonykey text,
    l_borrowerextradata_symphonyalt_id text,
    l_borrowerextradata_library text,
    l_borrowerextradata_user_profile text,
    l_borrowerextradata_default_pin text,
    l_borrowerextradata_default_name text
)
INHERITS (m_enum.actor_usr);


ALTER TABLE m_enum.actor_usr_legacy OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.actor_usr_note (
    id bigint NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_enum.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint,
    label_sortkey text,
    prefix integer DEFAULT '-1'::integer NOT NULL,
    suffix integer DEFAULT '-1'::integer NOT NULL
);


ALTER TABLE m_enum.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_enum.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_legacy; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.asset_copy_legacy (
    egid integer,
    hseq integer,
    l_item_num text,
    l_barcode text,
    l_collection text,
    l_call_num text,
    l_copy text,
    l_last_inv_date text,
    l_volume text,
    l_istat text,
    l_pieces text,
    l_create_date text,
    l_update_date text,
    l_location text,
    l_price text,
    l_last_checkout text,
    l_source text,
    l_itype text,
    l_note text,
    l_call_type text,
    l_checkin_note text,
    l_item_status text,
    l_num_loans text,
    l_internal_note text
)
INHERITS (m_enum.asset_copy);


ALTER TABLE m_enum.asset_copy_legacy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_enum.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_enum.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_enum.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_enum.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_enum.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_enum.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE m_enum.base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE m_enum.base_circ_field_map_id_seq OWNED BY m_enum.base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE m_enum.base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE m_enum.base_copy_location_map_id_seq OWNED BY m_enum.base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE m_enum.base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE m_enum.base_item_dynamic_field_map_id_seq OWNED BY m_enum.base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE m_enum.base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE m_enum.base_profile_map_id_seq OWNED BY m_enum.base_profile_map.id;


--
-- Name: bib_hbib_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.bib_hbib_map (
    record bigint,
    value text
);


ALTER TABLE m_enum.bib_hbib_map OWNER TO evergreen;

--
-- Name: bib_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.bib_map (
    item_eg_id bigint,
    egid bigint
);


ALTER TABLE m_enum.bib_map OWNER TO evergreen;

--
-- Name: card_collisions; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.card_collisions (
    id integer NOT NULL,
    reason text,
    usr integer,
    barcode text
);


ALTER TABLE m_enum.card_collisions OWNER TO evergreen;

--
-- Name: card_collisions_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE m_enum.card_collisions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.card_collisions_id_seq OWNER TO evergreen;

--
-- Name: card_collisions_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE m_enum.card_collisions_id_seq OWNED BY m_enum.card_collisions.id;


--
-- Name: circ; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.circ (
    l_item_barcode text,
    l_patron_num text,
    l_barcode text,
    l_checkout timestamp without time zone,
    l_loc text,
    l_due timestamp without time zone,
    l_renewals text
)
INHERITS (m_enum.action_circulation);


ALTER TABLE m_enum.circ OWNER TO evergreen;

--
-- Name: circ_mod_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.circ_mod_map (
    l_collection text,
    l_circ_mod text
);


ALTER TABLE m_enum.circ_mod_map OWNER TO evergreen;

--
-- Name: circs_missing_data; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.circs_missing_data (
    id bigint,
    usr integer,
    xact_start timestamp with time zone,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone,
    duration interval,
    fine_interval interval,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean,
    desk_renewal boolean,
    opac_renewal boolean,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint,
    grace_period interval,
    l_item_barcode text,
    l_patron_num text,
    l_barcode text,
    l_checkout timestamp without time zone,
    l_loc text,
    l_due timestamp without time zone,
    l_renewals text
);


ALTER TABLE m_enum.circs_missing_data OWNER TO evergreen;

--
-- Name: config; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.config (
    key text,
    value text
);


ALTER TABLE m_enum.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_enum.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: holds; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.holds (
    l_bib_num text,
    l_item_num text,
    l_bnum text,
    l_bbarc text,
    l_request_date text,
    l_expire_date text,
    l_on_shelf text,
    l_shelf_expire text,
    l_reactive text,
    l_status text,
    l_notes text
)
INHERITS (m_enum.action_hold_request);


ALTER TABLE m_enum.holds OWNER TO evergreen;

--
-- Name: holds_missing_stuff; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.holds_missing_stuff (
    id integer,
    request_time timestamp with time zone,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean,
    frozen boolean,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean,
    shelf_expire_time timestamp with time zone,
    l_bib_num text,
    l_item_num text,
    l_bnum text,
    l_bbarc text,
    l_request_date text,
    l_expire_date text,
    l_on_shelf text,
    l_shelf_expire text,
    l_reactive text,
    l_status text,
    l_notes text
);


ALTER TABLE m_enum.holds_missing_stuff OWNER TO evergreen;

--
-- Name: home_location_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.home_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.home_location_map OWNER TO evergreen;

--
-- Name: home_location_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE m_enum.home_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.home_location_map_id_seq OWNER TO evergreen;

--
-- Name: home_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE m_enum.home_location_map_id_seq OWNED BY m_enum.home_location_map.id;


--
-- Name: item_dynamic_field_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.item_dynamic_field_map OWNER TO evergreen;

--
-- Name: item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE m_enum.item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE m_enum.item_dynamic_field_map_id_seq OWNED BY m_enum.item_dynamic_field_map.id;


--
-- Name: item_key_barcode_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.item_key_barcode_map (
    key1 text,
    key2 text,
    key3 text,
    barcode text
);


ALTER TABLE m_enum.item_key_barcode_map OWNER TO evergreen;

--
-- Name: items_missing_barcodes; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.items_missing_barcodes (
    id bigint,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean,
    deleted boolean,
    floating boolean,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean,
    cost numeric(8,2),
    egid integer,
    hseq integer,
    l_item_num text,
    l_barcode text,
    l_collection text,
    l_call_num text,
    l_copy text,
    l_last_inv_date text,
    l_volume text,
    l_istat text,
    l_pieces text,
    l_create_date text,
    l_update_date text,
    l_location text,
    l_price text,
    l_last_checkout text,
    l_source text,
    l_itype text,
    l_note text,
    l_call_type text,
    l_checkin_note text,
    l_item_status text,
    l_num_loans text,
    l_internal_note text
);


ALTER TABLE m_enum.items_missing_barcodes OWNER TO evergreen;

--
-- Name: items_not_migrating; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.items_not_migrating (
    id bigint,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone,
    edit_date timestamp with time zone,
    copy_number integer,
    status integer,
    location integer,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean,
    deposit boolean,
    ref boolean,
    holdable boolean,
    deposit_amount numeric(6,2),
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean,
    deleted boolean,
    floating boolean,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean,
    cost numeric(8,2),
    egid integer,
    hseq integer,
    l_item_num text,
    l_barcode text,
    l_collection text,
    l_call_num text,
    l_copy text,
    l_last_inv_date text,
    l_volume text,
    l_istat text,
    l_pieces text,
    l_create_date text,
    l_update_date text,
    l_location text,
    l_price text,
    l_last_checkout text,
    l_source text,
    l_itype text,
    l_note text,
    l_call_type text,
    l_checkin_note text,
    l_item_status text,
    l_num_loans text,
    l_internal_note text
);


ALTER TABLE m_enum.items_not_migrating OWNER TO evergreen;

--
-- Name: loc_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.loc_map (
    l_collection text,
    l_loc text
);


ALTER TABLE m_enum.loc_map OWNER TO evergreen;

--
-- Name: billing; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.billing (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2) NOT NULL,
    billing_type text NOT NULL,
    btype integer NOT NULL,
    note text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    period_start timestamp with time zone,
    period_end timestamp with time zone
);


ALTER TABLE money.billing OWNER TO evergreen;

--
-- Name: billing_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE money.billing_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.billing_id_seq OWNER TO evergreen;

--
-- Name: billing_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE money.billing_id_seq OWNED BY money.billing.id;


--
-- Name: money_billing; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_enum.money_billing OWNER TO evergreen;

--
-- Name: payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.payment (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2) NOT NULL,
    note text
);


ALTER TABLE money.payment OWNER TO evergreen;

--
-- Name: payment_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE money.payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.payment_id_seq OWNER TO evergreen;

--
-- Name: payment_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE money.payment_id_seq OWNED BY money.payment.id;


--
-- Name: money_cash_payment; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_enum.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_enum.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_enum.money_grocery OWNER TO evergreen;

--
-- Name: new_merge; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.new_merge (
    hbib_id bigint,
    source_egid bigint,
    target_egid bigint
);


ALTER TABLE m_enum.new_merge OWNER TO evergreen;

--
-- Name: org_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.org_map (
    id integer NOT NULL,
    org_id integer,
    transcribed_shortname text,
    l_library text NOT NULL,
    patron_rebarcode_offset bigint DEFAULT 0 NOT NULL,
    item_rebarcode_offset bigint DEFAULT 0 NOT NULL,
    default_circ_staff integer DEFAULT 1 NOT NULL
);


ALTER TABLE m_enum.org_map OWNER TO evergreen;

--
-- Name: org_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE m_enum.org_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.org_map_id_seq OWNER TO evergreen;

--
-- Name: org_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE m_enum.org_map_id_seq OWNED BY m_enum.org_map.id;


--
-- Name: orig_egid_copy_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.orig_egid_copy_map (
    id bigint,
    egid integer
);


ALTER TABLE m_enum.orig_egid_copy_map OWNER TO evergreen;

--
-- Name: profile_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_enum.profile_map OWNER TO evergreen;

--
-- Name: profile_map_id_seq; Type: SEQUENCE; Schema: m_enum; Owner: evergreen
--

CREATE SEQUENCE m_enum.profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_enum.profile_map_id_seq OWNER TO evergreen;

--
-- Name: profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_enum; Owner: evergreen
--

ALTER SEQUENCE m_enum.profile_map_id_seq OWNED BY m_enum.profile_map.id;


--
-- Name: sql_current; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.sql_current (
    sql text
);


ALTER TABLE m_enum.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_enum.sql_log OWNER TO evergreen;

--
-- Name: user_key_barcode_map; Type: TABLE; Schema: m_enum; Owner: evergreen
--

CREATE TABLE m_enum.user_key_barcode_map (
    key text,
    barcode text
);


ALTER TABLE m_enum.user_key_barcode_map OWNER TO evergreen;

--
-- Name: action_circulation; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.action_circulation (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    target_copy bigint,
    circ_lib integer,
    circ_staff integer,
    checkin_staff integer,
    checkin_lib integer,
    renewal_remaining integer,
    due_date timestamp with time zone,
    stop_fines_time timestamp with time zone,
    checkin_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    duration interval,
    fine_interval interval DEFAULT '1 day'::interval NOT NULL,
    recurring_fine numeric(6,2),
    max_fine numeric(6,2),
    phone_renewal boolean DEFAULT false NOT NULL,
    desk_renewal boolean DEFAULT false NOT NULL,
    opac_renewal boolean DEFAULT false NOT NULL,
    duration_rule text,
    recurring_fine_rule text,
    max_fine_rule text,
    stop_fines text,
    workstation integer,
    checkin_workstation integer,
    checkin_scan_time timestamp with time zone,
    parent_circ bigint
);


ALTER TABLE m_test.action_circulation OWNER TO evergreen;

--
-- Name: action_hold_notification; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.action_hold_notification (
    id integer DEFAULT nextval('action.hold_notification_id_seq'::regclass) NOT NULL,
    hold integer,
    notify_staff integer,
    notify_time timestamp with time zone DEFAULT now() NOT NULL,
    method text,
    note text
);


ALTER TABLE m_test.action_hold_notification OWNER TO evergreen;

--
-- Name: action_hold_request; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.action_hold_request (
    id integer DEFAULT nextval('action.hold_request_id_seq'::regclass) NOT NULL,
    request_time timestamp with time zone DEFAULT now() NOT NULL,
    capture_time timestamp with time zone,
    fulfillment_time timestamp with time zone,
    checkin_time timestamp with time zone,
    return_time timestamp with time zone,
    prev_check_time timestamp with time zone,
    expire_time timestamp with time zone,
    cancel_time timestamp with time zone,
    cancel_cause integer,
    cancel_note text,
    target bigint,
    current_copy bigint,
    fulfillment_staff integer,
    fulfillment_lib integer,
    request_lib integer,
    requestor integer,
    usr integer,
    selection_ou integer,
    selection_depth integer DEFAULT 0 NOT NULL,
    pickup_lib integer,
    hold_type text,
    holdable_formats text,
    phone_notify text,
    email_notify boolean DEFAULT true NOT NULL,
    frozen boolean DEFAULT false NOT NULL,
    thaw_date timestamp with time zone,
    shelf_time timestamp with time zone,
    cut_in_line boolean,
    mint_condition boolean DEFAULT true NOT NULL,
    shelf_expire_time timestamp with time zone
);


ALTER TABLE m_test.action_hold_request OWNER TO evergreen;

--
-- Name: actor_card; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.actor_card (
    id integer DEFAULT nextval('actor.card_id_seq'::regclass) NOT NULL,
    usr integer,
    barcode text,
    active boolean DEFAULT true NOT NULL
);


ALTER TABLE m_test.actor_card OWNER TO evergreen;

--
-- Name: actor_stat_cat; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.actor_stat_cat (
    id integer DEFAULT nextval('actor.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    name text,
    opac_visible boolean DEFAULT false NOT NULL,
    usr_summary boolean DEFAULT false NOT NULL
);


ALTER TABLE m_test.actor_stat_cat OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.actor_stat_cat_entry (
    id integer DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_test.actor_stat_cat_entry OWNER TO evergreen;

--
-- Name: actor_stat_cat_entry_usr_map; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.actor_stat_cat_entry_usr_map (
    id bigint DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass) NOT NULL,
    stat_cat_entry text,
    stat_cat integer,
    target_usr integer
);


ALTER TABLE m_test.actor_stat_cat_entry_usr_map OWNER TO evergreen;

--
-- Name: actor_usr; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.actor_usr (
    id integer DEFAULT nextval('actor.usr_id_seq'::regclass) NOT NULL,
    card integer,
    profile integer,
    usrname text,
    email text,
    passwd text,
    standing integer DEFAULT 1 NOT NULL,
    ident_type integer,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer DEFAULT 1 NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text,
    second_given_name text,
    family_name text,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer,
    dob timestamp with time zone,
    active boolean DEFAULT true NOT NULL,
    master_account boolean DEFAULT false NOT NULL,
    super_user boolean DEFAULT false NOT NULL,
    barred boolean DEFAULT false NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    juvenile boolean DEFAULT false NOT NULL,
    usrgroup integer DEFAULT nextval('actor.usr_usrgroup_seq'::regclass) NOT NULL,
    claims_returned_count integer DEFAULT 0 NOT NULL,
    credit_forward_balance numeric(6,2) DEFAULT 0.00 NOT NULL,
    last_xact_id text DEFAULT 'none'::text NOT NULL,
    alert_message text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    expire_date timestamp with time zone DEFAULT (now() + '3 years'::interval) NOT NULL,
    claims_never_checked_out_count integer DEFAULT 0 NOT NULL
);


ALTER TABLE m_test.actor_usr OWNER TO evergreen;

--
-- Name: actor_usr_address; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.actor_usr_address (
    id integer DEFAULT nextval('actor.usr_address_id_seq'::regclass) NOT NULL,
    valid boolean DEFAULT true NOT NULL,
    within_city_limits boolean DEFAULT true NOT NULL,
    address_type text DEFAULT 'MAILING'::text NOT NULL,
    usr integer,
    street1 text,
    street2 text,
    city text,
    county text,
    state text,
    country text,
    post_code text,
    pending boolean DEFAULT false NOT NULL,
    replaces integer
);


ALTER TABLE m_test.actor_usr_address OWNER TO evergreen;

--
-- Name: actor_usr_note; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.actor_usr_note (
    id bigint NOT NULL,
    usr bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_test.actor_usr_note OWNER TO evergreen;

--
-- Name: asset_call_number; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.asset_call_number (
    id bigint DEFAULT nextval('asset.call_number_id_seq'::regclass) NOT NULL,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    editor bigint,
    edit_date timestamp with time zone DEFAULT now(),
    record bigint,
    owning_lib integer,
    label text,
    deleted boolean DEFAULT false NOT NULL,
    label_class bigint DEFAULT 1 NOT NULL,
    label_sortkey text
);


ALTER TABLE m_test.asset_call_number OWNER TO evergreen;

--
-- Name: asset_copy; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.asset_copy (
    id bigint DEFAULT nextval('asset.copy_id_seq'::regclass) NOT NULL,
    circ_lib integer,
    creator bigint,
    call_number bigint,
    editor bigint,
    create_date timestamp with time zone DEFAULT now(),
    edit_date timestamp with time zone DEFAULT now(),
    copy_number integer,
    status integer DEFAULT 0 NOT NULL,
    location integer DEFAULT 1 NOT NULL,
    loan_duration integer,
    fine_level integer,
    age_protect integer,
    circulate boolean DEFAULT true NOT NULL,
    deposit boolean DEFAULT false NOT NULL,
    ref boolean DEFAULT false NOT NULL,
    holdable boolean DEFAULT true NOT NULL,
    deposit_amount numeric(6,2) DEFAULT 0.00 NOT NULL,
    price numeric(8,2),
    barcode text,
    circ_modifier text,
    circ_as_type text,
    dummy_title text,
    dummy_author text,
    alert_message text,
    opac_visible boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    floating boolean DEFAULT false NOT NULL,
    dummy_isbn text,
    status_changed_time timestamp with time zone,
    mint_condition boolean DEFAULT true NOT NULL,
    cost numeric(8,2)
);


ALTER TABLE m_test.asset_copy OWNER TO evergreen;

--
-- Name: asset_copy_location; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.asset_copy_location (
    id integer DEFAULT nextval('asset.copy_location_id_seq'::regclass) NOT NULL,
    name text,
    owning_lib integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    label_prefix text,
    label_suffix text
);


ALTER TABLE m_test.asset_copy_location OWNER TO evergreen;

--
-- Name: asset_copy_note; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.asset_copy_note (
    id bigint DEFAULT nextval('asset.copy_note_id_seq'::regclass) NOT NULL,
    owning_copy bigint,
    creator bigint,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text,
    value text
);


ALTER TABLE m_test.asset_copy_note OWNER TO evergreen;

--
-- Name: asset_stat_cat; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.asset_stat_cat (
    id integer DEFAULT nextval('asset.stat_cat_id_seq'::regclass) NOT NULL,
    owner integer,
    opac_visible boolean DEFAULT false NOT NULL,
    name text,
    required boolean DEFAULT false NOT NULL
);


ALTER TABLE m_test.asset_stat_cat OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.asset_stat_cat_entry (
    id integer DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    owner integer,
    value text
);


ALTER TABLE m_test.asset_stat_cat_entry OWNER TO evergreen;

--
-- Name: asset_stat_cat_entry_copy_map; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.asset_stat_cat_entry_copy_map (
    id bigint DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass) NOT NULL,
    stat_cat integer,
    stat_cat_entry integer,
    owning_copy bigint
);


ALTER TABLE m_test.asset_stat_cat_entry_copy_map OWNER TO evergreen;

--
-- Name: base_circ_field_map; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.base_circ_field_map (
    id integer NOT NULL,
    circulate boolean,
    loan_period text,
    max_renewals text,
    max_out text,
    fine_amount text,
    fine_interval text,
    max_fine text,
    item_field1 text,
    item_value1 text,
    item_field2 text,
    item_value2 text,
    patron_field1 text,
    patron_value1 text,
    patron_field2 text,
    patron_value2 text
);


ALTER TABLE m_test.base_circ_field_map OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE; Schema: m_test; Owner: evergreen
--

CREATE SEQUENCE m_test.base_circ_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_test.base_circ_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_circ_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_test; Owner: evergreen
--

ALTER SEQUENCE m_test.base_circ_field_map_id_seq OWNED BY m_test.base_circ_field_map.id;


--
-- Name: base_copy_location_map; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.base_copy_location_map (
    id integer NOT NULL,
    location integer,
    holdable boolean DEFAULT true NOT NULL,
    hold_verify boolean DEFAULT false NOT NULL,
    opac_visible boolean DEFAULT true NOT NULL,
    circulate boolean DEFAULT true NOT NULL,
    transcribed_location text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_test.base_copy_location_map OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE; Schema: m_test; Owner: evergreen
--

CREATE SEQUENCE m_test.base_copy_location_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_test.base_copy_location_map_id_seq OWNER TO evergreen;

--
-- Name: base_copy_location_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_test; Owner: evergreen
--

ALTER SEQUENCE m_test.base_copy_location_map_id_seq OWNED BY m_test.base_copy_location_map.id;


--
-- Name: base_item_dynamic_field_map; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.base_item_dynamic_field_map (
    id integer NOT NULL,
    evergreen_field text,
    evergreen_value text,
    evergreen_datatype text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_test.base_item_dynamic_field_map OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE; Schema: m_test; Owner: evergreen
--

CREATE SEQUENCE m_test.base_item_dynamic_field_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_test.base_item_dynamic_field_map_id_seq OWNER TO evergreen;

--
-- Name: base_item_dynamic_field_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_test; Owner: evergreen
--

ALTER SEQUENCE m_test.base_item_dynamic_field_map_id_seq OWNED BY m_test.base_item_dynamic_field_map.id;


--
-- Name: base_profile_map; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.base_profile_map (
    id integer NOT NULL,
    perm_grp_id integer,
    transcribed_perm_group text,
    legacy_field1 text,
    legacy_value1 text,
    legacy_field2 text,
    legacy_value2 text,
    legacy_field3 text,
    legacy_value3 text
);


ALTER TABLE m_test.base_profile_map OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE; Schema: m_test; Owner: evergreen
--

CREATE SEQUENCE m_test.base_profile_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE m_test.base_profile_map_id_seq OWNER TO evergreen;

--
-- Name: base_profile_map_id_seq; Type: SEQUENCE OWNED BY; Schema: m_test; Owner: evergreen
--

ALTER SEQUENCE m_test.base_profile_map_id_seq OWNED BY m_test.base_profile_map.id;


--
-- Name: circhist; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.circhist (
    l_patron_id text,
    l_bib_num text,
    l_item_num text,
    l_checkout date
)
INHERITS (m_test.action_circulation);


ALTER TABLE m_test.circhist OWNER TO evergreen;

--
-- Name: config; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.config (
    key text,
    value text
);


ALTER TABLE m_test.config OWNER TO evergreen;

--
-- Name: fields_requiring_mapping; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.fields_requiring_mapping (
    table_schema text,
    table_name text,
    column_name text,
    data_type text
);


ALTER TABLE m_test.fields_requiring_mapping OWNER TO evergreen;

--
-- Name: money_billing; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.money_billing (
    id bigint DEFAULT nextval('money.billing_id_seq'::regclass) NOT NULL,
    xact bigint,
    billing_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2),
    billing_type text,
    btype integer,
    note text
);


ALTER TABLE m_test.money_billing OWNER TO evergreen;

--
-- Name: money_cash_payment; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.money_cash_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer,
    cash_drawer integer
);


ALTER TABLE m_test.money_cash_payment OWNER TO evergreen;

--
-- Name: money_forgive_payment; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.money_forgive_payment (
    id bigint DEFAULT nextval('money.payment_id_seq'::regclass) NOT NULL,
    xact bigint,
    payment_ts timestamp with time zone DEFAULT now() NOT NULL,
    voided boolean DEFAULT false NOT NULL,
    amount numeric(6,2),
    note text,
    amount_collected numeric(6,2),
    accepting_usr integer
);


ALTER TABLE m_test.money_forgive_payment OWNER TO evergreen;

--
-- Name: money_grocery; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.money_grocery (
    id bigint DEFAULT nextval('money.billable_xact_id_seq'::regclass) NOT NULL,
    usr integer,
    xact_start timestamp with time zone DEFAULT now() NOT NULL,
    xact_finish timestamp with time zone,
    unrecovered boolean,
    billing_location integer,
    note text
);


ALTER TABLE m_test.money_grocery OWNER TO evergreen;

--
-- Name: sql_current; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.sql_current (
    sql text
);


ALTER TABLE m_test.sql_current OWNER TO evergreen;

--
-- Name: sql_log; Type: TABLE; Schema: m_test; Owner: evergreen
--

CREATE TABLE m_test.sql_log (
    "time" timestamp without time zone DEFAULT now() NOT NULL,
    row_count integer,
    sql text
);


ALTER TABLE m_test.sql_log OWNER TO evergreen;

--
-- Name: author_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.author_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.author_field_entry OWNER TO evergreen;

--
-- Name: author_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.author_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.author_field_entry_id_seq OWNER TO evergreen;

--
-- Name: author_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.author_field_entry_id_seq OWNED BY metabib.author_field_entry.id;


--
-- Name: bib_export_data; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.bib_export_data (
    id bigint NOT NULL,
    bib bigint NOT NULL,
    export_date timestamp with time zone,
    import_date timestamp with time zone
);


ALTER TABLE metabib.bib_export_data OWNER TO evergreen;

--
-- Name: bib_export_data_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.bib_export_data_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.bib_export_data_id_seq OWNER TO evergreen;

--
-- Name: bib_export_data_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.bib_export_data_id_seq OWNED BY metabib.bib_export_data.id;


--
-- Name: browse_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.browse_entry (
    id bigint NOT NULL,
    value text,
    index_vector tsvector,
    sort_value text NOT NULL,
    truncated_sort_value text,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    metabib_fields_cache integer[]
);


ALTER TABLE metabib.browse_entry OWNER TO evergreen;

--
-- Name: browse_entry_def_map; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.browse_entry_def_map (
    id bigint NOT NULL,
    entry bigint,
    def integer,
    source bigint,
    authority bigint
);


ALTER TABLE metabib.browse_entry_def_map OWNER TO evergreen;

--
-- Name: browse_entry_def_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.browse_entry_def_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_entry_def_map_id_seq OWNER TO evergreen;

--
-- Name: browse_entry_def_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.browse_entry_def_map_id_seq OWNED BY metabib.browse_entry_def_map.id;


--
-- Name: browse_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.browse_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_entry_id_seq OWNER TO evergreen;

--
-- Name: browse_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.browse_entry_id_seq OWNED BY metabib.browse_entry.id;


--
-- Name: browse_entry_simple_heading_map; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.browse_entry_simple_heading_map (
    id bigint NOT NULL,
    entry bigint,
    simple_heading bigint
);


ALTER TABLE metabib.browse_entry_simple_heading_map OWNER TO evergreen;

--
-- Name: browse_entry_simple_heading_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.browse_entry_simple_heading_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.browse_entry_simple_heading_map_id_seq OWNER TO evergreen;

--
-- Name: browse_entry_simple_heading_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.browse_entry_simple_heading_map_id_seq OWNED BY metabib.browse_entry_simple_heading_map.id;


--
-- Name: call_number_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.call_number_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.call_number_field_entry OWNER TO evergreen;

--
-- Name: call_number_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.call_number_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.call_number_field_entry_id_seq OWNER TO evergreen;

--
-- Name: call_number_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.call_number_field_entry_id_seq OWNED BY metabib.call_number_field_entry.id;


--
-- Name: combined_author_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.combined_author_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_author_field_entry OWNER TO evergreen;

--
-- Name: combined_identifier_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.combined_identifier_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_identifier_field_entry OWNER TO evergreen;

--
-- Name: combined_keyword_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.combined_keyword_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_keyword_field_entry OWNER TO evergreen;

--
-- Name: combined_series_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.combined_series_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_series_field_entry OWNER TO evergreen;

--
-- Name: combined_subject_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.combined_subject_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_subject_field_entry OWNER TO evergreen;

--
-- Name: combined_title_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.combined_title_field_entry (
    record bigint NOT NULL,
    metabib_field integer,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.combined_title_field_entry OWNER TO evergreen;

--
-- Name: combined_all_field_entry; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW metabib.combined_all_field_entry AS
 SELECT combined_title_field_entry.record,
    combined_title_field_entry.metabib_field,
    combined_title_field_entry.index_vector
   FROM metabib.combined_title_field_entry
UNION ALL
 SELECT combined_author_field_entry.record,
    combined_author_field_entry.metabib_field,
    combined_author_field_entry.index_vector
   FROM metabib.combined_author_field_entry
UNION ALL
 SELECT combined_subject_field_entry.record,
    combined_subject_field_entry.metabib_field,
    combined_subject_field_entry.index_vector
   FROM metabib.combined_subject_field_entry
UNION ALL
 SELECT combined_keyword_field_entry.record,
    combined_keyword_field_entry.metabib_field,
    combined_keyword_field_entry.index_vector
   FROM metabib.combined_keyword_field_entry
UNION ALL
 SELECT combined_identifier_field_entry.record,
    combined_identifier_field_entry.metabib_field,
    combined_identifier_field_entry.index_vector
   FROM metabib.combined_identifier_field_entry
UNION ALL
 SELECT combined_series_field_entry.record,
    combined_series_field_entry.metabib_field,
    combined_series_field_entry.index_vector
   FROM metabib.combined_series_field_entry;


ALTER TABLE metabib.combined_all_field_entry OWNER TO evergreen;

--
-- Name: composite_attr_id_map; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW metabib.composite_attr_id_map AS
 SELECT c.id,
    c.ctype AS attr,
    c.code AS value
   FROM (config.coded_value_map c
     JOIN config.record_attr_definition d ON (((d.name = c.ctype) AND d.composite)));


ALTER TABLE metabib.composite_attr_id_map OWNER TO evergreen;

--
-- Name: display_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.display_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE metabib.display_entry OWNER TO evergreen;

--
-- Name: flat_display_entry; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW metabib.flat_display_entry AS
 SELECT mde.source,
    cdfm.name,
    cdfm.multi,
    cmf.label,
    cmf.id AS field,
    mde.value
   FROM ((metabib.display_entry mde
     JOIN config.metabib_field cmf ON ((cmf.id = mde.field)))
     JOIN config.display_field_map cdfm ON ((cdfm.field = mde.field)));


ALTER TABLE metabib.flat_display_entry OWNER TO evergreen;

--
-- Name: compressed_display_entry; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW metabib.compressed_display_entry AS
 SELECT flat_display_entry.source,
    flat_display_entry.name,
    flat_display_entry.multi,
    flat_display_entry.label,
    flat_display_entry.field,
        CASE
            WHEN flat_display_entry.multi THEN to_json(array_agg(flat_display_entry.value))
            ELSE to_json(min(flat_display_entry.value))
        END AS value
   FROM metabib.flat_display_entry
  GROUP BY flat_display_entry.source, flat_display_entry.name, flat_display_entry.multi, flat_display_entry.label, flat_display_entry.field;


ALTER TABLE metabib.compressed_display_entry OWNER TO evergreen;

--
-- Name: display_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.display_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.display_entry_id_seq OWNER TO evergreen;

--
-- Name: display_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.display_entry_id_seq OWNED BY metabib.display_entry.id;


--
-- Name: facet_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.facet_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL
);


ALTER TABLE metabib.facet_entry OWNER TO evergreen;

--
-- Name: facet_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.facet_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.facet_entry_id_seq OWNER TO evergreen;

--
-- Name: facet_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.facet_entry_id_seq OWNED BY metabib.facet_entry.id;


--
-- Name: uncontrolled_record_attr_value_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.uncontrolled_record_attr_value_id_seq
    START WITH -1
    INCREMENT BY -1
    MINVALUE -9223372036854775807
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.uncontrolled_record_attr_value_id_seq OWNER TO evergreen;

--
-- Name: uncontrolled_record_attr_value; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.uncontrolled_record_attr_value (
    id bigint DEFAULT nextval('metabib.uncontrolled_record_attr_value_id_seq'::regclass) NOT NULL,
    attr text NOT NULL,
    value text NOT NULL
);


ALTER TABLE metabib.uncontrolled_record_attr_value OWNER TO evergreen;

--
-- Name: record_attr_id_map; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW metabib.record_attr_id_map AS
 SELECT uncontrolled_record_attr_value.id,
    uncontrolled_record_attr_value.attr,
    uncontrolled_record_attr_value.value
   FROM metabib.uncontrolled_record_attr_value
UNION
 SELECT c.id,
    c.ctype AS attr,
    c.code AS value
   FROM (config.coded_value_map c
     JOIN config.record_attr_definition d ON (((d.name = c.ctype) AND (NOT d.composite))));


ALTER TABLE metabib.record_attr_id_map OWNER TO evergreen;

--
-- Name: full_attr_id_map; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW metabib.full_attr_id_map AS
 SELECT record_attr_id_map.id,
    record_attr_id_map.attr,
    record_attr_id_map.value
   FROM metabib.record_attr_id_map
UNION
 SELECT composite_attr_id_map.id,
    composite_attr_id_map.attr,
    composite_attr_id_map.value
   FROM metabib.composite_attr_id_map;


ALTER TABLE metabib.full_attr_id_map OWNER TO evergreen;

--
-- Name: identifier_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.identifier_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.identifier_field_entry OWNER TO evergreen;

--
-- Name: identifier_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.identifier_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.identifier_field_entry_id_seq OWNER TO evergreen;

--
-- Name: identifier_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.identifier_field_entry_id_seq OWNED BY metabib.identifier_field_entry.id;


--
-- Name: keyword_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.keyword_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.keyword_field_entry OWNER TO evergreen;

--
-- Name: keyword_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.keyword_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.keyword_field_entry_id_seq OWNER TO evergreen;

--
-- Name: keyword_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.keyword_field_entry_id_seq OWNED BY metabib.keyword_field_entry.id;


--
-- Name: metarecord; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.metarecord (
    id bigint NOT NULL,
    fingerprint text NOT NULL,
    master_record bigint,
    mods text
);


ALTER TABLE metabib.metarecord OWNER TO evergreen;

--
-- Name: metarecord_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.metarecord_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.metarecord_id_seq OWNER TO evergreen;

--
-- Name: metarecord_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.metarecord_id_seq OWNED BY metabib.metarecord.id;


--
-- Name: metarecord_source_map; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.metarecord_source_map (
    id bigint NOT NULL,
    metarecord bigint NOT NULL,
    source bigint NOT NULL
);


ALTER TABLE metabib.metarecord_source_map OWNER TO evergreen;

--
-- Name: metarecord_source_map_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.metarecord_source_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.metarecord_source_map_id_seq OWNER TO evergreen;

--
-- Name: metarecord_source_map_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.metarecord_source_map_id_seq OWNED BY metabib.metarecord_source_map.id;


--
-- Name: normalized_author_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.normalized_author_field_entry (
    id bigint NOT NULL,
    source bigint,
    value text,
    ind text
);


ALTER TABLE metabib.normalized_author_field_entry OWNER TO evergreen;

--
-- Name: normalized_keyword_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.normalized_keyword_field_entry (
    id bigint NOT NULL,
    source bigint,
    value text,
    ind text
);


ALTER TABLE metabib.normalized_keyword_field_entry OWNER TO evergreen;

--
-- Name: normalized_series_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.normalized_series_field_entry (
    id bigint NOT NULL,
    source bigint,
    value text,
    ind text
);


ALTER TABLE metabib.normalized_series_field_entry OWNER TO evergreen;

--
-- Name: normalized_subject_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.normalized_subject_field_entry (
    id bigint NOT NULL,
    source bigint,
    value text,
    ind text
);


ALTER TABLE metabib.normalized_subject_field_entry OWNER TO evergreen;

--
-- Name: normalized_title_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.normalized_title_field_entry (
    id bigint NOT NULL,
    source bigint,
    value text,
    ind text
);


ALTER TABLE metabib.normalized_title_field_entry OWNER TO evergreen;

--
-- Name: record_attr_vector_list; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.record_attr_vector_list (
    source bigint NOT NULL,
    vlist integer[] NOT NULL
);


ALTER TABLE metabib.record_attr_vector_list OWNER TO evergreen;

--
-- Name: record_attr_flat; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW metabib.record_attr_flat AS
 SELECT v.source AS id,
    m.attr,
    m.value
   FROM (metabib.record_attr_vector_list v
     LEFT JOIN metabib.uncontrolled_record_attr_value m ON ((m.id = ANY (v.vlist))))
UNION
 SELECT v.source AS id,
    c.ctype AS attr,
    c.code AS value
   FROM (metabib.record_attr_vector_list v
     LEFT JOIN config.coded_value_map c ON ((c.id = ANY (v.vlist))));


ALTER TABLE metabib.record_attr_flat OWNER TO evergreen;

--
-- Name: record_attr; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW metabib.record_attr AS
 SELECT record_attr_flat.id,
    evergreen.hstore(array_agg(record_attr_flat.attr), array_agg(record_attr_flat.value)) AS attrs
   FROM metabib.record_attr_flat
  WHERE (record_attr_flat.attr IS NOT NULL)
  GROUP BY record_attr_flat.id;


ALTER TABLE metabib.record_attr OWNER TO evergreen;

--
-- Name: rec_descriptor; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW metabib.rec_descriptor AS
 SELECT record_attr.id,
    record_attr.id AS record,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).item_type AS item_type,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).item_form AS item_form,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).bib_level AS bib_level,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).control_type AS control_type,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).char_encoding AS char_encoding,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).enc_level AS enc_level,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).audience AS audience,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).lit_form AS lit_form,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).type_mat AS type_mat,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).cat_form AS cat_form,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).pub_status AS pub_status,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).item_lang AS item_lang,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).vr_format AS vr_format,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).date1 AS date1,
    (evergreen.populate_record(NULL::metabib.rec_desc_type, record_attr.attrs)).date2 AS date2
   FROM metabib.record_attr;


ALTER TABLE metabib.rec_descriptor OWNER TO evergreen;

--
-- Name: record_attr_back; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.record_attr_back (
    id bigint,
    attrs evergreen.hstore
);


ALTER TABLE metabib.record_attr_back OWNER TO evergreen;

--
-- Name: record_sorter; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.record_sorter (
    id bigint NOT NULL,
    source bigint NOT NULL,
    attr text NOT NULL,
    value text NOT NULL
);


ALTER TABLE metabib.record_sorter OWNER TO evergreen;

--
-- Name: record_sorter_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.record_sorter_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.record_sorter_id_seq OWNER TO evergreen;

--
-- Name: record_sorter_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.record_sorter_id_seq OWNED BY metabib.record_sorter.id;


--
-- Name: series_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.series_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.series_field_entry OWNER TO evergreen;

--
-- Name: series_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.series_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.series_field_entry_id_seq OWNER TO evergreen;

--
-- Name: series_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.series_field_entry_id_seq OWNED BY metabib.series_field_entry.id;


--
-- Name: subject_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.subject_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.subject_field_entry OWNER TO evergreen;

--
-- Name: subject_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.subject_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.subject_field_entry_id_seq OWNER TO evergreen;

--
-- Name: subject_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.subject_field_entry_id_seq OWNED BY metabib.subject_field_entry.id;


--
-- Name: title_field_entry; Type: TABLE; Schema: metabib; Owner: evergreen
--

CREATE TABLE metabib.title_field_entry (
    id bigint NOT NULL,
    source bigint NOT NULL,
    field integer NOT NULL,
    value text NOT NULL,
    index_vector tsvector NOT NULL
);


ALTER TABLE metabib.title_field_entry OWNER TO evergreen;

--
-- Name: title_field_entry_id_seq; Type: SEQUENCE; Schema: metabib; Owner: evergreen
--

CREATE SEQUENCE metabib.title_field_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE metabib.title_field_entry_id_seq OWNER TO evergreen;

--
-- Name: title_field_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: metabib; Owner: evergreen
--

ALTER SEQUENCE metabib.title_field_entry_id_seq OWNED BY metabib.title_field_entry.id;


--
-- Name: wide_display_entry; Type: VIEW; Schema: metabib; Owner: evergreen
--

CREATE VIEW metabib.wide_display_entry AS
 SELECT bre.id AS source,
    (COALESCE(mcde_title.value, 'null'::json))::text AS title,
    (COALESCE(mcde_title_proper.value, 'null'::json))::text AS title_proper,
    (COALESCE(mcde_author.value, 'null'::json))::text AS author,
    (COALESCE(mcde_subject_geographic.value, 'null'::json))::text AS subject_geographic,
    (COALESCE(mcde_subject_name.value, 'null'::json))::text AS subject_name,
    (COALESCE(mcde_subject_temporal.value, 'null'::json))::text AS subject_temporal,
    (COALESCE(mcde_subject_topic.value, 'null'::json))::text AS subject_topic,
    (COALESCE(mcde_creators.value, 'null'::json))::text AS creators,
    (COALESCE(mcde_isbn.value, 'null'::json))::text AS isbn,
    (COALESCE(mcde_issn.value, 'null'::json))::text AS issn,
    (COALESCE(mcde_upc.value, 'null'::json))::text AS upc,
    (COALESCE(mcde_tcn.value, 'null'::json))::text AS tcn,
    (COALESCE(mcde_edition.value, 'null'::json))::text AS edition,
    (COALESCE(mcde_physical_description.value, 'null'::json))::text AS physical_description,
    (COALESCE(mcde_publisher.value, 'null'::json))::text AS publisher,
    (COALESCE(mcde_series_title.value, 'null'::json))::text AS series_title,
    (COALESCE(mcde_abstract.value, 'null'::json))::text AS abstract,
    (COALESCE(mcde_toc.value, 'null'::json))::text AS toc,
    (COALESCE(mcde_pubdate.value, 'null'::json))::text AS pubdate,
    (COALESCE(mcde_type_of_resource.value, 'null'::json))::text AS type_of_resource
   FROM (((((((((((((((((((((biblio.record_entry bre
     LEFT JOIN metabib.compressed_display_entry mcde_title ON (((bre.id = mcde_title.source) AND (mcde_title.name = 'title'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_title_proper ON (((bre.id = mcde_title_proper.source) AND (mcde_title_proper.name = 'title_proper'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_author ON (((bre.id = mcde_author.source) AND (mcde_author.name = 'author'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_subject ON (((bre.id = mcde_subject.source) AND (mcde_subject.name = 'subject'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_subject_geographic ON (((bre.id = mcde_subject_geographic.source) AND (mcde_subject_geographic.name = 'subject_geographic'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_subject_name ON (((bre.id = mcde_subject_name.source) AND (mcde_subject_name.name = 'subject_name'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_subject_temporal ON (((bre.id = mcde_subject_temporal.source) AND (mcde_subject_temporal.name = 'subject_temporal'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_subject_topic ON (((bre.id = mcde_subject_topic.source) AND (mcde_subject_topic.name = 'subject_topic'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_creators ON (((bre.id = mcde_creators.source) AND (mcde_creators.name = 'creators'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_isbn ON (((bre.id = mcde_isbn.source) AND (mcde_isbn.name = 'isbn'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_issn ON (((bre.id = mcde_issn.source) AND (mcde_issn.name = 'issn'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_upc ON (((bre.id = mcde_upc.source) AND (mcde_upc.name = 'upc'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_tcn ON (((bre.id = mcde_tcn.source) AND (mcde_tcn.name = 'tcn'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_edition ON (((bre.id = mcde_edition.source) AND (mcde_edition.name = 'edition'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_physical_description ON (((bre.id = mcde_physical_description.source) AND (mcde_physical_description.name = 'physical_description'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_publisher ON (((bre.id = mcde_publisher.source) AND (mcde_publisher.name = 'publisher'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_series_title ON (((bre.id = mcde_series_title.source) AND (mcde_series_title.name = 'series_title'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_abstract ON (((bre.id = mcde_abstract.source) AND (mcde_abstract.name = 'abstract'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_toc ON (((bre.id = mcde_toc.source) AND (mcde_toc.name = 'toc'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_pubdate ON (((bre.id = mcde_pubdate.source) AND (mcde_pubdate.name = 'pubdate'::text))))
     LEFT JOIN metabib.compressed_display_entry mcde_type_of_resource ON (((bre.id = mcde_type_of_resource.source) AND (mcde_type_of_resource.name = 'type_of_resource'::text))));


ALTER TABLE metabib.wide_display_entry OWNER TO evergreen;

--
-- Name: db_object_stash; Type: TABLE; Schema: migration_tools; Owner: evergreen
--

CREATE TABLE migration_tools.db_object_stash (
    schema_name name,
    table_name name,
    object_name name,
    object_type text,
    restore_command text,
    CONSTRAINT db_object_stash_object_type_check CHECK ((object_type = ANY (ARRAY['index'::text, 'trigger'::text, 'rule'::text])))
);


ALTER TABLE migration_tools.db_object_stash OWNER TO evergreen;

--
-- Name: bnm_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.bnm_payment (
    amount_collected numeric(6,2) NOT NULL,
    accepting_usr integer NOT NULL
)
INHERITS (money.payment);


ALTER TABLE money.bnm_payment OWNER TO evergreen;

--
-- Name: account_adjustment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.account_adjustment (
    billing bigint
)
INHERITS (money.bnm_payment);


ALTER TABLE money.account_adjustment OWNER TO evergreen;

--
-- Name: aged_billing; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.aged_billing (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    billing_ts timestamp with time zone NOT NULL,
    voided boolean NOT NULL,
    voider integer,
    void_time timestamp with time zone,
    amount numeric(6,2) NOT NULL,
    billing_type text NOT NULL,
    btype integer NOT NULL,
    note text,
    create_date timestamp with time zone,
    period_start timestamp with time zone,
    period_end timestamp with time zone
);


ALTER TABLE money.aged_billing OWNER TO evergreen;

--
-- Name: aged_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.aged_payment (
    id bigint NOT NULL,
    xact bigint NOT NULL,
    payment_ts timestamp with time zone NOT NULL,
    voided boolean NOT NULL,
    amount numeric(6,2) NOT NULL,
    note text,
    payment_type text NOT NULL,
    accepting_usr integer,
    cash_drawer integer,
    billing bigint
);


ALTER TABLE money.aged_payment OWNER TO evergreen;

--
-- Name: all_billings; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.all_billings AS
 SELECT billing.id,
    billing.xact,
    billing.billing_ts,
    billing.voided,
    billing.voider,
    billing.void_time,
    billing.amount,
    billing.billing_type,
    billing.btype,
    billing.note
   FROM money.billing
UNION ALL
 SELECT aged_billing.id,
    aged_billing.xact,
    aged_billing.billing_ts,
    aged_billing.voided,
    aged_billing.voider,
    aged_billing.void_time,
    aged_billing.amount,
    aged_billing.billing_type,
    aged_billing.btype,
    aged_billing.note
   FROM money.aged_billing;


ALTER TABLE money.all_billings OWNER TO evergreen;

--
-- Name: bnm_desk_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.bnm_desk_payment (
    cash_drawer integer
)
INHERITS (money.bnm_payment);


ALTER TABLE money.bnm_desk_payment OWNER TO evergreen;

--
-- Name: payment_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.payment_view AS
 SELECT p.id,
    p.xact,
    p.payment_ts,
    p.voided,
    p.amount,
    p.note,
    c.relname AS payment_type
   FROM (money.payment p
     JOIN pg_class c ON ((p.tableoid = c.oid)));


ALTER TABLE money.payment_view OWNER TO evergreen;

--
-- Name: payment_view_for_aging; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.payment_view_for_aging AS
 SELECT p.id,
    p.xact,
    p.payment_ts,
    p.voided,
    p.amount,
    p.note,
    p.payment_type,
    bnm.accepting_usr,
    bnmd.cash_drawer,
    maa.billing
   FROM (((money.payment_view p
     LEFT JOIN money.bnm_payment bnm ON ((bnm.id = p.id)))
     LEFT JOIN money.bnm_desk_payment bnmd ON ((bnmd.id = p.id)))
     LEFT JOIN money.account_adjustment maa ON ((maa.id = p.id)));


ALTER TABLE money.payment_view_for_aging OWNER TO evergreen;

--
-- Name: all_payments; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.all_payments AS
 SELECT payment_view_for_aging.id,
    payment_view_for_aging.xact,
    payment_view_for_aging.payment_ts,
    payment_view_for_aging.voided,
    payment_view_for_aging.amount,
    payment_view_for_aging.note,
    payment_view_for_aging.payment_type,
    payment_view_for_aging.accepting_usr,
    payment_view_for_aging.cash_drawer,
    payment_view_for_aging.billing
   FROM money.payment_view_for_aging
UNION ALL
 SELECT aged_payment.id,
    aged_payment.xact,
    aged_payment.payment_ts,
    aged_payment.voided,
    aged_payment.amount,
    aged_payment.note,
    aged_payment.payment_type,
    aged_payment.accepting_usr,
    aged_payment.cash_drawer,
    aged_payment.billing
   FROM money.aged_payment;


ALTER TABLE money.all_payments OWNER TO evergreen;

--
-- Name: materialized_billable_xact_summary; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.materialized_billable_xact_summary (
    id bigint NOT NULL,
    usr integer,
    xact_start timestamp with time zone,
    xact_finish timestamp with time zone,
    total_paid numeric,
    last_payment_ts timestamp with time zone,
    last_payment_note text,
    last_payment_type name,
    total_owed numeric,
    last_billing_ts timestamp with time zone,
    last_billing_note text,
    last_billing_type text,
    balance_owed numeric,
    xact_type name
);


ALTER TABLE money.materialized_billable_xact_summary OWNER TO evergreen;

--
-- Name: billable_xact_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.billable_xact_summary AS
 SELECT materialized_billable_xact_summary.id,
    materialized_billable_xact_summary.usr,
    materialized_billable_xact_summary.xact_start,
    materialized_billable_xact_summary.xact_finish,
    materialized_billable_xact_summary.total_paid,
    materialized_billable_xact_summary.last_payment_ts,
    materialized_billable_xact_summary.last_payment_note,
    materialized_billable_xact_summary.last_payment_type,
    materialized_billable_xact_summary.total_owed,
    materialized_billable_xact_summary.last_billing_ts,
    materialized_billable_xact_summary.last_billing_note,
    materialized_billable_xact_summary.last_billing_type,
    materialized_billable_xact_summary.balance_owed,
    materialized_billable_xact_summary.xact_type
   FROM money.materialized_billable_xact_summary;


ALTER TABLE money.billable_xact_summary OWNER TO evergreen;

--
-- Name: grocery; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.grocery (
    billing_location integer NOT NULL,
    note text
)
INHERITS (money.billable_xact);


ALTER TABLE money.grocery OWNER TO evergreen;

--
-- Name: billable_xact_summary_location_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.billable_xact_summary_location_view AS
 SELECT m.id,
    m.usr,
    m.xact_start,
    m.xact_finish,
    m.total_paid,
    m.last_payment_ts,
    m.last_payment_note,
    m.last_payment_type,
    m.total_owed,
    m.last_billing_ts,
    m.last_billing_note,
    m.last_billing_type,
    m.balance_owed,
    m.xact_type,
    COALESCE(c.circ_lib, g.billing_location, r.pickup_lib) AS billing_location
   FROM (((money.materialized_billable_xact_summary m
     LEFT JOIN action.circulation c ON ((c.id = m.id)))
     LEFT JOIN money.grocery g ON ((g.id = m.id)))
     LEFT JOIN booking.reservation r ON ((r.id = m.id)));


ALTER TABLE money.billable_xact_summary_location_view OWNER TO evergreen;

--
-- Name: billable_xact_with_void_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.billable_xact_with_void_summary AS
 SELECT xact.id,
    xact.usr,
    xact.xact_start,
    xact.xact_finish,
    sum(credit.amount) AS total_paid,
    max(credit.payment_ts) AS last_payment_ts,
    public.last(credit.note) AS last_payment_note,
    public.last(credit.payment_type) AS last_payment_type,
    sum(debit.amount) AS total_owed,
    max(debit.billing_ts) AS last_billing_ts,
    public.last(debit.note) AS last_billing_note,
    public.last(debit.billing_type) AS last_billing_type,
    (COALESCE(sum(debit.amount), (0)::numeric) - COALESCE(sum(credit.amount), (0)::numeric)) AS balance_owed,
    p.relname AS xact_type
   FROM (((money.billable_xact xact
     JOIN pg_class p ON ((xact.tableoid = p.oid)))
     LEFT JOIN money.billing debit ON ((xact.id = debit.xact)))
     LEFT JOIN money.payment_view credit ON ((xact.id = credit.xact)))
  GROUP BY xact.id, xact.usr, xact.xact_start, xact.xact_finish, p.relname
  ORDER BY (max(debit.billing_ts)), (max(credit.payment_ts));


ALTER TABLE money.billable_xact_with_void_summary OWNER TO evergreen;

--
-- Name: bnm_payment_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.bnm_payment_view AS
 SELECT p.id,
    p.xact,
    p.payment_ts,
    p.voided,
    p.amount,
    p.note,
    p.amount_collected,
    p.accepting_usr,
    c.relname AS payment_type
   FROM (money.bnm_payment p
     JOIN pg_class c ON ((p.tableoid = c.oid)));


ALTER TABLE money.bnm_payment_view OWNER TO evergreen;

--
-- Name: cash_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.cash_payment (
)
INHERITS (money.bnm_desk_payment);


ALTER TABLE money.cash_payment OWNER TO evergreen;

--
-- Name: cashdrawer_payment_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.cashdrawer_payment_view AS
 SELECT ou.id AS org_unit,
    ws.id AS cashdrawer,
    t.payment_type,
    p.payment_ts,
    p.amount,
    p.voided,
    p.note
   FROM (((actor.org_unit ou
     JOIN actor.workstation ws ON ((ou.id = ws.owning_lib)))
     LEFT JOIN money.bnm_desk_payment p ON ((ws.id = p.cash_drawer)))
     LEFT JOIN money.payment_view t ON ((p.id = t.id)));


ALTER TABLE money.cashdrawer_payment_view OWNER TO evergreen;

--
-- Name: check_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.check_payment (
    check_number text NOT NULL
)
INHERITS (money.bnm_desk_payment);


ALTER TABLE money.check_payment OWNER TO evergreen;

--
-- Name: collections_tracker; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.collections_tracker (
    id bigint NOT NULL,
    usr integer NOT NULL,
    collector integer NOT NULL,
    location integer NOT NULL,
    enter_time timestamp with time zone
);


ALTER TABLE money.collections_tracker OWNER TO evergreen;

--
-- Name: collections_tracker_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE money.collections_tracker_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.collections_tracker_id_seq OWNER TO evergreen;

--
-- Name: collections_tracker_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE money.collections_tracker_id_seq OWNED BY money.collections_tracker.id;


--
-- Name: credit_card_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.credit_card_payment (
    cc_number text,
    cc_processor text,
    approval_code text,
    cc_order_number text
)
INHERITS (money.bnm_desk_payment);


ALTER TABLE money.credit_card_payment OWNER TO evergreen;

--
-- Name: credit_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.credit_payment (
)
INHERITS (money.bnm_payment);


ALTER TABLE money.credit_payment OWNER TO evergreen;

--
-- Name: debit_card_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.debit_card_payment (
)
INHERITS (money.bnm_desk_payment);


ALTER TABLE money.debit_card_payment OWNER TO evergreen;

--
-- Name: desk_payment_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.desk_payment_view AS
 SELECT p.id,
    p.xact,
    p.payment_ts,
    p.voided,
    p.amount,
    p.note,
    p.amount_collected,
    p.accepting_usr,
    p.cash_drawer,
    c.relname AS payment_type
   FROM (money.bnm_desk_payment p
     JOIN pg_class c ON ((p.tableoid = c.oid)));


ALTER TABLE money.desk_payment_view OWNER TO evergreen;

--
-- Name: refundable_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.refundable_payment (
    id integer NOT NULL,
    refundable_xact bigint NOT NULL,
    payment bigint NOT NULL,
    payment_ou bigint NOT NULL,
    final_payment boolean DEFAULT true NOT NULL,
    receipt_number integer NOT NULL,
    refunded_via text,
    staff_name text NOT NULL,
    staff_email text NOT NULL,
    CONSTRAINT valid_refunded_via CHECK (((refunded_via IS NULL) OR (refunded_via = ANY (ARRAY['check'::text, 'credit_card'::text]))))
);


ALTER TABLE money.refundable_payment OWNER TO evergreen;

--
-- Name: refundable_xact; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.refundable_xact (
    id integer NOT NULL,
    xact bigint,
    item_price numeric(8,2) DEFAULT 0 NOT NULL,
    refund_amount numeric(8,2),
    notes text,
    usr_first_name text NOT NULL,
    usr_middle_name text,
    usr_family_name text NOT NULL,
    usr_barcode text NOT NULL,
    usr_street1 text NOT NULL,
    usr_street2 text,
    usr_city text NOT NULL,
    usr_state text NOT NULL,
    usr_post_code text NOT NULL,
    approve_date timestamp with time zone,
    approved_by integer,
    reject_date timestamp with time zone,
    rejected_by integer,
    pause_date timestamp with time zone,
    paused_by integer,
    refund_session integer,
    erp_export_date timestamp with time zone
);


ALTER TABLE money.refundable_xact OWNER TO evergreen;

--
-- Name: eligible_refundable_xact; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.eligible_refundable_xact AS
 WITH potential_xacts AS (
         SELECT mrx_1.id,
            mrx_1.xact,
            mrx_1.item_price,
            mrx_1.refund_amount,
            mrx_1.notes,
            mrx_1.usr_first_name,
            mrx_1.usr_middle_name,
            mrx_1.usr_family_name,
            mrx_1.usr_barcode,
            mrx_1.usr_street1,
            mrx_1.usr_street2,
            mrx_1.usr_city,
            mrx_1.usr_state,
            mrx_1.usr_post_code,
            mrx_1.approve_date,
            mrx_1.approved_by,
            mrx_1.reject_date,
            mrx_1.rejected_by,
            mrx_1.pause_date,
            mrx_1.paused_by,
            mrx_1.refund_session,
            mrx_1.erp_export_date
           FROM (money.refundable_xact mrx_1
             JOIN action.circulation circ ON ((circ.id = mrx_1.xact)))
          WHERE ((mrx_1.refund_session IS NULL) AND (circ.checkin_time IS NOT NULL) AND (circ.xact_finish IS NULL))
        )
 SELECT DISTINCT mrx.id,
    mrx.xact,
    mrx.item_price,
    mrx.refund_amount,
    mrx.notes,
    mrx.usr_first_name,
    mrx.usr_middle_name,
    mrx.usr_family_name,
    mrx.usr_barcode,
    mrx.usr_street1,
    mrx.usr_street2,
    mrx.usr_city,
    mrx.usr_state,
    mrx.usr_post_code,
    mrx.approve_date,
    mrx.approved_by,
    mrx.reject_date,
    mrx.rejected_by,
    mrx.pause_date,
    mrx.paused_by,
    mrx.refund_session,
    mrx.erp_export_date,
    au.home_ou AS patron_home_ou
   FROM (((((potential_xacts mrx
     JOIN money.billable_xact mbt ON ((mbt.id = mrx.xact)))
     JOIN actor.usr au ON ((au.id = mbt.usr)))
     JOIN money.refundable_payment mrp ON ((mrp.refundable_xact = mrx.id)))
     JOIN money.payment pay ON ((pay.id = mrp.payment)))
     JOIN config.global_flag cgf ON ((cgf.name = 'circ.lostpaid.refund.max_return.interval'::text)))
  WHERE (cgf.enabled AND (pay.payment_ts > (now() - (cgf.value)::interval)));


ALTER TABLE money.eligible_refundable_xact OWNER TO evergreen;

--
-- Name: forgive_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.forgive_payment (
)
INHERITS (money.bnm_payment);


ALTER TABLE money.forgive_payment OWNER TO evergreen;

--
-- Name: goods_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.goods_payment (
)
INHERITS (money.bnm_payment);


ALTER TABLE money.goods_payment OWNER TO evergreen;

--
-- Name: non_drawer_payment_view; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.non_drawer_payment_view AS
 SELECT p.id,
    p.xact,
    p.payment_ts,
    p.voided,
    p.amount,
    p.note,
    p.amount_collected,
    p.accepting_usr,
    c.relname AS payment_type
   FROM (money.bnm_payment p
     JOIN pg_class c ON ((p.tableoid = c.oid)))
  WHERE (c.relname <> ALL (ARRAY['cash_payment'::name, 'check_payment'::name, 'credit_card_payment'::name, 'debit_card_payment'::name]));


ALTER TABLE money.non_drawer_payment_view OWNER TO evergreen;

--
-- Name: open_circ_balance_by_circ_and_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_circ_balance_by_circ_and_owning_lib AS
 SELECT circ.id,
    circ.circ_lib,
    cn.owning_lib,
    bill.billing_type,
    sum(bill.amount) AS billed
   FROM (((action.circulation circ
     JOIN money.billing bill ON ((circ.id = bill.xact)))
     JOIN asset.copy cp ON ((circ.target_copy = cp.id)))
     JOIN asset.call_number cn ON ((cn.id = cp.call_number)))
  WHERE ((circ.xact_finish IS NULL) AND (NOT bill.voided))
  GROUP BY circ.id, circ.circ_lib, cn.owning_lib, bill.billing_type
  ORDER BY circ.id, circ.circ_lib, cn.owning_lib, bill.billing_type;


ALTER TABLE money.open_circ_balance_by_circ_and_owning_lib OWNER TO evergreen;

--
-- Name: open_balance_by_circ_and_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_balance_by_circ_and_owning_lib AS
 SELECT x.circ_lib,
    x.owning_lib,
    array_to_string(array_agg(DISTINCT x.billing_type), ', '::text) AS billing_types,
    (sum(x.billed) - sum(COALESCE(( SELECT sum(payment.amount) AS paid
           FROM money.payment
          WHERE ((NOT payment.voided) AND (payment.xact = x.id))), (0)::numeric))) AS balance
   FROM money.open_circ_balance_by_circ_and_owning_lib x
  GROUP BY x.circ_lib, x.owning_lib;


ALTER TABLE money.open_balance_by_circ_and_owning_lib OWNER TO evergreen;

--
-- Name: open_circ_balance_by_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_circ_balance_by_owning_lib AS
 SELECT circ.id,
    cn.owning_lib,
    bill.billing_type,
    sum(bill.amount) AS billed
   FROM (((action.circulation circ
     JOIN money.billing bill ON ((circ.id = bill.xact)))
     JOIN asset.copy cp ON ((circ.target_copy = cp.id)))
     JOIN asset.call_number cn ON ((cn.id = cp.call_number)))
  WHERE ((circ.xact_finish IS NULL) AND (NOT bill.voided))
  GROUP BY circ.id, cn.owning_lib, bill.billing_type
  ORDER BY circ.id, cn.owning_lib, bill.billing_type;


ALTER TABLE money.open_circ_balance_by_owning_lib OWNER TO evergreen;

--
-- Name: open_balance_by_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_balance_by_owning_lib AS
 SELECT x.owning_lib,
    array_to_string(array_agg(DISTINCT x.billing_type), ', '::text) AS billing_types,
    (sum(x.billed) - sum(COALESCE(( SELECT sum(payment.amount) AS paid
           FROM money.payment
          WHERE ((NOT payment.voided) AND (payment.xact = x.id))), (0)::numeric))) AS balance
   FROM money.open_circ_balance_by_owning_lib x
  GROUP BY x.owning_lib;


ALTER TABLE money.open_balance_by_owning_lib OWNER TO evergreen;

--
-- Name: open_circ_balance_by_usr_home_and_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_circ_balance_by_usr_home_and_owning_lib AS
 SELECT circ.id,
    usr.home_ou,
    cn.owning_lib,
    bill.billing_type,
    sum(bill.amount) AS billed
   FROM ((((action.circulation circ
     JOIN money.billing bill ON ((circ.id = bill.xact)))
     JOIN asset.copy cp ON ((circ.target_copy = cp.id)))
     JOIN asset.call_number cn ON ((cn.id = cp.call_number)))
     JOIN actor.usr usr ON ((circ.usr = usr.id)))
  WHERE ((circ.xact_finish IS NULL) AND (NOT bill.voided))
  GROUP BY circ.id, usr.home_ou, cn.owning_lib, bill.billing_type
  ORDER BY circ.id, usr.home_ou, cn.owning_lib, bill.billing_type;


ALTER TABLE money.open_circ_balance_by_usr_home_and_owning_lib OWNER TO evergreen;

--
-- Name: open_balance_by_usr_home_and_owning_lib; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_balance_by_usr_home_and_owning_lib AS
 SELECT x.home_ou,
    x.owning_lib,
    array_to_string(array_agg(DISTINCT x.billing_type), ', '::text) AS billing_types,
    (sum(x.billed) - sum(COALESCE(( SELECT sum(payment.amount) AS paid
           FROM money.payment
          WHERE ((NOT payment.voided) AND (payment.xact = x.id))), (0)::numeric))) AS balance
   FROM money.open_circ_balance_by_usr_home_and_owning_lib x
  GROUP BY x.home_ou, x.owning_lib;


ALTER TABLE money.open_balance_by_usr_home_and_owning_lib OWNER TO evergreen;

--
-- Name: open_billable_xact_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_billable_xact_summary AS
 SELECT billable_xact_summary_location_view.id,
    billable_xact_summary_location_view.usr,
    billable_xact_summary_location_view.xact_start,
    billable_xact_summary_location_view.xact_finish,
    billable_xact_summary_location_view.total_paid,
    billable_xact_summary_location_view.last_payment_ts,
    billable_xact_summary_location_view.last_payment_note,
    billable_xact_summary_location_view.last_payment_type,
    billable_xact_summary_location_view.total_owed,
    billable_xact_summary_location_view.last_billing_ts,
    billable_xact_summary_location_view.last_billing_note,
    billable_xact_summary_location_view.last_billing_type,
    billable_xact_summary_location_view.balance_owed,
    billable_xact_summary_location_view.xact_type,
    billable_xact_summary_location_view.billing_location
   FROM money.billable_xact_summary_location_view
  WHERE (billable_xact_summary_location_view.xact_finish IS NULL);


ALTER TABLE money.open_billable_xact_summary OWNER TO evergreen;

--
-- Name: open_transaction_billing_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_transaction_billing_summary AS
 SELECT billing.xact,
    public.last(billing.billing_type) AS last_billing_type,
    public.last(billing.note) AS last_billing_note,
    max(billing.billing_ts) AS last_billing_ts,
    sum(COALESCE(billing.amount, (0)::numeric)) AS total_owed
   FROM money.billing
  WHERE (billing.voided IS FALSE)
  GROUP BY billing.xact
  ORDER BY (max(billing.billing_ts));


ALTER TABLE money.open_transaction_billing_summary OWNER TO evergreen;

--
-- Name: open_transaction_billing_type_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_transaction_billing_type_summary AS
 SELECT billing.xact,
    billing.billing_type AS last_billing_type,
    public.last(billing.note) AS last_billing_note,
    max(billing.billing_ts) AS last_billing_ts,
    sum(COALESCE(billing.amount, (0)::numeric)) AS total_owed
   FROM money.billing
  WHERE (billing.voided IS FALSE)
  GROUP BY billing.xact, billing.billing_type
  ORDER BY (max(billing.billing_ts));


ALTER TABLE money.open_transaction_billing_type_summary OWNER TO evergreen;

--
-- Name: open_transaction_payment_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_transaction_payment_summary AS
 SELECT payment_view.xact,
    public.last(payment_view.payment_type) AS last_payment_type,
    public.last(payment_view.note) AS last_payment_note,
    max(payment_view.payment_ts) AS last_payment_ts,
    sum(COALESCE(payment_view.amount, (0)::numeric)) AS total_paid
   FROM money.payment_view
  WHERE (payment_view.voided IS FALSE)
  GROUP BY payment_view.xact
  ORDER BY (max(payment_view.payment_ts));


ALTER TABLE money.open_transaction_payment_summary OWNER TO evergreen;

--
-- Name: open_usr_circulation_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_usr_circulation_summary AS
 SELECT materialized_billable_xact_summary.usr,
    sum(materialized_billable_xact_summary.total_paid) AS total_paid,
    sum(materialized_billable_xact_summary.total_owed) AS total_owed,
    sum(materialized_billable_xact_summary.balance_owed) AS balance_owed
   FROM money.materialized_billable_xact_summary
  WHERE ((materialized_billable_xact_summary.xact_type = 'circulation'::name) AND (materialized_billable_xact_summary.xact_finish IS NULL))
  GROUP BY materialized_billable_xact_summary.usr;


ALTER TABLE money.open_usr_circulation_summary OWNER TO evergreen;

--
-- Name: open_usr_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_usr_summary AS
 SELECT materialized_billable_xact_summary.usr,
    sum(materialized_billable_xact_summary.total_paid) AS total_paid,
    sum(materialized_billable_xact_summary.total_owed) AS total_owed,
    sum(materialized_billable_xact_summary.balance_owed) AS balance_owed
   FROM money.materialized_billable_xact_summary
  WHERE (materialized_billable_xact_summary.xact_finish IS NULL)
  GROUP BY materialized_billable_xact_summary.usr;


ALTER TABLE money.open_usr_summary OWNER TO evergreen;

--
-- Name: open_with_balance_usr_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.open_with_balance_usr_summary AS
 SELECT materialized_billable_xact_summary.usr,
    sum(materialized_billable_xact_summary.total_paid) AS total_paid,
    sum(materialized_billable_xact_summary.total_owed) AS total_owed,
    sum(materialized_billable_xact_summary.balance_owed) AS balance_owed
   FROM money.materialized_billable_xact_summary
  WHERE ((materialized_billable_xact_summary.xact_finish IS NULL) AND (materialized_billable_xact_summary.balance_owed <> 0.0))
  GROUP BY materialized_billable_xact_summary.usr;


ALTER TABLE money.open_with_balance_usr_summary OWNER TO evergreen;

--
-- Name: refund_action; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.refund_action (
    id integer NOT NULL,
    session integer NOT NULL,
    refundable_xact integer NOT NULL,
    action text NOT NULL,
    payment bigint NOT NULL,
    CONSTRAINT valid_refund_action CHECK ((action = ANY (ARRAY['credit'::text, 'debit'::text])))
);


ALTER TABLE money.refund_action OWNER TO evergreen;

--
-- Name: refund_action_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE money.refund_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.refund_action_id_seq OWNER TO evergreen;

--
-- Name: refund_action_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE money.refund_action_id_seq OWNED BY money.refund_action.id;


--
-- Name: refund_session; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.refund_session (
    id integer NOT NULL,
    run_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE money.refund_session OWNER TO evergreen;

--
-- Name: refund_session_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE money.refund_session_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.refund_session_id_seq OWNER TO evergreen;

--
-- Name: refund_session_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE money.refund_session_id_seq OWNED BY money.refund_session.id;


--
-- Name: refundable_payment_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE money.refundable_payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.refundable_payment_id_seq OWNER TO evergreen;

--
-- Name: refundable_payment_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE money.refundable_payment_id_seq OWNED BY money.refundable_payment.id;


--
-- Name: refundable_payment_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.refundable_payment_summary AS
 SELECT mrp.id,
    mrp.refundable_xact,
    mrp.payment,
    mrp.payment_ou,
    mrp.final_payment,
    mrp.receipt_number,
    mrp.refunded_via,
    mrp.staff_name,
    mrp.staff_email,
    (aou.shortname || lpad((mrp.receipt_number)::text, 6, '0'::text)) AS receipt_code,
    pay.payment_ts AS payment_time,
    pay.amount,
    pay.payment_type,
    aws.name AS workstation,
    ccp.cc_order_number
   FROM (((((money.refundable_payment mrp
     JOIN money.payment_view pay ON ((pay.id = mrp.payment)))
     JOIN actor.org_unit aou ON ((aou.id = mrp.payment_ou)))
     LEFT JOIN money.cash_payment cash ON ((cash.id = pay.id)))
     LEFT JOIN actor.workstation aws ON ((aws.id = cash.cash_drawer)))
     LEFT JOIN money.credit_card_payment ccp ON ((ccp.id = pay.id)));


ALTER TABLE money.refundable_payment_summary OWNER TO evergreen;

--
-- Name: refundable_xact_id_seq; Type: SEQUENCE; Schema: money; Owner: evergreen
--

CREATE SEQUENCE money.refundable_xact_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE money.refundable_xact_id_seq OWNER TO evergreen;

--
-- Name: refundable_xact_id_seq; Type: SEQUENCE OWNED BY; Schema: money; Owner: evergreen
--

ALTER SEQUENCE money.refundable_xact_id_seq OWNED BY money.refundable_xact.id;


--
-- Name: materialized_simple_record; Type: TABLE; Schema: reporter; Owner: evergreen
--

CREATE TABLE reporter.materialized_simple_record (
    id bigint NOT NULL,
    fingerprint text,
    quality integer,
    tcn_source text,
    tcn_value text,
    title text,
    author text,
    publisher text,
    pubdate text,
    isbn text[],
    issn text[],
    title_proper text
);


ALTER TABLE reporter.materialized_simple_record OWNER TO evergreen;

--
-- Name: refundable_xact_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.refundable_xact_summary AS
 SELECT xact.id,
    xact.xact,
    xact.item_price,
    xact.refund_amount,
    xact.notes,
    xact.usr_first_name,
    xact.usr_middle_name,
    xact.usr_family_name,
    xact.usr_barcode,
    xact.usr_street1,
    xact.usr_street2,
    xact.usr_city,
    xact.usr_state,
    xact.usr_post_code,
    xact.approve_date,
    xact.approved_by,
    xact.reject_date,
    xact.rejected_by,
    xact.pause_date,
    xact.paused_by,
    xact.refund_session,
    xact.erp_export_date,
    acp.id AS copy,
    acp.barcode AS copy_barcode,
    acn.label AS call_number,
        CASE
            WHEN (acn.id = '-1'::integer) THEN acp.dummy_title
            ELSE rsr.title
        END AS title,
    circ.usr,
    circ.xact_start,
    circ.xact_finish,
    summary.total_owed,
    summary.balance_owed,
    (refundable_paid.amount)::numeric(8,2) AS refundable_paid,
    (total_paid.amount)::numeric(8,2) AS total_paid,
    (total_refunded.amount)::numeric(8,2) AS total_refunded,
    refundable_payment_count.count AS num_refundable_payments
   FROM (((((((((money.refundable_xact xact
     JOIN action.circulation circ ON ((circ.id = xact.xact)))
     JOIN asset.copy acp ON ((acp.id = circ.target_copy)))
     JOIN asset.call_number acn ON ((acn.id = acp.call_number)))
     JOIN reporter.materialized_simple_record rsr ON ((rsr.id = acn.record)))
     JOIN money.materialized_billable_xact_summary summary ON ((summary.id = xact.xact)))
     JOIN ( SELECT pay.xact,
            sum(pay.amount) AS amount
           FROM money.payment pay
          WHERE (pay.amount > (0)::numeric)
          GROUP BY pay.xact) total_paid ON ((total_paid.xact = xact.xact)))
     JOIN ( SELECT mrp.refundable_xact,
            sum(pay.amount) AS amount
           FROM (money.refundable_payment mrp
             JOIN money.payment pay ON ((mrp.payment = pay.id)))
          GROUP BY mrp.refundable_xact) refundable_paid ON ((refundable_paid.refundable_xact = xact.id)))
     LEFT JOIN ( SELECT pay.xact,
            (- sum(pay.amount)) AS amount
           FROM money.cash_payment pay
          WHERE (pay.amount < (0)::numeric)
          GROUP BY pay.xact) total_refunded ON ((total_refunded.xact = xact.xact)))
     JOIN ( SELECT count(*) AS count,
            mrp.refundable_xact
           FROM money.refundable_payment mrp
          GROUP BY mrp.refundable_xact) refundable_payment_count ON ((refundable_payment_count.refundable_xact = xact.id)));


ALTER TABLE money.refundable_xact_summary OWNER TO evergreen;

--
-- Name: tmp_billable_xact_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.tmp_billable_xact_summary AS
 SELECT xact.id,
    xact.usr,
    xact.xact_start,
    xact.xact_finish,
    COALESCE(credit.amount, 0.0) AS total_paid,
    credit.payment_ts AS last_payment_ts,
    credit.note AS last_payment_note,
    credit.payment_type AS last_payment_type,
    COALESCE(debit.amount, 0.0) AS total_owed,
    debit.billing_ts AS last_billing_ts,
    debit.note AS last_billing_note,
    debit.billing_type AS last_billing_type,
    (COALESCE(debit.amount, 0.0) - COALESCE(credit.amount, 0.0)) AS balance_owed,
    p.relname AS xact_type
   FROM (((money.billable_xact xact
     JOIN pg_class p ON ((xact.tableoid = p.oid)))
     LEFT JOIN ( SELECT billing.xact,
            sum(billing.amount) AS amount,
            max(billing.billing_ts) AS billing_ts,
            public.last(billing.note) AS note,
            public.last(billing.billing_type) AS billing_type
           FROM money.billing
          WHERE (billing.voided IS FALSE)
          GROUP BY billing.xact) debit ON ((xact.id = debit.xact)))
     LEFT JOIN ( SELECT payment_view.xact,
            sum(payment_view.amount) AS amount,
            max(payment_view.payment_ts) AS payment_ts,
            public.last(payment_view.note) AS note,
            public.last(payment_view.payment_type) AS payment_type
           FROM money.payment_view
          WHERE (payment_view.voided IS FALSE)
          GROUP BY payment_view.xact) credit ON ((xact.id = credit.xact)))
  ORDER BY debit.billing_ts, credit.payment_ts;


ALTER TABLE money.tmp_billable_xact_summary OWNER TO evergreen;

--
-- Name: transaction_billing_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.transaction_billing_summary AS
 SELECT materialized_billable_xact_summary.id AS xact,
    materialized_billable_xact_summary.last_billing_type,
    materialized_billable_xact_summary.last_billing_note,
    materialized_billable_xact_summary.last_billing_ts,
    materialized_billable_xact_summary.total_owed
   FROM money.materialized_billable_xact_summary;


ALTER TABLE money.transaction_billing_summary OWNER TO evergreen;

--
-- Name: transaction_billing_type_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.transaction_billing_type_summary AS
 SELECT billing.xact,
    billing.billing_type AS last_billing_type,
    public.last(billing.note) AS last_billing_note,
    max(billing.billing_ts) AS last_billing_ts,
    sum(COALESCE(billing.amount, (0)::numeric)) AS total_owed
   FROM money.billing
  WHERE (billing.voided IS FALSE)
  GROUP BY billing.xact, billing.billing_type
  ORDER BY (max(billing.billing_ts));


ALTER TABLE money.transaction_billing_type_summary OWNER TO evergreen;

--
-- Name: transaction_billing_with_void_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.transaction_billing_with_void_summary AS
 SELECT billing.xact,
    public.last(billing.billing_type) AS last_billing_type,
    public.last(billing.note) AS last_billing_note,
    max(billing.billing_ts) AS last_billing_ts,
    sum(
        CASE
            WHEN billing.voided THEN (0)::numeric
            ELSE COALESCE(billing.amount, (0)::numeric)
        END) AS total_owed
   FROM money.billing
  GROUP BY billing.xact
  ORDER BY (max(billing.billing_ts));


ALTER TABLE money.transaction_billing_with_void_summary OWNER TO evergreen;

--
-- Name: transaction_payment_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.transaction_payment_summary AS
 SELECT payment_view.xact,
    public.last(payment_view.payment_type) AS last_payment_type,
    public.last(payment_view.note) AS last_payment_note,
    max(payment_view.payment_ts) AS last_payment_ts,
    sum(COALESCE(payment_view.amount, (0)::numeric)) AS total_paid
   FROM money.payment_view
  WHERE (payment_view.voided IS FALSE)
  GROUP BY payment_view.xact
  ORDER BY (max(payment_view.payment_ts));


ALTER TABLE money.transaction_payment_summary OWNER TO evergreen;

--
-- Name: transaction_payment_with_void_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.transaction_payment_with_void_summary AS
 SELECT payment_view.xact,
    public.last(payment_view.payment_type) AS last_payment_type,
    public.last(payment_view.note) AS last_payment_note,
    max(payment_view.payment_ts) AS last_payment_ts,
    sum(
        CASE
            WHEN payment_view.voided THEN (0)::numeric
            ELSE COALESCE(payment_view.amount, (0)::numeric)
        END) AS total_paid
   FROM money.payment_view
  GROUP BY payment_view.xact
  ORDER BY (max(payment_view.payment_ts));


ALTER TABLE money.transaction_payment_with_void_summary OWNER TO evergreen;

--
-- Name: usr_circulation_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.usr_circulation_summary AS
 SELECT billable_xact_summary.usr,
    sum(billable_xact_summary.total_paid) AS total_paid,
    sum(billable_xact_summary.total_owed) AS total_owed,
    sum(billable_xact_summary.balance_owed) AS balance_owed
   FROM money.billable_xact_summary
  WHERE (billable_xact_summary.xact_type = 'circulation'::name)
  GROUP BY billable_xact_summary.usr;


ALTER TABLE money.usr_circulation_summary OWNER TO evergreen;

--
-- Name: usr_summary; Type: VIEW; Schema: money; Owner: evergreen
--

CREATE VIEW money.usr_summary AS
 SELECT materialized_billable_xact_summary.usr,
    sum(materialized_billable_xact_summary.total_paid) AS total_paid,
    sum(materialized_billable_xact_summary.total_owed) AS total_owed,
    sum(materialized_billable_xact_summary.balance_owed) AS balance_owed
   FROM money.materialized_billable_xact_summary
  GROUP BY materialized_billable_xact_summary.usr;


ALTER TABLE money.usr_summary OWNER TO evergreen;

--
-- Name: work_payment; Type: TABLE; Schema: money; Owner: evergreen
--

CREATE TABLE money.work_payment (
)
INHERITS (money.bnm_payment);


ALTER TABLE money.work_payment OWNER TO evergreen;

--
-- Name: authority; Type: VIEW; Schema: oai; Owner: evergreen
--

CREATE VIEW oai.authority AS
 SELECT are.id AS rec_id,
    timezone('UTC'::text, are.edit_date) AS datestamp,
    are.deleted
   FROM authority.record_entry are
  ORDER BY are.id;


ALTER TABLE oai.authority OWNER TO evergreen;

--
-- Name: biblio; Type: VIEW; Schema: oai; Owner: evergreen
--

CREATE VIEW oai.biblio AS
 SELECT bre.id AS rec_id,
    timezone('UTC'::text, bre.edit_date) AS datestamp,
    bre.deleted
   FROM biblio.record_entry bre
  ORDER BY bre.id;


ALTER TABLE oai.biblio OWNER TO evergreen;

--
-- Name: script; Type: TABLE; Schema: offline; Owner: evergreen
--

CREATE TABLE offline.script (
    id integer NOT NULL,
    session text NOT NULL,
    requestor integer NOT NULL,
    create_time integer NOT NULL,
    workstation text NOT NULL,
    logfile text NOT NULL,
    time_delta integer DEFAULT 0 NOT NULL,
    count integer DEFAULT 0 NOT NULL
);


ALTER TABLE offline.script OWNER TO evergreen;

--
-- Name: script_hs19982; Type: TABLE; Schema: offline; Owner: evergreen
--

CREATE TABLE offline.script_hs19982 (
    id integer,
    session text,
    requestor integer,
    create_time integer,
    workstation text,
    logfile text,
    time_delta integer,
    count integer
);


ALTER TABLE offline.script_hs19982 OWNER TO evergreen;

--
-- Name: script_id_seq; Type: SEQUENCE; Schema: offline; Owner: evergreen
--

CREATE SEQUENCE offline.script_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE offline.script_id_seq OWNER TO evergreen;

--
-- Name: script_id_seq; Type: SEQUENCE OWNED BY; Schema: offline; Owner: evergreen
--

ALTER SEQUENCE offline.script_id_seq OWNED BY offline.script.id;


--
-- Name: session; Type: TABLE; Schema: offline; Owner: evergreen
--

CREATE TABLE offline.session (
    key text NOT NULL,
    org integer NOT NULL,
    description text,
    creator integer NOT NULL,
    create_time integer NOT NULL,
    in_process integer DEFAULT 0 NOT NULL,
    start_time integer,
    end_time integer,
    num_complete integer DEFAULT 0 NOT NULL
);


ALTER TABLE offline.session OWNER TO evergreen;

--
-- Name: session_hs19982; Type: TABLE; Schema: offline; Owner: evergreen
--

CREATE TABLE offline.session_hs19982 (
    key text,
    org integer,
    description text,
    creator integer,
    create_time integer,
    in_process integer,
    start_time integer,
    end_time integer,
    num_complete integer
);


ALTER TABLE offline.session_hs19982 OWNER TO evergreen;

--
-- Name: grp_penalty_threshold; Type: TABLE; Schema: permission; Owner: evergreen
--

CREATE TABLE permission.grp_penalty_threshold (
    id integer NOT NULL,
    grp integer NOT NULL,
    org_unit integer NOT NULL,
    penalty integer NOT NULL,
    threshold numeric(8,2) NOT NULL
);


ALTER TABLE permission.grp_penalty_threshold OWNER TO evergreen;

--
-- Name: grp_penalty_threshold_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE permission.grp_penalty_threshold_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.grp_penalty_threshold_id_seq OWNER TO evergreen;

--
-- Name: grp_penalty_threshold_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE permission.grp_penalty_threshold_id_seq OWNED BY permission.grp_penalty_threshold.id;


--
-- Name: grp_perm_map; Type: TABLE; Schema: permission; Owner: evergreen
--

CREATE TABLE permission.grp_perm_map (
    id integer NOT NULL,
    grp integer NOT NULL,
    perm integer NOT NULL,
    depth integer NOT NULL,
    grantable boolean DEFAULT false NOT NULL
);


ALTER TABLE permission.grp_perm_map OWNER TO evergreen;

--
-- Name: grp_perm_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE permission.grp_perm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.grp_perm_map_id_seq OWNER TO evergreen;

--
-- Name: grp_perm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE permission.grp_perm_map_id_seq OWNED BY permission.grp_perm_map.id;


--
-- Name: grp_tree_display_entry; Type: TABLE; Schema: permission; Owner: evergreen
--

CREATE TABLE permission.grp_tree_display_entry (
    id integer NOT NULL,
    "position" integer NOT NULL,
    org integer NOT NULL,
    grp integer NOT NULL,
    parent integer
);


ALTER TABLE permission.grp_tree_display_entry OWNER TO evergreen;

--
-- Name: grp_tree_display_entry_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE permission.grp_tree_display_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.grp_tree_display_entry_id_seq OWNER TO evergreen;

--
-- Name: grp_tree_display_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE permission.grp_tree_display_entry_id_seq OWNED BY permission.grp_tree_display_entry.id;


--
-- Name: grp_tree_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE permission.grp_tree_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.grp_tree_id_seq OWNER TO evergreen;

--
-- Name: grp_tree_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE permission.grp_tree_id_seq OWNED BY permission.grp_tree.id;


--
-- Name: perm_list; Type: TABLE; Schema: permission; Owner: evergreen
--

CREATE TABLE permission.perm_list (
    id integer NOT NULL,
    code text NOT NULL,
    description text
);


ALTER TABLE permission.perm_list OWNER TO evergreen;

--
-- Name: perm_list_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE permission.perm_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.perm_list_id_seq OWNER TO evergreen;

--
-- Name: perm_list_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE permission.perm_list_id_seq OWNED BY permission.perm_list.id;


--
-- Name: usr_grp_map; Type: TABLE; Schema: permission; Owner: evergreen
--

CREATE TABLE permission.usr_grp_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    grp integer NOT NULL
);


ALTER TABLE permission.usr_grp_map OWNER TO evergreen;

--
-- Name: usr_grp_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE permission.usr_grp_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_grp_map_id_seq OWNER TO evergreen;

--
-- Name: usr_grp_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE permission.usr_grp_map_id_seq OWNED BY permission.usr_grp_map.id;


--
-- Name: usr_object_perm_map; Type: TABLE; Schema: permission; Owner: evergreen
--

CREATE TABLE permission.usr_object_perm_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    perm integer NOT NULL,
    object_type text NOT NULL,
    object_id text NOT NULL,
    grantable boolean DEFAULT false NOT NULL
);


ALTER TABLE permission.usr_object_perm_map OWNER TO evergreen;

--
-- Name: usr_object_perm_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE permission.usr_object_perm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_object_perm_map_id_seq OWNER TO evergreen;

--
-- Name: usr_object_perm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE permission.usr_object_perm_map_id_seq OWNED BY permission.usr_object_perm_map.id;


--
-- Name: usr_perm_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE permission.usr_perm_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_perm_map_id_seq OWNER TO evergreen;

--
-- Name: usr_perm_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE permission.usr_perm_map_id_seq OWNED BY permission.usr_perm_map.id;


--
-- Name: usr_work_ou_map; Type: TABLE; Schema: permission; Owner: evergreen
--

CREATE TABLE permission.usr_work_ou_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    work_ou integer NOT NULL
);


ALTER TABLE permission.usr_work_ou_map OWNER TO evergreen;

--
-- Name: usr_work_ou_map_id_seq; Type: SEQUENCE; Schema: permission; Owner: evergreen
--

CREATE SEQUENCE permission.usr_work_ou_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE permission.usr_work_ou_map_id_seq OWNER TO evergreen;

--
-- Name: usr_work_ou_map_id_seq; Type: SEQUENCE OWNED BY; Schema: permission; Owner: evergreen
--

ALTER SEQUENCE permission.usr_work_ou_map_id_seq OWNED BY permission.usr_work_ou_map.id;


--
-- Name: card; Type: TABLE; Schema: prod_staff_users; Owner: evergreen
--

CREATE TABLE prod_staff_users.card (
    id integer NOT NULL,
    usr integer NOT NULL,
    barcode text NOT NULL,
    active boolean NOT NULL
);


ALTER TABLE prod_staff_users.card OWNER TO evergreen;

--
-- Name: save_source; Type: TABLE; Schema: prod_staff_users; Owner: evergreen
--

CREATE TABLE prod_staff_users.save_source (
    barcode text,
    usrname text,
    fname text,
    lname text,
    passwd text
);


ALTER TABLE prod_staff_users.save_source OWNER TO evergreen;

--
-- Name: save_these; Type: TABLE; Schema: prod_staff_users; Owner: evergreen
--

CREATE TABLE prod_staff_users.save_these (
    id integer
);


ALTER TABLE prod_staff_users.save_these OWNER TO evergreen;

--
-- Name: usr; Type: TABLE; Schema: prod_staff_users; Owner: evergreen
--

CREATE TABLE prod_staff_users.usr (
    id integer NOT NULL,
    card integer,
    profile integer NOT NULL,
    usrname text NOT NULL,
    email text,
    passwd text NOT NULL,
    standing integer NOT NULL,
    ident_type integer NOT NULL,
    ident_value text,
    ident_type2 integer,
    ident_value2 text,
    net_access_level integer NOT NULL,
    photo_url text,
    prefix text,
    first_given_name text NOT NULL,
    second_given_name text,
    family_name text NOT NULL,
    suffix text,
    alias text,
    day_phone text,
    evening_phone text,
    other_phone text,
    mailing_address integer,
    billing_address integer,
    home_ou integer NOT NULL,
    dob timestamp with time zone,
    active boolean NOT NULL,
    master_account boolean NOT NULL,
    super_user boolean NOT NULL,
    barred boolean NOT NULL,
    deleted boolean NOT NULL,
    juvenile boolean NOT NULL,
    usrgroup integer NOT NULL,
    claims_returned_count integer NOT NULL,
    credit_forward_balance numeric(6,2) NOT NULL,
    last_xact_id text NOT NULL,
    alert_message text,
    create_date timestamp with time zone NOT NULL,
    expire_date timestamp with time zone NOT NULL,
    claims_never_checked_out_count integer NOT NULL
);


ALTER TABLE prod_staff_users.usr OWNER TO evergreen;

--
-- Name: usr_address; Type: TABLE; Schema: prod_staff_users; Owner: evergreen
--

CREATE TABLE prod_staff_users.usr_address (
    id integer NOT NULL,
    valid boolean NOT NULL,
    within_city_limits boolean NOT NULL,
    address_type text NOT NULL,
    usr integer NOT NULL,
    street1 text NOT NULL,
    street2 text,
    city text NOT NULL,
    county text,
    state text NOT NULL,
    country text NOT NULL,
    post_code text NOT NULL,
    pending boolean NOT NULL,
    replaces integer
);


ALTER TABLE prod_staff_users.usr_address OWNER TO evergreen;

--
-- Name: usr_perm_map; Type: TABLE; Schema: prod_staff_users; Owner: evergreen
--

CREATE TABLE prod_staff_users.usr_perm_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    perm integer NOT NULL,
    depth integer NOT NULL,
    grantable boolean NOT NULL
);


ALTER TABLE prod_staff_users.usr_perm_map OWNER TO evergreen;

--
-- Name: usr_setting; Type: TABLE; Schema: prod_staff_users; Owner: evergreen
--

CREATE TABLE prod_staff_users.usr_setting (
    id bigint NOT NULL,
    usr integer NOT NULL,
    name text NOT NULL,
    value text NOT NULL
);


ALTER TABLE prod_staff_users.usr_setting OWNER TO evergreen;

--
-- Name: usr_work_ou_map; Type: TABLE; Schema: prod_staff_users; Owner: evergreen
--

CREATE TABLE prod_staff_users.usr_work_ou_map (
    id integer NOT NULL,
    usr integer NOT NULL,
    work_ou integer NOT NULL
);


ALTER TABLE prod_staff_users.usr_work_ou_map OWNER TO evergreen;

--
-- Name: dupes2; Type: TABLE; Schema: public; Owner: evergreen
--

CREATE TABLE public.dupes2 (
    record bigint,
    value text
);


ALTER TABLE public.dupes2 OWNER TO evergreen;

--
-- Name: bind_variable; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.bind_variable (
    name text NOT NULL,
    type text NOT NULL,
    description text NOT NULL,
    default_value text,
    label text NOT NULL,
    CONSTRAINT bind_variable_type CHECK ((type = ANY (ARRAY['string'::text, 'number'::text, 'string_list'::text, 'number_list'::text])))
);


ALTER TABLE query.bind_variable OWNER TO evergreen;

--
-- Name: case_branch; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.case_branch (
    id integer NOT NULL,
    parent_expr integer NOT NULL,
    seq_no integer NOT NULL,
    condition integer,
    result integer NOT NULL
);


ALTER TABLE query.case_branch OWNER TO evergreen;

--
-- Name: case_branch_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.case_branch_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.case_branch_id_seq OWNER TO evergreen;

--
-- Name: case_branch_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.case_branch_id_seq OWNED BY query.case_branch.id;


--
-- Name: datatype; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.datatype (
    id integer NOT NULL,
    datatype_name text NOT NULL,
    is_numeric boolean DEFAULT false NOT NULL,
    is_composite boolean DEFAULT false NOT NULL,
    CONSTRAINT qdt_comp_not_num CHECK (((is_numeric IS FALSE) OR (is_composite IS FALSE)))
);


ALTER TABLE query.datatype OWNER TO evergreen;

--
-- Name: datatype_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.datatype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.datatype_id_seq OWNER TO evergreen;

--
-- Name: datatype_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.datatype_id_seq OWNED BY query.datatype.id;


--
-- Name: expression; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.expression (
    id integer NOT NULL,
    type text NOT NULL,
    parenthesize boolean DEFAULT false NOT NULL,
    parent_expr integer,
    seq_no integer DEFAULT 1 NOT NULL,
    literal text,
    table_alias text,
    column_name text,
    left_operand integer,
    operator text,
    right_operand integer,
    function_id integer,
    subquery integer,
    cast_type integer,
    negate boolean DEFAULT false NOT NULL,
    bind_variable text,
    CONSTRAINT expression_type CHECK ((type = ANY (ARRAY['xbet'::text, 'xbind'::text, 'xbool'::text, 'xcase'::text, 'xcast'::text, 'xcol'::text, 'xex'::text, 'xfunc'::text, 'xin'::text, 'xisnull'::text, 'xnull'::text, 'xnum'::text, 'xop'::text, 'xser'::text, 'xstr'::text, 'xsubq'::text])))
);


ALTER TABLE query.expression OWNER TO evergreen;

--
-- Name: expr_xbet; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xbet AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.left_operand,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xbet'::text);


ALTER TABLE query.expr_xbet OWNER TO evergreen;

--
-- Name: expr_xbind; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xbind AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.bind_variable
   FROM query.expression
  WHERE (expression.type = 'xbind'::text);


ALTER TABLE query.expr_xbind OWNER TO evergreen;

--
-- Name: expr_xbool; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xbool AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.literal,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xbool'::text);


ALTER TABLE query.expr_xbool OWNER TO evergreen;

--
-- Name: expr_xcase; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xcase AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.left_operand,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xcase'::text);


ALTER TABLE query.expr_xcase OWNER TO evergreen;

--
-- Name: expr_xcast; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xcast AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.left_operand,
    expression.cast_type,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xcast'::text);


ALTER TABLE query.expr_xcast OWNER TO evergreen;

--
-- Name: expr_xcol; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xcol AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.table_alias,
    expression.column_name,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xcol'::text);


ALTER TABLE query.expr_xcol OWNER TO evergreen;

--
-- Name: expr_xex; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xex AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.subquery,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xex'::text);


ALTER TABLE query.expr_xex OWNER TO evergreen;

--
-- Name: expr_xfunc; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xfunc AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.column_name,
    expression.function_id,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xfunc'::text);


ALTER TABLE query.expr_xfunc OWNER TO evergreen;

--
-- Name: expr_xin; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xin AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.left_operand,
    expression.subquery,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xin'::text);


ALTER TABLE query.expr_xin OWNER TO evergreen;

--
-- Name: expr_xisnull; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xisnull AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.left_operand,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xisnull'::text);


ALTER TABLE query.expr_xisnull OWNER TO evergreen;

--
-- Name: expr_xnull; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xnull AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xnull'::text);


ALTER TABLE query.expr_xnull OWNER TO evergreen;

--
-- Name: expr_xnum; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xnum AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.literal
   FROM query.expression
  WHERE (expression.type = 'xnum'::text);


ALTER TABLE query.expr_xnum OWNER TO evergreen;

--
-- Name: expr_xop; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xop AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.left_operand,
    expression.operator,
    expression.right_operand,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xop'::text);


ALTER TABLE query.expr_xop OWNER TO evergreen;

--
-- Name: expr_xser; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xser AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.operator,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xser'::text);


ALTER TABLE query.expr_xser OWNER TO evergreen;

--
-- Name: expr_xstr; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xstr AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.literal
   FROM query.expression
  WHERE (expression.type = 'xstr'::text);


ALTER TABLE query.expr_xstr OWNER TO evergreen;

--
-- Name: expr_xsubq; Type: VIEW; Schema: query; Owner: evergreen
--

CREATE VIEW query.expr_xsubq AS
 SELECT expression.id,
    expression.parenthesize,
    expression.parent_expr,
    expression.seq_no,
    expression.subquery,
    expression.negate
   FROM query.expression
  WHERE (expression.type = 'xsubq'::text);


ALTER TABLE query.expr_xsubq OWNER TO evergreen;

--
-- Name: expression_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.expression_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.expression_id_seq OWNER TO evergreen;

--
-- Name: expression_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.expression_id_seq OWNED BY query.expression.id;


--
-- Name: from_relation; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.from_relation (
    id integer NOT NULL,
    type text NOT NULL,
    table_name text,
    class_name text,
    subquery integer,
    function_call integer,
    table_alias text,
    parent_relation integer,
    seq_no integer DEFAULT 1 NOT NULL,
    join_type text,
    on_clause integer,
    CONSTRAINT good_join_type CHECK (((join_type IS NULL) OR (join_type = ANY (ARRAY['INNER'::text, 'LEFT'::text, 'RIGHT'::text, 'FULL'::text])))),
    CONSTRAINT join_or_core CHECK ((((parent_relation IS NULL) AND (join_type IS NULL) AND (on_clause IS NULL)) OR ((parent_relation IS NOT NULL) AND (join_type IS NOT NULL) AND (on_clause IS NOT NULL)))),
    CONSTRAINT relation_type CHECK ((type = ANY (ARRAY['RELATION'::text, 'SUBQUERY'::text, 'FUNCTION'::text])))
);


ALTER TABLE query.from_relation OWNER TO evergreen;

--
-- Name: from_relation_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.from_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.from_relation_id_seq OWNER TO evergreen;

--
-- Name: from_relation_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.from_relation_id_seq OWNED BY query.from_relation.id;


--
-- Name: function_param_def; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.function_param_def (
    id integer NOT NULL,
    function_id integer NOT NULL,
    seq_no integer NOT NULL,
    datatype integer NOT NULL,
    CONSTRAINT qfpd_pos_seq_no CHECK ((seq_no > 0))
);


ALTER TABLE query.function_param_def OWNER TO evergreen;

--
-- Name: function_param_def_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.function_param_def_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.function_param_def_id_seq OWNER TO evergreen;

--
-- Name: function_param_def_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.function_param_def_id_seq OWNED BY query.function_param_def.id;


--
-- Name: function_sig; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.function_sig (
    id integer NOT NULL,
    function_name text NOT NULL,
    return_type integer,
    is_aggregate boolean DEFAULT false NOT NULL,
    CONSTRAINT qfd_rtn_or_aggr CHECK (((return_type IS NULL) OR (is_aggregate = false)))
);


ALTER TABLE query.function_sig OWNER TO evergreen;

--
-- Name: function_sig_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.function_sig_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.function_sig_id_seq OWNER TO evergreen;

--
-- Name: function_sig_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.function_sig_id_seq OWNED BY query.function_sig.id;


--
-- Name: order_by_item; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.order_by_item (
    id integer NOT NULL,
    stored_query integer NOT NULL,
    seq_no integer NOT NULL,
    expression integer NOT NULL
);


ALTER TABLE query.order_by_item OWNER TO evergreen;

--
-- Name: order_by_item_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.order_by_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.order_by_item_id_seq OWNER TO evergreen;

--
-- Name: order_by_item_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.order_by_item_id_seq OWNED BY query.order_by_item.id;


--
-- Name: query_sequence; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.query_sequence (
    id integer NOT NULL,
    parent_query integer NOT NULL,
    seq_no integer NOT NULL,
    child_query integer NOT NULL
);


ALTER TABLE query.query_sequence OWNER TO evergreen;

--
-- Name: query_sequence_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.query_sequence_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.query_sequence_id_seq OWNER TO evergreen;

--
-- Name: query_sequence_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.query_sequence_id_seq OWNED BY query.query_sequence.id;


--
-- Name: record_column; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.record_column (
    id integer NOT NULL,
    from_relation integer NOT NULL,
    seq_no integer NOT NULL,
    column_name text NOT NULL,
    column_type integer NOT NULL
);


ALTER TABLE query.record_column OWNER TO evergreen;

--
-- Name: record_column_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.record_column_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.record_column_id_seq OWNER TO evergreen;

--
-- Name: record_column_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.record_column_id_seq OWNED BY query.record_column.id;


--
-- Name: select_item; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.select_item (
    id integer NOT NULL,
    stored_query integer NOT NULL,
    seq_no integer NOT NULL,
    expression integer NOT NULL,
    column_alias text,
    grouped_by boolean DEFAULT false NOT NULL
);


ALTER TABLE query.select_item OWNER TO evergreen;

--
-- Name: select_item_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.select_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.select_item_id_seq OWNER TO evergreen;

--
-- Name: select_item_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.select_item_id_seq OWNED BY query.select_item.id;


--
-- Name: stored_query; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.stored_query (
    id integer NOT NULL,
    type text NOT NULL,
    use_all boolean DEFAULT false NOT NULL,
    use_distinct boolean DEFAULT false NOT NULL,
    from_clause integer,
    where_clause integer,
    having_clause integer,
    limit_count integer,
    offset_count integer,
    CONSTRAINT query_type CHECK ((type = ANY (ARRAY['SELECT'::text, 'UNION'::text, 'INTERSECT'::text, 'EXCEPT'::text])))
);


ALTER TABLE query.stored_query OWNER TO evergreen;

--
-- Name: stored_query_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.stored_query_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.stored_query_id_seq OWNER TO evergreen;

--
-- Name: stored_query_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.stored_query_id_seq OWNED BY query.stored_query.id;


--
-- Name: subfield; Type: TABLE; Schema: query; Owner: evergreen
--

CREATE TABLE query.subfield (
    id integer NOT NULL,
    composite_type integer NOT NULL,
    seq_no integer NOT NULL,
    subfield_type integer NOT NULL,
    CONSTRAINT qsf_pos_seq_no CHECK ((seq_no > 0))
);


ALTER TABLE query.subfield OWNER TO evergreen;

--
-- Name: subfield_id_seq; Type: SEQUENCE; Schema: query; Owner: evergreen
--

CREATE SEQUENCE query.subfield_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE query.subfield_id_seq OWNER TO evergreen;

--
-- Name: subfield_id_seq; Type: SEQUENCE OWNED BY; Schema: query; Owner: evergreen
--

ALTER SEQUENCE query.subfield_id_seq OWNED BY query.subfield.id;


--
-- Name: badge; Type: TABLE; Schema: rating; Owner: evergreen
--

CREATE TABLE rating.badge (
    id integer NOT NULL,
    name text NOT NULL,
    description text,
    scope integer NOT NULL,
    weight integer DEFAULT 1 NOT NULL,
    horizon_age interval,
    importance_age interval,
    importance_interval interval DEFAULT '1 day'::interval NOT NULL,
    importance_scale numeric,
    recalc_interval interval DEFAULT '1 mon'::interval NOT NULL,
    attr_filter text,
    src_filter integer,
    circ_mod_filter text,
    loc_grp_filter integer,
    popularity_parameter integer NOT NULL,
    fixed_rating integer,
    percentile numeric,
    discard integer DEFAULT 0 NOT NULL,
    last_calc timestamp with time zone,
    CONSTRAINT badge_fixed_rating_check CHECK (((fixed_rating IS NULL) OR ((fixed_rating >= '-5'::integer) AND (fixed_rating <= 5)))),
    CONSTRAINT badge_importance_scale_check CHECK (((importance_scale IS NULL) OR (importance_scale > 0.0))),
    CONSTRAINT badge_percentile_check CHECK (((percentile IS NULL) OR ((percentile >= 50.0) AND (percentile < 100.0))))
);


ALTER TABLE rating.badge OWNER TO evergreen;

--
-- Name: badge_id_seq; Type: SEQUENCE; Schema: rating; Owner: evergreen
--

CREATE SEQUENCE rating.badge_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rating.badge_id_seq OWNER TO evergreen;

--
-- Name: badge_id_seq; Type: SEQUENCE OWNED BY; Schema: rating; Owner: evergreen
--

ALTER SEQUENCE rating.badge_id_seq OWNED BY rating.badge.id;


--
-- Name: badge_with_orgs; Type: VIEW; Schema: rating; Owner: evergreen
--

CREATE VIEW rating.badge_with_orgs AS
 WITH org_scope AS (
         SELECT x.id,
            array_agg(x.tree) AS orgs
           FROM ( SELECT org_unit.id,
                    (actor.org_unit_descendants(org_unit.id)).id AS tree
                   FROM actor.org_unit) x
          GROUP BY x.id
        )
 SELECT b.id,
    b.name,
    b.description,
    b.scope,
    b.weight,
    b.horizon_age,
    b.importance_age,
    b.importance_interval,
    b.importance_scale,
    b.recalc_interval,
    b.attr_filter,
    b.src_filter,
    b.circ_mod_filter,
    b.loc_grp_filter,
    b.popularity_parameter,
    b.fixed_rating,
    b.percentile,
    b.discard,
    b.last_calc,
    s.orgs
   FROM (rating.badge b
     JOIN org_scope s ON ((b.scope = s.id)));


ALTER TABLE rating.badge_with_orgs OWNER TO evergreen;

--
-- Name: popularity_parameter; Type: TABLE; Schema: rating; Owner: evergreen
--

CREATE TABLE rating.popularity_parameter (
    id integer NOT NULL,
    name text NOT NULL,
    description text,
    func text,
    require_horizon boolean DEFAULT false NOT NULL,
    require_importance boolean DEFAULT false NOT NULL,
    require_percentile boolean DEFAULT false NOT NULL
);


ALTER TABLE rating.popularity_parameter OWNER TO evergreen;

--
-- Name: record_badge_score; Type: TABLE; Schema: rating; Owner: evergreen
--

CREATE TABLE rating.record_badge_score (
    id bigint NOT NULL,
    record bigint NOT NULL,
    badge integer NOT NULL,
    score integer NOT NULL,
    CONSTRAINT record_badge_score_score_check CHECK (((score >= '-5'::integer) AND (score <= 5)))
);


ALTER TABLE rating.record_badge_score OWNER TO evergreen;

--
-- Name: record_badge_score_id_seq; Type: SEQUENCE; Schema: rating; Owner: evergreen
--

CREATE SEQUENCE rating.record_badge_score_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rating.record_badge_score_id_seq OWNER TO evergreen;

--
-- Name: record_badge_score_id_seq; Type: SEQUENCE OWNED BY; Schema: rating; Owner: evergreen
--

ALTER SEQUENCE rating.record_badge_score_id_seq OWNED BY rating.record_badge_score.id;


--
-- Name: asset_call_number_dewey; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.asset_call_number_dewey AS
 SELECT call_number.id AS call_number,
    public.call_number_dewey(call_number.label) AS dewey,
        CASE
            WHEN (public.call_number_dewey(call_number.label) ~ '^[0-9]+\.?[0-9]*$'::text) THEN btrim(to_char(((10)::double precision * floor(((public.call_number_dewey(call_number.label))::double precision / (10)::double precision))), '000'::text))
            ELSE NULL::text
        END AS dewey_block_tens,
        CASE
            WHEN (public.call_number_dewey(call_number.label) ~ '^[0-9]+\.?[0-9]*$'::text) THEN btrim(to_char(((100)::double precision * floor(((public.call_number_dewey(call_number.label))::double precision / (100)::double precision))), '000'::text))
            ELSE NULL::text
        END AS dewey_block_hundreds,
        CASE
            WHEN (public.call_number_dewey(call_number.label) ~ '^[0-9]+\.?[0-9]*$'::text) THEN ((btrim(to_char(((10)::double precision * floor(((public.call_number_dewey(call_number.label))::double precision / (10)::double precision))), '000'::text)) || '-'::text) || btrim(to_char((((10)::double precision * floor(((public.call_number_dewey(call_number.label))::double precision / (10)::double precision))) + (9)::double precision), '000'::text)))
            ELSE NULL::text
        END AS dewey_range_tens,
        CASE
            WHEN (public.call_number_dewey(call_number.label) ~ '^[0-9]+\.?[0-9]*$'::text) THEN ((btrim(to_char(((100)::double precision * floor(((public.call_number_dewey(call_number.label))::double precision / (100)::double precision))), '000'::text)) || '-'::text) || btrim(to_char((((100)::double precision * floor(((public.call_number_dewey(call_number.label))::double precision / (100)::double precision))) + (99)::double precision), '000'::text)))
            ELSE NULL::text
        END AS dewey_range_hundreds
   FROM asset.call_number
  WHERE (public.call_number_dewey(call_number.label) ~ '^[0-9]'::text);


ALTER TABLE reporter.asset_call_number_dewey OWNER TO evergreen;

--
-- Name: live_cataloged_browse_entry; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.live_cataloged_browse_entry AS
 WITH cataloged_entries AS (
         SELECT entry.id AS entry,
            entry.value AS entry_value,
            entry.sort_value AS entry_sort_value,
            entry.create_date AS entry_create_date,
            map.source AS bib_record,
            map.def AS field_def,
            bre.cataloging_date AS bib_cataloging_date,
            bre.editor AS bib_editor,
            bre.edit_date AS bib_edit_date,
            bre.create_date AS bib_create_date,
            cmf.field_class AS browse_axis,
            cmf.label AS field_label,
            ccvm.code AS mattype,
            GREATEST(bre.cataloging_date, entry.create_date) AS heading_date,
            rank() OVER (PARTITION BY entry.id ORDER BY bre.cataloging_date, map.id) AS rank
           FROM (((((metabib.browse_entry entry
             JOIN metabib.browse_entry_def_map map ON ((map.entry = entry.id)))
             JOIN config.metabib_field cmf ON ((cmf.id = map.def)))
             JOIN biblio.record_entry bre ON ((bre.id = map.source)))
             JOIN metabib.record_attr_vector_list vec ON ((vec.source = bre.id)))
             JOIN config.coded_value_map ccvm ON (((ccvm.ctype = 'mattype'::text) AND (ccvm.id = ANY (vec.vlist)))))
          WHERE ((bre.cataloging_date IS NOT NULL) AND (cmf.field_class = ANY (ARRAY['author'::text, 'subject'::text, 'series'::text])))
        )
 SELECT all_entries.entry,
    all_entries.entry_value,
    all_entries.entry_sort_value,
    all_entries.entry_create_date,
    all_entries.bib_record,
    all_entries.field_def,
    all_entries.bib_cataloging_date,
    all_entries.bib_editor,
    all_entries.bib_edit_date,
    all_entries.bib_create_date,
    all_entries.browse_axis,
    all_entries.field_label,
    all_entries.mattype,
    all_entries.heading_date,
    all_entries.rank
   FROM cataloged_entries all_entries
  WHERE (all_entries.rank = 1);


ALTER TABLE reporter.live_cataloged_browse_entry OWNER TO evergreen;

--
-- Name: cataloged_browse_entry_detail; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.cataloged_browse_entry_detail AS
 SELECT entry.entry,
    entry.entry_value,
    entry.entry_sort_value,
    entry.entry_create_date,
    entry.bib_record,
    entry.field_def,
    entry.bib_cataloging_date,
    entry.bib_editor,
    entry.bib_edit_date,
    entry.bib_create_date,
    entry.browse_axis,
    entry.field_label,
    entry.mattype,
    entry.heading_date,
    entry.rank,
    usr.usrname AS bib_editor_usrname,
    mfr.value AS bib_marc_001,
    evergreen.marc_tag_to_string('1'::text, bre.marc) AS bib_marc_1xx,
    evergreen.marc_tag_to_string('245'::text, bre.marc) AS bib_marc_245,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_entry AS prev_entry,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_entry_value AS prev_entry_value,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_entry_sort_value AS prev_entry_sort_value,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_entry_create_date AS prev_entry_create_date,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_bib_record AS prev_bib_record,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_bib_editor AS prev_bib_editor,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_bib_edit_date AS prev_bib_edit_date,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_bib_create_date AS prev_bib_create_date,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_bib_cataloging_date AS prev_bib_cataloging_date,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_field_def AS prev_field_def,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_field_label AS prev_field_label,
    (reporter.metabib_browse_entry_window_prev(entry.browse_axis, entry.entry_sort_value)).prev_auth_tag AS prev_auth_tag,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_entry AS next_entry,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_entry_value AS next_entry_value,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_entry_sort_value AS next_entry_sort_value,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_entry_create_date AS next_entry_create_date,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_bib_record AS next_bib_record,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_bib_editor AS next_bib_editor,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_bib_edit_date AS next_bib_edit_date,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_bib_create_date AS next_bib_create_date,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_bib_cataloging_date AS next_bib_cataloging_date,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_field_def AS next_field_def,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_field_label AS next_field_label,
    (reporter.metabib_browse_entry_window_next(entry.browse_axis, entry.entry_sort_value)).next_auth_tag AS next_auth_tag
   FROM (((reporter.live_cataloged_browse_entry entry
     JOIN biblio.record_entry bre ON ((bre.id = entry.bib_record)))
     JOIN metabib.full_rec mfr ON (((bre.id = mfr.record) AND (mfr.tag = '001'::bpchar))))
     JOIN actor.usr usr ON ((usr.id = bre.editor)))
  ORDER BY
        CASE entry.browse_axis
            WHEN 'author'::text THEN 1
            WHEN 'subject'::text THEN 2
            ELSE 3
        END, entry.entry_sort_value;


ALTER TABLE reporter.cataloged_browse_entry_detail OWNER TO evergreen;

--
-- Name: circ_type; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.circ_type AS
 SELECT circulation.id,
        CASE
            WHEN (circulation.opac_renewal OR circulation.phone_renewal OR circulation.desk_renewal OR circulation.auto_renewal) THEN 'RENEWAL'::text
            ELSE 'CHECKOUT'::text
        END AS type
   FROM action.circulation;


ALTER TABLE reporter.circ_type OWNER TO evergreen;

--
-- Name: demographic; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.demographic AS
 SELECT u.id,
    u.dob,
        CASE
            WHEN (u.dob IS NULL) THEN 'Adult'::text
            WHEN (age((u.dob)::timestamp with time zone) > '18 years'::interval) THEN 'Adult'::text
            ELSE 'Juvenile'::text
        END AS general_division,
        CASE
            WHEN (u.dob IS NULL) THEN 'No Date of Birth Entered'::text
            WHEN ((age((u.dob)::timestamp with time zone) >= '00:00:00'::interval) AND (age((u.dob)::timestamp with time zone) < '6 years'::interval)) THEN 'Child 0-5 Years Old'::text
            WHEN ((age((u.dob)::timestamp with time zone) >= '6 years'::interval) AND (age((u.dob)::timestamp with time zone) < '13 years'::interval)) THEN 'Child 6-12 Years Old'::text
            WHEN ((age((u.dob)::timestamp with time zone) >= '13 years'::interval) AND (age((u.dob)::timestamp with time zone) < '18 years'::interval)) THEN 'Teen 13-17 Years Old'::text
            WHEN ((age((u.dob)::timestamp with time zone) >= '18 years'::interval) AND (age((u.dob)::timestamp with time zone) < '26 years'::interval)) THEN 'Adult 18-25 Years Old'::text
            WHEN ((age((u.dob)::timestamp with time zone) >= '26 years'::interval) AND (age((u.dob)::timestamp with time zone) < '50 years'::interval)) THEN 'Adult 26-49 Years Old'::text
            WHEN ((age((u.dob)::timestamp with time zone) >= '50 years'::interval) AND (age((u.dob)::timestamp with time zone) < '60 years'::interval)) THEN 'Adult 50-59 Years Old'::text
            WHEN ((age((u.dob)::timestamp with time zone) >= '60 years'::interval) AND (age((u.dob)::timestamp with time zone) < '70 years'::interval)) THEN 'Adult 60-69 Years Old'::text
            WHEN (age((u.dob)::timestamp with time zone) >= '70 years'::interval) THEN 'Adult 70+'::text
            ELSE NULL::text
        END AS age_division
   FROM actor.usr u;


ALTER TABLE reporter.demographic OWNER TO evergreen;

--
-- Name: classic_current_billing_summary; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.classic_current_billing_summary AS
 SELECT x.id,
    x.usr,
    bl.shortname AS billing_location_shortname,
    bl.name AS billing_location_name,
    x.billing_location,
    c.barcode,
    u.home_ou AS usr_home_ou,
    ul.shortname AS usr_home_ou_shortname,
    ul.name AS usr_home_ou_name,
    x.xact_start,
    x.xact_finish,
    x.xact_type,
    x.total_paid,
    x.total_owed,
    x.balance_owed,
    x.last_payment_ts,
    x.last_payment_note,
    x.last_payment_type,
    x.last_billing_ts,
    x.last_billing_note,
    x.last_billing_type,
    paddr.county AS patron_county,
    paddr.city AS patron_city,
    paddr.post_code AS patron_zip,
    g.name AS profile_group,
    dem.general_division AS demographic_general_division
   FROM (((((((money.open_billable_xact_summary x
     JOIN actor.org_unit bl ON ((x.billing_location = bl.id)))
     JOIN actor.usr u ON ((u.id = x.usr)))
     JOIN actor.org_unit ul ON ((u.home_ou = ul.id)))
     JOIN actor.card c ON ((u.card = c.id)))
     JOIN permission.grp_tree g ON ((u.profile = g.id)))
     JOIN reporter.demographic dem ON ((dem.id = u.id)))
     JOIN actor.usr_address paddr ON ((paddr.id = u.billing_address)));


ALTER TABLE reporter.classic_current_billing_summary OWNER TO evergreen;

--
-- Name: classic_current_circ; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.classic_current_circ AS
 SELECT cl.shortname AS circ_lib,
    cl.id AS circ_lib_id,
    circ.xact_start,
    circ_type.type AS circ_type,
    cp.id AS copy_id,
    cp.circ_modifier,
    ol.shortname AS owning_lib_name,
    lm.value AS language,
    lfm.value AS lit_form,
    ifm.value AS item_form,
    itm.value AS item_type,
    sl.name AS shelving_location,
    p.id AS patron_id,
    g.name AS profile_group,
    dem.general_division AS demographic_general_division,
    circ.id,
    cn.id AS call_number,
    cn.label AS call_number_label,
    public.call_number_dewey(cn.label) AS dewey,
        CASE
            WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN btrim(to_char(((10)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (10)::double precision))), '000'::text))
            ELSE NULL::text
        END AS dewey_block_tens,
        CASE
            WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN btrim(to_char(((100)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (100)::double precision))), '000'::text))
            ELSE NULL::text
        END AS dewey_block_hundreds,
        CASE
            WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN ((btrim(to_char(((10)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (10)::double precision))), '000'::text)) || '-'::text) || btrim(to_char((((10)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (10)::double precision))) + (9)::double precision), '000'::text)))
            ELSE NULL::text
        END AS dewey_range_tens,
        CASE
            WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN ((btrim(to_char(((100)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (100)::double precision))), '000'::text)) || '-'::text) || btrim(to_char((((100)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (100)::double precision))) + (99)::double precision), '000'::text)))
            ELSE NULL::text
        END AS dewey_range_hundreds,
    hl.id AS patron_home_lib,
    hl.shortname AS patron_home_lib_shortname,
    paddr.county AS patron_county,
    paddr.city AS patron_city,
    paddr.post_code AS patron_zip,
    sc1.stat_cat_entry AS stat_cat_1,
    sc2.stat_cat_entry AS stat_cat_2,
    sce1.value AS stat_cat_1_value,
    sce2.value AS stat_cat_2_value
   FROM ((((((((((((((((((((action.circulation circ
     JOIN reporter.circ_type circ_type ON ((circ.id = circ_type.id)))
     JOIN asset.copy cp ON ((cp.id = circ.target_copy)))
     JOIN asset.copy_location sl ON ((cp.location = sl.id)))
     JOIN asset.call_number cn ON ((cp.call_number = cn.id)))
     JOIN actor.org_unit ol ON ((cn.owning_lib = ol.id)))
     JOIN metabib.rec_descriptor rd ON ((rd.record = cn.record)))
     JOIN actor.org_unit cl ON ((circ.circ_lib = cl.id)))
     JOIN actor.usr p ON ((p.id = circ.usr)))
     JOIN actor.org_unit hl ON ((p.home_ou = hl.id)))
     JOIN permission.grp_tree g ON ((p.profile = g.id)))
     JOIN reporter.demographic dem ON ((dem.id = p.id)))
     JOIN actor.usr_address paddr ON ((paddr.id = p.billing_address)))
     LEFT JOIN config.language_map lm ON ((rd.item_lang = lm.code)))
     LEFT JOIN config.lit_form_map lfm ON ((rd.lit_form = lfm.code)))
     LEFT JOIN config.item_form_map ifm ON ((rd.item_form = ifm.code)))
     LEFT JOIN config.item_type_map itm ON ((rd.item_type = itm.code)))
     LEFT JOIN asset.stat_cat_entry_copy_map sc1 ON (((sc1.owning_copy = cp.id) AND (sc1.stat_cat = 1))))
     LEFT JOIN asset.stat_cat_entry sce1 ON ((sce1.id = sc1.stat_cat_entry)))
     LEFT JOIN asset.stat_cat_entry_copy_map sc2 ON (((sc2.owning_copy = cp.id) AND (sc2.stat_cat = 2))))
     LEFT JOIN asset.stat_cat_entry sce2 ON ((sce2.id = sc2.stat_cat_entry)));


ALTER TABLE reporter.classic_current_circ OWNER TO evergreen;

--
-- Name: classic_item_list; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.classic_item_list AS
 SELECT rmsr.title,
    rmsr.author,
    rmsr.pubdate,
    cp.id,
    cp.price,
    cp.barcode,
    cn.label AS call_number_label,
        CASE
            WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN btrim(to_char(((10)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (10)::double precision))), '000'::text))
            ELSE NULL::text
        END AS dewey_block_tens,
        CASE
            WHEN (public.call_number_dewey(cn.label) ~ '^[0-9.]+$'::text) THEN btrim(to_char(((100)::double precision * floor(((public.call_number_dewey(cn.label))::double precision / (100)::double precision))), '000'::text))
            ELSE NULL::text
        END AS dewey_block_hundreds,
    erfcc.circ_count AS use_count,
    cp.circ_modifier,
    sl.name AS shelving_location,
    sc1.stat_cat_entry AS stat_cat_1,
    sc2.stat_cat_entry AS stat_cat_2,
    sce1.value AS stat_cat_1_value,
    sce2.value AS stat_cat_2_value,
    cp.edit_date,
    cp.create_date,
    ol.shortname AS owning_lib_name,
    cn.owning_lib,
    cl.shortname AS circ_lib_name,
    cl.id AS circ_lib,
    cp.creator,
    cp.age_protect,
    cp.opac_visible,
    cp.ref,
    cp.deposit_amount,
    cp.deleted,
    rmsr.tcn_value,
    cp.status,
    circ.stop_fines,
    circ.due_date,
    circ_card.barcode AS patron_barcode,
    ((circ_u.first_given_name || ' '::text) || circ_u.family_name) AS patron_name
   FROM (((((((((((((asset.copy cp
     JOIN extend_reporter.full_circ_count erfcc ON ((cp.id = erfcc.id)))
     JOIN asset.copy_location sl ON ((cp.location = sl.id)))
     JOIN asset.call_number cn ON ((cp.call_number = cn.id)))
     JOIN actor.org_unit ol ON ((cn.owning_lib = ol.id)))
     JOIN actor.org_unit cl ON ((cp.circ_lib = cl.id)))
     JOIN reporter.materialized_simple_record rmsr ON ((cn.record = rmsr.id)))
     LEFT JOIN action.circulation circ ON (((circ.target_copy = cp.id) AND (circ.checkin_time IS NULL))))
     LEFT JOIN actor.usr circ_u ON ((circ_u.id = circ.usr)))
     LEFT JOIN actor.card circ_card ON ((circ_u.card = circ_card.id)))
     LEFT JOIN asset.stat_cat_entry_copy_map sc1 ON (((sc1.owning_copy = cp.id) AND (sc1.stat_cat = 1))))
     LEFT JOIN asset.stat_cat_entry sce1 ON ((sce1.id = sc1.stat_cat_entry)))
     LEFT JOIN asset.stat_cat_entry_copy_map sc2 ON (((sc2.owning_copy = cp.id) AND (sc2.stat_cat = 2))))
     LEFT JOIN asset.stat_cat_entry sce2 ON ((sce2.id = sc2.stat_cat_entry)));


ALTER TABLE reporter.classic_item_list OWNER TO evergreen;

--
-- Name: report; Type: TABLE; Schema: reporter; Owner: evergreen
--

CREATE TABLE reporter.report (
    id integer NOT NULL,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text DEFAULT ''::text NOT NULL,
    description text DEFAULT ''::text NOT NULL,
    template integer NOT NULL,
    data text NOT NULL,
    folder integer NOT NULL,
    recur boolean DEFAULT false NOT NULL,
    recurrence interval
);


ALTER TABLE reporter.report OWNER TO evergreen;

--
-- Name: schedule; Type: TABLE; Schema: reporter; Owner: evergreen
--

CREATE TABLE reporter.schedule (
    id integer NOT NULL,
    report integer NOT NULL,
    folder integer NOT NULL,
    runner integer NOT NULL,
    run_time timestamp with time zone DEFAULT now() NOT NULL,
    start_time timestamp with time zone,
    complete_time timestamp with time zone,
    email text,
    excel_format boolean DEFAULT true NOT NULL,
    html_format boolean DEFAULT true NOT NULL,
    csv_format boolean DEFAULT true NOT NULL,
    chart_pie boolean DEFAULT false NOT NULL,
    chart_bar boolean DEFAULT false NOT NULL,
    chart_line boolean DEFAULT false NOT NULL,
    error_code integer,
    error_text text
);


ALTER TABLE reporter.schedule OWNER TO evergreen;

--
-- Name: template; Type: TABLE; Schema: reporter; Owner: evergreen
--

CREATE TABLE reporter.template (
    id integer NOT NULL,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    description text DEFAULT ''::text NOT NULL,
    data text NOT NULL,
    folder integer NOT NULL
);


ALTER TABLE reporter.template OWNER TO evergreen;

--
-- Name: completed_reports; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.completed_reports AS
 SELECT s.id AS run,
    r.id AS report,
    t.id AS template,
    t.owner AS template_owner,
    r.owner AS report_owner,
    s.runner,
    t.folder AS template_folder,
    r.folder AS report_folder,
    s.folder AS output_folder,
    r.name AS report_name,
    t.name AS template_name,
    s.start_time,
    s.run_time,
    s.complete_time,
    s.error_code,
    s.error_text
   FROM ((reporter.schedule s
     JOIN reporter.report r ON ((r.id = s.report)))
     JOIN reporter.template t ON ((t.id = r.template)))
  WHERE (s.complete_time IS NOT NULL);


ALTER TABLE reporter.completed_reports OWNER TO evergreen;

--
-- Name: currently_running; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.currently_running AS
 SELECT s.id,
    c.barcode AS runner_barcode,
    r.name,
    s.run_time,
    (s.run_time - now()) AS scheduled_wait_time
   FROM (((reporter.schedule s
     JOIN reporter.report r ON ((r.id = s.report)))
     JOIN actor.usr u ON ((s.runner = u.id)))
     JOIN actor.card c ON ((c.id = u.card)))
  WHERE ((s.start_time IS NOT NULL) AND (s.complete_time IS NULL));


ALTER TABLE reporter.currently_running OWNER TO evergreen;

--
-- Name: hold_request_record; Type: TABLE; Schema: reporter; Owner: evergreen
--

CREATE TABLE reporter.hold_request_record (
    id integer NOT NULL,
    target bigint,
    hold_type text,
    bib_record bigint
);


ALTER TABLE reporter.hold_request_record OWNER TO evergreen;

--
-- Name: legacy_cat1; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.legacy_cat1 AS
 SELECT stat_cat_entry.id,
    stat_cat_entry.owner,
    stat_cat_entry.value
   FROM asset.stat_cat_entry
  WHERE (stat_cat_entry.stat_cat = 1);


ALTER TABLE reporter.legacy_cat1 OWNER TO evergreen;

--
-- Name: legacy_cat2; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.legacy_cat2 AS
 SELECT stat_cat_entry.id,
    stat_cat_entry.owner,
    stat_cat_entry.value
   FROM asset.stat_cat_entry
  WHERE (stat_cat_entry.stat_cat = 2);


ALTER TABLE reporter.legacy_cat2 OWNER TO evergreen;

--
-- Name: materialized_cataloged_browse_entry; Type: MATERIALIZED VIEW; Schema: reporter; Owner: evergreen
--

CREATE MATERIALIZED VIEW reporter.materialized_cataloged_browse_entry AS
 WITH cataloged_entries AS (
         SELECT entry.id AS entry,
            entry.value AS entry_value,
            entry.sort_value AS entry_sort_value,
            entry.create_date AS entry_create_date,
            map.source AS bib_record,
            map.def AS field_def,
            bre.cataloging_date AS bib_cataloging_date,
            bre.editor AS bib_editor,
            bre.edit_date AS bib_edit_date,
            bre.create_date AS bib_create_date,
            cmf.field_class AS browse_axis,
            cmf.label AS field_label,
            ccvm.code AS mattype,
            GREATEST(bre.cataloging_date, entry.create_date) AS heading_date,
            rank() OVER (PARTITION BY entry.id ORDER BY bre.cataloging_date, map.id) AS rank
           FROM (((((metabib.browse_entry entry
             JOIN metabib.browse_entry_def_map map ON ((map.entry = entry.id)))
             JOIN config.metabib_field cmf ON ((cmf.id = map.def)))
             JOIN biblio.record_entry bre ON ((bre.id = map.source)))
             JOIN metabib.record_attr_vector_list vec ON ((vec.source = bre.id)))
             JOIN config.coded_value_map ccvm ON (((ccvm.ctype = 'mattype'::text) AND (ccvm.id = ANY (vec.vlist)))))
          WHERE ((bre.cataloging_date IS NOT NULL) AND (cmf.field_class = ANY (ARRAY['author'::text, 'subject'::text, 'series'::text])))
        )
 SELECT all_entries.entry,
    all_entries.entry_value,
    all_entries.entry_sort_value,
    all_entries.entry_create_date,
    all_entries.bib_record,
    all_entries.field_def,
    all_entries.bib_cataloging_date,
    all_entries.bib_editor,
    all_entries.bib_edit_date,
    all_entries.bib_create_date,
    all_entries.browse_axis,
    all_entries.field_label,
    all_entries.mattype,
    all_entries.heading_date,
    all_entries.rank
   FROM cataloged_entries all_entries
  WHERE (all_entries.rank = 1)
  WITH NO DATA;


ALTER TABLE reporter.materialized_cataloged_browse_entry OWNER TO evergreen;

--
-- Name: old_super_simple_record; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.old_super_simple_record AS
 SELECT r.id,
    r.fingerprint,
    r.quality,
    r.tcn_source,
    r.tcn_value,
    evergreen.oils_json_to_text(d.title) AS title,
    evergreen.oils_json_to_text(d.title_proper) AS title_proper,
    evergreen.oils_json_to_text(d.author) AS author,
    evergreen.oils_json_to_text(d.publisher) AS publisher,
    evergreen.oils_json_to_text(d.pubdate) AS pubdate,
        CASE
            WHEN (d.isbn = 'null'::text) THEN NULL::text[]
            ELSE ( SELECT ARRAY( SELECT json_array_elements_text((d.isbn)::json) AS json_array_elements_text) AS "array")
        END AS isbn,
        CASE
            WHEN (d.issn = 'null'::text) THEN NULL::text[]
            ELSE ( SELECT ARRAY( SELECT json_array_elements_text((d.issn)::json) AS json_array_elements_text) AS "array")
        END AS issn
   FROM (biblio.record_entry r
     JOIN metabib.wide_display_entry d ON ((r.id = d.source)));


ALTER TABLE reporter.old_super_simple_record OWNER TO evergreen;

--
-- Name: output_folder; Type: TABLE; Schema: reporter; Owner: evergreen
--

CREATE TABLE reporter.output_folder (
    id integer NOT NULL,
    parent integer,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    shared boolean DEFAULT false NOT NULL,
    share_with integer,
    simple_reporter boolean DEFAULT false
);


ALTER TABLE reporter.output_folder OWNER TO evergreen;

--
-- Name: output_folder_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE reporter.output_folder_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.output_folder_id_seq OWNER TO evergreen;

--
-- Name: output_folder_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE reporter.output_folder_id_seq OWNED BY reporter.output_folder.id;


--
-- Name: overdue_circs; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.overdue_circs AS
 SELECT circulation.id,
    circulation.usr,
    circulation.xact_start,
    circulation.xact_finish,
    circulation.unrecovered,
    circulation.target_copy,
    circulation.circ_lib,
    circulation.circ_staff,
    circulation.checkin_staff,
    circulation.checkin_lib,
    circulation.renewal_remaining,
    circulation.due_date,
    circulation.stop_fines_time,
    circulation.checkin_time,
    circulation.create_time,
    circulation.duration,
    circulation.fine_interval,
    circulation.recurring_fine,
    circulation.max_fine,
    circulation.phone_renewal,
    circulation.desk_renewal,
    circulation.opac_renewal,
    circulation.duration_rule,
    circulation.recurring_fine_rule,
    circulation.max_fine_rule,
    circulation.stop_fines,
    circulation.workstation,
    circulation.checkin_workstation,
    circulation.checkin_scan_time,
    circulation.parent_circ,
    circulation.grace_period,
    circulation.copy_location,
    circulation.auto_renewal,
    circulation.auto_renewal_remaining
   FROM action.circulation
  WHERE ((circulation.checkin_time IS NULL) AND ((circulation.stop_fines <> ALL (ARRAY['LOST'::text, 'CLAIMSRETURNED'::text])) OR (circulation.stop_fines IS NULL)) AND (circulation.due_date < now()));


ALTER TABLE reporter.overdue_circs OWNER TO evergreen;

--
-- Name: overdue_reports; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.overdue_reports AS
 SELECT s.id,
    c.barcode AS runner_barcode,
    r.name,
    s.run_time,
    (s.run_time - now()) AS scheduled_wait_time
   FROM (((reporter.schedule s
     JOIN reporter.report r ON ((r.id = s.report)))
     JOIN actor.usr u ON ((s.runner = u.id)))
     JOIN actor.card c ON ((c.id = u.card)))
  WHERE ((s.start_time IS NULL) AND (s.run_time < now()));


ALTER TABLE reporter.overdue_reports OWNER TO evergreen;

--
-- Name: pending_reports; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.pending_reports AS
 SELECT s.id,
    c.barcode AS runner_barcode,
    r.name,
    s.run_time,
    (s.run_time - now()) AS scheduled_wait_time
   FROM (((reporter.schedule s
     JOIN reporter.report r ON ((r.id = s.report)))
     JOIN actor.usr u ON ((s.runner = u.id)))
     JOIN actor.card c ON ((c.id = u.card)))
  WHERE (s.start_time IS NULL);


ALTER TABLE reporter.pending_reports OWNER TO evergreen;

--
-- Name: report_folder; Type: TABLE; Schema: reporter; Owner: evergreen
--

CREATE TABLE reporter.report_folder (
    id integer NOT NULL,
    parent integer,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    shared boolean DEFAULT false NOT NULL,
    share_with integer,
    simple_reporter boolean DEFAULT false
);


ALTER TABLE reporter.report_folder OWNER TO evergreen;

--
-- Name: report_folder_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE reporter.report_folder_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.report_folder_id_seq OWNER TO evergreen;

--
-- Name: report_folder_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE reporter.report_folder_id_seq OWNED BY reporter.report_folder.id;


--
-- Name: report_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE reporter.report_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.report_id_seq OWNER TO evergreen;

--
-- Name: report_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE reporter.report_id_seq OWNED BY reporter.report.id;


--
-- Name: schedule_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE reporter.schedule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.schedule_id_seq OWNER TO evergreen;

--
-- Name: schedule_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE reporter.schedule_id_seq OWNED BY reporter.schedule.id;


--
-- Name: schedule_original; Type: TABLE; Schema: reporter; Owner: evergreen
--

CREATE TABLE reporter.schedule_original (
    id integer NOT NULL,
    report integer NOT NULL,
    folder integer NOT NULL,
    runner integer NOT NULL,
    run_time timestamp with time zone NOT NULL,
    start_time timestamp with time zone,
    complete_time timestamp with time zone,
    email text,
    excel_format boolean NOT NULL,
    html_format boolean NOT NULL,
    csv_format boolean NOT NULL,
    chart_pie boolean NOT NULL,
    chart_bar boolean NOT NULL,
    chart_line boolean NOT NULL,
    error_code integer,
    error_text text
);


ALTER TABLE reporter.schedule_original OWNER TO evergreen;

--
-- Name: simple_record; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.simple_record AS
 SELECT r.id,
    s.metarecord,
    r.fingerprint,
    r.quality,
    r.tcn_source,
    r.tcn_value,
    title.value AS title,
    uniform_title.value AS uniform_title,
    author.value AS author,
    publisher.value AS publisher,
    "substring"(pubdate.value, '\d+'::text) AS pubdate,
    series_title.value AS series_title,
    series_statement.value AS series_statement,
    summary.value AS summary,
    array_agg(DISTINCT replace("substring"(isbn.value, '^\S+'::text), '-'::text, ''::text)) AS isbn,
    array_agg(DISTINCT regexp_replace(issn.value, '^\S*(\d{4})[-\s](\d{3,4}x?)'::text, '\1 \2'::text)) AS issn,
    ARRAY( SELECT DISTINCT full_rec.value
           FROM metabib.full_rec
          WHERE ((full_rec.tag = '650'::bpchar) AND (full_rec.subfield = 'a'::text) AND (full_rec.record = r.id))) AS topic_subject,
    ARRAY( SELECT DISTINCT full_rec.value
           FROM metabib.full_rec
          WHERE ((full_rec.tag = '651'::bpchar) AND (full_rec.subfield = 'a'::text) AND (full_rec.record = r.id))) AS geographic_subject,
    ARRAY( SELECT DISTINCT full_rec.value
           FROM metabib.full_rec
          WHERE ((full_rec.tag = '655'::bpchar) AND (full_rec.subfield = 'a'::text) AND (full_rec.record = r.id))) AS genre,
    ARRAY( SELECT DISTINCT full_rec.value
           FROM metabib.full_rec
          WHERE ((full_rec.tag = '600'::bpchar) AND (full_rec.subfield = 'a'::text) AND (full_rec.record = r.id))) AS name_subject,
    ARRAY( SELECT DISTINCT full_rec.value
           FROM metabib.full_rec
          WHERE ((full_rec.tag = '610'::bpchar) AND (full_rec.subfield = 'a'::text) AND (full_rec.record = r.id))) AS corporate_subject,
    ARRAY( SELECT full_rec.value
           FROM metabib.full_rec
          WHERE ((full_rec.tag = '856'::bpchar) AND (full_rec.subfield = ANY (ARRAY['3'::text, 'y'::text, 'u'::text])) AND (full_rec.record = r.id))
          ORDER BY
                CASE
                    WHEN (full_rec.subfield = ANY (ARRAY['3'::text, 'y'::text])) THEN 0
                    ELSE 1
                END) AS external_uri
   FROM (((((((((((biblio.record_entry r
     JOIN metabib.metarecord_source_map s ON ((s.source = r.id)))
     LEFT JOIN metabib.full_rec uniform_title ON (((r.id = uniform_title.record) AND (uniform_title.tag = '240'::bpchar) AND (uniform_title.subfield = 'a'::text))))
     LEFT JOIN metabib.full_rec title ON (((r.id = title.record) AND (title.tag = '245'::bpchar) AND (title.subfield = 'a'::text))))
     LEFT JOIN metabib.full_rec author ON (((r.id = author.record) AND (author.tag = '100'::bpchar) AND (author.subfield = 'a'::text))))
     LEFT JOIN metabib.full_rec publisher ON (((r.id = publisher.record) AND ((publisher.tag = '260'::bpchar) OR ((publisher.tag = '264'::bpchar) AND (publisher.ind2 = '1'::text))) AND (publisher.subfield = 'b'::text))))
     LEFT JOIN metabib.full_rec pubdate ON (((r.id = pubdate.record) AND ((pubdate.tag = '260'::bpchar) OR ((pubdate.tag = '264'::bpchar) AND (pubdate.ind2 = '1'::text))) AND (pubdate.subfield = 'c'::text))))
     LEFT JOIN metabib.full_rec isbn ON (((r.id = isbn.record) AND (isbn.tag = ANY (ARRAY['024'::bpchar, '020'::bpchar])) AND (isbn.subfield = ANY (ARRAY['a'::text, 'z'::text])))))
     LEFT JOIN metabib.full_rec issn ON (((r.id = issn.record) AND (issn.tag = '022'::bpchar) AND (issn.subfield = 'a'::text))))
     LEFT JOIN metabib.full_rec series_title ON (((r.id = series_title.record) AND (series_title.tag = ANY (ARRAY['830'::bpchar, '440'::bpchar])) AND (series_title.subfield = 'a'::text))))
     LEFT JOIN metabib.full_rec series_statement ON (((r.id = series_statement.record) AND (series_statement.tag = '490'::bpchar) AND (series_statement.subfield = 'a'::text))))
     LEFT JOIN metabib.full_rec summary ON (((r.id = summary.record) AND (summary.tag = '520'::bpchar) AND (summary.subfield = 'a'::text))))
  GROUP BY r.id, s.metarecord, r.fingerprint, r.quality, r.tcn_source, r.tcn_value, title.value, uniform_title.value, author.value, publisher.value, ("substring"(pubdate.value, '\d+'::text)), series_title.value, series_statement.value, summary.value;


ALTER TABLE reporter.simple_record OWNER TO evergreen;

--
-- Name: super_simple_record; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.super_simple_record AS
 SELECT materialized_simple_record.id,
    materialized_simple_record.fingerprint,
    materialized_simple_record.quality,
    materialized_simple_record.tcn_source,
    materialized_simple_record.tcn_value,
    materialized_simple_record.title,
    materialized_simple_record.author,
    materialized_simple_record.publisher,
    materialized_simple_record.pubdate,
    materialized_simple_record.isbn,
    materialized_simple_record.issn
   FROM reporter.materialized_simple_record;


ALTER TABLE reporter.super_simple_record OWNER TO evergreen;

--
-- Name: template_folder; Type: TABLE; Schema: reporter; Owner: evergreen
--

CREATE TABLE reporter.template_folder (
    id integer NOT NULL,
    parent integer,
    owner integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    shared boolean DEFAULT false NOT NULL,
    share_with integer,
    simple_reporter boolean DEFAULT false
);


ALTER TABLE reporter.template_folder OWNER TO evergreen;

--
-- Name: template_folder_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE reporter.template_folder_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.template_folder_id_seq OWNER TO evergreen;

--
-- Name: template_folder_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE reporter.template_folder_id_seq OWNED BY reporter.template_folder.id;


--
-- Name: template_id_seq; Type: SEQUENCE; Schema: reporter; Owner: evergreen
--

CREATE SEQUENCE reporter.template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reporter.template_id_seq OWNER TO evergreen;

--
-- Name: template_id_seq; Type: SEQUENCE OWNED BY; Schema: reporter; Owner: evergreen
--

ALTER SEQUENCE reporter.template_id_seq OWNED BY reporter.template.id;


--
-- Name: xact_billing_totals; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.xact_billing_totals AS
 SELECT b.xact,
    sum(
        CASE
            WHEN b.voided THEN (0)::numeric
            ELSE b.amount
        END) AS unvoided,
    sum(
        CASE
            WHEN b.voided THEN b.amount
            ELSE (0)::numeric
        END) AS voided,
    sum(b.amount) AS total
   FROM money.billing b
  GROUP BY b.xact;


ALTER TABLE reporter.xact_billing_totals OWNER TO evergreen;

--
-- Name: xact_paid_totals; Type: VIEW; Schema: reporter; Owner: evergreen
--

CREATE VIEW reporter.xact_paid_totals AS
 SELECT b.xact,
    sum(
        CASE
            WHEN b.voided THEN (0)::numeric
            ELSE b.amount
        END) AS unvoided,
    sum(
        CASE
            WHEN b.voided THEN b.amount
            ELSE (0)::numeric
        END) AS voided,
    sum(b.amount) AS total
   FROM money.payment b
  GROUP BY b.xact;


ALTER TABLE reporter.xact_paid_totals OWNER TO evergreen;

--
-- Name: best_tsconfig; Type: VIEW; Schema: search; Owner: evergreen
--

CREATE VIEW search.best_tsconfig AS
 SELECT m.id,
    COALESCE(f.ts_config, c.ts_config, 'simple'::text) AS ts_config
   FROM ((config.metabib_field m
     LEFT JOIN config.metabib_class_ts_map c ON (((c.field_class = m.field_class) AND (c.index_weight = 'C'::bpchar))))
     LEFT JOIN config.metabib_field_ts_map f ON (((f.metabib_field = m.id) AND (f.index_weight = 'C'::bpchar))));


ALTER TABLE search.best_tsconfig OWNER TO evergreen;

--
-- Name: relevance_adjustment; Type: TABLE; Schema: search; Owner: evergreen
--

CREATE TABLE search.relevance_adjustment (
    id integer NOT NULL,
    active boolean DEFAULT true NOT NULL,
    field integer NOT NULL,
    bump_type text NOT NULL,
    multiplier numeric DEFAULT 1.0 NOT NULL,
    CONSTRAINT relevance_adjustment_bump_type_check CHECK ((bump_type = ANY (ARRAY['word_order'::text, 'first_word'::text, 'full_match'::text])))
);


ALTER TABLE search.relevance_adjustment OWNER TO evergreen;

--
-- Name: relevance_adjustment_id_seq; Type: SEQUENCE; Schema: search; Owner: evergreen
--

CREATE SEQUENCE search.relevance_adjustment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE search.relevance_adjustment_id_seq OWNER TO evergreen;

--
-- Name: relevance_adjustment_id_seq; Type: SEQUENCE OWNED BY; Schema: search; Owner: evergreen
--

ALTER SEQUENCE search.relevance_adjustment_id_seq OWNED BY search.relevance_adjustment.id;


--
-- Name: symspell_dictionary_updates; Type: TABLE; Schema: search; Owner: evergreen
--

CREATE UNLOGGED TABLE search.symspell_dictionary_updates (
    transaction_id bigint,
    keyword_count integer DEFAULT 0 NOT NULL,
    title_count integer DEFAULT 0 NOT NULL,
    author_count integer DEFAULT 0 NOT NULL,
    subject_count integer DEFAULT 0 NOT NULL,
    series_count integer DEFAULT 0 NOT NULL,
    identifier_count integer DEFAULT 0 NOT NULL,
    prefix_key text NOT NULL,
    keyword_suggestions text[],
    title_suggestions text[],
    author_suggestions text[],
    subject_suggestions text[],
    series_suggestions text[],
    identifier_suggestions text[]
);


ALTER TABLE search.symspell_dictionary_updates OWNER TO evergreen;

--
-- Name: basic_summary; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.basic_summary (
    id integer NOT NULL,
    distribution integer NOT NULL,
    generated_coverage text NOT NULL,
    textual_holdings text,
    show_generated boolean DEFAULT true NOT NULL
);


ALTER TABLE serial.basic_summary OWNER TO evergreen;

--
-- Name: index_summary; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.index_summary (
    id integer NOT NULL,
    distribution integer NOT NULL,
    generated_coverage text NOT NULL,
    textual_holdings text,
    show_generated boolean DEFAULT true NOT NULL
);


ALTER TABLE serial.index_summary OWNER TO evergreen;

--
-- Name: supplement_summary; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.supplement_summary (
    id integer NOT NULL,
    distribution integer NOT NULL,
    generated_coverage text NOT NULL,
    textual_holdings text,
    show_generated boolean DEFAULT true NOT NULL
);


ALTER TABLE serial.supplement_summary OWNER TO evergreen;

--
-- Name: any_summary; Type: VIEW; Schema: serial; Owner: evergreen
--

CREATE VIEW serial.any_summary AS
 SELECT 'basic'::text AS summary_type,
    basic_summary.id,
    basic_summary.distribution,
    basic_summary.generated_coverage,
    basic_summary.textual_holdings,
    basic_summary.show_generated
   FROM serial.basic_summary
UNION
 SELECT 'index'::text AS summary_type,
    index_summary.id,
    index_summary.distribution,
    index_summary.generated_coverage,
    index_summary.textual_holdings,
    index_summary.show_generated
   FROM serial.index_summary
UNION
 SELECT 'supplement'::text AS summary_type,
    supplement_summary.id,
    supplement_summary.distribution,
    supplement_summary.generated_coverage,
    supplement_summary.textual_holdings,
    supplement_summary.show_generated
   FROM serial.supplement_summary;


ALTER TABLE serial.any_summary OWNER TO evergreen;

--
-- Name: basic_summary_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.basic_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.basic_summary_id_seq OWNER TO evergreen;

--
-- Name: basic_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.basic_summary_id_seq OWNED BY serial.basic_summary.id;


--
-- Name: caption_and_pattern; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.caption_and_pattern (
    id integer NOT NULL,
    type text NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    active boolean DEFAULT false NOT NULL,
    pattern_code text NOT NULL,
    enum_1 text,
    enum_2 text,
    enum_3 text,
    enum_4 text,
    enum_5 text,
    enum_6 text,
    chron_1 text,
    chron_2 text,
    chron_3 text,
    chron_4 text,
    chron_5 text,
    subscription integer NOT NULL,
    start_date timestamp with time zone DEFAULT now(),
    end_date timestamp with time zone,
    CONSTRAINT cap_type CHECK ((type = ANY (ARRAY['basic'::text, 'supplement'::text, 'index'::text])))
);


ALTER TABLE serial.caption_and_pattern OWNER TO evergreen;

--
-- Name: caption_and_pattern_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.caption_and_pattern_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.caption_and_pattern_id_seq OWNER TO evergreen;

--
-- Name: caption_and_pattern_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.caption_and_pattern_id_seq OWNED BY serial.caption_and_pattern.id;


--
-- Name: distribution; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.distribution (
    id integer NOT NULL,
    subscription integer NOT NULL,
    holding_lib integer NOT NULL,
    label text NOT NULL,
    receive_call_number bigint,
    receive_unit_template integer,
    bind_call_number bigint,
    bind_unit_template integer,
    unit_label_prefix text,
    unit_label_suffix text,
    record_entry integer,
    summary_method text,
    display_grouping text DEFAULT 'chron'::text NOT NULL,
    CONSTRAINT distribution_display_grouping_check CHECK ((display_grouping = ANY (ARRAY['enum'::text, 'chron'::text]))),
    CONSTRAINT summary_method_check CHECK (((summary_method IS NULL) OR (summary_method = ANY (ARRAY['add_to_sre'::text, 'merge_with_sre'::text, 'use_sre_only'::text, 'use_sdist_only'::text]))))
);


ALTER TABLE serial.distribution OWNER TO evergreen;

--
-- Name: distribution_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.distribution_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.distribution_id_seq OWNER TO evergreen;

--
-- Name: distribution_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.distribution_id_seq OWNED BY serial.distribution.id;


--
-- Name: distribution_note; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.distribution_note (
    id integer NOT NULL,
    distribution integer NOT NULL,
    creator integer NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL,
    alert boolean DEFAULT false NOT NULL
);


ALTER TABLE serial.distribution_note OWNER TO evergreen;

--
-- Name: distribution_note_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.distribution_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.distribution_note_id_seq OWNER TO evergreen;

--
-- Name: distribution_note_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.distribution_note_id_seq OWNED BY serial.distribution_note.id;


--
-- Name: index_summary_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.index_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.index_summary_id_seq OWNER TO evergreen;

--
-- Name: index_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.index_summary_id_seq OWNED BY serial.index_summary.id;


--
-- Name: issuance; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.issuance (
    id integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    subscription integer NOT NULL,
    label text,
    date_published timestamp with time zone,
    holding_code text,
    holding_type text,
    holding_link_id integer,
    caption_and_pattern integer,
    CONSTRAINT issuance_holding_code_check CHECK (((holding_code IS NULL) OR evergreen.could_be_serial_holding_code(holding_code))),
    CONSTRAINT valid_holding_type CHECK (((holding_type IS NULL) OR (holding_type = ANY (ARRAY['basic'::text, 'supplement'::text, 'index'::text]))))
);


ALTER TABLE serial.issuance OWNER TO evergreen;

--
-- Name: issuance_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.issuance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.issuance_id_seq OWNER TO evergreen;

--
-- Name: issuance_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.issuance_id_seq OWNED BY serial.issuance.id;


--
-- Name: item; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.item (
    id integer NOT NULL,
    creator integer NOT NULL,
    editor integer NOT NULL,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    issuance integer NOT NULL,
    stream integer NOT NULL,
    unit integer,
    uri integer,
    date_expected timestamp with time zone,
    date_received timestamp with time zone,
    status text DEFAULT 'Expected'::text,
    shadowed boolean DEFAULT false NOT NULL,
    CONSTRAINT value_status_check CHECK ((status = ANY (ARRAY['Bindery'::text, 'Bound'::text, 'Claimed'::text, 'Discarded'::text, 'Expected'::text, 'Not Held'::text, 'Not Published'::text, 'Received'::text])))
);


ALTER TABLE serial.item OWNER TO evergreen;

--
-- Name: item_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.item_id_seq OWNER TO evergreen;

--
-- Name: item_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.item_id_seq OWNED BY serial.item.id;


--
-- Name: item_note; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.item_note (
    id integer NOT NULL,
    item integer NOT NULL,
    creator integer NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL,
    alert boolean DEFAULT false NOT NULL
);


ALTER TABLE serial.item_note OWNER TO evergreen;

--
-- Name: item_note_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.item_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.item_note_id_seq OWNER TO evergreen;

--
-- Name: item_note_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.item_note_id_seq OWNED BY serial.item_note.id;


--
-- Name: materialized_holding_code; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.materialized_holding_code (
    id bigint NOT NULL,
    issuance integer NOT NULL,
    subfield character(1),
    value text
);


ALTER TABLE serial.materialized_holding_code OWNER TO evergreen;

--
-- Name: materialized_holding_code_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.materialized_holding_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.materialized_holding_code_id_seq OWNER TO evergreen;

--
-- Name: materialized_holding_code_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.materialized_holding_code_id_seq OWNED BY serial.materialized_holding_code.id;


--
-- Name: pattern_template_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.pattern_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.pattern_template_id_seq OWNER TO evergreen;

--
-- Name: pattern_template_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.pattern_template_id_seq OWNED BY serial.pattern_template.id;


--
-- Name: record_entry; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.record_entry (
    id bigint NOT NULL,
    record bigint,
    owning_lib integer DEFAULT 1 NOT NULL,
    creator integer DEFAULT 1 NOT NULL,
    editor integer DEFAULT 1 NOT NULL,
    source integer,
    create_date timestamp with time zone DEFAULT now() NOT NULL,
    edit_date timestamp with time zone DEFAULT now() NOT NULL,
    active boolean DEFAULT true NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    marc text,
    last_xact_id text NOT NULL,
    owner integer
);


ALTER TABLE serial.record_entry OWNER TO evergreen;

--
-- Name: record_entry_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.record_entry_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.record_entry_id_seq OWNER TO evergreen;

--
-- Name: record_entry_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.record_entry_id_seq OWNED BY serial.record_entry.id;


--
-- Name: routing_list_user; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.routing_list_user (
    id integer NOT NULL,
    stream integer NOT NULL,
    pos integer DEFAULT 1 NOT NULL,
    reader integer,
    department text,
    note text,
    CONSTRAINT reader_or_dept CHECK ((((reader IS NOT NULL) AND (department IS NULL)) OR ((reader IS NULL) AND (department IS NOT NULL))))
);


ALTER TABLE serial.routing_list_user OWNER TO evergreen;

--
-- Name: routing_list_user_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.routing_list_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.routing_list_user_id_seq OWNER TO evergreen;

--
-- Name: routing_list_user_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.routing_list_user_id_seq OWNED BY serial.routing_list_user.id;


--
-- Name: stream; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.stream (
    id integer NOT NULL,
    distribution integer NOT NULL,
    routing_label text
);


ALTER TABLE serial.stream OWNER TO evergreen;

--
-- Name: stream_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.stream_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.stream_id_seq OWNER TO evergreen;

--
-- Name: stream_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.stream_id_seq OWNED BY serial.stream.id;


--
-- Name: subscription; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.subscription (
    id integer NOT NULL,
    start_date timestamp with time zone NOT NULL,
    end_date timestamp with time zone,
    record_entry bigint,
    expected_date_offset interval,
    owning_lib integer DEFAULT 1 NOT NULL
);


ALTER TABLE serial.subscription OWNER TO evergreen;

--
-- Name: subscription_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.subscription_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.subscription_id_seq OWNER TO evergreen;

--
-- Name: subscription_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.subscription_id_seq OWNED BY serial.subscription.id;


--
-- Name: subscription_note; Type: TABLE; Schema: serial; Owner: evergreen
--

CREATE TABLE serial.subscription_note (
    id integer NOT NULL,
    subscription integer NOT NULL,
    creator integer NOT NULL,
    create_date timestamp with time zone DEFAULT now(),
    pub boolean DEFAULT false NOT NULL,
    title text NOT NULL,
    value text NOT NULL,
    alert boolean DEFAULT false NOT NULL
);


ALTER TABLE serial.subscription_note OWNER TO evergreen;

--
-- Name: subscription_note_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.subscription_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.subscription_note_id_seq OWNER TO evergreen;

--
-- Name: subscription_note_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.subscription_note_id_seq OWNED BY serial.subscription_note.id;


--
-- Name: supplement_summary_id_seq; Type: SEQUENCE; Schema: serial; Owner: evergreen
--

CREATE SEQUENCE serial.supplement_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE serial.supplement_summary_id_seq OWNER TO evergreen;

--
-- Name: supplement_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: serial; Owner: evergreen
--

ALTER SEQUENCE serial.supplement_summary_id_seq OWNED BY serial.supplement_summary.id;


--
-- Name: account; Type: TABLE; Schema: sip; Owner: evergreen
--

CREATE TABLE sip.account (
    id integer NOT NULL,
    enabled boolean DEFAULT true NOT NULL,
    setting_group integer NOT NULL,
    sip_username text NOT NULL,
    usr bigint NOT NULL,
    workstation integer,
    transient boolean DEFAULT false NOT NULL,
    activity_who text
);


ALTER TABLE sip.account OWNER TO evergreen;

--
-- Name: account_id_seq; Type: SEQUENCE; Schema: sip; Owner: evergreen
--

CREATE SEQUENCE sip.account_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sip.account_id_seq OWNER TO evergreen;

--
-- Name: account_id_seq; Type: SEQUENCE OWNED BY; Schema: sip; Owner: evergreen
--

ALTER SEQUENCE sip.account_id_seq OWNED BY sip.account.id;


--
-- Name: screen_message; Type: TABLE; Schema: sip; Owner: evergreen
--

CREATE TABLE sip.screen_message (
    key text NOT NULL,
    message text NOT NULL
);


ALTER TABLE sip.screen_message OWNER TO evergreen;

--
-- Name: session; Type: TABLE; Schema: sip; Owner: evergreen
--

CREATE TABLE sip.session (
    key text NOT NULL,
    ils_token text NOT NULL,
    account integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE sip.session OWNER TO evergreen;

--
-- Name: setting; Type: TABLE; Schema: sip; Owner: evergreen
--

CREATE TABLE sip.setting (
    id integer NOT NULL,
    setting_group integer NOT NULL,
    name text NOT NULL,
    description text NOT NULL,
    value json NOT NULL
);


ALTER TABLE sip.setting OWNER TO evergreen;

--
-- Name: setting_group; Type: TABLE; Schema: sip; Owner: evergreen
--

CREATE TABLE sip.setting_group (
    id integer NOT NULL,
    label text NOT NULL,
    institution text NOT NULL
);


ALTER TABLE sip.setting_group OWNER TO evergreen;

--
-- Name: setting_group_id_seq; Type: SEQUENCE; Schema: sip; Owner: evergreen
--

CREATE SEQUENCE sip.setting_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sip.setting_group_id_seq OWNER TO evergreen;

--
-- Name: setting_group_id_seq; Type: SEQUENCE OWNED BY; Schema: sip; Owner: evergreen
--

ALTER SEQUENCE sip.setting_group_id_seq OWNED BY sip.setting_group.id;


--
-- Name: setting_id_seq; Type: SEQUENCE; Schema: sip; Owner: evergreen
--

CREATE SEQUENCE sip.setting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sip.setting_id_seq OWNER TO evergreen;

--
-- Name: setting_id_seq; Type: SEQUENCE OWNED BY; Schema: sip; Owner: evergreen
--

ALTER SEQUENCE sip.setting_id_seq OWNED BY sip.setting.id;


--
-- Name: user; Type: TABLE; Schema: sip_temp; Owner: evergreen
--

CREATE TABLE sip_temp."user" (
    usrname text,
    passwd text,
    org_unit text
);


ALTER TABLE sip_temp."user" OWNER TO evergreen;

--
-- Name: mailing_address_stage; Type: TABLE; Schema: staging; Owner: evergreen
--

CREATE TABLE staging.mailing_address_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    street1 text,
    street2 text,
    city text DEFAULT ''::text NOT NULL,
    state text,
    country text DEFAULT 'US'::text NOT NULL,
    post_code text NOT NULL,
    complete boolean DEFAULT false,
    county text
);


ALTER TABLE staging.mailing_address_stage OWNER TO evergreen;

--
-- Name: mailing_address_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: evergreen
--

CREATE SEQUENCE staging.mailing_address_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.mailing_address_stage_row_id_seq OWNER TO evergreen;

--
-- Name: mailing_address_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: evergreen
--

ALTER SEQUENCE staging.mailing_address_stage_row_id_seq OWNED BY staging.mailing_address_stage.row_id;


--
-- Name: billing_address_stage; Type: TABLE; Schema: staging; Owner: evergreen
--

CREATE TABLE staging.billing_address_stage (
    row_id bigint DEFAULT nextval('staging.mailing_address_stage_row_id_seq'::regclass) NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    street1 text,
    street2 text,
    city text DEFAULT ''::text NOT NULL,
    state text,
    country text DEFAULT 'US'::text NOT NULL,
    post_code text NOT NULL,
    complete boolean DEFAULT false,
    county text
);


ALTER TABLE staging.billing_address_stage OWNER TO evergreen;

--
-- Name: card_stage; Type: TABLE; Schema: staging; Owner: evergreen
--

CREATE TABLE staging.card_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    barcode text NOT NULL,
    complete boolean DEFAULT false
);


ALTER TABLE staging.card_stage OWNER TO evergreen;

--
-- Name: card_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: evergreen
--

CREATE SEQUENCE staging.card_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.card_stage_row_id_seq OWNER TO evergreen;

--
-- Name: card_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: evergreen
--

ALTER SEQUENCE staging.card_stage_row_id_seq OWNED BY staging.card_stage.row_id;


--
-- Name: setting_stage; Type: TABLE; Schema: staging; Owner: evergreen
--

CREATE TABLE staging.setting_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    setting text NOT NULL,
    value text NOT NULL,
    complete boolean DEFAULT false
);


ALTER TABLE staging.setting_stage OWNER TO evergreen;

--
-- Name: setting_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: evergreen
--

CREATE SEQUENCE staging.setting_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.setting_stage_row_id_seq OWNER TO evergreen;

--
-- Name: setting_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: evergreen
--

ALTER SEQUENCE staging.setting_stage_row_id_seq OWNED BY staging.setting_stage.row_id;


--
-- Name: statcat_stage; Type: TABLE; Schema: staging; Owner: evergreen
--

CREATE TABLE staging.statcat_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    statcat text NOT NULL,
    value text NOT NULL,
    complete boolean DEFAULT false
);


ALTER TABLE staging.statcat_stage OWNER TO evergreen;

--
-- Name: statcat_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: evergreen
--

CREATE SEQUENCE staging.statcat_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.statcat_stage_row_id_seq OWNER TO evergreen;

--
-- Name: statcat_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: evergreen
--

ALTER SEQUENCE staging.statcat_stage_row_id_seq OWNED BY staging.statcat_stage.row_id;


--
-- Name: user_stage; Type: TABLE; Schema: staging; Owner: evergreen
--

CREATE TABLE staging.user_stage (
    row_id bigint NOT NULL,
    row_date timestamp with time zone DEFAULT now(),
    usrname text NOT NULL,
    profile text,
    email text,
    passwd text,
    ident_type integer DEFAULT 3,
    first_given_name text,
    second_given_name text,
    family_name text,
    day_phone text,
    evening_phone text,
    home_ou integer DEFAULT 2,
    dob text,
    complete boolean DEFAULT false,
    requesting_usr integer,
    ident_value2 text,
    delivery_method text,
    net_access_level integer,
    pref_first_given_name text,
    pref_second_given_name text,
    pref_family_name text
);


ALTER TABLE staging.user_stage OWNER TO evergreen;

--
-- Name: user_stage_row_id_seq; Type: SEQUENCE; Schema: staging; Owner: evergreen
--

CREATE SEQUENCE staging.user_stage_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE staging.user_stage_row_id_seq OWNER TO evergreen;

--
-- Name: user_stage_row_id_seq; Type: SEQUENCE OWNED BY; Schema: staging; Owner: evergreen
--

ALTER SEQUENCE staging.user_stage_row_id_seq OWNED BY staging.user_stage.row_id;


--
-- Name: fleshed_call_number; Type: VIEW; Schema: stats; Owner: evergreen
--

CREATE VIEW stats.fleshed_call_number AS
 SELECT cn.id,
    cn.creator,
    cn.create_date,
    cn.editor,
    cn.edit_date,
    cn.record,
    cn.owning_lib,
    cn.label,
    cn.deleted,
    cn.label_class,
    cn.label_sortkey,
    cn.prefix,
    cn.suffix,
    (cn.create_date)::date AS create_date_day,
    (cn.edit_date)::date AS edit_date_day,
    date_trunc('hour'::text, cn.create_date) AS create_date_hour,
    date_trunc('hour'::text, cn.edit_date) AS edit_date_hour,
    rd.item_lang,
    rd.item_type,
    rd.item_form
   FROM (asset.call_number cn
     JOIN metabib.rec_descriptor rd ON ((rd.record = cn.record)));


ALTER TABLE stats.fleshed_call_number OWNER TO evergreen;

--
-- Name: fleshed_copy; Type: VIEW; Schema: stats; Owner: evergreen
--

CREATE VIEW stats.fleshed_copy AS
 SELECT cp.id,
    cp.circ_lib,
    cp.creator,
    cp.call_number,
    cp.editor,
    cp.create_date,
    cp.edit_date,
    cp.copy_number,
    cp.status,
    cp.location,
    cp.loan_duration,
    cp.fine_level,
    cp.age_protect,
    cp.circulate,
    cp.deposit,
    cp.ref,
    cp.holdable,
    cp.deposit_amount,
    cp.price,
    cp.barcode,
    cp.circ_modifier,
    cp.circ_as_type,
    cp.dummy_title,
    cp.dummy_author,
    cp.alert_message,
    cp.opac_visible,
    cp.deleted,
    cp.floating,
    cp.dummy_isbn,
    cp.status_changed_time,
    cp.mint_condition,
    cp.cost,
    (cp.create_date)::date AS create_date_day,
    (cp.edit_date)::date AS edit_date_day,
    date_trunc('hour'::text, cp.create_date) AS create_date_hour,
    date_trunc('hour'::text, cp.edit_date) AS edit_date_hour,
    cn.label AS call_number_label,
    cn.owning_lib,
    rd.item_lang,
    rd.item_type,
    rd.item_form
   FROM ((asset.copy cp
     JOIN asset.call_number cn ON ((cp.call_number = cn.id)))
     JOIN metabib.rec_descriptor rd ON ((rd.record = cn.record)));


ALTER TABLE stats.fleshed_copy OWNER TO evergreen;

--
-- Name: fleshed_circulation; Type: VIEW; Schema: stats; Owner: evergreen
--

CREATE VIEW stats.fleshed_circulation AS
 SELECT c.id,
    c.usr,
    c.xact_start,
    c.xact_finish,
    c.unrecovered,
    c.target_copy,
    c.circ_lib,
    c.circ_staff,
    c.checkin_staff,
    c.checkin_lib,
    c.renewal_remaining,
    c.due_date,
    c.stop_fines_time,
    c.checkin_time,
    c.create_time,
    c.duration,
    c.fine_interval,
    c.recurring_fine,
    c.max_fine,
    c.phone_renewal,
    c.desk_renewal,
    c.opac_renewal,
    c.duration_rule,
    c.recurring_fine_rule,
    c.max_fine_rule,
    c.stop_fines,
    c.workstation,
    c.checkin_workstation,
    c.checkin_scan_time,
    c.parent_circ,
    c.grace_period,
    (c.xact_start)::date AS start_date_day,
    (c.xact_finish)::date AS finish_date_day,
    date_trunc('hour'::text, c.xact_start) AS start_date_hour,
    date_trunc('hour'::text, c.xact_finish) AS finish_date_hour,
    cp.call_number_label,
    cp.owning_lib,
    cp.item_lang,
    cp.item_type,
    cp.item_form
   FROM (action.circulation c
     JOIN stats.fleshed_copy cp ON ((cp.id = c.target_copy)));


ALTER TABLE stats.fleshed_circulation OWNER TO evergreen;

--
-- Name: bre_output_layout; Type: TABLE; Schema: unapi; Owner: evergreen
--

CREATE TABLE unapi.bre_output_layout (
    name text NOT NULL,
    transform text,
    mime_type text NOT NULL,
    feed_top text NOT NULL,
    holdings_element text,
    title_element text,
    description_element text,
    creator_element text,
    update_ts_element text
);


ALTER TABLE unapi.bre_output_layout OWNER TO evergreen;

--
-- Name: session; Type: TABLE; Schema: url_verify; Owner: evergreen
--

CREATE TABLE url_verify.session (
    id integer NOT NULL,
    name text NOT NULL,
    owning_lib integer NOT NULL,
    creator integer NOT NULL,
    container integer NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    search text NOT NULL
);


ALTER TABLE url_verify.session OWNER TO evergreen;

--
-- Name: session_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: evergreen
--

CREATE SEQUENCE url_verify.session_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.session_id_seq OWNER TO evergreen;

--
-- Name: session_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: evergreen
--

ALTER SEQUENCE url_verify.session_id_seq OWNED BY url_verify.session.id;


--
-- Name: url_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: evergreen
--

CREATE SEQUENCE url_verify.url_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.url_id_seq OWNER TO evergreen;

--
-- Name: url_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: evergreen
--

ALTER SEQUENCE url_verify.url_id_seq OWNED BY url_verify.url.id;


--
-- Name: url_selector; Type: TABLE; Schema: url_verify; Owner: evergreen
--

CREATE TABLE url_verify.url_selector (
    id integer NOT NULL,
    xpath text NOT NULL,
    session integer NOT NULL
);


ALTER TABLE url_verify.url_selector OWNER TO evergreen;

--
-- Name: url_selector_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: evergreen
--

CREATE SEQUENCE url_verify.url_selector_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.url_selector_id_seq OWNER TO evergreen;

--
-- Name: url_selector_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: evergreen
--

ALTER SEQUENCE url_verify.url_selector_id_seq OWNED BY url_verify.url_selector.id;


--
-- Name: url_verification; Type: TABLE; Schema: url_verify; Owner: evergreen
--

CREATE TABLE url_verify.url_verification (
    id integer NOT NULL,
    url integer NOT NULL,
    attempt integer NOT NULL,
    req_time timestamp with time zone DEFAULT now() NOT NULL,
    res_time timestamp with time zone,
    res_code integer,
    res_text text,
    redirect_to integer,
    CONSTRAINT url_verification_res_code_check CHECK (((res_code >= 100) AND (res_code <= 999)))
);


ALTER TABLE url_verify.url_verification OWNER TO evergreen;

--
-- Name: url_verification_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: evergreen
--

CREATE SEQUENCE url_verify.url_verification_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.url_verification_id_seq OWNER TO evergreen;

--
-- Name: url_verification_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: evergreen
--

ALTER SEQUENCE url_verify.url_verification_id_seq OWNED BY url_verify.url_verification.id;


--
-- Name: verification_attempt; Type: TABLE; Schema: url_verify; Owner: evergreen
--

CREATE TABLE url_verify.verification_attempt (
    id integer NOT NULL,
    usr integer NOT NULL,
    session integer NOT NULL,
    start_time timestamp with time zone DEFAULT now() NOT NULL,
    finish_time timestamp with time zone
);


ALTER TABLE url_verify.verification_attempt OWNER TO evergreen;

--
-- Name: verification_attempt_id_seq; Type: SEQUENCE; Schema: url_verify; Owner: evergreen
--

CREATE SEQUENCE url_verify.verification_attempt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE url_verify.verification_attempt_id_seq OWNER TO evergreen;

--
-- Name: verification_attempt_id_seq; Type: SEQUENCE OWNED BY; Schema: url_verify; Owner: evergreen
--

ALTER SEQUENCE url_verify.verification_attempt_id_seq OWNED BY url_verify.verification_attempt.id;


--
-- Name: authority_attr_definition; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.authority_attr_definition (
    id integer NOT NULL,
    code text NOT NULL,
    description text,
    xpath text NOT NULL,
    remove text DEFAULT ''::text NOT NULL
);


ALTER TABLE vandelay.authority_attr_definition OWNER TO evergreen;

--
-- Name: authority_attr_definition_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.authority_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.authority_attr_definition_id_seq OWNER TO evergreen;

--
-- Name: authority_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.authority_attr_definition_id_seq OWNED BY vandelay.authority_attr_definition.id;


--
-- Name: authority_match; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.authority_match (
    id bigint NOT NULL,
    queued_record bigint,
    eg_record bigint,
    quality integer DEFAULT 0 NOT NULL,
    match_score integer DEFAULT 0 NOT NULL
);


ALTER TABLE vandelay.authority_match OWNER TO evergreen;

--
-- Name: authority_match_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.authority_match_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.authority_match_id_seq OWNER TO evergreen;

--
-- Name: authority_match_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.authority_match_id_seq OWNED BY vandelay.authority_match.id;


--
-- Name: queue; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.queue (
    id bigint NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    complete boolean DEFAULT false NOT NULL,
    match_set integer
);


ALTER TABLE vandelay.queue OWNER TO evergreen;

--
-- Name: authority_queue; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.authority_queue (
    queue_type vandelay.authority_queue_queue_type DEFAULT 'authority'::vandelay.authority_queue_queue_type NOT NULL
)
INHERITS (vandelay.queue);


ALTER TABLE vandelay.authority_queue OWNER TO evergreen;

--
-- Name: bib_attr_definition; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.bib_attr_definition (
    id integer NOT NULL,
    code text NOT NULL,
    description text,
    xpath text NOT NULL,
    remove text DEFAULT ''::text NOT NULL
);


ALTER TABLE vandelay.bib_attr_definition OWNER TO evergreen;

--
-- Name: bib_attr_definition_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.bib_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.bib_attr_definition_id_seq OWNER TO evergreen;

--
-- Name: bib_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.bib_attr_definition_id_seq OWNED BY vandelay.bib_attr_definition.id;


--
-- Name: bib_match; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.bib_match (
    id bigint NOT NULL,
    queued_record bigint,
    eg_record bigint,
    quality integer DEFAULT 1 NOT NULL,
    match_score integer DEFAULT 0 NOT NULL
);


ALTER TABLE vandelay.bib_match OWNER TO evergreen;

--
-- Name: bib_match_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.bib_match_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.bib_match_id_seq OWNER TO evergreen;

--
-- Name: bib_match_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.bib_match_id_seq OWNED BY vandelay.bib_match.id;


--
-- Name: bib_queue; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.bib_queue (
    queue_type vandelay.bib_queue_queue_type DEFAULT 'bib'::vandelay.bib_queue_queue_type NOT NULL,
    item_attr_def bigint,
    match_bucket integer
)
INHERITS (vandelay.queue);


ALTER TABLE vandelay.bib_queue OWNER TO evergreen;

--
-- Name: import_bib_trash_fields; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.import_bib_trash_fields (
    id bigint NOT NULL,
    field text NOT NULL,
    grp integer NOT NULL
);


ALTER TABLE vandelay.import_bib_trash_fields OWNER TO evergreen;

--
-- Name: import_bib_trash_fields_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.import_bib_trash_fields_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_bib_trash_fields_id_seq OWNER TO evergreen;

--
-- Name: import_bib_trash_fields_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.import_bib_trash_fields_id_seq OWNED BY vandelay.import_bib_trash_fields.id;


--
-- Name: import_bib_trash_group; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.import_bib_trash_group (
    id integer NOT NULL,
    owner integer NOT NULL,
    label text NOT NULL,
    always_apply boolean DEFAULT false NOT NULL
);


ALTER TABLE vandelay.import_bib_trash_group OWNER TO evergreen;

--
-- Name: import_bib_trash_group_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.import_bib_trash_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_bib_trash_group_id_seq OWNER TO evergreen;

--
-- Name: import_bib_trash_group_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.import_bib_trash_group_id_seq OWNED BY vandelay.import_bib_trash_group.id;


--
-- Name: import_error; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.import_error (
    code text NOT NULL,
    description text NOT NULL
);


ALTER TABLE vandelay.import_error OWNER TO evergreen;

--
-- Name: import_item_attr_definition; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.import_item_attr_definition (
    id bigint NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    tag text NOT NULL,
    keep boolean DEFAULT false NOT NULL,
    owning_lib text,
    circ_lib text,
    call_number text,
    copy_number text,
    status text,
    location text,
    circulate text,
    deposit text,
    deposit_amount text,
    ref text,
    holdable text,
    price text,
    barcode text,
    circ_modifier text,
    circ_as_type text,
    alert_message text,
    opac_visible text,
    pub_note_title text,
    pub_note text,
    priv_note_title text,
    priv_note text,
    internal_id text,
    stat_cat_data text,
    parts_data text
);


ALTER TABLE vandelay.import_item_attr_definition OWNER TO evergreen;

--
-- Name: import_item_attr_definition_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.import_item_attr_definition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_item_attr_definition_id_seq OWNER TO evergreen;

--
-- Name: import_item_attr_definition_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.import_item_attr_definition_id_seq OWNED BY vandelay.import_item_attr_definition.id;


--
-- Name: import_item_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.import_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.import_item_id_seq OWNER TO evergreen;

--
-- Name: import_item_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.import_item_id_seq OWNED BY vandelay.import_item.id;


--
-- Name: match_set; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.match_set (
    id integer NOT NULL,
    name text NOT NULL,
    owner integer NOT NULL,
    mtype text DEFAULT 'biblio'::text NOT NULL
);


ALTER TABLE vandelay.match_set OWNER TO evergreen;

--
-- Name: match_set_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.match_set_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.match_set_id_seq OWNER TO evergreen;

--
-- Name: match_set_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.match_set_id_seq OWNED BY vandelay.match_set.id;


--
-- Name: match_set_point_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.match_set_point_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.match_set_point_id_seq OWNER TO evergreen;

--
-- Name: match_set_point_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.match_set_point_id_seq OWNED BY vandelay.match_set_point.id;


--
-- Name: match_set_quality; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.match_set_quality (
    id integer NOT NULL,
    match_set integer NOT NULL,
    svf text,
    tag text,
    subfield text,
    value text NOT NULL,
    quality integer DEFAULT 1 NOT NULL,
    CONSTRAINT vmsq_need_a_subfield_with_a_tag CHECK ((((tag IS NOT NULL) AND (subfield IS NOT NULL)) OR (tag IS NULL))),
    CONSTRAINT vmsq_need_a_tag_or_a_ff CHECK ((((tag IS NOT NULL) AND (svf IS NULL)) OR ((tag IS NULL) AND (svf IS NOT NULL))))
);


ALTER TABLE vandelay.match_set_quality OWNER TO evergreen;

--
-- Name: match_set_quality_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.match_set_quality_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.match_set_quality_id_seq OWNER TO evergreen;

--
-- Name: match_set_quality_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.match_set_quality_id_seq OWNED BY vandelay.match_set_quality.id;


--
-- Name: merge_profile; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.merge_profile (
    id bigint NOT NULL,
    owner integer NOT NULL,
    name text NOT NULL,
    add_spec text,
    replace_spec text,
    strip_spec text,
    preserve_spec text,
    lwm_ratio numeric,
    update_bib_source boolean DEFAULT false NOT NULL,
    update_bib_editor boolean DEFAULT false NOT NULL,
    CONSTRAINT add_replace_strip_or_preserve CHECK (((preserve_spec IS NOT NULL) OR (replace_spec IS NOT NULL) OR ((preserve_spec IS NULL) AND (replace_spec IS NULL))))
);


ALTER TABLE vandelay.merge_profile OWNER TO evergreen;

--
-- Name: merge_profile_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.merge_profile_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.merge_profile_id_seq OWNER TO evergreen;

--
-- Name: merge_profile_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.merge_profile_id_seq OWNED BY vandelay.merge_profile.id;


--
-- Name: queue_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queue_id_seq OWNER TO evergreen;

--
-- Name: queue_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.queue_id_seq OWNED BY vandelay.queue.id;


--
-- Name: queued_record; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.queued_record (
    id bigint NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    import_time timestamp with time zone,
    purpose text DEFAULT 'import'::text NOT NULL,
    marc text NOT NULL,
    quality integer DEFAULT 0 NOT NULL,
    CONSTRAINT queued_record_purpose_check CHECK ((purpose = ANY (ARRAY['import'::text, 'overlay'::text])))
);


ALTER TABLE vandelay.queued_record OWNER TO evergreen;

--
-- Name: queued_authority_record; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.queued_authority_record (
    queue integer NOT NULL,
    imported_as integer,
    import_error text,
    error_detail text
)
INHERITS (vandelay.queued_record);


ALTER TABLE vandelay.queued_authority_record OWNER TO evergreen;

--
-- Name: queued_authority_record_attr; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.queued_authority_record_attr (
    id bigint NOT NULL,
    record bigint NOT NULL,
    field integer NOT NULL,
    attr_value text NOT NULL
);


ALTER TABLE vandelay.queued_authority_record_attr OWNER TO evergreen;

--
-- Name: queued_authority_record_attr_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.queued_authority_record_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queued_authority_record_attr_id_seq OWNER TO evergreen;

--
-- Name: queued_authority_record_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.queued_authority_record_attr_id_seq OWNED BY vandelay.queued_authority_record_attr.id;


--
-- Name: queued_bib_record; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.queued_bib_record (
    queue integer NOT NULL,
    bib_source integer,
    imported_as bigint,
    import_error text,
    error_detail text
)
INHERITS (vandelay.queued_record);


ALTER TABLE vandelay.queued_bib_record OWNER TO evergreen;

--
-- Name: queued_bib_record_attr; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.queued_bib_record_attr (
    id bigint NOT NULL,
    record bigint NOT NULL,
    field integer NOT NULL,
    attr_value text NOT NULL
);


ALTER TABLE vandelay.queued_bib_record_attr OWNER TO evergreen;

--
-- Name: queued_bib_record_attr_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.queued_bib_record_attr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queued_bib_record_attr_id_seq OWNER TO evergreen;

--
-- Name: queued_bib_record_attr_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.queued_bib_record_attr_id_seq OWNED BY vandelay.queued_bib_record_attr.id;


--
-- Name: queued_record_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.queued_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.queued_record_id_seq OWNER TO evergreen;

--
-- Name: queued_record_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.queued_record_id_seq OWNED BY vandelay.queued_record.id;


--
-- Name: session_tracker; Type: TABLE; Schema: vandelay; Owner: evergreen
--

CREATE TABLE vandelay.session_tracker (
    id bigint NOT NULL,
    session_key text NOT NULL,
    name text NOT NULL,
    usr integer NOT NULL,
    workstation integer NOT NULL,
    record_type text DEFAULT 'bib'::text NOT NULL,
    queue bigint NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    update_time timestamp with time zone DEFAULT now() NOT NULL,
    state text DEFAULT 'active'::text NOT NULL,
    action_type text DEFAULT 'enqueue'::text NOT NULL,
    total_actions integer DEFAULT 0 NOT NULL,
    actions_performed integer DEFAULT 0 NOT NULL,
    CONSTRAINT vand_tracker_valid_action_type CHECK ((action_type = ANY (ARRAY['upload'::text, 'enqueue'::text, 'import'::text]))),
    CONSTRAINT vand_tracker_valid_record_type CHECK ((record_type = ANY (ARRAY['bib'::text, 'authority'::text]))),
    CONSTRAINT vand_tracker_valid_state CHECK ((state = ANY (ARRAY['active'::text, 'error'::text, 'complete'::text])))
);


ALTER TABLE vandelay.session_tracker OWNER TO evergreen;

--
-- Name: session_tracker_id_seq; Type: SEQUENCE; Schema: vandelay; Owner: evergreen
--

CREATE SEQUENCE vandelay.session_tracker_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vandelay.session_tracker_id_seq OWNER TO evergreen;

--
-- Name: session_tracker_id_seq; Type: SEQUENCE OWNED BY; Schema: vandelay; Owner: evergreen
--

ALTER SEQUENCE vandelay.session_tracker_id_seq OWNED BY vandelay.session_tracker.id;


--
-- Name: cancel_reason id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.cancel_reason ALTER COLUMN id SET DEFAULT nextval('acq.cancel_reason_id_seq'::regclass);


--
-- Name: claim id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim ALTER COLUMN id SET DEFAULT nextval('acq.claim_id_seq'::regclass);


--
-- Name: claim_event id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_event ALTER COLUMN id SET DEFAULT nextval('acq.claim_event_id_seq'::regclass);


--
-- Name: claim_event claim; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_event ALTER COLUMN claim SET DEFAULT nextval('acq.claim_event_claim_seq'::regclass);


--
-- Name: claim_event_type id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_event_type ALTER COLUMN id SET DEFAULT nextval('acq.claim_event_type_id_seq'::regclass);


--
-- Name: claim_policy id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_policy ALTER COLUMN id SET DEFAULT nextval('acq.claim_policy_id_seq'::regclass);


--
-- Name: claim_policy_action id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_policy_action ALTER COLUMN id SET DEFAULT nextval('acq.claim_policy_action_id_seq'::regclass);


--
-- Name: claim_type id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_type ALTER COLUMN id SET DEFAULT nextval('acq.claim_type_id_seq'::regclass);


--
-- Name: distribution_formula id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula ALTER COLUMN id SET DEFAULT nextval('acq.distribution_formula_id_seq'::regclass);


--
-- Name: distribution_formula_application id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_application ALTER COLUMN id SET DEFAULT nextval('acq.distribution_formula_application_id_seq'::regclass);


--
-- Name: distribution_formula_entry id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_entry ALTER COLUMN id SET DEFAULT nextval('acq.distribution_formula_entry_id_seq'::regclass);


--
-- Name: edi_attr_set id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_attr_set ALTER COLUMN id SET DEFAULT nextval('acq.edi_attr_set_id_seq'::regclass);


--
-- Name: edi_attr_set_map id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_attr_set_map ALTER COLUMN id SET DEFAULT nextval('acq.edi_attr_set_map_id_seq'::regclass);


--
-- Name: edi_message id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_message ALTER COLUMN id SET DEFAULT nextval('acq.edi_message_id_seq'::regclass);


--
-- Name: exchange_rate id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.exchange_rate ALTER COLUMN id SET DEFAULT nextval('acq.exchange_rate_id_seq'::regclass);


--
-- Name: fiscal_calendar id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fiscal_calendar ALTER COLUMN id SET DEFAULT nextval('acq.fiscal_calendar_id_seq'::regclass);


--
-- Name: fiscal_year id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fiscal_year ALTER COLUMN id SET DEFAULT nextval('acq.fiscal_year_id_seq'::regclass);


--
-- Name: fund id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund ALTER COLUMN id SET DEFAULT nextval('acq.fund_id_seq'::regclass);


--
-- Name: fund_allocation id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_allocation ALTER COLUMN id SET DEFAULT nextval('acq.fund_allocation_id_seq'::regclass);


--
-- Name: fund_allocation_percent id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_allocation_percent ALTER COLUMN id SET DEFAULT nextval('acq.fund_allocation_percent_id_seq'::regclass);


--
-- Name: fund_debit id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_debit ALTER COLUMN id SET DEFAULT nextval('acq.fund_debit_id_seq'::regclass);


--
-- Name: fund_tag id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_tag ALTER COLUMN id SET DEFAULT nextval('acq.fund_tag_id_seq'::regclass);


--
-- Name: fund_tag_map id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_tag_map ALTER COLUMN id SET DEFAULT nextval('acq.fund_tag_map_id_seq'::regclass);


--
-- Name: fund_transfer id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_transfer ALTER COLUMN id SET DEFAULT nextval('acq.fund_transfer_id_seq'::regclass);


--
-- Name: funding_source id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.funding_source ALTER COLUMN id SET DEFAULT nextval('acq.funding_source_id_seq'::regclass);


--
-- Name: funding_source_credit id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.funding_source_credit ALTER COLUMN id SET DEFAULT nextval('acq.funding_source_credit_id_seq'::regclass);


--
-- Name: invoice id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice ALTER COLUMN id SET DEFAULT nextval('acq.invoice_id_seq'::regclass);


--
-- Name: invoice_entry id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_entry ALTER COLUMN id SET DEFAULT nextval('acq.invoice_entry_id_seq'::regclass);


--
-- Name: invoice_item id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_item ALTER COLUMN id SET DEFAULT nextval('acq.invoice_item_id_seq'::regclass);


--
-- Name: lineitem id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem ALTER COLUMN id SET DEFAULT nextval('acq.lineitem_id_seq'::regclass);


--
-- Name: lineitem_alert_text id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_alert_text ALTER COLUMN id SET DEFAULT nextval('acq.lineitem_alert_text_id_seq'::regclass);


--
-- Name: lineitem_attr id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_attr ALTER COLUMN id SET DEFAULT nextval('acq.lineitem_attr_id_seq'::regclass);


--
-- Name: lineitem_attr_definition id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_attr_definition ALTER COLUMN id SET DEFAULT nextval('acq.lineitem_attr_definition_id_seq'::regclass);


--
-- Name: lineitem_detail id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_detail ALTER COLUMN id SET DEFAULT nextval('acq.lineitem_detail_id_seq'::regclass);


--
-- Name: lineitem_generated_attr_definition remove; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_generated_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: lineitem_generated_attr_definition ident; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_generated_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: lineitem_local_attr_definition remove; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_local_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: lineitem_local_attr_definition ident; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_local_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: lineitem_marc_attr_definition remove; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_marc_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: lineitem_marc_attr_definition ident; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_marc_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: lineitem_note id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_note ALTER COLUMN id SET DEFAULT nextval('acq.lineitem_note_id_seq'::regclass);


--
-- Name: lineitem_provider_attr_definition remove; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_provider_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: lineitem_provider_attr_definition ident; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_provider_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: lineitem_usr_attr_definition remove; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_usr_attr_definition ALTER COLUMN remove SET DEFAULT ''::text;


--
-- Name: lineitem_usr_attr_definition ident; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_usr_attr_definition ALTER COLUMN ident SET DEFAULT false;


--
-- Name: picklist id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.picklist ALTER COLUMN id SET DEFAULT nextval('acq.picklist_id_seq'::regclass);


--
-- Name: po_item id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.po_item ALTER COLUMN id SET DEFAULT nextval('acq.po_item_id_seq'::regclass);


--
-- Name: po_note id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.po_note ALTER COLUMN id SET DEFAULT nextval('acq.po_note_id_seq'::regclass);


--
-- Name: provider id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider ALTER COLUMN id SET DEFAULT nextval('acq.provider_id_seq'::regclass);


--
-- Name: provider_address id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_address ALTER COLUMN id SET DEFAULT nextval('acq.provider_address_id_seq'::regclass);


--
-- Name: provider_contact id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_contact ALTER COLUMN id SET DEFAULT nextval('acq.provider_contact_id_seq'::regclass);


--
-- Name: provider_contact_address id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_contact_address ALTER COLUMN id SET DEFAULT nextval('acq.provider_contact_address_id_seq'::regclass);


--
-- Name: provider_holding_subfield_map id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_holding_subfield_map ALTER COLUMN id SET DEFAULT nextval('acq.provider_holding_subfield_map_id_seq'::regclass);


--
-- Name: provider_note id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_note ALTER COLUMN id SET DEFAULT nextval('acq.provider_note_id_seq'::regclass);


--
-- Name: purchase_order id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.purchase_order ALTER COLUMN id SET DEFAULT nextval('acq.purchase_order_id_seq'::regclass);


--
-- Name: serial_claim id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.serial_claim ALTER COLUMN id SET DEFAULT nextval('acq.serial_claim_id_seq'::regclass);


--
-- Name: serial_claim_event id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.serial_claim_event ALTER COLUMN id SET DEFAULT nextval('acq.serial_claim_event_id_seq'::regclass);


--
-- Name: serial_claim_event claim; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.serial_claim_event ALTER COLUMN claim SET DEFAULT nextval('acq.serial_claim_event_claim_seq'::regclass);


--
-- Name: shipment_notification id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification ALTER COLUMN id SET DEFAULT nextval('acq.shipment_notification_id_seq'::regclass);


--
-- Name: shipment_notification_entry id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification_entry ALTER COLUMN id SET DEFAULT nextval('acq.shipment_notification_entry_id_seq'::regclass);


--
-- Name: user_request id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request ALTER COLUMN id SET DEFAULT nextval('acq.user_request_id_seq'::regclass);


--
-- Name: user_request_status_type id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request_status_type ALTER COLUMN id SET DEFAULT nextval('acq.user_request_status_type_id_seq'::regclass);


--
-- Name: user_request_type id; Type: DEFAULT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request_type ALTER COLUMN id SET DEFAULT nextval('acq.user_request_type_id_seq'::regclass);


--
-- Name: archive_actor_stat_cat id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.archive_actor_stat_cat ALTER COLUMN id SET DEFAULT nextval('action.archive_actor_stat_cat_id_seq'::regclass);


--
-- Name: archive_asset_stat_cat id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.archive_asset_stat_cat ALTER COLUMN id SET DEFAULT nextval('action.archive_asset_stat_cat_id_seq'::regclass);


--
-- Name: batch_hold_event id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.batch_hold_event ALTER COLUMN id SET DEFAULT nextval('action.batch_hold_event_id_seq'::regclass);


--
-- Name: batch_hold_event_map id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.batch_hold_event_map ALTER COLUMN id SET DEFAULT nextval('action.batch_hold_event_map_id_seq'::regclass);


--
-- Name: circulation xact_start; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.circulation ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: curbside id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.curbside ALTER COLUMN id SET DEFAULT nextval('action.curbside_id_seq'::regclass);


--
-- Name: emergency_closing id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing ALTER COLUMN id SET DEFAULT nextval('action.emergency_closing_id_seq'::regclass);


--
-- Name: emergency_closing_circulation id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_circulation ALTER COLUMN id SET DEFAULT nextval('action.emergency_closing_circulation_id_seq'::regclass);


--
-- Name: emergency_closing_hold id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_hold ALTER COLUMN id SET DEFAULT nextval('action.emergency_closing_hold_id_seq'::regclass);


--
-- Name: emergency_closing_reservation id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_reservation ALTER COLUMN id SET DEFAULT nextval('action.emergency_closing_reservation_id_seq'::regclass);


--
-- Name: fieldset id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset ALTER COLUMN id SET DEFAULT nextval('action.fieldset_id_seq'::regclass);


--
-- Name: fieldset_col_val id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset_col_val ALTER COLUMN id SET DEFAULT nextval('action.fieldset_col_val_id_seq'::regclass);


--
-- Name: fieldset_group id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset_group ALTER COLUMN id SET DEFAULT nextval('action.fieldset_group_id_seq'::regclass);


--
-- Name: hold_copy_map id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_copy_map ALTER COLUMN id SET DEFAULT nextval('action.hold_copy_map_id_seq'::regclass);


--
-- Name: hold_notification id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_notification ALTER COLUMN id SET DEFAULT nextval('action.hold_notification_id_seq'::regclass);


--
-- Name: hold_request id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request ALTER COLUMN id SET DEFAULT nextval('action.hold_request_id_seq'::regclass);


--
-- Name: hold_request_cancel_cause id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request_cancel_cause ALTER COLUMN id SET DEFAULT nextval('action.hold_request_cancel_cause_id_seq'::regclass);


--
-- Name: hold_request_note id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request_note ALTER COLUMN id SET DEFAULT nextval('action.hold_request_note_id_seq'::regclass);


--
-- Name: hold_transit_copy id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_transit_copy ALTER COLUMN id SET DEFAULT nextval('action.transit_copy_id_seq'::regclass);


--
-- Name: hold_transit_copy persistant_transfer; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_transit_copy ALTER COLUMN persistant_transfer SET DEFAULT false;


--
-- Name: in_house_use id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.in_house_use ALTER COLUMN id SET DEFAULT nextval('action.in_house_use_id_seq'::regclass);


--
-- Name: non_cat_in_house_use id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cat_in_house_use ALTER COLUMN id SET DEFAULT nextval('action.non_cat_in_house_use_id_seq'::regclass);


--
-- Name: non_cataloged_circulation id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cataloged_circulation ALTER COLUMN id SET DEFAULT nextval('action.non_cataloged_circulation_id_seq'::regclass);


--
-- Name: reservation_transit_copy id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.reservation_transit_copy ALTER COLUMN id SET DEFAULT nextval('action.transit_copy_id_seq'::regclass);


--
-- Name: reservation_transit_copy persistant_transfer; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.reservation_transit_copy ALTER COLUMN persistant_transfer SET DEFAULT false;


--
-- Name: survey id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey ALTER COLUMN id SET DEFAULT nextval('action.survey_id_seq'::regclass);


--
-- Name: survey_answer id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey_answer ALTER COLUMN id SET DEFAULT nextval('action.survey_answer_id_seq'::regclass);


--
-- Name: survey_question id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey_question ALTER COLUMN id SET DEFAULT nextval('action.survey_question_id_seq'::regclass);


--
-- Name: survey_response id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey_response ALTER COLUMN id SET DEFAULT nextval('action.survey_response_id_seq'::regclass);


--
-- Name: transit_copy id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.transit_copy ALTER COLUMN id SET DEFAULT nextval('action.transit_copy_id_seq'::regclass);


--
-- Name: unfulfilled_hold_list id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.unfulfilled_hold_list ALTER COLUMN id SET DEFAULT nextval('action.unfulfilled_hold_list_id_seq'::regclass);


--
-- Name: usr_circ_history id; Type: DEFAULT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.usr_circ_history ALTER COLUMN id SET DEFAULT nextval('action.usr_circ_history_id_seq'::regclass);


--
-- Name: alternate_template id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.alternate_template ALTER COLUMN id SET DEFAULT nextval('action_trigger.alternate_template_id_seq'::regclass);


--
-- Name: environment id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.environment ALTER COLUMN id SET DEFAULT nextval('action_trigger.environment_id_seq'::regclass);


--
-- Name: event id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event ALTER COLUMN id SET DEFAULT nextval('action_trigger.event_id_seq'::regclass);


--
-- Name: event_def_group id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_def_group ALTER COLUMN id SET DEFAULT nextval('action_trigger.event_def_group_id_seq'::regclass);


--
-- Name: event_def_group_member id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_def_group_member ALTER COLUMN id SET DEFAULT nextval('action_trigger.event_def_group_member_id_seq'::regclass);


--
-- Name: event_definition id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_definition ALTER COLUMN id SET DEFAULT nextval('action_trigger.event_definition_id_seq'::regclass);


--
-- Name: event_output id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_output ALTER COLUMN id SET DEFAULT nextval('action_trigger.event_output_id_seq'::regclass);


--
-- Name: event_params id; Type: DEFAULT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_params ALTER COLUMN id SET DEFAULT nextval('action_trigger.event_params_id_seq'::regclass);


--
-- Name: ada_request id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.ada_request ALTER COLUMN id SET DEFAULT nextval('actor.ada_request_id_seq'::regclass);


--
-- Name: address_alert id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.address_alert ALTER COLUMN id SET DEFAULT nextval('actor.address_alert_id_seq'::regclass);


--
-- Name: card id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.card ALTER COLUMN id SET DEFAULT nextval('actor.card_id_seq'::regclass);


--
-- Name: copy_alert_suppress id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.copy_alert_suppress ALTER COLUMN id SET DEFAULT nextval('actor.copy_alert_suppress_id_seq'::regclass);


--
-- Name: org_address id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_address ALTER COLUMN id SET DEFAULT nextval('actor.org_address_id_seq'::regclass);


--
-- Name: org_lasso id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_lasso ALTER COLUMN id SET DEFAULT nextval('actor.org_lasso_id_seq'::regclass);


--
-- Name: org_lasso_map id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_lasso_map ALTER COLUMN id SET DEFAULT nextval('actor.org_lasso_map_id_seq'::regclass);


--
-- Name: org_unit id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit ALTER COLUMN id SET DEFAULT nextval('actor.org_unit_id_seq'::regclass);


--
-- Name: org_unit_closed id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_closed ALTER COLUMN id SET DEFAULT nextval('actor.org_unit_closed_id_seq'::regclass);


--
-- Name: org_unit_custom_tree id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_custom_tree ALTER COLUMN id SET DEFAULT nextval('actor.org_unit_custom_tree_id_seq'::regclass);


--
-- Name: org_unit_custom_tree_node id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_custom_tree_node ALTER COLUMN id SET DEFAULT nextval('actor.org_unit_custom_tree_node_id_seq'::regclass);


--
-- Name: org_unit_proximity id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_proximity ALTER COLUMN id SET DEFAULT nextval('actor.org_unit_proximity_id_seq'::regclass);


--
-- Name: org_unit_proximity_adjustment id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_proximity_adjustment ALTER COLUMN id SET DEFAULT nextval('actor.org_unit_proximity_adjustment_id_seq'::regclass);


--
-- Name: org_unit_setting id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_setting ALTER COLUMN id SET DEFAULT nextval('actor.org_unit_setting_id_seq'::regclass);


--
-- Name: org_unit_type id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_type ALTER COLUMN id SET DEFAULT nextval('actor.org_unit_type_id_seq'::regclass);


--
-- Name: passwd id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.passwd ALTER COLUMN id SET DEFAULT nextval('actor.passwd_id_seq'::regclass);


--
-- Name: search_filter_group id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_filter_group ALTER COLUMN id SET DEFAULT nextval('actor.search_filter_group_id_seq'::regclass);


--
-- Name: search_filter_group_entry id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_filter_group_entry ALTER COLUMN id SET DEFAULT nextval('actor.search_filter_group_entry_id_seq'::regclass);


--
-- Name: search_query id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_query ALTER COLUMN id SET DEFAULT nextval('actor.search_query_id_seq'::regclass);


--
-- Name: stat_cat id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat ALTER COLUMN id SET DEFAULT nextval('actor.stat_cat_id_seq'::regclass);


--
-- Name: stat_cat_entry id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry ALTER COLUMN id SET DEFAULT nextval('actor.stat_cat_entry_id_seq'::regclass);


--
-- Name: stat_cat_entry_default id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry_default ALTER COLUMN id SET DEFAULT nextval('actor.stat_cat_entry_default_id_seq'::regclass);


--
-- Name: stat_cat_entry_usr_map id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry_usr_map ALTER COLUMN id SET DEFAULT nextval('actor.stat_cat_entry_usr_map_id_seq'::regclass);


--
-- Name: toolbar id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.toolbar ALTER COLUMN id SET DEFAULT nextval('actor.toolbar_id_seq'::regclass);


--
-- Name: usr id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr ALTER COLUMN id SET DEFAULT nextval('actor.usr_id_seq'::regclass);


--
-- Name: usr usrgroup; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr ALTER COLUMN usrgroup SET DEFAULT nextval('actor.usr_usrgroup_seq'::regclass);


--
-- Name: usr_activity id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_activity ALTER COLUMN id SET DEFAULT nextval('actor.usr_activity_id_seq'::regclass);


--
-- Name: usr_address id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_address ALTER COLUMN id SET DEFAULT nextval('actor.usr_address_id_seq'::regclass);


--
-- Name: usr_message id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_message ALTER COLUMN id SET DEFAULT nextval('actor.usr_message_id_seq'::regclass);


--
-- Name: usr_org_unit_opt_in id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_org_unit_opt_in ALTER COLUMN id SET DEFAULT nextval('actor.usr_org_unit_opt_in_id_seq'::regclass);


--
-- Name: usr_password_reset id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_password_reset ALTER COLUMN id SET DEFAULT nextval('actor.usr_password_reset_id_seq'::regclass);


--
-- Name: usr_privacy_waiver id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_privacy_waiver ALTER COLUMN id SET DEFAULT nextval('actor.usr_privacy_waiver_id_seq'::regclass);


--
-- Name: usr_saved_search id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_saved_search ALTER COLUMN id SET DEFAULT nextval('actor.usr_saved_search_id_seq'::regclass);


--
-- Name: usr_setting id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_setting ALTER COLUMN id SET DEFAULT nextval('actor.usr_setting_id_seq'::regclass);


--
-- Name: workstation id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.workstation ALTER COLUMN id SET DEFAULT nextval('actor.workstation_id_seq'::regclass);


--
-- Name: workstation_setting id; Type: DEFAULT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.workstation_setting ALTER COLUMN id SET DEFAULT nextval('actor.workstation_setting_id_seq'::regclass);


--
-- Name: call_number id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number ALTER COLUMN id SET DEFAULT nextval('asset.call_number_id_seq'::regclass);


--
-- Name: call_number_class id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_class ALTER COLUMN id SET DEFAULT nextval('asset.call_number_class_id_seq'::regclass);


--
-- Name: call_number_note id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_note ALTER COLUMN id SET DEFAULT nextval('asset.call_number_note_id_seq'::regclass);


--
-- Name: call_number_prefix id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_prefix ALTER COLUMN id SET DEFAULT nextval('asset.call_number_prefix_id_seq'::regclass);


--
-- Name: call_number_suffix id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_suffix ALTER COLUMN id SET DEFAULT nextval('asset.call_number_suffix_id_seq'::regclass);


--
-- Name: copy id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: copy_alert id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_alert ALTER COLUMN id SET DEFAULT nextval('asset.copy_alert_id_seq'::regclass);


--
-- Name: copy_inventory id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_inventory ALTER COLUMN id SET DEFAULT nextval('asset.copy_inventory_id_seq'::regclass);


--
-- Name: copy_location id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location ALTER COLUMN id SET DEFAULT nextval('asset.copy_location_id_seq'::regclass);


--
-- Name: copy_location_group id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_group ALTER COLUMN id SET DEFAULT nextval('asset.copy_location_group_id_seq'::regclass);


--
-- Name: copy_location_group_map id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_group_map ALTER COLUMN id SET DEFAULT nextval('asset.copy_location_group_map_id_seq'::regclass);


--
-- Name: copy_location_order id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_order ALTER COLUMN id SET DEFAULT nextval('asset.copy_location_order_id_seq'::regclass);


--
-- Name: copy_note id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_note ALTER COLUMN id SET DEFAULT nextval('asset.copy_note_id_seq'::regclass);


--
-- Name: copy_part_map id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_part_map ALTER COLUMN id SET DEFAULT nextval('asset.copy_part_map_id_seq'::regclass);


--
-- Name: copy_tag id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_tag ALTER COLUMN id SET DEFAULT nextval('asset.copy_tag_id_seq'::regclass);


--
-- Name: copy_tag_copy_map id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_tag_copy_map ALTER COLUMN id SET DEFAULT nextval('asset.copy_tag_copy_map_id_seq'::regclass);


--
-- Name: copy_template id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_template ALTER COLUMN id SET DEFAULT nextval('asset.copy_template_id_seq'::regclass);


--
-- Name: copy_vis_attr_cache id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_vis_attr_cache ALTER COLUMN id SET DEFAULT nextval('asset.copy_vis_attr_cache_id_seq'::regclass);


--
-- Name: course_module_course id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course ALTER COLUMN id SET DEFAULT nextval('asset.course_module_course_id_seq'::regclass);


--
-- Name: course_module_course_materials id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_materials ALTER COLUMN id SET DEFAULT nextval('asset.course_module_course_materials_id_seq'::regclass);


--
-- Name: course_module_course_users id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_users ALTER COLUMN id SET DEFAULT nextval('asset.course_module_course_users_id_seq'::regclass);


--
-- Name: course_module_role id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_role ALTER COLUMN id SET DEFAULT nextval('asset.course_module_role_id_seq'::regclass);


--
-- Name: course_module_term id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_term ALTER COLUMN id SET DEFAULT nextval('asset.course_module_term_id_seq'::regclass);


--
-- Name: course_module_term_course_map id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_term_course_map ALTER COLUMN id SET DEFAULT nextval('asset.course_module_term_course_map_id_seq'::regclass);


--
-- Name: stat_cat id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat ALTER COLUMN id SET DEFAULT nextval('asset.stat_cat_id_seq'::regclass);


--
-- Name: stat_cat_entry id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry ALTER COLUMN id SET DEFAULT nextval('asset.stat_cat_entry_id_seq'::regclass);


--
-- Name: stat_cat_entry_copy_map id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry_copy_map ALTER COLUMN id SET DEFAULT nextval('asset.stat_cat_entry_copy_map_id_seq'::regclass);


--
-- Name: stat_cat_entry_transparency_map id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry_transparency_map ALTER COLUMN id SET DEFAULT nextval('asset.stat_cat_entry_transparency_map_id_seq'::regclass);


--
-- Name: uri id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.uri ALTER COLUMN id SET DEFAULT nextval('asset.uri_id_seq'::regclass);


--
-- Name: uri_call_number_map id; Type: DEFAULT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.uri_call_number_map ALTER COLUMN id SET DEFAULT nextval('asset.uri_call_number_map_id_seq'::regclass);


--
-- Name: authority_linking id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.authority_linking ALTER COLUMN id SET DEFAULT nextval('authority.authority_linking_id_seq'::regclass);


--
-- Name: bib_linking id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.bib_linking ALTER COLUMN id SET DEFAULT nextval('authority.bib_linking_id_seq'::regclass);


--
-- Name: browse_axis_authority_field_map id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.browse_axis_authority_field_map ALTER COLUMN id SET DEFAULT nextval('authority.browse_axis_authority_field_map_id_seq'::regclass);


--
-- Name: control_set id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set ALTER COLUMN id SET DEFAULT nextval('authority.control_set_id_seq'::regclass);


--
-- Name: control_set_authority_field id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_authority_field ALTER COLUMN id SET DEFAULT nextval('authority.control_set_authority_field_id_seq'::regclass);


--
-- Name: control_set_bib_field id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_bib_field ALTER COLUMN id SET DEFAULT nextval('authority.control_set_bib_field_id_seq'::regclass);


--
-- Name: control_set_bib_field_metabib_field_map id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_bib_field_metabib_field_map ALTER COLUMN id SET DEFAULT nextval('authority.control_set_bib_field_metabib_field_map_id_seq'::regclass);


--
-- Name: display_5xx_headings id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.display_5xx_headings ALTER COLUMN id SET DEFAULT nextval('authority.display_5xx_headings_id_seq'::regclass);


--
-- Name: full_rec id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.full_rec ALTER COLUMN id SET DEFAULT nextval('authority.full_rec_id_seq'::regclass);


--
-- Name: heading_field id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.heading_field ALTER COLUMN id SET DEFAULT nextval('authority.heading_field_id_seq'::regclass);


--
-- Name: heading_field_norm_map id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.heading_field_norm_map ALTER COLUMN id SET DEFAULT nextval('authority.heading_field_norm_map_id_seq'::regclass);


--
-- Name: rec_descriptor id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.rec_descriptor ALTER COLUMN id SET DEFAULT nextval('authority.rec_descriptor_id_seq'::regclass);


--
-- Name: record_entry id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.record_entry ALTER COLUMN id SET DEFAULT nextval('authority.record_entry_id_seq'::regclass);


--
-- Name: record_note id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.record_note ALTER COLUMN id SET DEFAULT nextval('authority.record_note_id_seq'::regclass);


--
-- Name: simple_heading id; Type: DEFAULT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.simple_heading ALTER COLUMN id SET DEFAULT nextval('authority.simple_heading_id_seq'::regclass);


--
-- Name: monograph_part id; Type: DEFAULT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.monograph_part ALTER COLUMN id SET DEFAULT nextval('biblio.monograph_part_id_seq'::regclass);


--
-- Name: peer_bib_copy_map id; Type: DEFAULT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.peer_bib_copy_map ALTER COLUMN id SET DEFAULT nextval('biblio.peer_bib_copy_map_id_seq'::regclass);


--
-- Name: peer_type id; Type: DEFAULT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.peer_type ALTER COLUMN id SET DEFAULT nextval('biblio.peer_type_id_seq'::regclass);


--
-- Name: record_entry id; Type: DEFAULT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.record_entry ALTER COLUMN id SET DEFAULT nextval('biblio.record_entry_id_seq'::regclass);


--
-- Name: record_note id; Type: DEFAULT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.record_note ALTER COLUMN id SET DEFAULT nextval('biblio.record_note_id_seq'::regclass);


--
-- Name: reservation xact_start; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: reservation_attr_value_map id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation_attr_value_map ALTER COLUMN id SET DEFAULT nextval('booking.reservation_attr_value_map_id_seq'::regclass);


--
-- Name: resource id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource ALTER COLUMN id SET DEFAULT nextval('booking.resource_id_seq'::regclass);


--
-- Name: resource_attr id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr ALTER COLUMN id SET DEFAULT nextval('booking.resource_attr_id_seq'::regclass);


--
-- Name: resource_attr_map id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr_map ALTER COLUMN id SET DEFAULT nextval('booking.resource_attr_map_id_seq'::regclass);


--
-- Name: resource_attr_value id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr_value ALTER COLUMN id SET DEFAULT nextval('booking.resource_attr_value_id_seq'::regclass);


--
-- Name: resource_type id; Type: DEFAULT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_type ALTER COLUMN id SET DEFAULT nextval('booking.resource_type_id_seq'::regclass);


--
-- Name: barcode_completion id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.barcode_completion ALTER COLUMN id SET DEFAULT nextval('config.barcode_completion_id_seq'::regclass);


--
-- Name: best_hold_order id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.best_hold_order ALTER COLUMN id SET DEFAULT nextval('config.best_hold_order_id_seq'::regclass);


--
-- Name: bib_source id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.bib_source ALTER COLUMN id SET DEFAULT nextval('config.bib_source_id_seq'::regclass);


--
-- Name: biblio_fingerprint id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.biblio_fingerprint ALTER COLUMN id SET DEFAULT nextval('config.biblio_fingerprint_id_seq'::regclass);


--
-- Name: billing_type id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.billing_type ALTER COLUMN id SET DEFAULT nextval('config.billing_type_id_seq'::regclass);


--
-- Name: carousel_type id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.carousel_type ALTER COLUMN id SET DEFAULT nextval('config.carousel_type_id_seq'::regclass);


--
-- Name: circ_limit_group id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_group ALTER COLUMN id SET DEFAULT nextval('config.circ_limit_group_id_seq'::regclass);


--
-- Name: circ_limit_set id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set ALTER COLUMN id SET DEFAULT nextval('config.circ_limit_set_id_seq'::regclass);


--
-- Name: circ_limit_set_circ_mod_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_circ_mod_map ALTER COLUMN id SET DEFAULT nextval('config.circ_limit_set_circ_mod_map_id_seq'::regclass);


--
-- Name: circ_limit_set_copy_loc_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_copy_loc_map ALTER COLUMN id SET DEFAULT nextval('config.circ_limit_set_copy_loc_map_id_seq'::regclass);


--
-- Name: circ_limit_set_group_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_group_map ALTER COLUMN id SET DEFAULT nextval('config.circ_limit_set_group_map_id_seq'::regclass);


--
-- Name: circ_matrix_circ_mod_test id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_circ_mod_test ALTER COLUMN id SET DEFAULT nextval('config.circ_matrix_circ_mod_test_id_seq'::regclass);


--
-- Name: circ_matrix_circ_mod_test_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_circ_mod_test_map ALTER COLUMN id SET DEFAULT nextval('config.circ_matrix_circ_mod_test_map_id_seq'::regclass);


--
-- Name: circ_matrix_limit_set_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_limit_set_map ALTER COLUMN id SET DEFAULT nextval('config.circ_matrix_limit_set_map_id_seq'::regclass);


--
-- Name: circ_matrix_matchpoint id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint ALTER COLUMN id SET DEFAULT nextval('config.circ_matrix_matchpoint_id_seq'::regclass);


--
-- Name: circ_matrix_weights id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_weights ALTER COLUMN id SET DEFAULT nextval('config.circ_matrix_weights_id_seq'::regclass);


--
-- Name: coded_value_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.coded_value_map ALTER COLUMN id SET DEFAULT nextval('config.coded_value_map_id_seq'::regclass);


--
-- Name: copy_alert_type id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.copy_alert_type ALTER COLUMN id SET DEFAULT nextval('config.copy_alert_type_id_seq'::regclass);


--
-- Name: copy_status id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.copy_status ALTER COLUMN id SET DEFAULT nextval('config.copy_status_id_seq'::regclass);


--
-- Name: filter_dialog_filter_set id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.filter_dialog_filter_set ALTER COLUMN id SET DEFAULT nextval('config.filter_dialog_filter_set_id_seq'::regclass);


--
-- Name: floating_group id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.floating_group ALTER COLUMN id SET DEFAULT nextval('config.floating_group_id_seq'::regclass);


--
-- Name: floating_group_member id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.floating_group_member ALTER COLUMN id SET DEFAULT nextval('config.floating_group_member_id_seq'::regclass);


--
-- Name: geolocation_service id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.geolocation_service ALTER COLUMN id SET DEFAULT nextval('config.geolocation_service_id_seq'::regclass);


--
-- Name: global_flag enabled; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.global_flag ALTER COLUMN enabled SET DEFAULT false;


--
-- Name: hard_due_date id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hard_due_date ALTER COLUMN id SET DEFAULT nextval('config.hard_due_date_id_seq'::regclass);


--
-- Name: hard_due_date_values id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hard_due_date_values ALTER COLUMN id SET DEFAULT nextval('config.hard_due_date_values_id_seq'::regclass);


--
-- Name: hold_matrix_matchpoint id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint ALTER COLUMN id SET DEFAULT nextval('config.hold_matrix_matchpoint_id_seq'::regclass);


--
-- Name: hold_matrix_weights id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_weights ALTER COLUMN id SET DEFAULT nextval('config.hold_matrix_weights_id_seq'::regclass);


--
-- Name: hold_type id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_type ALTER COLUMN id SET DEFAULT nextval('config.hold_type_id_seq'::regclass);


--
-- Name: i18n_core id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.i18n_core ALTER COLUMN id SET DEFAULT nextval('config.i18n_core_id_seq'::regclass);


--
-- Name: identification_type id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.identification_type ALTER COLUMN id SET DEFAULT nextval('config.identification_type_id_seq'::regclass);


--
-- Name: idl_field_doc id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.idl_field_doc ALTER COLUMN id SET DEFAULT nextval('config.idl_field_doc_id_seq'::regclass);


--
-- Name: index_normalizer id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.index_normalizer ALTER COLUMN id SET DEFAULT nextval('config.index_normalizer_id_seq'::regclass);


--
-- Name: marc21_ff_pos_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc21_ff_pos_map ALTER COLUMN id SET DEFAULT nextval('config.marc21_ff_pos_map_id_seq'::regclass);


--
-- Name: marc21_physical_characteristic_subfield_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc21_physical_characteristic_subfield_map ALTER COLUMN id SET DEFAULT nextval('config.marc21_physical_characteristic_subfield_map_id_seq'::regclass);


--
-- Name: marc21_physical_characteristic_value_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc21_physical_characteristic_value_map ALTER COLUMN id SET DEFAULT nextval('config.marc21_physical_characteristic_value_map_id_seq'::regclass);


--
-- Name: marc_field id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc_field ALTER COLUMN id SET DEFAULT nextval('config.marc_field_id_seq'::regclass);


--
-- Name: marc_format id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc_format ALTER COLUMN id SET DEFAULT nextval('config.marc_format_id_seq'::regclass);


--
-- Name: marc_subfield id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc_subfield ALTER COLUMN id SET DEFAULT nextval('config.marc_subfield_id_seq'::regclass);


--
-- Name: metabib_class_ts_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_class_ts_map ALTER COLUMN id SET DEFAULT nextval('config.metabib_class_ts_map_id_seq'::regclass);


--
-- Name: metabib_field id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field ALTER COLUMN id SET DEFAULT nextval('config.metabib_field_id_seq'::regclass);


--
-- Name: metabib_field_index_norm_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_index_norm_map ALTER COLUMN id SET DEFAULT nextval('config.metabib_field_index_norm_map_id_seq'::regclass);


--
-- Name: metabib_field_ts_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_ts_map ALTER COLUMN id SET DEFAULT nextval('config.metabib_field_ts_map_id_seq'::regclass);


--
-- Name: metabib_field_virtual_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_virtual_map ALTER COLUMN id SET DEFAULT nextval('config.metabib_field_virtual_map_id_seq'::regclass);


--
-- Name: net_access_level id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.net_access_level ALTER COLUMN id SET DEFAULT nextval('config.net_access_level_id_seq'::regclass);


--
-- Name: non_cataloged_type id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.non_cataloged_type ALTER COLUMN id SET DEFAULT nextval('config.non_cataloged_type_id_seq'::regclass);


--
-- Name: org_unit_setting_type_log id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.org_unit_setting_type_log ALTER COLUMN id SET DEFAULT nextval('config.org_unit_setting_type_log_id_seq'::regclass);


--
-- Name: patron_message id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.patron_message ALTER COLUMN id SET DEFAULT nextval('config.patron_message_id_seq'::regclass);


--
-- Name: print_template id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.print_template ALTER COLUMN id SET DEFAULT nextval('config.print_template_id_seq'::regclass);


--
-- Name: record_attr_index_norm_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.record_attr_index_norm_map ALTER COLUMN id SET DEFAULT nextval('config.record_attr_index_norm_map_id_seq'::regclass);


--
-- Name: remote_account id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.remote_account ALTER COLUMN id SET DEFAULT nextval('config.remote_account_id_seq'::regclass);


--
-- Name: rule_age_hold_protect id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_age_hold_protect ALTER COLUMN id SET DEFAULT nextval('config.rule_age_hold_protect_id_seq'::regclass);


--
-- Name: rule_circ_duration id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_circ_duration ALTER COLUMN id SET DEFAULT nextval('config.rule_circ_duration_id_seq'::regclass);


--
-- Name: rule_max_fine id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_max_fine ALTER COLUMN id SET DEFAULT nextval('config.rule_max_fine_id_seq'::regclass);


--
-- Name: rule_recurring_fine id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_recurring_fine ALTER COLUMN id SET DEFAULT nextval('config.rule_recurring_fine_id_seq'::regclass);


--
-- Name: sms_carrier id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.sms_carrier ALTER COLUMN id SET DEFAULT nextval('config.sms_carrier_id_seq'::regclass);


--
-- Name: standing id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.standing ALTER COLUMN id SET DEFAULT nextval('config.standing_id_seq'::regclass);


--
-- Name: standing_penalty id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.standing_penalty ALTER COLUMN id SET DEFAULT nextval('config.standing_penalty_id_seq'::regclass);


--
-- Name: ui_staff_portal_page_entry id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.ui_staff_portal_page_entry ALTER COLUMN id SET DEFAULT nextval('config.ui_staff_portal_page_entry_id_seq'::regclass);


--
-- Name: usr_activity_type id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.usr_activity_type ALTER COLUMN id SET DEFAULT nextval('config.usr_activity_type_id_seq'::regclass);


--
-- Name: weight_assoc id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.weight_assoc ALTER COLUMN id SET DEFAULT nextval('config.weight_assoc_id_seq'::regclass);


--
-- Name: z3950_attr id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_attr ALTER COLUMN id SET DEFAULT nextval('config.z3950_attr_id_seq'::regclass);


--
-- Name: z3950_index_field_map id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_index_field_map ALTER COLUMN id SET DEFAULT nextval('config.z3950_index_field_map_id_seq'::regclass);


--
-- Name: z3950_source_credentials id; Type: DEFAULT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_source_credentials ALTER COLUMN id SET DEFAULT nextval('config.z3950_source_credentials_id_seq'::regclass);


--
-- Name: biblio_record_entry_bucket id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket ALTER COLUMN id SET DEFAULT nextval('container.biblio_record_entry_bucket_id_seq'::regclass);


--
-- Name: biblio_record_entry_bucket_item id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_item ALTER COLUMN id SET DEFAULT nextval('container.biblio_record_entry_bucket_item_id_seq'::regclass);


--
-- Name: biblio_record_entry_bucket_item_note id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('container.biblio_record_entry_bucket_item_note_id_seq'::regclass);


--
-- Name: biblio_record_entry_bucket_note id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_note ALTER COLUMN id SET DEFAULT nextval('container.biblio_record_entry_bucket_note_id_seq'::regclass);


--
-- Name: call_number_bucket id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket ALTER COLUMN id SET DEFAULT nextval('container.call_number_bucket_id_seq'::regclass);


--
-- Name: call_number_bucket_item id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_item ALTER COLUMN id SET DEFAULT nextval('container.call_number_bucket_item_id_seq'::regclass);


--
-- Name: call_number_bucket_item_note id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('container.call_number_bucket_item_note_id_seq'::regclass);


--
-- Name: call_number_bucket_note id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_note ALTER COLUMN id SET DEFAULT nextval('container.call_number_bucket_note_id_seq'::regclass);


--
-- Name: carousel id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.carousel ALTER COLUMN id SET DEFAULT nextval('container.carousel_id_seq'::regclass);


--
-- Name: carousel_org_unit id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.carousel_org_unit ALTER COLUMN id SET DEFAULT nextval('container.carousel_org_unit_id_seq'::regclass);


--
-- Name: copy_bucket id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket ALTER COLUMN id SET DEFAULT nextval('container.copy_bucket_id_seq'::regclass);


--
-- Name: copy_bucket_item id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket_item ALTER COLUMN id SET DEFAULT nextval('container.copy_bucket_item_id_seq'::regclass);


--
-- Name: copy_bucket_item_note id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('container.copy_bucket_item_note_id_seq'::regclass);


--
-- Name: copy_bucket_note id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket_note ALTER COLUMN id SET DEFAULT nextval('container.copy_bucket_note_id_seq'::regclass);


--
-- Name: user_bucket id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket ALTER COLUMN id SET DEFAULT nextval('container.user_bucket_id_seq'::regclass);


--
-- Name: user_bucket_item id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_item ALTER COLUMN id SET DEFAULT nextval('container.user_bucket_item_id_seq'::regclass);


--
-- Name: user_bucket_item_note id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_item_note ALTER COLUMN id SET DEFAULT nextval('container.user_bucket_item_note_id_seq'::regclass);


--
-- Name: user_bucket_note id; Type: DEFAULT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_note ALTER COLUMN id SET DEFAULT nextval('container.user_bucket_note_id_seq'::regclass);


--
-- Name: node id; Type: DEFAULT; Schema: elastic; Owner: evergreen
--

ALTER TABLE ONLY elastic.node ALTER COLUMN id SET DEFAULT nextval('elastic.node_id_seq'::regclass);


--
-- Name: actor_stat_cat_entry_map id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_stat_cat_entry_map ALTER COLUMN id SET DEFAULT nextval('m_enum.actor_stat_cat_entry_map_id_seq'::regclass);


--
-- Name: actor_stat_cat_map id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_stat_cat_map ALTER COLUMN id SET DEFAULT nextval('m_enum.actor_stat_cat_map_id_seq'::regclass);


--
-- Name: actor_usr_legacy id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN id SET DEFAULT nextval('actor.usr_id_seq'::regclass);


--
-- Name: actor_usr_legacy standing; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN standing SET DEFAULT 1;


--
-- Name: actor_usr_legacy net_access_level; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN net_access_level SET DEFAULT 1;


--
-- Name: actor_usr_legacy active; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN active SET DEFAULT true;


--
-- Name: actor_usr_legacy master_account; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN master_account SET DEFAULT false;


--
-- Name: actor_usr_legacy super_user; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN super_user SET DEFAULT false;


--
-- Name: actor_usr_legacy barred; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN barred SET DEFAULT false;


--
-- Name: actor_usr_legacy deleted; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: actor_usr_legacy juvenile; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN juvenile SET DEFAULT false;


--
-- Name: actor_usr_legacy usrgroup; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN usrgroup SET DEFAULT nextval('actor.usr_usrgroup_seq'::regclass);


--
-- Name: actor_usr_legacy claims_returned_count; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN claims_returned_count SET DEFAULT 0;


--
-- Name: actor_usr_legacy credit_forward_balance; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN credit_forward_balance SET DEFAULT 0.00;


--
-- Name: actor_usr_legacy last_xact_id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN last_xact_id SET DEFAULT 'none'::text;


--
-- Name: actor_usr_legacy create_date; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: actor_usr_legacy expire_date; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN expire_date SET DEFAULT (now() + '3 years'::interval);


--
-- Name: actor_usr_legacy claims_never_checked_out_count; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.actor_usr_legacy ALTER COLUMN claims_never_checked_out_count SET DEFAULT 0;


--
-- Name: asset_copy_legacy id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN id SET DEFAULT nextval('asset.copy_id_seq'::regclass);


--
-- Name: asset_copy_legacy create_date; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: asset_copy_legacy edit_date; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: asset_copy_legacy status; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN status SET DEFAULT 0;


--
-- Name: asset_copy_legacy location; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN location SET DEFAULT 1;


--
-- Name: asset_copy_legacy circulate; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: asset_copy_legacy deposit; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: asset_copy_legacy ref; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN ref SET DEFAULT false;


--
-- Name: asset_copy_legacy holdable; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: asset_copy_legacy deposit_amount; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: asset_copy_legacy opac_visible; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: asset_copy_legacy deleted; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: asset_copy_legacy floating; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN floating SET DEFAULT false;


--
-- Name: asset_copy_legacy mint_condition; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.asset_copy_legacy ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: base_circ_field_map id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('m_enum.base_circ_field_map_id_seq'::regclass);


--
-- Name: base_copy_location_map id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('m_enum.base_copy_location_map_id_seq'::regclass);


--
-- Name: base_item_dynamic_field_map id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('m_enum.base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: base_profile_map id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.base_profile_map ALTER COLUMN id SET DEFAULT nextval('m_enum.base_profile_map_id_seq'::regclass);


--
-- Name: card_collisions id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.card_collisions ALTER COLUMN id SET DEFAULT nextval('m_enum.card_collisions_id_seq'::regclass);


--
-- Name: circ id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.circ ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: circ xact_start; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.circ ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: circ create_time; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.circ ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: circ fine_interval; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.circ ALTER COLUMN fine_interval SET DEFAULT '1 day'::interval;


--
-- Name: circ phone_renewal; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.circ ALTER COLUMN phone_renewal SET DEFAULT false;


--
-- Name: circ desk_renewal; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.circ ALTER COLUMN desk_renewal SET DEFAULT false;


--
-- Name: circ opac_renewal; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.circ ALTER COLUMN opac_renewal SET DEFAULT false;


--
-- Name: holds id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.holds ALTER COLUMN id SET DEFAULT nextval('action.hold_request_id_seq'::regclass);


--
-- Name: holds request_time; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.holds ALTER COLUMN request_time SET DEFAULT now();


--
-- Name: holds selection_depth; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.holds ALTER COLUMN selection_depth SET DEFAULT 0;


--
-- Name: holds email_notify; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.holds ALTER COLUMN email_notify SET DEFAULT true;


--
-- Name: holds frozen; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.holds ALTER COLUMN frozen SET DEFAULT false;


--
-- Name: holds mint_condition; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.holds ALTER COLUMN mint_condition SET DEFAULT false;


--
-- Name: home_location_map id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.home_location_map ALTER COLUMN id SET DEFAULT nextval('m_enum.home_location_map_id_seq'::regclass);


--
-- Name: item_dynamic_field_map id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('m_enum.item_dynamic_field_map_id_seq'::regclass);


--
-- Name: org_map id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.org_map ALTER COLUMN id SET DEFAULT nextval('m_enum.org_map_id_seq'::regclass);


--
-- Name: profile_map id; Type: DEFAULT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.profile_map ALTER COLUMN id SET DEFAULT nextval('m_enum.profile_map_id_seq'::regclass);


--
-- Name: base_circ_field_map id; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.base_circ_field_map ALTER COLUMN id SET DEFAULT nextval('m_test.base_circ_field_map_id_seq'::regclass);


--
-- Name: base_copy_location_map id; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.base_copy_location_map ALTER COLUMN id SET DEFAULT nextval('m_test.base_copy_location_map_id_seq'::regclass);


--
-- Name: base_item_dynamic_field_map id; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.base_item_dynamic_field_map ALTER COLUMN id SET DEFAULT nextval('m_test.base_item_dynamic_field_map_id_seq'::regclass);


--
-- Name: base_profile_map id; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.base_profile_map ALTER COLUMN id SET DEFAULT nextval('m_test.base_profile_map_id_seq'::regclass);


--
-- Name: circhist id; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.circhist ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: circhist xact_start; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.circhist ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: circhist create_time; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.circhist ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: circhist fine_interval; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.circhist ALTER COLUMN fine_interval SET DEFAULT '1 day'::interval;


--
-- Name: circhist phone_renewal; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.circhist ALTER COLUMN phone_renewal SET DEFAULT false;


--
-- Name: circhist desk_renewal; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.circhist ALTER COLUMN desk_renewal SET DEFAULT false;


--
-- Name: circhist opac_renewal; Type: DEFAULT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.circhist ALTER COLUMN opac_renewal SET DEFAULT false;


--
-- Name: author_field_entry id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.author_field_entry ALTER COLUMN id SET DEFAULT nextval('metabib.author_field_entry_id_seq'::regclass);


--
-- Name: bib_export_data id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.bib_export_data ALTER COLUMN id SET DEFAULT nextval('metabib.bib_export_data_id_seq'::regclass);


--
-- Name: browse_entry id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry ALTER COLUMN id SET DEFAULT nextval('metabib.browse_entry_id_seq'::regclass);


--
-- Name: browse_entry_def_map id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry_def_map ALTER COLUMN id SET DEFAULT nextval('metabib.browse_entry_def_map_id_seq'::regclass);


--
-- Name: browse_entry_simple_heading_map id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry_simple_heading_map ALTER COLUMN id SET DEFAULT nextval('metabib.browse_entry_simple_heading_map_id_seq'::regclass);


--
-- Name: call_number_field_entry id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.call_number_field_entry ALTER COLUMN id SET DEFAULT nextval('metabib.call_number_field_entry_id_seq'::regclass);


--
-- Name: display_entry id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.display_entry ALTER COLUMN id SET DEFAULT nextval('metabib.display_entry_id_seq'::regclass);


--
-- Name: facet_entry id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.facet_entry ALTER COLUMN id SET DEFAULT nextval('metabib.facet_entry_id_seq'::regclass);


--
-- Name: identifier_field_entry id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.identifier_field_entry ALTER COLUMN id SET DEFAULT nextval('metabib.identifier_field_entry_id_seq'::regclass);


--
-- Name: keyword_field_entry id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.keyword_field_entry ALTER COLUMN id SET DEFAULT nextval('metabib.keyword_field_entry_id_seq'::regclass);


--
-- Name: metarecord id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.metarecord ALTER COLUMN id SET DEFAULT nextval('metabib.metarecord_id_seq'::regclass);


--
-- Name: metarecord_source_map id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.metarecord_source_map ALTER COLUMN id SET DEFAULT nextval('metabib.metarecord_source_map_id_seq'::regclass);


--
-- Name: record_sorter id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.record_sorter ALTER COLUMN id SET DEFAULT nextval('metabib.record_sorter_id_seq'::regclass);


--
-- Name: series_field_entry id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.series_field_entry ALTER COLUMN id SET DEFAULT nextval('metabib.series_field_entry_id_seq'::regclass);


--
-- Name: subject_field_entry id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.subject_field_entry ALTER COLUMN id SET DEFAULT nextval('metabib.subject_field_entry_id_seq'::regclass);


--
-- Name: title_field_entry id; Type: DEFAULT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.title_field_entry ALTER COLUMN id SET DEFAULT nextval('metabib.title_field_entry_id_seq'::regclass);


--
-- Name: account_adjustment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.account_adjustment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: account_adjustment payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.account_adjustment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: account_adjustment voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.account_adjustment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: billable_xact id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.billable_xact ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: billing id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.billing ALTER COLUMN id SET DEFAULT nextval('money.billing_id_seq'::regclass);


--
-- Name: bnm_desk_payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.bnm_desk_payment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: bnm_desk_payment payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.bnm_desk_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: bnm_desk_payment voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.bnm_desk_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: bnm_payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.bnm_payment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: bnm_payment payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.bnm_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: bnm_payment voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.bnm_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: cash_payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.cash_payment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: cash_payment payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.cash_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: cash_payment voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.cash_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: check_payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.check_payment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: check_payment payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.check_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: check_payment voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.check_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: collections_tracker id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.collections_tracker ALTER COLUMN id SET DEFAULT nextval('money.collections_tracker_id_seq'::regclass);


--
-- Name: credit_card_payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.credit_card_payment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: credit_card_payment payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.credit_card_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: credit_card_payment voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.credit_card_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: credit_payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.credit_payment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: credit_payment payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.credit_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: credit_payment voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.credit_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: debit_card_payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.debit_card_payment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: debit_card_payment payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.debit_card_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: debit_card_payment voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.debit_card_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: forgive_payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.forgive_payment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: forgive_payment payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.forgive_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: forgive_payment voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.forgive_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: goods_payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.goods_payment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: goods_payment payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.goods_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: goods_payment voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.goods_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: grocery id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.grocery ALTER COLUMN id SET DEFAULT nextval('money.billable_xact_id_seq'::regclass);


--
-- Name: grocery xact_start; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.grocery ALTER COLUMN xact_start SET DEFAULT now();


--
-- Name: payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.payment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: refund_action id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refund_action ALTER COLUMN id SET DEFAULT nextval('money.refund_action_id_seq'::regclass);


--
-- Name: refund_session id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refund_session ALTER COLUMN id SET DEFAULT nextval('money.refund_session_id_seq'::regclass);


--
-- Name: refundable_payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refundable_payment ALTER COLUMN id SET DEFAULT nextval('money.refundable_payment_id_seq'::regclass);


--
-- Name: refundable_xact id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refundable_xact ALTER COLUMN id SET DEFAULT nextval('money.refundable_xact_id_seq'::regclass);


--
-- Name: work_payment id; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.work_payment ALTER COLUMN id SET DEFAULT nextval('money.payment_id_seq'::regclass);


--
-- Name: work_payment payment_ts; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.work_payment ALTER COLUMN payment_ts SET DEFAULT now();


--
-- Name: work_payment voided; Type: DEFAULT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.work_payment ALTER COLUMN voided SET DEFAULT false;


--
-- Name: script id; Type: DEFAULT; Schema: offline; Owner: evergreen
--

ALTER TABLE ONLY offline.script ALTER COLUMN id SET DEFAULT nextval('offline.script_id_seq'::regclass);


--
-- Name: grp_penalty_threshold id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_penalty_threshold ALTER COLUMN id SET DEFAULT nextval('permission.grp_penalty_threshold_id_seq'::regclass);


--
-- Name: grp_perm_map id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_perm_map ALTER COLUMN id SET DEFAULT nextval('permission.grp_perm_map_id_seq'::regclass);


--
-- Name: grp_tree id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_tree ALTER COLUMN id SET DEFAULT nextval('permission.grp_tree_id_seq'::regclass);


--
-- Name: grp_tree_display_entry id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_tree_display_entry ALTER COLUMN id SET DEFAULT nextval('permission.grp_tree_display_entry_id_seq'::regclass);


--
-- Name: perm_list id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.perm_list ALTER COLUMN id SET DEFAULT nextval('permission.perm_list_id_seq'::regclass);


--
-- Name: usr_grp_map id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_grp_map ALTER COLUMN id SET DEFAULT nextval('permission.usr_grp_map_id_seq'::regclass);


--
-- Name: usr_object_perm_map id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_object_perm_map ALTER COLUMN id SET DEFAULT nextval('permission.usr_object_perm_map_id_seq'::regclass);


--
-- Name: usr_perm_map id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_perm_map ALTER COLUMN id SET DEFAULT nextval('permission.usr_perm_map_id_seq'::regclass);


--
-- Name: usr_work_ou_map id; Type: DEFAULT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_work_ou_map ALTER COLUMN id SET DEFAULT nextval('permission.usr_work_ou_map_id_seq'::regclass);


--
-- Name: case_branch id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.case_branch ALTER COLUMN id SET DEFAULT nextval('query.case_branch_id_seq'::regclass);


--
-- Name: datatype id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.datatype ALTER COLUMN id SET DEFAULT nextval('query.datatype_id_seq'::regclass);


--
-- Name: expression id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.expression ALTER COLUMN id SET DEFAULT nextval('query.expression_id_seq'::regclass);


--
-- Name: from_relation id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.from_relation ALTER COLUMN id SET DEFAULT nextval('query.from_relation_id_seq'::regclass);


--
-- Name: function_param_def id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.function_param_def ALTER COLUMN id SET DEFAULT nextval('query.function_param_def_id_seq'::regclass);


--
-- Name: function_sig id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.function_sig ALTER COLUMN id SET DEFAULT nextval('query.function_sig_id_seq'::regclass);


--
-- Name: order_by_item id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.order_by_item ALTER COLUMN id SET DEFAULT nextval('query.order_by_item_id_seq'::regclass);


--
-- Name: query_sequence id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.query_sequence ALTER COLUMN id SET DEFAULT nextval('query.query_sequence_id_seq'::regclass);


--
-- Name: record_column id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.record_column ALTER COLUMN id SET DEFAULT nextval('query.record_column_id_seq'::regclass);


--
-- Name: select_item id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.select_item ALTER COLUMN id SET DEFAULT nextval('query.select_item_id_seq'::regclass);


--
-- Name: stored_query id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.stored_query ALTER COLUMN id SET DEFAULT nextval('query.stored_query_id_seq'::regclass);


--
-- Name: subfield id; Type: DEFAULT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.subfield ALTER COLUMN id SET DEFAULT nextval('query.subfield_id_seq'::regclass);


--
-- Name: badge id; Type: DEFAULT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.badge ALTER COLUMN id SET DEFAULT nextval('rating.badge_id_seq'::regclass);


--
-- Name: record_badge_score id; Type: DEFAULT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.record_badge_score ALTER COLUMN id SET DEFAULT nextval('rating.record_badge_score_id_seq'::regclass);


--
-- Name: output_folder id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.output_folder ALTER COLUMN id SET DEFAULT nextval('reporter.output_folder_id_seq'::regclass);


--
-- Name: report id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.report ALTER COLUMN id SET DEFAULT nextval('reporter.report_id_seq'::regclass);


--
-- Name: report_folder id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.report_folder ALTER COLUMN id SET DEFAULT nextval('reporter.report_folder_id_seq'::regclass);


--
-- Name: schedule id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.schedule ALTER COLUMN id SET DEFAULT nextval('reporter.schedule_id_seq'::regclass);


--
-- Name: template id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.template ALTER COLUMN id SET DEFAULT nextval('reporter.template_id_seq'::regclass);


--
-- Name: template_folder id; Type: DEFAULT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.template_folder ALTER COLUMN id SET DEFAULT nextval('reporter.template_folder_id_seq'::regclass);


--
-- Name: relevance_adjustment id; Type: DEFAULT; Schema: search; Owner: evergreen
--

ALTER TABLE ONLY search.relevance_adjustment ALTER COLUMN id SET DEFAULT nextval('search.relevance_adjustment_id_seq'::regclass);


--
-- Name: basic_summary id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.basic_summary ALTER COLUMN id SET DEFAULT nextval('serial.basic_summary_id_seq'::regclass);


--
-- Name: caption_and_pattern id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.caption_and_pattern ALTER COLUMN id SET DEFAULT nextval('serial.caption_and_pattern_id_seq'::regclass);


--
-- Name: distribution id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution ALTER COLUMN id SET DEFAULT nextval('serial.distribution_id_seq'::regclass);


--
-- Name: distribution_note id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution_note ALTER COLUMN id SET DEFAULT nextval('serial.distribution_note_id_seq'::regclass);


--
-- Name: index_summary id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.index_summary ALTER COLUMN id SET DEFAULT nextval('serial.index_summary_id_seq'::regclass);


--
-- Name: issuance id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.issuance ALTER COLUMN id SET DEFAULT nextval('serial.issuance_id_seq'::regclass);


--
-- Name: item id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item ALTER COLUMN id SET DEFAULT nextval('serial.item_id_seq'::regclass);


--
-- Name: item_note id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item_note ALTER COLUMN id SET DEFAULT nextval('serial.item_note_id_seq'::regclass);


--
-- Name: materialized_holding_code id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.materialized_holding_code ALTER COLUMN id SET DEFAULT nextval('serial.materialized_holding_code_id_seq'::regclass);


--
-- Name: pattern_template id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.pattern_template ALTER COLUMN id SET DEFAULT nextval('serial.pattern_template_id_seq'::regclass);


--
-- Name: record_entry id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.record_entry ALTER COLUMN id SET DEFAULT nextval('serial.record_entry_id_seq'::regclass);


--
-- Name: routing_list_user id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.routing_list_user ALTER COLUMN id SET DEFAULT nextval('serial.routing_list_user_id_seq'::regclass);


--
-- Name: stream id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.stream ALTER COLUMN id SET DEFAULT nextval('serial.stream_id_seq'::regclass);


--
-- Name: subscription id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.subscription ALTER COLUMN id SET DEFAULT nextval('serial.subscription_id_seq'::regclass);


--
-- Name: subscription_note id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.subscription_note ALTER COLUMN id SET DEFAULT nextval('serial.subscription_note_id_seq'::regclass);


--
-- Name: supplement_summary id; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.supplement_summary ALTER COLUMN id SET DEFAULT nextval('serial.supplement_summary_id_seq'::regclass);


--
-- Name: unit create_date; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN create_date SET DEFAULT now();


--
-- Name: unit edit_date; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN edit_date SET DEFAULT now();


--
-- Name: unit status; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN status SET DEFAULT 0;


--
-- Name: unit location; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN location SET DEFAULT 1;


--
-- Name: unit circulate; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN circulate SET DEFAULT true;


--
-- Name: unit deposit; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN deposit SET DEFAULT false;


--
-- Name: unit ref; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN ref SET DEFAULT false;


--
-- Name: unit holdable; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN holdable SET DEFAULT true;


--
-- Name: unit deposit_amount; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN deposit_amount SET DEFAULT 0.00;


--
-- Name: unit opac_visible; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN opac_visible SET DEFAULT true;


--
-- Name: unit deleted; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN deleted SET DEFAULT false;


--
-- Name: unit mint_condition; Type: DEFAULT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit ALTER COLUMN mint_condition SET DEFAULT true;


--
-- Name: account id; Type: DEFAULT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.account ALTER COLUMN id SET DEFAULT nextval('sip.account_id_seq'::regclass);


--
-- Name: setting id; Type: DEFAULT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.setting ALTER COLUMN id SET DEFAULT nextval('sip.setting_id_seq'::regclass);


--
-- Name: setting_group id; Type: DEFAULT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.setting_group ALTER COLUMN id SET DEFAULT nextval('sip.setting_group_id_seq'::regclass);


--
-- Name: card_stage row_id; Type: DEFAULT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.card_stage ALTER COLUMN row_id SET DEFAULT nextval('staging.card_stage_row_id_seq'::regclass);


--
-- Name: mailing_address_stage row_id; Type: DEFAULT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.mailing_address_stage ALTER COLUMN row_id SET DEFAULT nextval('staging.mailing_address_stage_row_id_seq'::regclass);


--
-- Name: setting_stage row_id; Type: DEFAULT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.setting_stage ALTER COLUMN row_id SET DEFAULT nextval('staging.setting_stage_row_id_seq'::regclass);


--
-- Name: statcat_stage row_id; Type: DEFAULT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.statcat_stage ALTER COLUMN row_id SET DEFAULT nextval('staging.statcat_stage_row_id_seq'::regclass);


--
-- Name: user_stage row_id; Type: DEFAULT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.user_stage ALTER COLUMN row_id SET DEFAULT nextval('staging.user_stage_row_id_seq'::regclass);


--
-- Name: session id; Type: DEFAULT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.session ALTER COLUMN id SET DEFAULT nextval('url_verify.session_id_seq'::regclass);


--
-- Name: url id; Type: DEFAULT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url ALTER COLUMN id SET DEFAULT nextval('url_verify.url_id_seq'::regclass);


--
-- Name: url_selector id; Type: DEFAULT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url_selector ALTER COLUMN id SET DEFAULT nextval('url_verify.url_selector_id_seq'::regclass);


--
-- Name: url_verification id; Type: DEFAULT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url_verification ALTER COLUMN id SET DEFAULT nextval('url_verify.url_verification_id_seq'::regclass);


--
-- Name: verification_attempt id; Type: DEFAULT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.verification_attempt ALTER COLUMN id SET DEFAULT nextval('url_verify.verification_attempt_id_seq'::regclass);


--
-- Name: authority_attr_definition id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.authority_attr_definition ALTER COLUMN id SET DEFAULT nextval('vandelay.authority_attr_definition_id_seq'::regclass);


--
-- Name: authority_match id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.authority_match ALTER COLUMN id SET DEFAULT nextval('vandelay.authority_match_id_seq'::regclass);


--
-- Name: authority_queue id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.authority_queue ALTER COLUMN id SET DEFAULT nextval('vandelay.queue_id_seq'::regclass);


--
-- Name: authority_queue complete; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.authority_queue ALTER COLUMN complete SET DEFAULT false;


--
-- Name: bib_attr_definition id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_attr_definition ALTER COLUMN id SET DEFAULT nextval('vandelay.bib_attr_definition_id_seq'::regclass);


--
-- Name: bib_match id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_match ALTER COLUMN id SET DEFAULT nextval('vandelay.bib_match_id_seq'::regclass);


--
-- Name: bib_queue id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_queue ALTER COLUMN id SET DEFAULT nextval('vandelay.queue_id_seq'::regclass);


--
-- Name: bib_queue complete; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_queue ALTER COLUMN complete SET DEFAULT false;


--
-- Name: import_bib_trash_fields id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_bib_trash_fields ALTER COLUMN id SET DEFAULT nextval('vandelay.import_bib_trash_fields_id_seq'::regclass);


--
-- Name: import_bib_trash_group id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_bib_trash_group ALTER COLUMN id SET DEFAULT nextval('vandelay.import_bib_trash_group_id_seq'::regclass);


--
-- Name: import_item id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_item ALTER COLUMN id SET DEFAULT nextval('vandelay.import_item_id_seq'::regclass);


--
-- Name: import_item_attr_definition id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_item_attr_definition ALTER COLUMN id SET DEFAULT nextval('vandelay.import_item_attr_definition_id_seq'::regclass);


--
-- Name: match_set id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set ALTER COLUMN id SET DEFAULT nextval('vandelay.match_set_id_seq'::regclass);


--
-- Name: match_set_point id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set_point ALTER COLUMN id SET DEFAULT nextval('vandelay.match_set_point_id_seq'::regclass);


--
-- Name: match_set_quality id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set_quality ALTER COLUMN id SET DEFAULT nextval('vandelay.match_set_quality_id_seq'::regclass);


--
-- Name: merge_profile id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.merge_profile ALTER COLUMN id SET DEFAULT nextval('vandelay.merge_profile_id_seq'::regclass);


--
-- Name: queue id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queue ALTER COLUMN id SET DEFAULT nextval('vandelay.queue_id_seq'::regclass);


--
-- Name: queued_authority_record id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record ALTER COLUMN id SET DEFAULT nextval('vandelay.queued_record_id_seq'::regclass);


--
-- Name: queued_authority_record create_time; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: queued_authority_record purpose; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record ALTER COLUMN purpose SET DEFAULT 'import'::text;


--
-- Name: queued_authority_record quality; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record ALTER COLUMN quality SET DEFAULT 0;


--
-- Name: queued_authority_record_attr id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record_attr ALTER COLUMN id SET DEFAULT nextval('vandelay.queued_authority_record_attr_id_seq'::regclass);


--
-- Name: queued_bib_record id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record ALTER COLUMN id SET DEFAULT nextval('vandelay.queued_record_id_seq'::regclass);


--
-- Name: queued_bib_record create_time; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record ALTER COLUMN create_time SET DEFAULT now();


--
-- Name: queued_bib_record purpose; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record ALTER COLUMN purpose SET DEFAULT 'import'::text;


--
-- Name: queued_bib_record quality; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record ALTER COLUMN quality SET DEFAULT 0;


--
-- Name: queued_bib_record_attr id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record_attr ALTER COLUMN id SET DEFAULT nextval('vandelay.queued_bib_record_attr_id_seq'::regclass);


--
-- Name: queued_record id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_record ALTER COLUMN id SET DEFAULT nextval('vandelay.queued_record_id_seq'::regclass);


--
-- Name: session_tracker id; Type: DEFAULT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.session_tracker ALTER COLUMN id SET DEFAULT nextval('vandelay.session_tracker_id_seq'::regclass);


--
-- Name: cancel_reason acq_cancel_reason_one_per_org_unit; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.cancel_reason
    ADD CONSTRAINT acq_cancel_reason_one_per_org_unit UNIQUE (org_unit, label);


--
-- Name: fiscal_year acq_fy_logical_key; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fiscal_year
    ADD CONSTRAINT acq_fy_logical_key UNIQUE (calendar, year);


--
-- Name: fiscal_year acq_fy_physical_key; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fiscal_year
    ADD CONSTRAINT acq_fy_physical_key UNIQUE (calendar, year_begin);


--
-- Name: acq_lineitem_history acq_lineitem_history_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.acq_lineitem_history
    ADD CONSTRAINT acq_lineitem_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_purchase_order_history acq_purchase_order_history_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.acq_purchase_order_history
    ADD CONSTRAINT acq_purchase_order_history_pkey PRIMARY KEY (audit_id);


--
-- Name: distribution_formula acqdf_name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula
    ADD CONSTRAINT acqdf_name_once_per_owner UNIQUE (name, owner);


--
-- Name: distribution_formula_entry acqdfe_lib_once_per_formula; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_entry
    ADD CONSTRAINT acqdfe_lib_once_per_formula UNIQUE (formula, "position");


--
-- Name: fund_tag acqft_tag_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_tag
    ADD CONSTRAINT acqft_tag_once_per_owner UNIQUE (name, owner);


--
-- Name: fund_tag_map acqftm_fund_once_per_tag; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_tag_map
    ADD CONSTRAINT acqftm_fund_once_per_tag UNIQUE (fund, tag);


--
-- Name: claim_policy_action action_sequence; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_policy_action
    ADD CONSTRAINT action_sequence UNIQUE (claim_policy, action_interval);


--
-- Name: lineitem_alert_text alert_one_code_per_org; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_alert_text
    ADD CONSTRAINT alert_one_code_per_org UNIQUE (code, owning_lib);


--
-- Name: cancel_reason cancel_reason_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.cancel_reason
    ADD CONSTRAINT cancel_reason_pkey PRIMARY KEY (id);


--
-- Name: claim_event claim_event_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_event
    ADD CONSTRAINT claim_event_pkey PRIMARY KEY (id);


--
-- Name: claim_event_type claim_event_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_event_type
    ADD CONSTRAINT claim_event_type_pkey PRIMARY KEY (id);


--
-- Name: claim claim_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim
    ADD CONSTRAINT claim_pkey PRIMARY KEY (id);


--
-- Name: claim_policy_action claim_policy_action_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_policy_action
    ADD CONSTRAINT claim_policy_action_pkey PRIMARY KEY (id);


--
-- Name: claim_policy claim_policy_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_policy
    ADD CONSTRAINT claim_policy_pkey PRIMARY KEY (id);


--
-- Name: claim_type claim_type_once_per_org; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_type
    ADD CONSTRAINT claim_type_once_per_org UNIQUE (org_unit, code);


--
-- Name: claim_type claim_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_type
    ADD CONSTRAINT claim_type_pkey PRIMARY KEY (id);


--
-- Name: fund code_once_per_org_year; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund
    ADD CONSTRAINT code_once_per_org_year UNIQUE (org, code, year);


--
-- Name: provider code_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider
    ADD CONSTRAINT code_once_per_owner UNIQUE (code, owner);


--
-- Name: shipment_notification container_code_once_per_provider; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification
    ADD CONSTRAINT container_code_once_per_provider UNIQUE (provider, container_code);


--
-- Name: currency_type currency_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.currency_type
    ADD CONSTRAINT currency_type_pkey PRIMARY KEY (code);


--
-- Name: debit_attribution debit_attribution_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.debit_attribution
    ADD CONSTRAINT debit_attribution_pkey PRIMARY KEY (id);


--
-- Name: distribution_formula_application distribution_formula_application_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_pkey PRIMARY KEY (id);


--
-- Name: distribution_formula_entry distribution_formula_entry_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_pkey PRIMARY KEY (id);


--
-- Name: distribution_formula distribution_formula_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula
    ADD CONSTRAINT distribution_formula_pkey PRIMARY KEY (id);


--
-- Name: edi_account edi_account_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_account
    ADD CONSTRAINT edi_account_pkey PRIMARY KEY (id);


--
-- Name: edi_attr edi_attr_label_key; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_attr
    ADD CONSTRAINT edi_attr_label_key UNIQUE (label);


--
-- Name: edi_attr edi_attr_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_attr
    ADD CONSTRAINT edi_attr_pkey PRIMARY KEY (key);


--
-- Name: edi_attr_set edi_attr_set_label_key; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_attr_set
    ADD CONSTRAINT edi_attr_set_label_key UNIQUE (label);


--
-- Name: edi_attr_set_map edi_attr_set_map_attr_once; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_attr_set_map
    ADD CONSTRAINT edi_attr_set_map_attr_once UNIQUE (attr_set, attr);


--
-- Name: edi_attr_set_map edi_attr_set_map_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_attr_set_map
    ADD CONSTRAINT edi_attr_set_map_pkey PRIMARY KEY (id);


--
-- Name: edi_attr_set edi_attr_set_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_attr_set
    ADD CONSTRAINT edi_attr_set_pkey PRIMARY KEY (id);


--
-- Name: edi_message edi_message_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_message
    ADD CONSTRAINT edi_message_pkey PRIMARY KEY (id);


--
-- Name: claim_event_type event_type_once_per_org; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_event_type
    ADD CONSTRAINT event_type_once_per_org UNIQUE (org_unit, code);


--
-- Name: exchange_rate exchange_rate_from_to_once; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.exchange_rate
    ADD CONSTRAINT exchange_rate_from_to_once UNIQUE (from_currency, to_currency);


--
-- Name: exchange_rate exchange_rate_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.exchange_rate
    ADD CONSTRAINT exchange_rate_pkey PRIMARY KEY (id);


--
-- Name: fiscal_calendar fiscal_calendar_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fiscal_calendar
    ADD CONSTRAINT fiscal_calendar_pkey PRIMARY KEY (id);


--
-- Name: fiscal_year fiscal_year_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fiscal_year
    ADD CONSTRAINT fiscal_year_pkey PRIMARY KEY (id);


--
-- Name: fund_allocation_percent fund_allocation_percent_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_pkey PRIMARY KEY (id);


--
-- Name: fund_allocation fund_allocation_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_allocation
    ADD CONSTRAINT fund_allocation_pkey PRIMARY KEY (id);


--
-- Name: fund_debit fund_debit_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_debit
    ADD CONSTRAINT fund_debit_pkey PRIMARY KEY (id);


--
-- Name: fund fund_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund
    ADD CONSTRAINT fund_pkey PRIMARY KEY (id);


--
-- Name: fund_tag_map fund_tag_map_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_tag_map
    ADD CONSTRAINT fund_tag_map_pkey PRIMARY KEY (id);


--
-- Name: fund_tag fund_tag_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_tag
    ADD CONSTRAINT fund_tag_pkey PRIMARY KEY (id);


--
-- Name: fund_transfer fund_transfer_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_transfer
    ADD CONSTRAINT fund_transfer_pkey PRIMARY KEY (id);


--
-- Name: funding_source funding_source_code_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.funding_source
    ADD CONSTRAINT funding_source_code_once_per_owner UNIQUE (code, owner);


--
-- Name: funding_source_credit funding_source_credit_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.funding_source_credit
    ADD CONSTRAINT funding_source_credit_pkey PRIMARY KEY (id);


--
-- Name: funding_source funding_source_name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.funding_source
    ADD CONSTRAINT funding_source_name_once_per_owner UNIQUE (name, owner);


--
-- Name: funding_source funding_source_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.funding_source
    ADD CONSTRAINT funding_source_pkey PRIMARY KEY (id);


--
-- Name: invoice inv_ident_once_per_provider; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice
    ADD CONSTRAINT inv_ident_once_per_provider UNIQUE (provider, inv_ident);


--
-- Name: invoice_entry invoice_entry_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_entry
    ADD CONSTRAINT invoice_entry_pkey PRIMARY KEY (id);


--
-- Name: invoice_item invoice_item_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_item
    ADD CONSTRAINT invoice_item_pkey PRIMARY KEY (id);


--
-- Name: invoice_item_type invoice_item_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_item_type
    ADD CONSTRAINT invoice_item_type_pkey PRIMARY KEY (code);


--
-- Name: invoice_method invoice_method_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_method
    ADD CONSTRAINT invoice_method_pkey PRIMARY KEY (code);


--
-- Name: invoice_payment_method invoice_payment_method_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_payment_method
    ADD CONSTRAINT invoice_payment_method_pkey PRIMARY KEY (code);


--
-- Name: invoice invoice_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice
    ADD CONSTRAINT invoice_pkey PRIMARY KEY (id);


--
-- Name: lineitem_alert_text lineitem_alert_text_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_alert_text
    ADD CONSTRAINT lineitem_alert_text_pkey PRIMARY KEY (id);


--
-- Name: lineitem_attr_definition lineitem_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_attr_definition
    ADD CONSTRAINT lineitem_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_attr lineitem_attr_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_attr
    ADD CONSTRAINT lineitem_attr_pkey PRIMARY KEY (id);


--
-- Name: lineitem_detail lineitem_detail_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_detail
    ADD CONSTRAINT lineitem_detail_pkey PRIMARY KEY (id);


--
-- Name: lineitem_generated_attr_definition lineitem_generated_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_generated_attr_definition
    ADD CONSTRAINT lineitem_generated_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_local_attr_definition lineitem_local_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_local_attr_definition
    ADD CONSTRAINT lineitem_local_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_marc_attr_definition lineitem_marc_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_marc_attr_definition
    ADD CONSTRAINT lineitem_marc_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_note lineitem_note_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_note
    ADD CONSTRAINT lineitem_note_pkey PRIMARY KEY (id);


--
-- Name: lineitem lineitem_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem
    ADD CONSTRAINT lineitem_pkey PRIMARY KEY (id);


--
-- Name: lineitem_provider_attr_definition lineitem_provider_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_provider_attr_definition
    ADD CONSTRAINT lineitem_provider_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: lineitem_usr_attr_definition lineitem_usr_attr_definition_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_usr_attr_definition
    ADD CONSTRAINT lineitem_usr_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: fund_allocation_percent logical_key; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_allocation_percent
    ADD CONSTRAINT logical_key UNIQUE (funding_source, org, fund_code);


--
-- Name: claim_policy name_once_per_org; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_policy
    ADD CONSTRAINT name_once_per_org UNIQUE (org_unit, name);


--
-- Name: fund name_once_per_org_year; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund
    ADD CONSTRAINT name_once_per_org_year UNIQUE (org, name, year);


--
-- Name: picklist name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.picklist
    ADD CONSTRAINT name_once_per_owner UNIQUE (name, owner);


--
-- Name: provider_holding_subfield_map name_once_per_provider; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_holding_subfield_map
    ADD CONSTRAINT name_once_per_provider UNIQUE (provider, name);


--
-- Name: picklist picklist_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.picklist
    ADD CONSTRAINT picklist_pkey PRIMARY KEY (id);


--
-- Name: po_item po_item_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.po_item
    ADD CONSTRAINT po_item_pkey PRIMARY KEY (id);


--
-- Name: po_note po_note_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.po_note
    ADD CONSTRAINT po_note_pkey PRIMARY KEY (id);


--
-- Name: provider_address provider_address_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_address
    ADD CONSTRAINT provider_address_pkey PRIMARY KEY (id);


--
-- Name: provider_contact_address provider_contact_address_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_contact_address
    ADD CONSTRAINT provider_contact_address_pkey PRIMARY KEY (id);


--
-- Name: provider_contact provider_contact_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_contact
    ADD CONSTRAINT provider_contact_pkey PRIMARY KEY (id);


--
-- Name: provider_holding_subfield_map provider_holding_subfield_map_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_holding_subfield_map
    ADD CONSTRAINT provider_holding_subfield_map_pkey PRIMARY KEY (id);


--
-- Name: provider provider_name_once_per_owner; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider
    ADD CONSTRAINT provider_name_once_per_owner UNIQUE (name, owner);


--
-- Name: provider_note provider_note_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_note
    ADD CONSTRAINT provider_note_pkey PRIMARY KEY (id);


--
-- Name: provider provider_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider
    ADD CONSTRAINT provider_pkey PRIMARY KEY (id);


--
-- Name: purchase_order purchase_order_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.purchase_order
    ADD CONSTRAINT purchase_order_pkey PRIMARY KEY (id);


--
-- Name: serial_claim_event serial_claim_event_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.serial_claim_event
    ADD CONSTRAINT serial_claim_event_pkey PRIMARY KEY (id);


--
-- Name: serial_claim serial_claim_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.serial_claim
    ADD CONSTRAINT serial_claim_pkey PRIMARY KEY (id);


--
-- Name: shipment_notification_entry shipment_notification_entry_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification_entry
    ADD CONSTRAINT shipment_notification_entry_pkey PRIMARY KEY (id);


--
-- Name: shipment_notification shipment_notification_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification
    ADD CONSTRAINT shipment_notification_pkey PRIMARY KEY (id);


--
-- Name: user_request user_request_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request
    ADD CONSTRAINT user_request_pkey PRIMARY KEY (id);


--
-- Name: user_request_status_type user_request_status_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request_status_type
    ADD CONSTRAINT user_request_status_type_pkey PRIMARY KEY (id);


--
-- Name: user_request_type user_request_type_label_key; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request_type
    ADD CONSTRAINT user_request_type_label_key UNIQUE (label);


--
-- Name: user_request_type user_request_type_pkey; Type: CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request_type
    ADD CONSTRAINT user_request_type_pkey PRIMARY KEY (id);


--
-- Name: aged_circulation aged_circulation_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.aged_circulation
    ADD CONSTRAINT aged_circulation_pkey PRIMARY KEY (id);


--
-- Name: aged_hold_request aged_hold_request_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.aged_hold_request
    ADD CONSTRAINT aged_hold_request_pkey PRIMARY KEY (id);


--
-- Name: archive_actor_stat_cat archive_actor_stat_cat_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.archive_actor_stat_cat
    ADD CONSTRAINT archive_actor_stat_cat_pkey PRIMARY KEY (id);


--
-- Name: archive_asset_stat_cat archive_asset_stat_cat_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.archive_asset_stat_cat
    ADD CONSTRAINT archive_asset_stat_cat_pkey PRIMARY KEY (id);


--
-- Name: batch_hold_event_map batch_hold_event_map_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.batch_hold_event_map
    ADD CONSTRAINT batch_hold_event_map_pkey PRIMARY KEY (id);


--
-- Name: batch_hold_event batch_hold_event_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.batch_hold_event
    ADD CONSTRAINT batch_hold_event_pkey PRIMARY KEY (id);


--
-- Name: circulation_limit_group_map circulation_limit_group_map_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.circulation_limit_group_map
    ADD CONSTRAINT circulation_limit_group_map_pkey PRIMARY KEY (circ, limit_group);


--
-- Name: circulation circulation_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.circulation
    ADD CONSTRAINT circulation_pkey PRIMARY KEY (id);


--
-- Name: hold_copy_map copy_once_per_hold; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_copy_map
    ADD CONSTRAINT copy_once_per_hold UNIQUE (hold, target_copy);


--
-- Name: curbside curbside_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.curbside
    ADD CONSTRAINT curbside_pkey PRIMARY KEY (id);


--
-- Name: emergency_closing_circulation emergency_closing_circulation_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_circulation
    ADD CONSTRAINT emergency_closing_circulation_pkey PRIMARY KEY (id);


--
-- Name: emergency_closing_hold emergency_closing_hold_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_hold
    ADD CONSTRAINT emergency_closing_hold_pkey PRIMARY KEY (id);


--
-- Name: emergency_closing emergency_closing_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing
    ADD CONSTRAINT emergency_closing_pkey PRIMARY KEY (id);


--
-- Name: emergency_closing_reservation emergency_closing_reservation_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_reservation
    ADD CONSTRAINT emergency_closing_reservation_pkey PRIMARY KEY (id);


--
-- Name: fieldset_col_val fieldset_col_once_per_set; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset_col_val
    ADD CONSTRAINT fieldset_col_once_per_set UNIQUE (fieldset, col);


--
-- Name: fieldset_col_val fieldset_col_val_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset_col_val
    ADD CONSTRAINT fieldset_col_val_pkey PRIMARY KEY (id);


--
-- Name: fieldset_group fieldset_group_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset_group
    ADD CONSTRAINT fieldset_group_pkey PRIMARY KEY (id);


--
-- Name: fieldset fieldset_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset
    ADD CONSTRAINT fieldset_pkey PRIMARY KEY (id);


--
-- Name: hold_copy_map hold_copy_map_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_copy_map
    ADD CONSTRAINT hold_copy_map_pkey PRIMARY KEY (id);


--
-- Name: hold_notification hold_notification_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_notification
    ADD CONSTRAINT hold_notification_pkey PRIMARY KEY (id);


--
-- Name: hold_request_cancel_cause hold_request_cancel_cause_label_key; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request_cancel_cause
    ADD CONSTRAINT hold_request_cancel_cause_label_key UNIQUE (label);


--
-- Name: hold_request_cancel_cause hold_request_cancel_cause_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request_cancel_cause
    ADD CONSTRAINT hold_request_cancel_cause_pkey PRIMARY KEY (id);


--
-- Name: hold_request_note hold_request_note_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request_note
    ADD CONSTRAINT hold_request_note_pkey PRIMARY KEY (id);


--
-- Name: hold_request hold_request_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_pkey PRIMARY KEY (id);


--
-- Name: hold_transit_copy hold_transit_copy_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_transit_copy
    ADD CONSTRAINT hold_transit_copy_pkey PRIMARY KEY (id);


--
-- Name: in_house_use in_house_use_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.in_house_use
    ADD CONSTRAINT in_house_use_pkey PRIMARY KEY (id);


--
-- Name: fieldset lib_name_unique; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset
    ADD CONSTRAINT lib_name_unique UNIQUE (owning_lib, name);


--
-- Name: non_cat_in_house_use non_cat_in_house_use_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_pkey PRIMARY KEY (id);


--
-- Name: non_cataloged_circulation non_cataloged_circulation_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_pkey PRIMARY KEY (id);


--
-- Name: reservation_transit_copy reservation_transit_copy_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.reservation_transit_copy
    ADD CONSTRAINT reservation_transit_copy_pkey PRIMARY KEY (id);


--
-- Name: survey_answer survey_answer_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey_answer
    ADD CONSTRAINT survey_answer_pkey PRIMARY KEY (id);


--
-- Name: survey survey_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey
    ADD CONSTRAINT survey_pkey PRIMARY KEY (id);


--
-- Name: survey_question survey_question_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey_question
    ADD CONSTRAINT survey_question_pkey PRIMARY KEY (id);


--
-- Name: survey_response survey_response_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey_response
    ADD CONSTRAINT survey_response_pkey PRIMARY KEY (id);


--
-- Name: transit_copy transit_copy_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.transit_copy
    ADD CONSTRAINT transit_copy_pkey PRIMARY KEY (id);


--
-- Name: unfulfilled_hold_list unfulfilled_hold_list_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.unfulfilled_hold_list
    ADD CONSTRAINT unfulfilled_hold_list_pkey PRIMARY KEY (id);


--
-- Name: usr_circ_history usr_circ_history_pkey; Type: CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.usr_circ_history
    ADD CONSTRAINT usr_circ_history_pkey PRIMARY KEY (id);


--
-- Name: action_circulation action_circulation_pkey; Type: CONSTRAINT; Schema: action_log; Owner: evergreen
--

ALTER TABLE ONLY action_log.action_circulation
    ADD CONSTRAINT action_circulation_pkey PRIMARY KEY (id);


--
-- Name: alternate_template alternate_template_event_def_locale_key; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.alternate_template
    ADD CONSTRAINT alternate_template_event_def_locale_key UNIQUE (event_def, locale);


--
-- Name: cleanup cleanup_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.cleanup
    ADD CONSTRAINT cleanup_pkey PRIMARY KEY (module);


--
-- Name: collector collector_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.collector
    ADD CONSTRAINT collector_pkey PRIMARY KEY (module);


--
-- Name: environment env_event_label_once; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.environment
    ADD CONSTRAINT env_event_label_once UNIQUE (event_def, label);


--
-- Name: environment environment_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.environment
    ADD CONSTRAINT environment_pkey PRIMARY KEY (id);


--
-- Name: event_definition ev_def_name_owner_once; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_definition
    ADD CONSTRAINT ev_def_name_owner_once UNIQUE (owner, name);


--
-- Name: event_definition ev_def_owner_hook_val_react_clean_delay_once; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_definition
    ADD CONSTRAINT ev_def_owner_hook_val_react_clean_delay_once UNIQUE (owner, hook, validator, reactor, delay, delay_field);


--
-- Name: event_def_group_member event_def_group_member_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_def_group_member
    ADD CONSTRAINT event_def_group_member_pkey PRIMARY KEY (id);


--
-- Name: event_def_group event_def_group_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_def_group
    ADD CONSTRAINT event_def_group_pkey PRIMARY KEY (id);


--
-- Name: event_definition event_definition_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_definition
    ADD CONSTRAINT event_definition_pkey PRIMARY KEY (id);


--
-- Name: event_output event_output_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_output
    ADD CONSTRAINT event_output_pkey PRIMARY KEY (id);


--
-- Name: event_params event_params_event_def_param_once; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_params
    ADD CONSTRAINT event_params_event_def_param_once UNIQUE (event_def, param);


--
-- Name: event_params event_params_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_params
    ADD CONSTRAINT event_params_pkey PRIMARY KEY (id);


--
-- Name: event event_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event
    ADD CONSTRAINT event_pkey PRIMARY KEY (id);


--
-- Name: hook hook_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.hook
    ADD CONSTRAINT hook_pkey PRIMARY KEY (key);


--
-- Name: reactor reactor_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.reactor
    ADD CONSTRAINT reactor_pkey PRIMARY KEY (module);


--
-- Name: validator validator_pkey; Type: CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.validator
    ADD CONSTRAINT validator_pkey PRIMARY KEY (module);


--
-- Name: ada_request ada_request_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.ada_request
    ADD CONSTRAINT ada_request_pkey PRIMARY KEY (id);


--
-- Name: address_alert address_alert_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.address_alert
    ADD CONSTRAINT address_alert_pkey PRIMARY KEY (id);


--
-- Name: org_unit_custom_tree_node aouctn_once_per_org; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_custom_tree_node
    ADD CONSTRAINT aouctn_once_per_org UNIQUE (tree, org_unit);


--
-- Name: search_filter_group asfg_code_once_per_org; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_filter_group
    ADD CONSTRAINT asfg_code_once_per_org UNIQUE (owner, code);


--
-- Name: search_filter_group asfg_label_once_per_org; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_filter_group
    ADD CONSTRAINT asfg_label_once_per_org UNIQUE (owner, label);


--
-- Name: search_filter_group_entry asfge_query_once_per_group; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_filter_group_entry
    ADD CONSTRAINT asfge_query_once_per_group UNIQUE (grp, query);


--
-- Name: card card_barcode_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.card
    ADD CONSTRAINT card_barcode_key UNIQUE (barcode);


--
-- Name: card card_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.card
    ADD CONSTRAINT card_pkey PRIMARY KEY (id);


--
-- Name: copy_alert_suppress copy_alert_suppress_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.copy_alert_suppress
    ADD CONSTRAINT copy_alert_suppress_pkey PRIMARY KEY (id);


--
-- Name: hours_of_operation hours_of_operation_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.hours_of_operation
    ADD CONSTRAINT hours_of_operation_pkey PRIMARY KEY (id);


--
-- Name: usr_saved_search name_once_per_user; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_saved_search
    ADD CONSTRAINT name_once_per_user UNIQUE (owner, name);


--
-- Name: org_address org_address_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_address
    ADD CONSTRAINT org_address_pkey PRIMARY KEY (id);


--
-- Name: org_lasso_map org_lasso_map_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_lasso_map
    ADD CONSTRAINT org_lasso_map_pkey PRIMARY KEY (id);


--
-- Name: org_lasso org_lasso_name_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_lasso
    ADD CONSTRAINT org_lasso_name_key UNIQUE (name);


--
-- Name: org_lasso org_lasso_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_lasso
    ADD CONSTRAINT org_lasso_pkey PRIMARY KEY (id);


--
-- Name: org_unit_closed org_unit_closed_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_closed
    ADD CONSTRAINT org_unit_closed_pkey PRIMARY KEY (id);


--
-- Name: org_unit_custom_tree_node org_unit_custom_tree_node_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_pkey PRIMARY KEY (id);


--
-- Name: org_unit_custom_tree org_unit_custom_tree_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_custom_tree
    ADD CONSTRAINT org_unit_custom_tree_pkey PRIMARY KEY (id);


--
-- Name: org_unit_custom_tree org_unit_custom_tree_purpose_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_custom_tree
    ADD CONSTRAINT org_unit_custom_tree_purpose_key UNIQUE (purpose);


--
-- Name: org_unit org_unit_name_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit
    ADD CONSTRAINT org_unit_name_key UNIQUE (name);


--
-- Name: org_unit org_unit_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit
    ADD CONSTRAINT org_unit_pkey PRIMARY KEY (id);


--
-- Name: org_unit_proximity_adjustment org_unit_proximity_adjustment_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_pkey PRIMARY KEY (id);


--
-- Name: org_unit_proximity org_unit_proximity_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_proximity
    ADD CONSTRAINT org_unit_proximity_pkey PRIMARY KEY (id);


--
-- Name: org_unit_setting org_unit_setting_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_setting
    ADD CONSTRAINT org_unit_setting_pkey PRIMARY KEY (id);


--
-- Name: org_unit org_unit_shortname_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit
    ADD CONSTRAINT org_unit_shortname_key UNIQUE (shortname);


--
-- Name: org_unit_type org_unit_type_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_type
    ADD CONSTRAINT org_unit_type_pkey PRIMARY KEY (id);


--
-- Name: org_unit_setting ou_once_per_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_setting
    ADD CONSTRAINT ou_once_per_key UNIQUE (org_unit, name);


--
-- Name: passwd passwd_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.passwd
    ADD CONSTRAINT passwd_pkey PRIMARY KEY (id);


--
-- Name: passwd_type passwd_type_name_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.passwd_type
    ADD CONSTRAINT passwd_type_name_key UNIQUE (name);


--
-- Name: passwd passwd_type_once_per_user; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.passwd
    ADD CONSTRAINT passwd_type_once_per_user UNIQUE (usr, passwd_type);


--
-- Name: passwd_type passwd_type_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.passwd_type
    ADD CONSTRAINT passwd_type_pkey PRIMARY KEY (code);


--
-- Name: stat_cat sc_once_per_owner; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat
    ADD CONSTRAINT sc_once_per_owner UNIQUE (owner, name);


--
-- Name: stat_cat_entry_usr_map sc_once_per_usr; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry_usr_map
    ADD CONSTRAINT sc_once_per_usr UNIQUE (target_usr, stat_cat);


--
-- Name: stat_cat_entry sce_once_per_owner; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry
    ADD CONSTRAINT sce_once_per_owner UNIQUE (stat_cat, owner, value);


--
-- Name: stat_cat_entry_default sced_once_per_owner; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry_default
    ADD CONSTRAINT sced_once_per_owner UNIQUE (stat_cat, owner);


--
-- Name: search_filter_group_entry search_filter_group_entry_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_filter_group_entry
    ADD CONSTRAINT search_filter_group_entry_pkey PRIMARY KEY (id);


--
-- Name: search_filter_group search_filter_group_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_filter_group
    ADD CONSTRAINT search_filter_group_pkey PRIMARY KEY (id);


--
-- Name: search_query search_query_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_query
    ADD CONSTRAINT search_query_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_default stat_cat_entry_default_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry stat_cat_entry_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry
    ADD CONSTRAINT stat_cat_entry_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_usr_map stat_cat_entry_usr_map_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry_usr_map
    ADD CONSTRAINT stat_cat_entry_usr_map_pkey PRIMARY KEY (id);


--
-- Name: stat_cat stat_cat_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat
    ADD CONSTRAINT stat_cat_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_sip_fields stat_cat_sip_fields_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_sip_fields
    ADD CONSTRAINT stat_cat_sip_fields_pkey PRIMARY KEY (field);


--
-- Name: toolbar toolbar_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.toolbar
    ADD CONSTRAINT toolbar_pkey PRIMARY KEY (id);


--
-- Name: usr_activity usr_activity_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_activity
    ADD CONSTRAINT usr_activity_pkey PRIMARY KEY (id);


--
-- Name: usr_address usr_address_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_address
    ADD CONSTRAINT usr_address_pkey PRIMARY KEY (id);


--
-- Name: usr usr_card_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT usr_card_key UNIQUE (card);


--
-- Name: usr_message usr_message_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_message
    ADD CONSTRAINT usr_message_pkey PRIMARY KEY (id);


--
-- Name: usr_setting usr_once_per_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_setting
    ADD CONSTRAINT usr_once_per_key UNIQUE (usr, name);


--
-- Name: usr_org_unit_opt_in usr_opt_in_once_per_org_unit; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_org_unit_opt_in
    ADD CONSTRAINT usr_opt_in_once_per_org_unit UNIQUE (usr, org_unit);


--
-- Name: usr_org_unit_opt_in usr_org_unit_opt_in_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_pkey PRIMARY KEY (id);


--
-- Name: usr_password_reset usr_password_reset_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_password_reset
    ADD CONSTRAINT usr_password_reset_pkey PRIMARY KEY (id);


--
-- Name: usr usr_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT usr_pkey PRIMARY KEY (id);


--
-- Name: usr_privacy_waiver usr_privacy_waiver_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_privacy_waiver
    ADD CONSTRAINT usr_privacy_waiver_pkey PRIMARY KEY (id);


--
-- Name: usr_saved_search usr_saved_search_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_saved_search
    ADD CONSTRAINT usr_saved_search_pkey PRIMARY KEY (id);


--
-- Name: usr_setting usr_setting_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_setting
    ADD CONSTRAINT usr_setting_pkey PRIMARY KEY (id);


--
-- Name: usr_standing_penalty usr_standing_penalty_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_pkey PRIMARY KEY (id);


--
-- Name: usr usr_usrname_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT usr_usrname_key UNIQUE (usrname);


--
-- Name: workstation workstation_name_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.workstation
    ADD CONSTRAINT workstation_name_key UNIQUE (name);


--
-- Name: workstation workstation_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.workstation
    ADD CONSTRAINT workstation_pkey PRIMARY KEY (id);


--
-- Name: workstation_setting workstation_setting_pkey; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.workstation_setting
    ADD CONSTRAINT workstation_setting_pkey PRIMARY KEY (id);


--
-- Name: workstation_setting ws_once_per_key; Type: CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.workstation_setting
    ADD CONSTRAINT ws_once_per_key UNIQUE (workstation, name);


--
-- Name: copy_location_order acplo_once_per_org; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_order
    ADD CONSTRAINT acplo_once_per_org UNIQUE (location, org);


--
-- Name: call_number_class call_number_class_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_class
    ADD CONSTRAINT call_number_class_pkey PRIMARY KEY (id);


--
-- Name: call_number_note call_number_note_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_note
    ADD CONSTRAINT call_number_note_pkey PRIMARY KEY (id);


--
-- Name: call_number call_number_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number
    ADD CONSTRAINT call_number_pkey PRIMARY KEY (id);


--
-- Name: call_number_prefix call_number_prefix_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_prefix
    ADD CONSTRAINT call_number_prefix_pkey PRIMARY KEY (id);


--
-- Name: call_number_suffix call_number_suffix_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_suffix
    ADD CONSTRAINT call_number_suffix_pkey PRIMARY KEY (id);


--
-- Name: course_module_term cmt_once_per_owning_lib; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_term
    ADD CONSTRAINT cmt_once_per_owning_lib UNIQUE (owning_lib, name);


--
-- Name: copy_alert copy_alert_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_alert
    ADD CONSTRAINT copy_alert_pkey PRIMARY KEY (id);


--
-- Name: copy_inventory copy_inventory_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_inventory
    ADD CONSTRAINT copy_inventory_pkey PRIMARY KEY (id);


--
-- Name: copy_location_group_map copy_location_group_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_group_map
    ADD CONSTRAINT copy_location_group_map_pkey PRIMARY KEY (id);


--
-- Name: copy_location_group copy_location_group_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_group
    ADD CONSTRAINT copy_location_group_pkey PRIMARY KEY (id);


--
-- Name: copy_location_order copy_location_order_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_order
    ADD CONSTRAINT copy_location_order_pkey PRIMARY KEY (id);


--
-- Name: copy_location copy_location_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location
    ADD CONSTRAINT copy_location_pkey PRIMARY KEY (id);


--
-- Name: copy_note copy_note_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_note
    ADD CONSTRAINT copy_note_pkey PRIMARY KEY (id);


--
-- Name: copy_part_map copy_part_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_part_map
    ADD CONSTRAINT copy_part_map_pkey PRIMARY KEY (id);


--
-- Name: copy copy_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy
    ADD CONSTRAINT copy_pkey PRIMARY KEY (id);


--
-- Name: copy_tag_copy_map copy_tag_copy_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_tag_copy_map
    ADD CONSTRAINT copy_tag_copy_map_pkey PRIMARY KEY (id);


--
-- Name: copy_tag copy_tag_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_tag
    ADD CONSTRAINT copy_tag_pkey PRIMARY KEY (id);


--
-- Name: copy_template copy_template_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_template
    ADD CONSTRAINT copy_template_pkey PRIMARY KEY (id);


--
-- Name: copy_vis_attr_cache copy_vis_attr_cache_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_vis_attr_cache
    ADD CONSTRAINT copy_vis_attr_cache_pkey PRIMARY KEY (id);


--
-- Name: course_module_course_materials course_module_course_materials_course_item_record_key; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_materials
    ADD CONSTRAINT course_module_course_materials_course_item_record_key UNIQUE (course, item, record);


--
-- Name: course_module_course_materials course_module_course_materials_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_materials
    ADD CONSTRAINT course_module_course_materials_pkey PRIMARY KEY (id);


--
-- Name: course_module_course course_module_course_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course
    ADD CONSTRAINT course_module_course_pkey PRIMARY KEY (id);


--
-- Name: course_module_course_users course_module_course_users_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_users
    ADD CONSTRAINT course_module_course_users_pkey PRIMARY KEY (id);


--
-- Name: course_module_role course_module_role_name_key; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_role
    ADD CONSTRAINT course_module_role_name_key UNIQUE (name);


--
-- Name: course_module_role course_module_role_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_role
    ADD CONSTRAINT course_module_role_pkey PRIMARY KEY (id);


--
-- Name: course_module_term_course_map course_module_term_course_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_term_course_map
    ADD CONSTRAINT course_module_term_course_map_pkey PRIMARY KEY (id);


--
-- Name: course_module_term course_module_term_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_term
    ADD CONSTRAINT course_module_term_pkey PRIMARY KEY (id);


--
-- Name: copy_location_group_map lgroup_once_per_group; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_group_map
    ADD CONSTRAINT lgroup_once_per_group UNIQUE (lgroup, location);


--
-- Name: copy_location_group lgroup_once_per_owner; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_group
    ADD CONSTRAINT lgroup_once_per_owner UNIQUE (owner, name);


--
-- Name: stat_cat sc_once_per_owner; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat
    ADD CONSTRAINT sc_once_per_owner UNIQUE (owner, name);


--
-- Name: stat_cat_entry_copy_map sce_once_per_copy; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry_copy_map
    ADD CONSTRAINT sce_once_per_copy UNIQUE (owning_copy, stat_cat);


--
-- Name: stat_cat_entry sce_once_per_owner; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry
    ADD CONSTRAINT sce_once_per_owner UNIQUE (stat_cat, owner, value);


--
-- Name: stat_cat_entry_transparency_map scte_once_per_trans; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry_transparency_map
    ADD CONSTRAINT scte_once_per_trans UNIQUE (owning_transparency, stat_cat);


--
-- Name: stat_cat_entry_copy_map stat_cat_entry_copy_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry_copy_map
    ADD CONSTRAINT stat_cat_entry_copy_map_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry stat_cat_entry_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry
    ADD CONSTRAINT stat_cat_entry_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_entry_transparency_map stat_cat_entry_transparency_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry_transparency_map
    ADD CONSTRAINT stat_cat_entry_transparency_map_pkey PRIMARY KEY (id);


--
-- Name: stat_cat stat_cat_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat
    ADD CONSTRAINT stat_cat_pkey PRIMARY KEY (id);


--
-- Name: stat_cat_sip_fields stat_cat_sip_fields_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_sip_fields
    ADD CONSTRAINT stat_cat_sip_fields_pkey PRIMARY KEY (field);


--
-- Name: uri_call_number_map uri_call_number_map_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.uri_call_number_map
    ADD CONSTRAINT uri_call_number_map_pkey PRIMARY KEY (id);


--
-- Name: uri_call_number_map uri_cn_once; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.uri_call_number_map
    ADD CONSTRAINT uri_cn_once UNIQUE (uri, call_number);


--
-- Name: uri uri_pkey; Type: CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.uri
    ADD CONSTRAINT uri_pkey PRIMARY KEY (id);


--
-- Name: acq_fund_debit_history acq_fund_debit_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.acq_fund_debit_history
    ADD CONSTRAINT acq_fund_debit_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_invoice_entry_history acq_invoice_entry_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.acq_invoice_entry_history
    ADD CONSTRAINT acq_invoice_entry_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_invoice_history acq_invoice_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.acq_invoice_history
    ADD CONSTRAINT acq_invoice_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_invoice_item_history acq_invoice_item_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.acq_invoice_item_history
    ADD CONSTRAINT acq_invoice_item_history_pkey PRIMARY KEY (audit_id);


--
-- Name: acq_lineitem_detail_history acq_lineitem_detail_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.acq_lineitem_detail_history
    ADD CONSTRAINT acq_lineitem_detail_history_pkey PRIMARY KEY (audit_id);


--
-- Name: action_trigger_event_definition_history action_trigger_event_definition_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.action_trigger_event_definition_history
    ADD CONSTRAINT action_trigger_event_definition_history_pkey PRIMARY KEY (audit_id);


--
-- Name: actor_org_unit_history actor_org_unit_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.actor_org_unit_history
    ADD CONSTRAINT actor_org_unit_history_pkey PRIMARY KEY (audit_id);


--
-- Name: actor_usr_address_history actor_usr_address_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.actor_usr_address_history
    ADD CONSTRAINT actor_usr_address_history_pkey PRIMARY KEY (audit_id);


--
-- Name: actor_usr_history actor_usr_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.actor_usr_history
    ADD CONSTRAINT actor_usr_history_pkey PRIMARY KEY (audit_id);


--
-- Name: actor_usr_setting_history actor_usr_setting_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.actor_usr_setting_history
    ADD CONSTRAINT actor_usr_setting_history_pkey PRIMARY KEY (audit_id);


--
-- Name: asset_call_number_history asset_call_number_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.asset_call_number_history
    ADD CONSTRAINT asset_call_number_history_pkey PRIMARY KEY (audit_id);


--
-- Name: asset_copy_history asset_copy_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.asset_copy_history
    ADD CONSTRAINT asset_copy_history_pkey PRIMARY KEY (audit_id);


--
-- Name: biblio_record_entry_history biblio_record_entry_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.biblio_record_entry_history
    ADD CONSTRAINT biblio_record_entry_history_pkey PRIMARY KEY (audit_id);


--
-- Name: serial_unit_history serial_unit_history_pkey; Type: CONSTRAINT; Schema: auditor; Owner: evergreen
--

ALTER TABLE ONLY auditor.serial_unit_history
    ADD CONSTRAINT serial_unit_history_pkey PRIMARY KEY (audit_id);


--
-- Name: control_set_bib_field_metabib_field_map a_bf_mf_map_once; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_bib_field_metabib_field_map
    ADD CONSTRAINT a_bf_mf_map_once UNIQUE (bib_field, metabib_field);


--
-- Name: authority_linking authority_linking_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.authority_linking
    ADD CONSTRAINT authority_linking_pkey PRIMARY KEY (id);


--
-- Name: bib_linking bib_linking_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.bib_linking
    ADD CONSTRAINT bib_linking_pkey PRIMARY KEY (id);


--
-- Name: browse_axis_authority_field_map browse_axis_authority_field_map_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.browse_axis_authority_field_map
    ADD CONSTRAINT browse_axis_authority_field_map_pkey PRIMARY KEY (id);


--
-- Name: browse_axis browse_axis_name_key; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.browse_axis
    ADD CONSTRAINT browse_axis_name_key UNIQUE (name);


--
-- Name: browse_axis browse_axis_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.browse_axis
    ADD CONSTRAINT browse_axis_pkey PRIMARY KEY (code);


--
-- Name: control_set_authority_field control_set_authority_field_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_authority_field
    ADD CONSTRAINT control_set_authority_field_pkey PRIMARY KEY (id);


--
-- Name: control_set_bib_field_metabib_field_map control_set_bib_field_metabib_field_map_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_bib_field_metabib_field_map
    ADD CONSTRAINT control_set_bib_field_metabib_field_map_pkey PRIMARY KEY (id);


--
-- Name: control_set_bib_field control_set_bib_field_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_bib_field
    ADD CONSTRAINT control_set_bib_field_pkey PRIMARY KEY (id);


--
-- Name: control_set control_set_name_key; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set
    ADD CONSTRAINT control_set_name_key UNIQUE (name);


--
-- Name: control_set control_set_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set
    ADD CONSTRAINT control_set_pkey PRIMARY KEY (id);


--
-- Name: full_rec full_rec_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.full_rec
    ADD CONSTRAINT full_rec_pkey PRIMARY KEY (id);


--
-- Name: heading_field_norm_map heading_field_norm_map_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.heading_field_norm_map
    ADD CONSTRAINT heading_field_norm_map_pkey PRIMARY KEY (id);


--
-- Name: heading_field heading_field_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.heading_field
    ADD CONSTRAINT heading_field_pkey PRIMARY KEY (id);


--
-- Name: rec_descriptor rec_descriptor_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.rec_descriptor
    ADD CONSTRAINT rec_descriptor_pkey PRIMARY KEY (id);


--
-- Name: record_entry record_entry_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.record_entry
    ADD CONSTRAINT record_entry_pkey PRIMARY KEY (id);


--
-- Name: record_note record_note_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.record_note
    ADD CONSTRAINT record_note_pkey PRIMARY KEY (id);


--
-- Name: display_5xx_headings reference_headings_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.display_5xx_headings
    ADD CONSTRAINT reference_headings_pkey PRIMARY KEY (id);


--
-- Name: simple_heading simple_heading_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.simple_heading
    ADD CONSTRAINT simple_heading_pkey PRIMARY KEY (id);


--
-- Name: thesaurus thesaurus_name_key; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.thesaurus
    ADD CONSTRAINT thesaurus_name_key UNIQUE (name);


--
-- Name: thesaurus thesaurus_pkey; Type: CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.thesaurus
    ADD CONSTRAINT thesaurus_pkey PRIMARY KEY (code);


--
-- Name: monograph_part monograph_part_pkey; Type: CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.monograph_part
    ADD CONSTRAINT monograph_part_pkey PRIMARY KEY (id);


--
-- Name: peer_bib_copy_map peer_bib_copy_map_pkey; Type: CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.peer_bib_copy_map
    ADD CONSTRAINT peer_bib_copy_map_pkey PRIMARY KEY (id);


--
-- Name: peer_type peer_type_name_key; Type: CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.peer_type
    ADD CONSTRAINT peer_type_name_key UNIQUE (name);


--
-- Name: peer_type peer_type_pkey; Type: CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.peer_type
    ADD CONSTRAINT peer_type_pkey PRIMARY KEY (id);


--
-- Name: record_entry record_entry_pkey; Type: CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.record_entry
    ADD CONSTRAINT record_entry_pkey PRIMARY KEY (id);


--
-- Name: record_note record_note_pkey; Type: CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.record_note
    ADD CONSTRAINT record_note_pkey PRIMARY KEY (id);


--
-- Name: resource br_unique; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource
    ADD CONSTRAINT br_unique UNIQUE (owner, barcode);


--
-- Name: resource_attr bra_name_once_per_type; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr
    ADD CONSTRAINT bra_name_once_per_type UNIQUE (resource_type, name);


--
-- Name: resource_attr_map bram_one_value_per_attr; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr_map
    ADD CONSTRAINT bram_one_value_per_attr UNIQUE (resource, resource_attr);


--
-- Name: resource_attr_value brav_logical_key; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr_value
    ADD CONSTRAINT brav_logical_key UNIQUE (owner, attr, valid_value);


--
-- Name: reservation_attr_value_map bravm_logical_key; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation_attr_value_map
    ADD CONSTRAINT bravm_logical_key UNIQUE (reservation, attr_value);


--
-- Name: resource_type brt_name_and_record_once_per_owner; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_type
    ADD CONSTRAINT brt_name_and_record_once_per_owner UNIQUE (owner, name, record);


--
-- Name: reservation_attr_value_map reservation_attr_value_map_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation_attr_value_map
    ADD CONSTRAINT reservation_attr_value_map_pkey PRIMARY KEY (id);


--
-- Name: reservation reservation_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation
    ADD CONSTRAINT reservation_pkey PRIMARY KEY (id);


--
-- Name: resource_attr_map resource_attr_map_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr_map
    ADD CONSTRAINT resource_attr_map_pkey PRIMARY KEY (id);


--
-- Name: resource_attr resource_attr_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr
    ADD CONSTRAINT resource_attr_pkey PRIMARY KEY (id);


--
-- Name: resource_attr_value resource_attr_value_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr_value
    ADD CONSTRAINT resource_attr_value_pkey PRIMARY KEY (id);


--
-- Name: resource resource_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource
    ADD CONSTRAINT resource_pkey PRIMARY KEY (id);


--
-- Name: resource_type resource_type_pkey; Type: CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_type
    ADD CONSTRAINT resource_type_pkey PRIMARY KEY (id);


--
-- Name: barcode_completion barcode_completion_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.barcode_completion
    ADD CONSTRAINT barcode_completion_pkey PRIMARY KEY (id);


--
-- Name: best_hold_order best_hold_order_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.best_hold_order
    ADD CONSTRAINT best_hold_order_name_key UNIQUE (name);


--
-- Name: best_hold_order best_hold_order_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.best_hold_order
    ADD CONSTRAINT best_hold_order_pkey PRIMARY KEY (id);


--
-- Name: bib_source bib_source_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.bib_source
    ADD CONSTRAINT bib_source_pkey PRIMARY KEY (id);


--
-- Name: bib_source bib_source_source_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.bib_source
    ADD CONSTRAINT bib_source_source_key UNIQUE (source);


--
-- Name: biblio_fingerprint biblio_fingerprint_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.biblio_fingerprint
    ADD CONSTRAINT biblio_fingerprint_pkey PRIMARY KEY (id);


--
-- Name: billing_type billing_type_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.billing_type
    ADD CONSTRAINT billing_type_once_per_lib UNIQUE (name, owner);


--
-- Name: billing_type billing_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.billing_type
    ADD CONSTRAINT billing_type_pkey PRIMARY KEY (id);


--
-- Name: carousel_type carousel_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.carousel_type
    ADD CONSTRAINT carousel_type_pkey PRIMARY KEY (id);


--
-- Name: filter_dialog_filter_set cfdfs_name_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.filter_dialog_filter_set
    ADD CONSTRAINT cfdfs_name_once_per_lib UNIQUE (name, owning_lib);


--
-- Name: circ_limit_group circ_limit_group_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_group
    ADD CONSTRAINT circ_limit_group_name_key UNIQUE (name);


--
-- Name: circ_limit_group circ_limit_group_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_group
    ADD CONSTRAINT circ_limit_group_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set_circ_mod_map circ_limit_set_circ_mod_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_circ_mod_map
    ADD CONSTRAINT circ_limit_set_circ_mod_map_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set_copy_loc_map circ_limit_set_copy_loc_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_copy_loc_map
    ADD CONSTRAINT circ_limit_set_copy_loc_map_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set_group_map circ_limit_set_group_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_group_map
    ADD CONSTRAINT circ_limit_set_group_map_pkey PRIMARY KEY (id);


--
-- Name: circ_limit_set circ_limit_set_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set
    ADD CONSTRAINT circ_limit_set_name_key UNIQUE (name);


--
-- Name: circ_matrix_limit_set_map circ_limit_set_once_per_matchpoint; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_limit_set_map
    ADD CONSTRAINT circ_limit_set_once_per_matchpoint UNIQUE (matchpoint, limit_set);


--
-- Name: circ_limit_set circ_limit_set_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set
    ADD CONSTRAINT circ_limit_set_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_circ_mod_test_map circ_matrix_circ_mod_test_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_circ_mod_test_map
    ADD CONSTRAINT circ_matrix_circ_mod_test_map_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_circ_mod_test circ_matrix_circ_mod_test_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_circ_mod_test
    ADD CONSTRAINT circ_matrix_circ_mod_test_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_limit_set_map circ_matrix_limit_set_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_limit_set_map
    ADD CONSTRAINT circ_matrix_limit_set_map_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_pkey PRIMARY KEY (id);


--
-- Name: circ_matrix_weights circ_matrix_weights_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_weights
    ADD CONSTRAINT circ_matrix_weights_name_key UNIQUE (name);


--
-- Name: circ_matrix_weights circ_matrix_weights_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_weights
    ADD CONSTRAINT circ_matrix_weights_pkey PRIMARY KEY (id);


--
-- Name: circ_modifier circ_modifier_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_modifier
    ADD CONSTRAINT circ_modifier_name_key UNIQUE (name);


--
-- Name: circ_modifier circ_modifier_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_modifier
    ADD CONSTRAINT circ_modifier_pkey PRIMARY KEY (code);


--
-- Name: circ_limit_set_copy_loc_map cl_once_per_set; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_copy_loc_map
    ADD CONSTRAINT cl_once_per_set UNIQUE (limit_set, copy_loc);


--
-- Name: circ_limit_set_group_map clg_once_per_set; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_group_map
    ADD CONSTRAINT clg_once_per_set UNIQUE (limit_set, limit_group);


--
-- Name: circ_limit_set_circ_mod_map cm_once_per_set; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_circ_mod_map
    ADD CONSTRAINT cm_once_per_set UNIQUE (limit_set, circ_mod);


--
-- Name: circ_matrix_circ_mod_test_map cm_once_per_test; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_circ_mod_test_map
    ADD CONSTRAINT cm_once_per_test UNIQUE (circ_mod_test, circ_mod);


--
-- Name: coded_value_map coded_value_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.coded_value_map
    ADD CONSTRAINT coded_value_map_pkey PRIMARY KEY (id);


--
-- Name: composite_attr_entry_definition composite_attr_entry_definition_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.composite_attr_entry_definition
    ADD CONSTRAINT composite_attr_entry_definition_pkey PRIMARY KEY (coded_value);


--
-- Name: copy_alert_type copy_alert_type_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.copy_alert_type
    ADD CONSTRAINT copy_alert_type_name_key UNIQUE (name);


--
-- Name: copy_alert_type copy_alert_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.copy_alert_type
    ADD CONSTRAINT copy_alert_type_pkey PRIMARY KEY (id);


--
-- Name: copy_status copy_status_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.copy_status
    ADD CONSTRAINT copy_status_name_key UNIQUE (name);


--
-- Name: copy_status copy_status_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.copy_status
    ADD CONSTRAINT copy_status_pkey PRIMARY KEY (id);


--
-- Name: copy_tag_type copy_tag_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.copy_tag_type
    ADD CONSTRAINT copy_tag_type_pkey PRIMARY KEY (code);


--
-- Name: z3950_source_credentials czsc_source_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_source_credentials
    ADD CONSTRAINT czsc_source_once_per_lib UNIQUE (source, owner);


--
-- Name: db_patch_dependencies db_patch_dependencies_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.db_patch_dependencies
    ADD CONSTRAINT db_patch_dependencies_pkey PRIMARY KEY (db_patch);


--
-- Name: display_field_map display_field_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.display_field_map
    ADD CONSTRAINT display_field_map_pkey PRIMARY KEY (name);


--
-- Name: filter_dialog_filter_set filter_dialog_filter_set_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.filter_dialog_filter_set
    ADD CONSTRAINT filter_dialog_filter_set_pkey PRIMARY KEY (id);


--
-- Name: filter_dialog_interface filter_dialog_interface_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.filter_dialog_interface
    ADD CONSTRAINT filter_dialog_interface_pkey PRIMARY KEY (key);


--
-- Name: floating_group_member floating_group_member_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.floating_group_member
    ADD CONSTRAINT floating_group_member_pkey PRIMARY KEY (id);


--
-- Name: floating_group floating_group_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.floating_group
    ADD CONSTRAINT floating_group_name_key UNIQUE (name);


--
-- Name: floating_group floating_group_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.floating_group
    ADD CONSTRAINT floating_group_pkey PRIMARY KEY (id);


--
-- Name: geolocation_service geolocation_service_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.geolocation_service
    ADD CONSTRAINT geolocation_service_pkey PRIMARY KEY (id);


--
-- Name: global_flag global_flag_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.global_flag
    ADD CONSTRAINT global_flag_pkey PRIMARY KEY (name);


--
-- Name: hard_due_date hard_due_date_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hard_due_date
    ADD CONSTRAINT hard_due_date_name_key UNIQUE (name);


--
-- Name: hard_due_date hard_due_date_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hard_due_date
    ADD CONSTRAINT hard_due_date_pkey PRIMARY KEY (id);


--
-- Name: hard_due_date_values hard_due_date_values_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hard_due_date_values
    ADD CONSTRAINT hard_due_date_values_pkey PRIMARY KEY (id);


--
-- Name: hold_matrix_matchpoint hold_matrix_matchpoint_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_pkey PRIMARY KEY (id);


--
-- Name: hold_matrix_weights hold_matrix_weights_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_weights
    ADD CONSTRAINT hold_matrix_weights_name_key UNIQUE (name);


--
-- Name: hold_matrix_weights hold_matrix_weights_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_weights
    ADD CONSTRAINT hold_matrix_weights_pkey PRIMARY KEY (id);


--
-- Name: hold_type hold_type_hold_type_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_type
    ADD CONSTRAINT hold_type_hold_type_key UNIQUE (hold_type);


--
-- Name: i18n_core i18n_core_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.i18n_core
    ADD CONSTRAINT i18n_core_pkey PRIMARY KEY (id);


--
-- Name: i18n_locale i18n_locale_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.i18n_locale
    ADD CONSTRAINT i18n_locale_name_key UNIQUE (name);


--
-- Name: i18n_locale i18n_locale_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.i18n_locale
    ADD CONSTRAINT i18n_locale_pkey PRIMARY KEY (code);


--
-- Name: identification_type identification_type_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.identification_type
    ADD CONSTRAINT identification_type_name_key UNIQUE (name);


--
-- Name: identification_type identification_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.identification_type
    ADD CONSTRAINT identification_type_pkey PRIMARY KEY (id);


--
-- Name: idl_field_doc idl_field_doc_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.idl_field_doc
    ADD CONSTRAINT idl_field_doc_pkey PRIMARY KEY (id);


--
-- Name: index_normalizer index_normalizer_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.index_normalizer
    ADD CONSTRAINT index_normalizer_name_key UNIQUE (name);


--
-- Name: index_normalizer index_normalizer_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.index_normalizer
    ADD CONSTRAINT index_normalizer_pkey PRIMARY KEY (id);


--
-- Name: internal_flag internal_flag_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.internal_flag
    ADD CONSTRAINT internal_flag_pkey PRIMARY KEY (name);


--
-- Name: print_template label_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.print_template
    ADD CONSTRAINT label_once_per_lib UNIQUE (owner, label);


--
-- Name: marc21_ff_pos_map marc21_ff_pos_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc21_ff_pos_map
    ADD CONSTRAINT marc21_ff_pos_map_pkey PRIMARY KEY (id);


--
-- Name: marc21_physical_characteristic_subfield_map marc21_physical_characteristic_subfield_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc21_physical_characteristic_subfield_map
    ADD CONSTRAINT marc21_physical_characteristic_subfield_map_pkey PRIMARY KEY (id);


--
-- Name: marc21_physical_characteristic_type_map marc21_physical_characteristic_type_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc21_physical_characteristic_type_map
    ADD CONSTRAINT marc21_physical_characteristic_type_map_pkey PRIMARY KEY (ptype_key);


--
-- Name: marc21_physical_characteristic_value_map marc21_physical_characteristic_value_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc21_physical_characteristic_value_map
    ADD CONSTRAINT marc21_physical_characteristic_value_map_pkey PRIMARY KEY (id);


--
-- Name: marc21_rec_type_map marc21_rec_type_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc21_rec_type_map
    ADD CONSTRAINT marc21_rec_type_map_pkey PRIMARY KEY (code);


--
-- Name: marc_field marc_field_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc_field
    ADD CONSTRAINT marc_field_pkey PRIMARY KEY (id);


--
-- Name: marc_format marc_format_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc_format
    ADD CONSTRAINT marc_format_pkey PRIMARY KEY (id);


--
-- Name: marc_subfield marc_subfield_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc_subfield
    ADD CONSTRAINT marc_subfield_pkey PRIMARY KEY (id);


--
-- Name: metabib_class metabib_class_label_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_class
    ADD CONSTRAINT metabib_class_label_key UNIQUE (label);


--
-- Name: metabib_class metabib_class_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_class
    ADD CONSTRAINT metabib_class_pkey PRIMARY KEY (name);


--
-- Name: metabib_class_ts_map metabib_class_ts_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_class_ts_map
    ADD CONSTRAINT metabib_class_ts_map_pkey PRIMARY KEY (id);


--
-- Name: metabib_field_index_norm_map metabib_field_index_norm_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_index_norm_map
    ADD CONSTRAINT metabib_field_index_norm_map_pkey PRIMARY KEY (id);


--
-- Name: metabib_field metabib_field_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field
    ADD CONSTRAINT metabib_field_pkey PRIMARY KEY (id);


--
-- Name: metabib_field_ts_map metabib_field_ts_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_ts_map
    ADD CONSTRAINT metabib_field_ts_map_pkey PRIMARY KEY (id);


--
-- Name: metabib_field_virtual_map metabib_field_virtual_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_virtual_map
    ADD CONSTRAINT metabib_field_virtual_map_pkey PRIMARY KEY (id);


--
-- Name: metabib_search_alias metabib_search_alias_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_search_alias
    ADD CONSTRAINT metabib_search_alias_pkey PRIMARY KEY (alias);


--
-- Name: print_template name_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.print_template
    ADD CONSTRAINT name_once_per_lib UNIQUE (owner, name);


--
-- Name: net_access_level net_access_level_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.net_access_level
    ADD CONSTRAINT net_access_level_name_key UNIQUE (name);


--
-- Name: net_access_level net_access_level_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.net_access_level
    ADD CONSTRAINT net_access_level_pkey PRIMARY KEY (id);


--
-- Name: non_cataloged_type non_cataloged_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.non_cataloged_type
    ADD CONSTRAINT non_cataloged_type_pkey PRIMARY KEY (id);


--
-- Name: non_cataloged_type noncat_once_per_lib; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.non_cataloged_type
    ADD CONSTRAINT noncat_once_per_lib UNIQUE (owning_lib, name);


--
-- Name: org_unit_setting_type org_unit_setting_type_label_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.org_unit_setting_type
    ADD CONSTRAINT org_unit_setting_type_label_key UNIQUE (label);


--
-- Name: org_unit_setting_type_log org_unit_setting_type_log_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.org_unit_setting_type_log
    ADD CONSTRAINT org_unit_setting_type_log_pkey PRIMARY KEY (id);


--
-- Name: org_unit_setting_type org_unit_setting_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.org_unit_setting_type
    ADD CONSTRAINT org_unit_setting_type_pkey PRIMARY KEY (name);


--
-- Name: patron_message patron_message_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.patron_message
    ADD CONSTRAINT patron_message_pkey PRIMARY KEY (id);


--
-- Name: print_template print_template_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.print_template
    ADD CONSTRAINT print_template_pkey PRIMARY KEY (id);


--
-- Name: record_attr_definition record_attr_definition_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.record_attr_definition
    ADD CONSTRAINT record_attr_definition_pkey PRIMARY KEY (name);


--
-- Name: record_attr_index_norm_map record_attr_index_norm_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.record_attr_index_norm_map
    ADD CONSTRAINT record_attr_index_norm_map_pkey PRIMARY KEY (id);


--
-- Name: remote_account remote_account_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.remote_account
    ADD CONSTRAINT remote_account_pkey PRIMARY KEY (id);


--
-- Name: remoteauth_profile remoteauth_profile_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.remoteauth_profile
    ADD CONSTRAINT remoteauth_profile_pkey PRIMARY KEY (name);


--
-- Name: rule_age_hold_protect rule_age_hold_protect_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_age_hold_protect
    ADD CONSTRAINT rule_age_hold_protect_name_key UNIQUE (name);


--
-- Name: rule_age_hold_protect rule_age_hold_protect_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_age_hold_protect
    ADD CONSTRAINT rule_age_hold_protect_pkey PRIMARY KEY (id);


--
-- Name: rule_circ_duration rule_circ_duration_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_circ_duration
    ADD CONSTRAINT rule_circ_duration_name_key UNIQUE (name);


--
-- Name: rule_circ_duration rule_circ_duration_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_circ_duration
    ADD CONSTRAINT rule_circ_duration_pkey PRIMARY KEY (id);


--
-- Name: rule_max_fine rule_max_fine_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_max_fine
    ADD CONSTRAINT rule_max_fine_name_key UNIQUE (name);


--
-- Name: rule_max_fine rule_max_fine_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_max_fine
    ADD CONSTRAINT rule_max_fine_pkey PRIMARY KEY (id);


--
-- Name: rule_recurring_fine rule_recurring_fine_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_recurring_fine
    ADD CONSTRAINT rule_recurring_fine_name_key UNIQUE (name);


--
-- Name: rule_recurring_fine rule_recurring_fine_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.rule_recurring_fine
    ADD CONSTRAINT rule_recurring_fine_pkey PRIMARY KEY (id);


--
-- Name: settings_group settings_group_label_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.settings_group
    ADD CONSTRAINT settings_group_label_key UNIQUE (label);


--
-- Name: settings_group settings_group_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.settings_group
    ADD CONSTRAINT settings_group_pkey PRIMARY KEY (name);


--
-- Name: sms_carrier sms_carrier_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.sms_carrier
    ADD CONSTRAINT sms_carrier_pkey PRIMARY KEY (id);


--
-- Name: standing_penalty standing_penalty_name_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.standing_penalty
    ADD CONSTRAINT standing_penalty_name_key UNIQUE (name);


--
-- Name: standing_penalty standing_penalty_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.standing_penalty
    ADD CONSTRAINT standing_penalty_pkey PRIMARY KEY (id);


--
-- Name: standing standing_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.standing
    ADD CONSTRAINT standing_pkey PRIMARY KEY (id);


--
-- Name: standing standing_value_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.standing
    ADD CONSTRAINT standing_value_key UNIQUE (value);


--
-- Name: ts_config_list ts_config_list_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.ts_config_list
    ADD CONSTRAINT ts_config_list_pkey PRIMARY KEY (id);


--
-- Name: ui_staff_portal_page_entry ui_staff_portal_page_entry_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.ui_staff_portal_page_entry
    ADD CONSTRAINT ui_staff_portal_page_entry_pkey PRIMARY KEY (id);


--
-- Name: ui_staff_portal_page_entry_type ui_staff_portal_page_entry_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.ui_staff_portal_page_entry_type
    ADD CONSTRAINT ui_staff_portal_page_entry_type_pkey PRIMARY KEY (code);


--
-- Name: upgrade_log upgrade_log_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.upgrade_log
    ADD CONSTRAINT upgrade_log_pkey PRIMARY KEY (version);


--
-- Name: usr_activity_type usr_activity_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.usr_activity_type
    ADD CONSTRAINT usr_activity_type_pkey PRIMARY KEY (id);


--
-- Name: usr_setting_type usr_setting_type_label_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.usr_setting_type
    ADD CONSTRAINT usr_setting_type_label_key UNIQUE (label);


--
-- Name: usr_setting_type usr_setting_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.usr_setting_type
    ADD CONSTRAINT usr_setting_type_pkey PRIMARY KEY (name);


--
-- Name: weight_assoc weight_assoc_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.weight_assoc
    ADD CONSTRAINT weight_assoc_pkey PRIMARY KEY (id);


--
-- Name: workstation_setting_type workstation_setting_type_label_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.workstation_setting_type
    ADD CONSTRAINT workstation_setting_type_label_key UNIQUE (label);


--
-- Name: workstation_setting_type workstation_setting_type_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.workstation_setting_type
    ADD CONSTRAINT workstation_setting_type_pkey PRIMARY KEY (name);


--
-- Name: xml_transform xml_transform_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.xml_transform
    ADD CONSTRAINT xml_transform_pkey PRIMARY KEY (name);


--
-- Name: z3950_attr z3950_attr_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_attr
    ADD CONSTRAINT z3950_attr_pkey PRIMARY KEY (id);


--
-- Name: z3950_index_field_map z3950_index_field_map_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_index_field_map
    ADD CONSTRAINT z3950_index_field_map_pkey PRIMARY KEY (id);


--
-- Name: z3950_source_credentials z3950_source_credentials_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_source_credentials
    ADD CONSTRAINT z3950_source_credentials_pkey PRIMARY KEY (id);


--
-- Name: z3950_source z3950_source_label_key; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_source
    ADD CONSTRAINT z3950_source_label_key UNIQUE (label);


--
-- Name: z3950_source z3950_source_pkey; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_source
    ADD CONSTRAINT z3950_source_pkey PRIMARY KEY (name);


--
-- Name: z3950_attr z_code_format_once_per_source; Type: CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_attr
    ADD CONSTRAINT z_code_format_once_per_source UNIQUE (code, format, source);


--
-- Name: biblio_record_entry_bucket_item_note biblio_record_entry_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_item_note
    ADD CONSTRAINT biblio_record_entry_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket_item biblio_record_entry_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_item
    ADD CONSTRAINT biblio_record_entry_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket_note biblio_record_entry_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_note
    ADD CONSTRAINT biblio_record_entry_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket biblio_record_entry_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket
    ADD CONSTRAINT biblio_record_entry_bucket_pkey PRIMARY KEY (id);


--
-- Name: biblio_record_entry_bucket_type biblio_record_entry_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_type
    ADD CONSTRAINT biblio_record_entry_bucket_type_label_key UNIQUE (label);


--
-- Name: biblio_record_entry_bucket_type biblio_record_entry_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_type
    ADD CONSTRAINT biblio_record_entry_bucket_type_pkey PRIMARY KEY (code);


--
-- Name: biblio_record_entry_bucket breb_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket
    ADD CONSTRAINT breb_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: call_number_bucket_item_note call_number_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_item_note
    ADD CONSTRAINT call_number_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket_item call_number_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_item
    ADD CONSTRAINT call_number_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket_note call_number_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_note
    ADD CONSTRAINT call_number_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket call_number_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket
    ADD CONSTRAINT call_number_bucket_pkey PRIMARY KEY (id);


--
-- Name: call_number_bucket_type call_number_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_type
    ADD CONSTRAINT call_number_bucket_type_label_key UNIQUE (label);


--
-- Name: call_number_bucket_type call_number_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_type
    ADD CONSTRAINT call_number_bucket_type_pkey PRIMARY KEY (code);


--
-- Name: carousel_org_unit carousel_org_unit_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.carousel_org_unit
    ADD CONSTRAINT carousel_org_unit_pkey PRIMARY KEY (id);


--
-- Name: carousel carousel_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.carousel
    ADD CONSTRAINT carousel_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket cb_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket
    ADD CONSTRAINT cb_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: call_number_bucket cnb_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket
    ADD CONSTRAINT cnb_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: copy_bucket_item_note copy_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket_item_note
    ADD CONSTRAINT copy_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket_item copy_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket_item
    ADD CONSTRAINT copy_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket_note copy_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket_note
    ADD CONSTRAINT copy_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket copy_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket
    ADD CONSTRAINT copy_bucket_pkey PRIMARY KEY (id);


--
-- Name: copy_bucket_type copy_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket_type
    ADD CONSTRAINT copy_bucket_type_label_key UNIQUE (label);


--
-- Name: copy_bucket_type copy_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket_type
    ADD CONSTRAINT copy_bucket_type_pkey PRIMARY KEY (code);


--
-- Name: user_bucket ub_name_once_per_owner; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket
    ADD CONSTRAINT ub_name_once_per_owner UNIQUE (owner, name, btype);


--
-- Name: user_bucket_item_note user_bucket_item_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_item_note
    ADD CONSTRAINT user_bucket_item_note_pkey PRIMARY KEY (id);


--
-- Name: user_bucket_item user_bucket_item_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_item
    ADD CONSTRAINT user_bucket_item_pkey PRIMARY KEY (id);


--
-- Name: user_bucket_note user_bucket_note_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_note
    ADD CONSTRAINT user_bucket_note_pkey PRIMARY KEY (id);


--
-- Name: user_bucket user_bucket_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket
    ADD CONSTRAINT user_bucket_pkey PRIMARY KEY (id);


--
-- Name: user_bucket_type user_bucket_type_label_key; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_type
    ADD CONSTRAINT user_bucket_type_label_key UNIQUE (label);


--
-- Name: user_bucket_type user_bucket_type_pkey; Type: CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_type
    ADD CONSTRAINT user_bucket_type_pkey PRIMARY KEY (code);


--
-- Name: cluster cluster_pkey; Type: CONSTRAINT; Schema: elastic; Owner: evergreen
--

ALTER TABLE ONLY elastic.cluster
    ADD CONSTRAINT cluster_pkey PRIMARY KEY (code);


--
-- Name: node node_label_key; Type: CONSTRAINT; Schema: elastic; Owner: evergreen
--

ALTER TABLE ONLY elastic.node
    ADD CONSTRAINT node_label_key UNIQUE (label);


--
-- Name: node node_once; Type: CONSTRAINT; Schema: elastic; Owner: evergreen
--

ALTER TABLE ONLY elastic.node
    ADD CONSTRAINT node_once UNIQUE (host, port, path, cluster);


--
-- Name: node node_pkey; Type: CONSTRAINT; Schema: elastic; Owner: evergreen
--

ALTER TABLE ONLY elastic.node
    ADD CONSTRAINT node_pkey PRIMARY KEY (id);


--
-- Name: legacy_circ_count legacy_circ_count_pkey; Type: CONSTRAINT; Schema: extend_reporter; Owner: evergreen
--

ALTER TABLE ONLY extend_reporter.legacy_circ_count
    ADD CONSTRAINT legacy_circ_count_pkey PRIMARY KEY (id);


--
-- Name: bib_map bib_map_egid_key; Type: CONSTRAINT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.bib_map
    ADD CONSTRAINT bib_map_egid_key UNIQUE (egid);


--
-- Name: bib_map bib_map_item_eg_id_key; Type: CONSTRAINT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.bib_map
    ADD CONSTRAINT bib_map_item_eg_id_key UNIQUE (item_eg_id);


--
-- Name: config config_key_key; Type: CONSTRAINT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.config
    ADD CONSTRAINT config_key_key UNIQUE (key);


--
-- Name: org_map org_map_l_library_key; Type: CONSTRAINT; Schema: m_enum; Owner: evergreen
--

ALTER TABLE ONLY m_enum.org_map
    ADD CONSTRAINT org_map_l_library_key UNIQUE (l_library);


--
-- Name: config config_key_key; Type: CONSTRAINT; Schema: m_test; Owner: evergreen
--

ALTER TABLE ONLY m_test.config
    ADD CONSTRAINT config_key_key UNIQUE (key);


--
-- Name: author_field_entry author_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.author_field_entry
    ADD CONSTRAINT author_field_entry_pkey PRIMARY KEY (id);


--
-- Name: bib_export_data bib_export_data_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.bib_export_data
    ADD CONSTRAINT bib_export_data_pkey PRIMARY KEY (id);


--
-- Name: browse_entry_def_map browse_entry_def_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_pkey PRIMARY KEY (id);


--
-- Name: browse_entry browse_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry
    ADD CONSTRAINT browse_entry_pkey PRIMARY KEY (id);


--
-- Name: browse_entry_simple_heading_map browse_entry_simple_heading_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry_simple_heading_map
    ADD CONSTRAINT browse_entry_simple_heading_map_pkey PRIMARY KEY (id);


--
-- Name: call_number_field_entry call_number_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.call_number_field_entry
    ADD CONSTRAINT call_number_field_entry_pkey PRIMARY KEY (id);


--
-- Name: display_entry display_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.display_entry
    ADD CONSTRAINT display_entry_pkey PRIMARY KEY (id);


--
-- Name: facet_entry facet_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.facet_entry
    ADD CONSTRAINT facet_entry_pkey PRIMARY KEY (id);


--
-- Name: identifier_field_entry identifier_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.identifier_field_entry
    ADD CONSTRAINT identifier_field_entry_pkey PRIMARY KEY (id);


--
-- Name: keyword_field_entry keyword_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.keyword_field_entry
    ADD CONSTRAINT keyword_field_entry_pkey PRIMARY KEY (id);


--
-- Name: metarecord metarecord_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.metarecord
    ADD CONSTRAINT metarecord_pkey PRIMARY KEY (id);


--
-- Name: metarecord_source_map metarecord_source_map_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.metarecord_source_map
    ADD CONSTRAINT metarecord_source_map_pkey PRIMARY KEY (id);


--
-- Name: normalized_author_field_entry normalized_author_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.normalized_author_field_entry
    ADD CONSTRAINT normalized_author_field_entry_pkey PRIMARY KEY (id);


--
-- Name: normalized_keyword_field_entry normalized_keyword_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.normalized_keyword_field_entry
    ADD CONSTRAINT normalized_keyword_field_entry_pkey PRIMARY KEY (id);


--
-- Name: normalized_series_field_entry normalized_series_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.normalized_series_field_entry
    ADD CONSTRAINT normalized_series_field_entry_pkey PRIMARY KEY (id);


--
-- Name: normalized_subject_field_entry normalized_subject_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.normalized_subject_field_entry
    ADD CONSTRAINT normalized_subject_field_entry_pkey PRIMARY KEY (id);


--
-- Name: normalized_title_field_entry normalized_title_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.normalized_title_field_entry
    ADD CONSTRAINT normalized_title_field_entry_pkey PRIMARY KEY (id);


--
-- Name: real_full_rec real_full_rec_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.real_full_rec
    ADD CONSTRAINT real_full_rec_pkey PRIMARY KEY (id);


--
-- Name: record_attr_vector_list record_attr_vector_list_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.record_attr_vector_list
    ADD CONSTRAINT record_attr_vector_list_pkey PRIMARY KEY (source);


--
-- Name: record_sorter record_sorter_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.record_sorter
    ADD CONSTRAINT record_sorter_pkey PRIMARY KEY (id);


--
-- Name: series_field_entry series_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.series_field_entry
    ADD CONSTRAINT series_field_entry_pkey PRIMARY KEY (id);


--
-- Name: subject_field_entry subject_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.subject_field_entry
    ADD CONSTRAINT subject_field_entry_pkey PRIMARY KEY (id);


--
-- Name: title_field_entry title_field_entry_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.title_field_entry
    ADD CONSTRAINT title_field_entry_pkey PRIMARY KEY (id);


--
-- Name: uncontrolled_record_attr_value uncontrolled_record_attr_value_pkey; Type: CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.uncontrolled_record_attr_value
    ADD CONSTRAINT uncontrolled_record_attr_value_pkey PRIMARY KEY (id);


--
-- Name: account_adjustment account_adjustment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.account_adjustment
    ADD CONSTRAINT account_adjustment_pkey PRIMARY KEY (id);


--
-- Name: aged_billing aged_billing_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.aged_billing
    ADD CONSTRAINT aged_billing_pkey PRIMARY KEY (id);


--
-- Name: aged_payment aged_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.aged_payment
    ADD CONSTRAINT aged_payment_pkey PRIMARY KEY (id);


--
-- Name: billable_xact billable_xact_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.billable_xact
    ADD CONSTRAINT billable_xact_pkey PRIMARY KEY (id);


--
-- Name: billing billing_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.billing
    ADD CONSTRAINT billing_pkey PRIMARY KEY (id);


--
-- Name: bnm_desk_payment bnm_desk_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.bnm_desk_payment
    ADD CONSTRAINT bnm_desk_payment_pkey PRIMARY KEY (id);


--
-- Name: bnm_payment bnm_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.bnm_payment
    ADD CONSTRAINT bnm_payment_pkey PRIMARY KEY (id);


--
-- Name: cash_payment cash_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.cash_payment
    ADD CONSTRAINT cash_payment_pkey PRIMARY KEY (id);


--
-- Name: check_payment check_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.check_payment
    ADD CONSTRAINT check_payment_pkey PRIMARY KEY (id);


--
-- Name: collections_tracker collections_tracker_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.collections_tracker
    ADD CONSTRAINT collections_tracker_pkey PRIMARY KEY (id);


--
-- Name: credit_card_payment credit_card_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.credit_card_payment
    ADD CONSTRAINT credit_card_payment_pkey PRIMARY KEY (id);


--
-- Name: credit_payment credit_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.credit_payment
    ADD CONSTRAINT credit_payment_pkey PRIMARY KEY (id);


--
-- Name: debit_card_payment debit_card_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.debit_card_payment
    ADD CONSTRAINT debit_card_payment_pkey PRIMARY KEY (id);


--
-- Name: forgive_payment forgive_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.forgive_payment
    ADD CONSTRAINT forgive_payment_pkey PRIMARY KEY (id);


--
-- Name: goods_payment goods_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.goods_payment
    ADD CONSTRAINT goods_payment_pkey PRIMARY KEY (id);


--
-- Name: grocery grocery_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.grocery
    ADD CONSTRAINT grocery_pkey PRIMARY KEY (id);


--
-- Name: materialized_billable_xact_summary materialized_billable_xact_summary_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.materialized_billable_xact_summary
    ADD CONSTRAINT materialized_billable_xact_summary_pkey PRIMARY KEY (id);


--
-- Name: payment payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.payment
    ADD CONSTRAINT payment_pkey PRIMARY KEY (id);


--
-- Name: refund_action refund_action_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refund_action
    ADD CONSTRAINT refund_action_pkey PRIMARY KEY (id);


--
-- Name: refund_session refund_session_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refund_session
    ADD CONSTRAINT refund_session_pkey PRIMARY KEY (id);


--
-- Name: refundable_payment refundable_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refundable_payment
    ADD CONSTRAINT refundable_payment_pkey PRIMARY KEY (id);


--
-- Name: refundable_xact refundable_xact_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refundable_xact
    ADD CONSTRAINT refundable_xact_pkey PRIMARY KEY (id);


--
-- Name: work_payment work_payment_pkey; Type: CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.work_payment
    ADD CONSTRAINT work_payment_pkey PRIMARY KEY (id);


--
-- Name: script script_pkey; Type: CONSTRAINT; Schema: offline; Owner: evergreen
--

ALTER TABLE ONLY offline.script
    ADD CONSTRAINT script_pkey PRIMARY KEY (id);


--
-- Name: session session_pkey; Type: CONSTRAINT; Schema: offline; Owner: evergreen
--

ALTER TABLE ONLY offline.session
    ADD CONSTRAINT session_pkey PRIMARY KEY (key);


--
-- Name: grp_penalty_threshold grp_penalty_threshold_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_pkey PRIMARY KEY (id);


--
-- Name: grp_perm_map grp_perm_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_perm_map
    ADD CONSTRAINT grp_perm_map_pkey PRIMARY KEY (id);


--
-- Name: grp_tree_display_entry grp_tree_display_entry_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_tree_display_entry
    ADD CONSTRAINT grp_tree_display_entry_pkey PRIMARY KEY (id);


--
-- Name: grp_tree grp_tree_name_key; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_tree
    ADD CONSTRAINT grp_tree_name_key UNIQUE (name);


--
-- Name: grp_tree grp_tree_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_tree
    ADD CONSTRAINT grp_tree_pkey PRIMARY KEY (id);


--
-- Name: grp_penalty_threshold penalty_grp_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_penalty_threshold
    ADD CONSTRAINT penalty_grp_once UNIQUE (grp, penalty, org_unit);


--
-- Name: grp_perm_map perm_grp_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_perm_map
    ADD CONSTRAINT perm_grp_once UNIQUE (grp, perm);


--
-- Name: perm_list perm_list_code_key; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.perm_list
    ADD CONSTRAINT perm_list_code_key UNIQUE (code);


--
-- Name: perm_list perm_list_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.perm_list
    ADD CONSTRAINT perm_list_pkey PRIMARY KEY (id);


--
-- Name: usr_object_perm_map perm_usr_obj_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_object_perm_map
    ADD CONSTRAINT perm_usr_obj_once UNIQUE (usr, perm, object_type, object_id);


--
-- Name: usr_perm_map perm_usr_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_perm_map
    ADD CONSTRAINT perm_usr_once UNIQUE (usr, perm);


--
-- Name: grp_tree_display_entry pgtde_once_per_org; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_tree_display_entry
    ADD CONSTRAINT pgtde_once_per_org UNIQUE (org, grp);


--
-- Name: usr_grp_map usr_grp_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_grp_map
    ADD CONSTRAINT usr_grp_map_pkey PRIMARY KEY (id);


--
-- Name: usr_grp_map usr_grp_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_grp_map
    ADD CONSTRAINT usr_grp_once UNIQUE (usr, grp);


--
-- Name: usr_object_perm_map usr_object_perm_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_object_perm_map
    ADD CONSTRAINT usr_object_perm_map_pkey PRIMARY KEY (id);


--
-- Name: usr_perm_map usr_perm_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_perm_map
    ADD CONSTRAINT usr_perm_map_pkey PRIMARY KEY (id);


--
-- Name: usr_work_ou_map usr_work_ou_map_pkey; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_map_pkey PRIMARY KEY (id);


--
-- Name: usr_work_ou_map usr_work_ou_once; Type: CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_once UNIQUE (usr, work_ou);


--
-- Name: usr_address address_pk; Type: CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.usr_address
    ADD CONSTRAINT address_pk PRIMARY KEY (id);


--
-- Name: card card_pkey; Type: CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.card
    ADD CONSTRAINT card_pkey PRIMARY KEY (id);


--
-- Name: usr usr_pkey; Type: CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.usr
    ADD CONSTRAINT usr_pkey PRIMARY KEY (id);


--
-- Name: bind_variable bind_variable_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.bind_variable
    ADD CONSTRAINT bind_variable_pkey PRIMARY KEY (name);


--
-- Name: case_branch case_branch_parent_seq; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.case_branch
    ADD CONSTRAINT case_branch_parent_seq UNIQUE (parent_expr, seq_no);


--
-- Name: case_branch case_branch_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.case_branch
    ADD CONSTRAINT case_branch_pkey PRIMARY KEY (id);


--
-- Name: record_column column_sequence; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.record_column
    ADD CONSTRAINT column_sequence UNIQUE (from_relation, seq_no);


--
-- Name: datatype datatype_datatype_name_key; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.datatype
    ADD CONSTRAINT datatype_datatype_name_key UNIQUE (datatype_name);


--
-- Name: datatype datatype_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.datatype
    ADD CONSTRAINT datatype_pkey PRIMARY KEY (id);


--
-- Name: expression expression_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.expression
    ADD CONSTRAINT expression_pkey PRIMARY KEY (id);


--
-- Name: from_relation from_relation_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.from_relation
    ADD CONSTRAINT from_relation_pkey PRIMARY KEY (id);


--
-- Name: function_param_def function_param_def_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.function_param_def
    ADD CONSTRAINT function_param_def_pkey PRIMARY KEY (id);


--
-- Name: function_sig function_sig_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.function_sig
    ADD CONSTRAINT function_sig_pkey PRIMARY KEY (id);


--
-- Name: order_by_item order_by_item_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.order_by_item
    ADD CONSTRAINT order_by_item_pkey PRIMARY KEY (id);


--
-- Name: order_by_item order_by_sequence; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.order_by_item
    ADD CONSTRAINT order_by_sequence UNIQUE (stored_query, seq_no);


--
-- Name: function_param_def qfpd_function_param_seq; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.function_param_def
    ADD CONSTRAINT qfpd_function_param_seq UNIQUE (function_id, seq_no);


--
-- Name: subfield qsf_datatype_seq_no; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.subfield
    ADD CONSTRAINT qsf_datatype_seq_no UNIQUE (composite_type, seq_no);


--
-- Name: query_sequence query_query_seq; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.query_sequence
    ADD CONSTRAINT query_query_seq UNIQUE (parent_query, seq_no);


--
-- Name: query_sequence query_sequence_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.query_sequence
    ADD CONSTRAINT query_sequence_pkey PRIMARY KEY (id);


--
-- Name: record_column record_column_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.record_column
    ADD CONSTRAINT record_column_pkey PRIMARY KEY (id);


--
-- Name: select_item select_item_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.select_item
    ADD CONSTRAINT select_item_pkey PRIMARY KEY (id);


--
-- Name: select_item select_sequence; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.select_item
    ADD CONSTRAINT select_sequence UNIQUE (stored_query, seq_no);


--
-- Name: stored_query stored_query_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.stored_query
    ADD CONSTRAINT stored_query_pkey PRIMARY KEY (id);


--
-- Name: subfield subfield_pkey; Type: CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.subfield
    ADD CONSTRAINT subfield_pkey PRIMARY KEY (id);


--
-- Name: badge badge_pkey; Type: CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.badge
    ADD CONSTRAINT badge_pkey PRIMARY KEY (id);


--
-- Name: popularity_parameter popularity_parameter_name_key; Type: CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.popularity_parameter
    ADD CONSTRAINT popularity_parameter_name_key UNIQUE (name);


--
-- Name: popularity_parameter popularity_parameter_pkey; Type: CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.popularity_parameter
    ADD CONSTRAINT popularity_parameter_pkey PRIMARY KEY (id);


--
-- Name: record_badge_score record_badge_score_pkey; Type: CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.record_badge_score
    ADD CONSTRAINT record_badge_score_pkey PRIMARY KEY (id);


--
-- Name: badge unique_name_scope; Type: CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.badge
    ADD CONSTRAINT unique_name_scope UNIQUE (name, scope);


--
-- Name: record_badge_score unique_record_badge; Type: CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.record_badge_score
    ADD CONSTRAINT unique_record_badge UNIQUE (record, badge);


--
-- Name: materialized_simple_record materialized_simple_record_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.materialized_simple_record
    ADD CONSTRAINT materialized_simple_record_pkey PRIMARY KEY (id);


--
-- Name: output_folder output_folder_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.output_folder
    ADD CONSTRAINT output_folder_pkey PRIMARY KEY (id);


--
-- Name: report_folder report_folder_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.report_folder
    ADD CONSTRAINT report_folder_pkey PRIMARY KEY (id);


--
-- Name: report report_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.report
    ADD CONSTRAINT report_pkey PRIMARY KEY (id);


--
-- Name: hold_request_record reporter_hold_request_record_pkey_idx; Type: CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.hold_request_record
    ADD CONSTRAINT reporter_hold_request_record_pkey_idx PRIMARY KEY (id);


--
-- Name: schedule schedule_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.schedule
    ADD CONSTRAINT schedule_pkey PRIMARY KEY (id);


--
-- Name: template_folder template_folder_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.template_folder
    ADD CONSTRAINT template_folder_pkey PRIMARY KEY (id);


--
-- Name: template template_pkey; Type: CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.template
    ADD CONSTRAINT template_pkey PRIMARY KEY (id);


--
-- Name: relevance_adjustment relevance_adjustment_pkey; Type: CONSTRAINT; Schema: search; Owner: evergreen
--

ALTER TABLE ONLY search.relevance_adjustment
    ADD CONSTRAINT relevance_adjustment_pkey PRIMARY KEY (id);


--
-- Name: symspell_dictionary symspell_dictionary_pkey; Type: CONSTRAINT; Schema: search; Owner: evergreen
--

ALTER TABLE ONLY search.symspell_dictionary
    ADD CONSTRAINT symspell_dictionary_pkey PRIMARY KEY (prefix_key);


--
-- Name: basic_summary bib_summary_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.basic_summary
    ADD CONSTRAINT bib_summary_pkey PRIMARY KEY (id);


--
-- Name: caption_and_pattern caption_and_pattern_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.caption_and_pattern
    ADD CONSTRAINT caption_and_pattern_pkey PRIMARY KEY (id);


--
-- Name: distribution_note distribution_note_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution_note
    ADD CONSTRAINT distribution_note_pkey PRIMARY KEY (id);


--
-- Name: distribution distribution_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution
    ADD CONSTRAINT distribution_pkey PRIMARY KEY (id);


--
-- Name: index_summary index_summary_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.index_summary
    ADD CONSTRAINT index_summary_pkey PRIMARY KEY (id);


--
-- Name: issuance issuance_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.issuance
    ADD CONSTRAINT issuance_pkey PRIMARY KEY (id);


--
-- Name: item_note item_note_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item_note
    ADD CONSTRAINT item_note_pkey PRIMARY KEY (id);


--
-- Name: item item_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item
    ADD CONSTRAINT item_pkey PRIMARY KEY (id);


--
-- Name: materialized_holding_code materialized_holding_code_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.materialized_holding_code
    ADD CONSTRAINT materialized_holding_code_pkey PRIMARY KEY (id);


--
-- Name: routing_list_user one_pos_per_routing_list; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.routing_list_user
    ADD CONSTRAINT one_pos_per_routing_list UNIQUE (stream, pos);


--
-- Name: pattern_template pattern_template_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.pattern_template
    ADD CONSTRAINT pattern_template_pkey PRIMARY KEY (id);


--
-- Name: record_entry record_entry_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.record_entry
    ADD CONSTRAINT record_entry_pkey PRIMARY KEY (id);


--
-- Name: routing_list_user routing_list_user_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.routing_list_user
    ADD CONSTRAINT routing_list_user_pkey PRIMARY KEY (id);


--
-- Name: stream stream_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.stream
    ADD CONSTRAINT stream_pkey PRIMARY KEY (id);


--
-- Name: subscription_note subscription_note_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.subscription_note
    ADD CONSTRAINT subscription_note_pkey PRIMARY KEY (id);


--
-- Name: subscription subscription_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.subscription
    ADD CONSTRAINT subscription_pkey PRIMARY KEY (id);


--
-- Name: supplement_summary sup_summary_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.supplement_summary
    ADD CONSTRAINT sup_summary_pkey PRIMARY KEY (id);


--
-- Name: unit unit_pkey; Type: CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit
    ADD CONSTRAINT unit_pkey PRIMARY KEY (id);


--
-- Name: account account_pkey; Type: CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.account
    ADD CONSTRAINT account_pkey PRIMARY KEY (id);


--
-- Name: account account_sip_username_key; Type: CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.account
    ADD CONSTRAINT account_sip_username_key UNIQUE (sip_username);


--
-- Name: setting name_once_per_inst; Type: CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.setting
    ADD CONSTRAINT name_once_per_inst UNIQUE (setting_group, name);


--
-- Name: screen_message screen_message_pkey; Type: CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.screen_message
    ADD CONSTRAINT screen_message_pkey PRIMARY KEY (key);


--
-- Name: session session_ils_token_key; Type: CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.session
    ADD CONSTRAINT session_ils_token_key UNIQUE (ils_token);


--
-- Name: session session_pkey; Type: CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.session
    ADD CONSTRAINT session_pkey PRIMARY KEY (key);


--
-- Name: setting_group setting_group_label_key; Type: CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.setting_group
    ADD CONSTRAINT setting_group_label_key UNIQUE (label);


--
-- Name: setting_group setting_group_pkey; Type: CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.setting_group
    ADD CONSTRAINT setting_group_pkey PRIMARY KEY (id);


--
-- Name: setting setting_pkey; Type: CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.setting
    ADD CONSTRAINT setting_pkey PRIMARY KEY (id);



--
-- Name: billing_address_stage billing_address_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.billing_address_stage
    ADD CONSTRAINT billing_address_stage_pkey PRIMARY KEY (row_id);


--
-- Name: card_stage card_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.card_stage
    ADD CONSTRAINT card_stage_pkey PRIMARY KEY (row_id);


--
-- Name: mailing_address_stage mailing_address_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.mailing_address_stage
    ADD CONSTRAINT mailing_address_stage_pkey PRIMARY KEY (row_id);


--
-- Name: setting_stage setting_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.setting_stage
    ADD CONSTRAINT setting_stage_pkey PRIMARY KEY (row_id);


--
-- Name: statcat_stage statcat_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.statcat_stage
    ADD CONSTRAINT statcat_stage_pkey PRIMARY KEY (row_id);


--
-- Name: user_stage user_stage_pkey; Type: CONSTRAINT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.user_stage
    ADD CONSTRAINT user_stage_pkey PRIMARY KEY (row_id);


--
-- Name: bre_output_layout bre_output_layout_pkey; Type: CONSTRAINT; Schema: unapi; Owner: evergreen
--

ALTER TABLE ONLY unapi.bre_output_layout
    ADD CONSTRAINT bre_output_layout_pkey PRIMARY KEY (name);


--
-- Name: session session_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.session
    ADD CONSTRAINT session_pkey PRIMARY KEY (id);


--
-- Name: url_selector tag_once_per_sess; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url_selector
    ADD CONSTRAINT tag_once_per_sess UNIQUE (xpath, session);


--
-- Name: url url_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url
    ADD CONSTRAINT url_pkey PRIMARY KEY (id);


--
-- Name: url_selector url_selector_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url_selector
    ADD CONSTRAINT url_selector_pkey PRIMARY KEY (id);


--
-- Name: url_verification url_verification_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url_verification
    ADD CONSTRAINT url_verification_pkey PRIMARY KEY (id);


--
-- Name: session uvs_name_once_per_lib; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.session
    ADD CONSTRAINT uvs_name_once_per_lib UNIQUE (name, owning_lib);


--
-- Name: verification_attempt verification_attempt_pkey; Type: CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.verification_attempt
    ADD CONSTRAINT verification_attempt_pkey PRIMARY KEY (id);


--
-- Name: authority_attr_definition authority_attr_definition_code_key; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.authority_attr_definition
    ADD CONSTRAINT authority_attr_definition_code_key UNIQUE (code);


--
-- Name: authority_attr_definition authority_attr_definition_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.authority_attr_definition
    ADD CONSTRAINT authority_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: authority_match authority_match_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.authority_match
    ADD CONSTRAINT authority_match_pkey PRIMARY KEY (id);


--
-- Name: authority_queue authority_queue_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.authority_queue
    ADD CONSTRAINT authority_queue_pkey PRIMARY KEY (id);


--
-- Name: bib_attr_definition bib_attr_definition_code_key; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_attr_definition
    ADD CONSTRAINT bib_attr_definition_code_key UNIQUE (code);


--
-- Name: bib_attr_definition bib_attr_definition_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_attr_definition
    ADD CONSTRAINT bib_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: bib_match bib_match_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_match
    ADD CONSTRAINT bib_match_pkey PRIMARY KEY (id);


--
-- Name: bib_queue bib_queue_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_queue
    ADD CONSTRAINT bib_queue_pkey PRIMARY KEY (id);


--
-- Name: import_bib_trash_fields import_bib_trash_fields_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_bib_trash_fields
    ADD CONSTRAINT import_bib_trash_fields_pkey PRIMARY KEY (id);


--
-- Name: import_bib_trash_group import_bib_trash_group_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_bib_trash_group
    ADD CONSTRAINT import_bib_trash_group_pkey PRIMARY KEY (id);


--
-- Name: import_error import_error_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_error
    ADD CONSTRAINT import_error_pkey PRIMARY KEY (code);


--
-- Name: import_item_attr_definition import_item_attr_definition_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_item_attr_definition
    ADD CONSTRAINT import_item_attr_definition_pkey PRIMARY KEY (id);


--
-- Name: import_item import_item_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_item
    ADD CONSTRAINT import_item_pkey PRIMARY KEY (id);


--
-- Name: match_set match_set_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set
    ADD CONSTRAINT match_set_pkey PRIMARY KEY (id);


--
-- Name: match_set_point match_set_point_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set_point
    ADD CONSTRAINT match_set_point_pkey PRIMARY KEY (id);


--
-- Name: match_set_quality match_set_quality_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set_quality
    ADD CONSTRAINT match_set_quality_pkey PRIMARY KEY (id);


--
-- Name: merge_profile merge_profile_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.merge_profile
    ADD CONSTRAINT merge_profile_pkey PRIMARY KEY (id);


--
-- Name: match_set name_once_per_owner_mtype; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set
    ADD CONSTRAINT name_once_per_owner_mtype UNIQUE (name, owner, mtype);


--
-- Name: queue queue_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queue
    ADD CONSTRAINT queue_pkey PRIMARY KEY (id);


--
-- Name: queued_authority_record_attr queued_authority_record_attr_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record_attr
    ADD CONSTRAINT queued_authority_record_attr_pkey PRIMARY KEY (id);


--
-- Name: queued_authority_record queued_authority_record_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record
    ADD CONSTRAINT queued_authority_record_pkey PRIMARY KEY (id);


--
-- Name: queued_bib_record_attr queued_bib_record_attr_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record_attr
    ADD CONSTRAINT queued_bib_record_attr_pkey PRIMARY KEY (id);


--
-- Name: queued_bib_record queued_bib_record_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record
    ADD CONSTRAINT queued_bib_record_pkey PRIMARY KEY (id);


--
-- Name: queued_record queued_record_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_record
    ADD CONSTRAINT queued_record_pkey PRIMARY KEY (id);


--
-- Name: session_tracker session_tracker_pkey; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.session_tracker
    ADD CONSTRAINT session_tracker_pkey PRIMARY KEY (id);


--
-- Name: authority_queue vand_authority_queue_name_once_per_owner_const; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.authority_queue
    ADD CONSTRAINT vand_authority_queue_name_once_per_owner_const UNIQUE (owner, name, queue_type);


--
-- Name: bib_queue vand_bib_queue_name_once_per_owner_const; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_queue
    ADD CONSTRAINT vand_bib_queue_name_once_per_owner_const UNIQUE (owner, name, queue_type);


--
-- Name: import_bib_trash_fields vand_import_bib_trash_fields_once_per; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_bib_trash_fields
    ADD CONSTRAINT vand_import_bib_trash_fields_once_per UNIQUE (grp, field);


--
-- Name: import_bib_trash_group vand_import_bib_trash_grp_owner_label; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_bib_trash_group
    ADD CONSTRAINT vand_import_bib_trash_grp_owner_label UNIQUE (owner, label);


--
-- Name: import_item_attr_definition vand_import_item_attr_def_idx; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_item_attr_definition
    ADD CONSTRAINT vand_import_item_attr_def_idx UNIQUE (owner, name);


--
-- Name: merge_profile vand_merge_prof_owner_name_idx; Type: CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.merge_profile
    ADD CONSTRAINT vand_merge_prof_owner_name_idx UNIQUE (owner, name);


--
-- Name: account_status_remote_file_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX account_status_remote_file_idx ON acq.edi_message USING btree (account, status, remote_file);


--
-- Name: acq_asn_container_code_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_asn_container_code_idx ON acq.shipment_notification USING btree (container_code);


--
-- Name: acq_attribution_credit_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_attribution_credit_idx ON acq.debit_attribution USING btree (funding_source_credit);


--
-- Name: acq_attribution_debit_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_attribution_debit_idx ON acq.debit_attribution USING btree (fund_debit);


--
-- Name: acq_lineitem_hist_id_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_lineitem_hist_id_idx ON acq.acq_lineitem_history USING btree (id);


--
-- Name: acq_lineitem_history_queued_record_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_lineitem_history_queued_record_idx ON acq.acq_lineitem_history USING btree (queued_record);


--
-- Name: acq_lineitem_marc_attr_definition_sortkey_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_lineitem_marc_attr_definition_sortkey_idx ON acq.lineitem_marc_attr_definition USING btree (description_sortkey);


--
-- Name: acq_picklist_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_picklist_creator_idx ON acq.picklist USING btree (creator);


--
-- Name: acq_picklist_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_picklist_editor_idx ON acq.picklist USING btree (editor);


--
-- Name: acq_picklist_owner_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_picklist_owner_idx ON acq.picklist USING btree (owner);


--
-- Name: acq_po_hist_id_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_po_hist_id_idx ON acq.acq_purchase_order_history USING btree (id);


--
-- Name: acq_po_note_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_po_note_creator_idx ON acq.po_note USING btree (creator);


--
-- Name: acq_po_note_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_po_note_editor_idx ON acq.po_note USING btree (editor);


--
-- Name: acq_po_org_name_order_date_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_po_org_name_order_date_idx ON acq.purchase_order USING btree (ordering_agency, name, order_date);


--
-- Name: acq_pro_note_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_pro_note_creator_idx ON acq.provider_note USING btree (creator);


--
-- Name: acq_pro_note_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_pro_note_editor_idx ON acq.provider_note USING btree (editor);


--
-- Name: acq_pro_note_pro_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acq_pro_note_pro_idx ON acq.provider_note USING btree (provider);


--
-- Name: acqdfa_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acqdfa_creator_idx ON acq.distribution_formula_application USING btree (creator);


--
-- Name: acqdfa_df_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acqdfa_df_idx ON acq.distribution_formula_application USING btree (formula);


--
-- Name: acqdfa_li_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acqdfa_li_idx ON acq.distribution_formula_application USING btree (lineitem);


--
-- Name: acqftr_usr_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX acqftr_usr_idx ON acq.fund_transfer USING btree (transfer_user);


--
-- Name: claim_event_claim_date_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX claim_event_claim_date_idx ON acq.claim_event USING btree (claim, event_date);


--
-- Name: claim_lid_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX claim_lid_idx ON acq.claim USING btree (lineitem_detail);


--
-- Name: edi_message_remote_file_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX edi_message_remote_file_idx ON acq.edi_message USING btree (evergreen.lowercase(remote_file));


--
-- Name: fund_alloc_allocator_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX fund_alloc_allocator_idx ON acq.fund_allocation USING btree (allocator);


--
-- Name: fund_debit_invoice_entry_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX fund_debit_invoice_entry_idx ON acq.fund_debit USING btree (invoice_entry);


--
-- Name: ii_fund_debit_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX ii_fund_debit_idx ON acq.invoice_item USING btree (fund_debit);


--
-- Name: li_attr_definition_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_attr_definition_idx ON acq.lineitem_attr USING btree (definition);


--
-- Name: li_attr_li_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_attr_li_idx ON acq.lineitem_attr USING btree (lineitem);


--
-- Name: li_attr_value_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_attr_value_idx ON acq.lineitem_attr USING btree (attr_value);


--
-- Name: li_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_creator_idx ON acq.lineitem USING btree (creator);


--
-- Name: li_detail_li_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_detail_li_idx ON acq.lineitem_detail USING btree (lineitem);


--
-- Name: li_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_editor_idx ON acq.lineitem USING btree (editor);


--
-- Name: li_note_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_note_creator_idx ON acq.lineitem_note USING btree (creator);


--
-- Name: li_note_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_note_editor_idx ON acq.lineitem_note USING btree (editor);


--
-- Name: li_note_li_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_note_li_idx ON acq.lineitem_note USING btree (lineitem);


--
-- Name: li_pl_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_pl_idx ON acq.lineitem USING btree (picklist);


--
-- Name: li_po_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_po_idx ON acq.lineitem USING btree (purchase_order);


--
-- Name: li_queued_record_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_queued_record_idx ON acq.lineitem USING btree (queued_record);


--
-- Name: li_selector_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_selector_idx ON acq.lineitem USING btree (selector);


--
-- Name: li_usr_attr_def_usr_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX li_usr_attr_def_usr_idx ON acq.lineitem_usr_attr_definition USING btree (usr);


--
-- Name: lineitem_detail_fund_debit_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX lineitem_detail_fund_debit_idx ON acq.lineitem_detail USING btree (fund_debit);


--
-- Name: lineitem_queued_record_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX lineitem_queued_record_idx ON acq.lineitem USING btree (queued_record);


--
-- Name: po_creator_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX po_creator_idx ON acq.purchase_order USING btree (creator);


--
-- Name: po_editor_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX po_editor_idx ON acq.purchase_order USING btree (editor);


--
-- Name: po_note_po_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX po_note_po_idx ON acq.po_note USING btree (purchase_order);


--
-- Name: po_owner_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX po_owner_idx ON acq.purchase_order USING btree (owner);


--
-- Name: po_provider_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX po_provider_idx ON acq.purchase_order USING btree (provider);


--
-- Name: po_state_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX po_state_idx ON acq.purchase_order USING btree (state);


--
-- Name: poi_fund_debit_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX poi_fund_debit_idx ON acq.po_item USING btree (fund_debit);


--
-- Name: serial_claim_event_claim_date_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX serial_claim_event_claim_date_idx ON acq.serial_claim_event USING btree (claim, event_date);


--
-- Name: serial_claim_lid_idx; Type: INDEX; Schema: acq; Owner: evergreen
--

CREATE INDEX serial_claim_lid_idx ON acq.serial_claim USING btree (item);


--
-- Name: acm_copy_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX acm_copy_idx ON action.hold_copy_map USING btree (target_copy);


--
-- Name: action_aged_circulation_parent_circ_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX action_aged_circulation_parent_circ_idx ON action.aged_circulation USING btree (parent_circ);


--
-- Name: action_fieldset_sched_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX action_fieldset_sched_time_idx ON action.fieldset USING btree (scheduled_time);


--
-- Name: action_in_house_use_staff_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX action_in_house_use_staff_idx ON action.in_house_use USING btree (staff);


--
-- Name: action_in_house_use_ws_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX action_in_house_use_ws_idx ON action.in_house_use USING btree (workstation);


--
-- Name: action_non_cat_circ_patron_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX action_non_cat_circ_patron_idx ON action.non_cataloged_circulation USING btree (patron);


--
-- Name: action_non_cat_circ_staff_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX action_non_cat_circ_staff_idx ON action.non_cataloged_circulation USING btree (staff);


--
-- Name: action_owner_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX action_owner_idx ON action.fieldset USING btree (owner);


--
-- Name: action_survey_response_usr_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX action_survey_response_usr_idx ON action.survey_response USING btree (usr);


--
-- Name: action_usr_circ_history_source_circ_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX action_usr_circ_history_source_circ_idx ON action.usr_circ_history USING btree (source_circ);


--
-- Name: action_usr_circ_history_usr_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX action_usr_circ_history_usr_idx ON action.usr_circ_history USING btree (usr);


--
-- Name: active_hold_transit_cp_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX active_hold_transit_cp_idx ON action.hold_transit_copy USING btree (target_copy);


--
-- Name: active_hold_transit_dest_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX active_hold_transit_dest_idx ON action.hold_transit_copy USING btree (dest);


--
-- Name: active_hold_transit_hold_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX active_hold_transit_hold_idx ON action.hold_transit_copy USING btree (hold);


--
-- Name: active_hold_transit_source_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX active_hold_transit_source_idx ON action.hold_transit_copy USING btree (source);


--
-- Name: active_reservation_transit_cp_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX active_reservation_transit_cp_idx ON action.reservation_transit_copy USING btree (target_copy);


--
-- Name: active_reservation_transit_dest_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX active_reservation_transit_dest_idx ON action.reservation_transit_copy USING btree (dest);


--
-- Name: active_reservation_transit_source_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX active_reservation_transit_source_idx ON action.reservation_transit_copy USING btree (source);


--
-- Name: active_transit_cp_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX active_transit_cp_idx ON action.transit_copy USING btree (target_copy);


--
-- Name: active_transit_dest_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX active_transit_dest_idx ON action.transit_copy USING btree (dest);


--
-- Name: active_transit_for_copy; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX active_transit_for_copy ON action.transit_copy USING btree (target_copy) WHERE ((dest_recv_time IS NULL) AND (cancel_time IS NULL));


--
-- Name: active_transit_source_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX active_transit_source_idx ON action.transit_copy USING btree (source);


--
-- Name: aged_circ_circ_lib_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX aged_circ_circ_lib_idx ON action.aged_circulation USING btree (circ_lib);


--
-- Name: aged_circ_copy_circ_lib_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX aged_circ_copy_circ_lib_idx ON action.aged_circulation USING btree (copy_circ_lib);


--
-- Name: aged_circ_copy_location_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX aged_circ_copy_location_idx ON action.aged_circulation USING btree (copy_location);


--
-- Name: aged_circ_copy_owning_lib_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX aged_circ_copy_owning_lib_idx ON action.aged_circulation USING btree (copy_owning_lib);


--
-- Name: aged_circ_id_target_copy; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX aged_circ_id_target_copy ON action.aged_circulation USING btree (id, target_copy);


--
-- Name: aged_circ_start_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX aged_circ_start_idx ON action.aged_circulation USING btree (xact_start);


--
-- Name: aged_circ_target_copy_xact_start_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX aged_circ_target_copy_xact_start_idx ON action.aged_circulation USING btree (target_copy, xact_start);


--
-- Name: aged_hold_request_current_copy_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX aged_hold_request_current_copy_idx ON action.aged_hold_request USING btree (current_copy);


--
-- Name: aged_hold_request_fulfillment_staff_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX aged_hold_request_fulfillment_staff_idx ON action.aged_hold_request USING btree (fulfillment_staff);


--
-- Name: aged_hold_request_pickup_lib_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX aged_hold_request_pickup_lib_idx ON action.aged_hold_request USING btree (pickup_lib);


--
-- Name: aged_hold_request_target_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX aged_hold_request_target_idx ON action.aged_hold_request USING btree (target);


--
-- Name: ahn_hold_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX ahn_hold_idx ON action.hold_notification USING btree (hold);


--
-- Name: ahn_notify_staff_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX ahn_notify_staff_idx ON action.hold_notification USING btree (notify_staff);


--
-- Name: ahr_target_and_type_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX ahr_target_and_type_idx ON action.hold_request USING btree (target, hold_type, id);


--
-- Name: ahrn_hold_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX ahrn_hold_idx ON action.hold_request_note USING btree (hold);


--
-- Name: archived_hold_request_2005_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX archived_hold_request_2005_request_time_idx ON action.archived_hold_request_2005 USING btree (request_time);


--
-- Name: archived_hold_request_2006_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX archived_hold_request_2006_request_time_idx ON action.archived_hold_request_2006 USING btree (request_time);


--
-- Name: archived_hold_request_2007_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX archived_hold_request_2007_request_time_idx ON action.archived_hold_request_2007 USING btree (request_time);


--
-- Name: archived_hold_request_2008_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX archived_hold_request_2008_request_time_idx ON action.archived_hold_request_2008 USING btree (request_time);


--
-- Name: archived_hold_request_2009_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX archived_hold_request_2009_request_time_idx ON action.archived_hold_request_2009 USING btree (request_time);


--
-- Name: archived_hold_request_2010_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX archived_hold_request_2010_request_time_idx ON action.archived_hold_request_2010 USING btree (request_time);


--
-- Name: archived_hold_request_2011_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX archived_hold_request_2011_request_time_idx ON action.archived_hold_request_2011 USING btree (request_time);


--
-- Name: archived_hold_request_2012_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX archived_hold_request_2012_request_time_idx ON action.archived_hold_request_2012 USING btree (request_time);


--
-- Name: archived_hold_request_2013_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX archived_hold_request_2013_request_time_idx ON action.archived_hold_request_2013 USING btree (request_time);


--
-- Name: asv_once_per_owner_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE UNIQUE INDEX asv_once_per_owner_idx ON action.survey USING btree (owner, name);


--
-- Name: cancel_fulfill_target_type_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX cancel_fulfill_target_type_idx ON action.hold_request USING btree (target, hold_type) WHERE ((cancel_time IS NULL) AND (fulfillment_time IS NULL));


--
-- Name: circ_all_usr_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_all_usr_idx ON action.circulation USING btree (usr);


--
-- Name: circ_checkin_staff_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_checkin_staff_idx ON action.circulation USING btree (checkin_staff);


--
-- Name: circ_checkin_time; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_checkin_time ON action.circulation USING btree (checkin_time) WHERE (checkin_time IS NOT NULL);


--
-- Name: circ_circ_lib_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_circ_lib_idx ON action.circulation USING btree (circ_lib);


--
-- Name: circ_circ_staff_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_circ_staff_idx ON action.circulation USING btree (circ_staff);


--
-- Name: circ_open_date_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_open_date_idx ON action.circulation USING btree (xact_start) WHERE (xact_finish IS NULL);


--
-- Name: circ_open_xacts_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_open_xacts_idx ON action.circulation USING btree (usr) WHERE (xact_finish IS NULL);


--
-- Name: circ_outstanding_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_outstanding_idx ON action.circulation USING btree (usr) WHERE (checkin_time IS NULL);


--
-- Name: circ_parent_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE UNIQUE INDEX circ_parent_idx ON action.circulation USING btree (parent_circ) WHERE (parent_circ IS NOT NULL);


--
-- Name: circ_start_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_start_idx ON action.circulation USING btree (((timezone('us/pacific'::text, xact_start))::date));


--
-- Name: circ_target_copy_id_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_target_copy_id_idx ON action.circulation USING btree (target_copy, id);


--
-- Name: circ_target_copy_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_target_copy_idx ON action.circulation USING btree (target_copy);


--
-- Name: circ_target_copy_xact_start_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_target_copy_xact_start_idx ON action.circulation USING btree (target_copy, xact_start);


--
-- Name: circ_xact_finish_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX circ_xact_finish_idx ON action.circulation USING btree (xact_finish);


--
-- Name: emergency_closing_circulation_circulation_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX emergency_closing_circulation_circulation_idx ON action.emergency_closing_circulation USING btree (circulation);


--
-- Name: emergency_closing_circulation_emergency_closing_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX emergency_closing_circulation_emergency_closing_idx ON action.emergency_closing_circulation USING btree (emergency_closing);


--
-- Name: emergency_closing_hold_emergency_closing_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX emergency_closing_hold_emergency_closing_idx ON action.emergency_closing_hold USING btree (emergency_closing);


--
-- Name: emergency_closing_hold_hold_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX emergency_closing_hold_hold_idx ON action.emergency_closing_hold USING btree (hold);


--
-- Name: emergency_closing_reservation_emergency_closing_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX emergency_closing_reservation_emergency_closing_idx ON action.emergency_closing_reservation USING btree (emergency_closing);


--
-- Name: emergency_closing_reservation_reservation_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX emergency_closing_reservation_reservation_idx ON action.emergency_closing_reservation USING btree (reservation);


--
-- Name: hold_fulfillment_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX hold_fulfillment_time_idx ON action.hold_request USING btree (fulfillment_time) WHERE (fulfillment_time IS NOT NULL);


--
-- Name: hold_request_capture_protect_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE UNIQUE INDEX hold_request_capture_protect_idx ON action.hold_request USING btree (current_copy) WHERE ((current_copy IS NOT NULL) AND (capture_time IS NOT NULL) AND (cancel_time IS NULL) AND (fulfillment_time IS NULL));


--
-- Name: hold_request_copy_capture_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX hold_request_copy_capture_time_idx ON action.hold_request USING btree (current_copy, capture_time);


--
-- Name: hold_request_current_copy_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX hold_request_current_copy_idx ON action.hold_request USING btree (current_copy);


--
-- Name: hold_request_fulfillment_staff_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX hold_request_fulfillment_staff_idx ON action.hold_request USING btree (fulfillment_staff);


--
-- Name: hold_request_open_captured_shelf_lib_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX hold_request_open_captured_shelf_lib_idx ON action.hold_request USING btree (current_shelf_lib) WHERE ((capture_time IS NOT NULL) AND (fulfillment_time IS NULL) AND (pickup_lib <> current_shelf_lib));


--
-- Name: hold_request_pickup_lib_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX hold_request_pickup_lib_idx ON action.hold_request USING btree (pickup_lib);


--
-- Name: hold_request_prev_check_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX hold_request_prev_check_time_idx ON action.hold_request USING btree (prev_check_time);


--
-- Name: hold_request_requestor_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX hold_request_requestor_idx ON action.hold_request USING btree (requestor);


--
-- Name: hold_request_target_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX hold_request_target_idx ON action.hold_request USING btree (target);


--
-- Name: hold_request_time_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX hold_request_time_idx ON action.hold_request USING btree (request_time);


--
-- Name: hold_request_usr_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX hold_request_usr_idx ON action.hold_request USING btree (usr);


--
-- Name: non_cat_in_house_use_staff_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX non_cat_in_house_use_staff_idx ON action.non_cat_in_house_use USING btree (staff);


--
-- Name: non_cat_in_house_use_ws_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX non_cat_in_house_use_ws_idx ON action.non_cat_in_house_use USING btree (workstation);


--
-- Name: only_one_concurrent_checkout_per_copy; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE UNIQUE INDEX only_one_concurrent_checkout_per_copy ON action.circulation USING btree (target_copy) WHERE (checkin_time IS NULL);


--
-- Name: uhr_hold_idx; Type: INDEX; Schema: action; Owner: evergreen
--

CREATE INDEX uhr_hold_idx ON action.unfulfilled_hold_list USING btree (hold);


--
-- Name: action_trigger_event_async_output_idx; Type: INDEX; Schema: action_trigger; Owner: evergreen
--

CREATE INDEX action_trigger_event_async_output_idx ON action_trigger.event USING btree (async_output);


--
-- Name: action_trigger_event_error_output_idx; Type: INDEX; Schema: action_trigger; Owner: evergreen
--

CREATE INDEX action_trigger_event_error_output_idx ON action_trigger.event USING btree (error_output);


--
-- Name: action_trigger_event_template_output_idx; Type: INDEX; Schema: action_trigger; Owner: evergreen
--

CREATE INDEX action_trigger_event_template_output_idx ON action_trigger.event USING btree (template_output);


--
-- Name: atev_context_item; Type: INDEX; Schema: action_trigger; Owner: evergreen
--

CREATE INDEX atev_context_item ON action_trigger.event USING btree (context_item);


--
-- Name: atev_context_library; Type: INDEX; Schema: action_trigger; Owner: evergreen
--

CREATE INDEX atev_context_library ON action_trigger.event USING btree (context_library);


--
-- Name: atev_context_user; Type: INDEX; Schema: action_trigger; Owner: evergreen
--

CREATE INDEX atev_context_user ON action_trigger.event USING btree (context_user);


--
-- Name: atev_def_state_update_time_idx; Type: INDEX; Schema: action_trigger; Owner: evergreen
--

CREATE INDEX atev_def_state_update_time_idx ON action_trigger.event USING btree (event_def, state, update_time);


--
-- Name: atev_target_def_idx; Type: INDEX; Schema: action_trigger; Owner: evergreen
--

CREATE INDEX atev_target_def_idx ON action_trigger.event USING btree (target, event_def);


--
-- Name: actor_card_barcode_evergreen_lowercase_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_card_barcode_evergreen_lowercase_idx ON actor.card USING btree (evergreen.lowercase(barcode));


--
-- Name: actor_card_barcode_lower_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_card_barcode_lower_idx ON actor.card USING btree (lower(barcode));


--
-- Name: actor_card_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_card_usr_idx ON actor.card USING btree (usr);


--
-- Name: actor_org_address_org_unit_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_org_address_org_unit_idx ON actor.org_address USING btree (org_unit);


--
-- Name: actor_org_unit_billing_address_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_org_unit_billing_address_idx ON actor.org_unit USING btree (billing_address);


--
-- Name: actor_org_unit_holds_address_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_org_unit_holds_address_idx ON actor.org_unit USING btree (holds_address);


--
-- Name: actor_org_unit_ill_address_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_org_unit_ill_address_idx ON actor.org_unit USING btree (ill_address);


--
-- Name: actor_org_unit_mailing_address_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_org_unit_mailing_address_idx ON actor.org_unit USING btree (mailing_address);


--
-- Name: actor_org_unit_ou_type_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_org_unit_ou_type_idx ON actor.org_unit USING btree (ou_type);


--
-- Name: actor_org_unit_parent_ou_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_org_unit_parent_ou_idx ON actor.org_unit USING btree (parent_ou);


--
-- Name: actor_org_unit_setting_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_org_unit_setting_usr_idx ON actor.org_unit_setting USING btree (org_unit);


--
-- Name: actor_org_unit_type_parent_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_org_unit_type_parent_idx ON actor.org_unit_type USING btree (parent);


--
-- Name: actor_stat_cat_entry_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_stat_cat_entry_usr_idx ON actor.stat_cat_entry_usr_map USING btree (target_usr);


--
-- Name: actor_usr_addr_city_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_addr_city_idx ON actor.usr_address USING btree (evergreen.lowercase(city));


--
-- Name: actor_usr_addr_post_code_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_addr_post_code_idx ON actor.usr_address USING btree (evergreen.lowercase(post_code));


--
-- Name: actor_usr_addr_state_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_addr_state_idx ON actor.usr_address USING btree (evergreen.lowercase(state));


--
-- Name: actor_usr_addr_street1_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_addr_street1_idx ON actor.usr_address USING btree (evergreen.lowercase(street1));


--
-- Name: actor_usr_addr_street2_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_addr_street2_idx ON actor.usr_address USING btree (evergreen.lowercase(street2));


--
-- Name: actor_usr_addr_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_addr_usr_idx ON actor.usr_address USING btree (usr);


--
-- Name: actor_usr_billing_address_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_billing_address_idx ON actor.usr USING btree (billing_address);


--
-- Name: actor_usr_day_phone_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_day_phone_idx ON actor.usr USING btree (evergreen.lowercase(day_phone));


--
-- Name: actor_usr_day_phone_idx_numeric; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_day_phone_idx_numeric ON actor.usr USING btree (evergreen.lowercase(regexp_replace(day_phone, '[^0-9]'::text, ''::text, 'g'::text)));


--
-- Name: actor_usr_day_phone_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_day_phone_tpo_idx ON actor.usr USING btree (evergreen.lowercase(day_phone) text_pattern_ops);


--
-- Name: actor_usr_email_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_email_idx ON actor.usr USING btree (evergreen.lowercase(email));


--
-- Name: actor_usr_email_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_email_tpo_idx ON actor.usr USING btree (evergreen.lowercase(email) text_pattern_ops);


--
-- Name: actor_usr_evening_phone_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_evening_phone_idx ON actor.usr USING btree (evergreen.lowercase(evening_phone));


--
-- Name: actor_usr_evening_phone_idx_numeric; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_evening_phone_idx_numeric ON actor.usr USING btree (evergreen.lowercase(regexp_replace(evening_phone, '[^0-9]'::text, ''::text, 'g'::text)));


--
-- Name: actor_usr_evening_phone_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_evening_phone_tpo_idx ON actor.usr USING btree (evergreen.lowercase(evening_phone) text_pattern_ops);


--
-- Name: actor_usr_family_name_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_family_name_idx ON actor.usr USING btree (evergreen.lowercase(family_name));


--
-- Name: actor_usr_family_name_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_family_name_tpo_idx ON actor.usr USING btree (evergreen.lowercase(family_name) text_pattern_ops);


--
-- Name: actor_usr_family_name_unaccent_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_family_name_unaccent_idx ON actor.usr USING btree (evergreen.unaccent_and_squash(family_name));


--
-- Name: actor_usr_first_given_name_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_first_given_name_idx ON actor.usr USING btree (evergreen.lowercase(first_given_name));


--
-- Name: actor_usr_first_given_name_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_first_given_name_tpo_idx ON actor.usr USING btree (evergreen.lowercase(first_given_name) text_pattern_ops);


--
-- Name: actor_usr_first_given_name_unaccent_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_first_given_name_unaccent_idx ON actor.usr USING btree (evergreen.unaccent_and_squash(first_given_name));


--
-- Name: actor_usr_guardian_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_guardian_idx ON actor.usr USING btree (evergreen.lowercase(guardian));


--
-- Name: actor_usr_guardian_unaccent_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_guardian_unaccent_idx ON actor.usr USING btree (evergreen.unaccent_and_squash(guardian));


--
-- Name: actor_usr_home_ou_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_home_ou_idx ON actor.usr USING btree (home_ou);


--
-- Name: actor_usr_ident_value2_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_ident_value2_idx ON actor.usr USING btree (evergreen.lowercase(ident_value2));


--
-- Name: actor_usr_ident_value2_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_ident_value2_tpo_idx ON actor.usr USING btree (evergreen.lowercase(ident_value2) text_pattern_ops);


--
-- Name: actor_usr_ident_value_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_ident_value_idx ON actor.usr USING btree (evergreen.lowercase(ident_value));


--
-- Name: actor_usr_ident_value_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_ident_value_tpo_idx ON actor.usr USING btree (evergreen.lowercase(ident_value) text_pattern_ops);


--
-- Name: actor_usr_mailing_address_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_mailing_address_idx ON actor.usr USING btree (mailing_address);


--
-- Name: actor_usr_other_phone_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_other_phone_idx ON actor.usr USING btree (evergreen.lowercase(other_phone));


--
-- Name: actor_usr_other_phone_idx_numeric; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_other_phone_idx_numeric ON actor.usr USING btree (evergreen.lowercase(regexp_replace(other_phone, '[^0-9]'::text, ''::text, 'g'::text)));


--
-- Name: actor_usr_other_phone_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_other_phone_tpo_idx ON actor.usr USING btree (evergreen.lowercase(other_phone) text_pattern_ops);


--
-- Name: actor_usr_password_reset_has_been_reset_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_password_reset_has_been_reset_idx ON actor.usr_password_reset USING btree (has_been_reset);


--
-- Name: actor_usr_password_reset_request_time_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_password_reset_request_time_idx ON actor.usr_password_reset USING btree (request_time);


--
-- Name: actor_usr_password_reset_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_password_reset_usr_idx ON actor.usr_password_reset USING btree (usr);


--
-- Name: actor_usr_password_reset_uuid_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE UNIQUE INDEX actor_usr_password_reset_uuid_idx ON actor.usr_password_reset USING btree (uuid);


--
-- Name: actor_usr_pref_family_name_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_pref_family_name_idx ON actor.usr USING btree (evergreen.lowercase(pref_family_name));


--
-- Name: actor_usr_pref_family_name_unaccent_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_pref_family_name_unaccent_idx ON actor.usr USING btree (evergreen.unaccent_and_squash(pref_family_name));


--
-- Name: actor_usr_pref_first_given_name_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_pref_first_given_name_idx ON actor.usr USING btree (evergreen.lowercase(pref_first_given_name));


--
-- Name: actor_usr_pref_first_given_name_unaccent_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_pref_first_given_name_unaccent_idx ON actor.usr USING btree (evergreen.unaccent_and_squash(pref_first_given_name));


--
-- Name: actor_usr_pref_second_given_name_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_pref_second_given_name_idx ON actor.usr USING btree (evergreen.lowercase(pref_second_given_name));


--
-- Name: actor_usr_pref_second_given_name_unaccent_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_pref_second_given_name_unaccent_idx ON actor.usr USING btree (evergreen.unaccent_and_squash(pref_second_given_name));


--
-- Name: actor_usr_privacy_waiver_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_privacy_waiver_usr_idx ON actor.usr_privacy_waiver USING btree (usr);


--
-- Name: actor_usr_second_given_name_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_second_given_name_idx ON actor.usr USING btree (evergreen.lowercase(second_given_name));


--
-- Name: actor_usr_second_given_name_tpo_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_second_given_name_tpo_idx ON actor.usr USING btree (evergreen.lowercase(second_given_name) text_pattern_ops);


--
-- Name: actor_usr_second_given_name_unaccent_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_second_given_name_unaccent_idx ON actor.usr USING btree (evergreen.unaccent_and_squash(second_given_name));


--
-- Name: actor_usr_setting_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_setting_usr_idx ON actor.usr_setting USING btree (usr);


--
-- Name: actor_usr_standing_penalty_staff_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_standing_penalty_staff_idx ON actor.usr_standing_penalty USING btree (staff);


--
-- Name: actor_usr_standing_penalty_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_standing_penalty_usr_idx ON actor.usr_standing_penalty USING btree (usr);


--
-- Name: actor_usr_usrgroup_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_usrgroup_idx ON actor.usr USING btree (usrgroup);


--
-- Name: actor_usr_usrname_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_usrname_idx ON actor.usr USING btree (evergreen.lowercase(usrname));


--
-- Name: actor_usr_usrname_unaccent_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_usr_usrname_unaccent_idx ON actor.usr USING btree (evergreen.unaccent_and_squash(usrname));


--
-- Name: actor_workstation_setting_workstation_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX actor_workstation_setting_workstation_idx ON actor.workstation_setting USING btree (workstation);


--
-- Name: aum_editor; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX aum_editor ON actor.usr_message USING btree (editor);


--
-- Name: aum_usr; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX aum_usr ON actor.usr_message USING btree (usr);


--
-- Name: from_prox_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX from_prox_idx ON actor.org_unit_proximity USING btree (from_org);


--
-- Name: label_once_per_org; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE UNIQUE INDEX label_once_per_org ON actor.toolbar USING btree (org, label) WHERE (org IS NOT NULL);


--
-- Name: label_once_per_usr; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE UNIQUE INDEX label_once_per_usr ON actor.toolbar USING btree (usr, label) WHERE (usr IS NOT NULL);


--
-- Name: label_once_per_ws; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE UNIQUE INDEX label_once_per_ws ON actor.toolbar USING btree (ws, label) WHERE (ws IS NOT NULL);


--
-- Name: ou_lasso_lasso_ou_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE UNIQUE INDEX ou_lasso_lasso_ou_idx ON actor.org_lasso_map USING btree (lasso, org_unit);


--
-- Name: ou_lasso_org_unit_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX ou_lasso_org_unit_idx ON actor.org_lasso_map USING btree (org_unit);


--
-- Name: prox_adj_circ_lib_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX prox_adj_circ_lib_idx ON actor.org_unit_proximity_adjustment USING btree (item_circ_lib);


--
-- Name: prox_adj_circ_mod_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX prox_adj_circ_mod_idx ON actor.org_unit_proximity_adjustment USING btree (circ_mod);


--
-- Name: prox_adj_copy_location_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX prox_adj_copy_location_idx ON actor.org_unit_proximity_adjustment USING btree (copy_location);


--
-- Name: prox_adj_once_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE UNIQUE INDEX prox_adj_once_idx ON actor.org_unit_proximity_adjustment USING btree (COALESCE(item_circ_lib, '-1'::integer), COALESCE(item_owning_lib, '-1'::integer), COALESCE(copy_location, '-1'::integer), COALESCE(hold_pickup_lib, '-1'::integer), COALESCE(hold_request_lib, '-1'::integer), COALESCE(circ_mod, ''::text), pos);


--
-- Name: prox_adj_owning_lib_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX prox_adj_owning_lib_idx ON actor.org_unit_proximity_adjustment USING btree (item_owning_lib);


--
-- Name: prox_adj_pickup_lib_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX prox_adj_pickup_lib_idx ON actor.org_unit_proximity_adjustment USING btree (hold_pickup_lib);


--
-- Name: prox_adj_request_lib_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX prox_adj_request_lib_idx ON actor.org_unit_proximity_adjustment USING btree (hold_request_lib);


--
-- Name: user_activity_usr_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX user_activity_usr_idx ON actor.usr_activity USING btree (usr);


--
-- Name: usr_org_unit_opt_in_staff_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX usr_org_unit_opt_in_staff_idx ON actor.usr_org_unit_opt_in USING btree (staff);


--
-- Name: usr_standing_penalty_usr_message_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX usr_standing_penalty_usr_message_idx ON actor.usr_standing_penalty USING btree (usr_message);


--
-- Name: xxxx_usr_message_for_private_notes_orig_id_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX xxxx_usr_message_for_private_notes_orig_id_idx ON actor.xxxx_usr_message_for_private_notes USING btree (orig_id);


--
-- Name: xxxx_usr_message_for_unmatched_public_notes_orig_id_idx; Type: INDEX; Schema: actor; Owner: evergreen
--

CREATE INDEX xxxx_usr_message_for_unmatched_public_notes_orig_id_idx ON actor.xxxx_usr_message_for_unmatched_public_notes USING btree (orig_id);


--
-- Name: acl_name_once_per_lib; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE UNIQUE INDEX acl_name_once_per_lib ON asset.copy_location USING btree (name, owning_lib) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: acn_edit_date_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX acn_edit_date_idx ON asset.call_number USING btree (edit_date);


--
-- Name: asset_call_number_creator_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_call_number_creator_idx ON asset.call_number USING btree (creator);


--
-- Name: asset_call_number_dewey_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_call_number_dewey_idx ON asset.call_number USING btree (public.call_number_dewey(label));


--
-- Name: asset_call_number_editor_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_call_number_editor_idx ON asset.call_number USING btree (editor);


--
-- Name: asset_call_number_label_once_per_lib; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE UNIQUE INDEX asset_call_number_label_once_per_lib ON asset.call_number USING btree (record, owning_lib, label, prefix, suffix) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: asset_call_number_label_sortkey; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_call_number_label_sortkey ON asset.call_number USING btree (evergreen.oils_text_as_bytea(label_sortkey));


--
-- Name: asset_call_number_label_sortkey_browse; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_call_number_label_sortkey_browse ON asset.call_number USING btree (evergreen.oils_text_as_bytea(label_sortkey), evergreen.oils_text_as_bytea(label), id, owning_lib) WHERE ((deleted IS FALSE) OR (deleted = false));


--
-- Name: asset_call_number_note_creator_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_call_number_note_creator_idx ON asset.call_number_note USING btree (creator);


--
-- Name: asset_call_number_prefix_once_per_lib; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE UNIQUE INDEX asset_call_number_prefix_once_per_lib ON asset.call_number_prefix USING btree (label, owning_lib);


--
-- Name: asset_call_number_prefix_sortkey_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_call_number_prefix_sortkey_idx ON asset.call_number_prefix USING btree (label_sortkey);


--
-- Name: asset_call_number_record_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_call_number_record_idx ON asset.call_number USING btree (record);


--
-- Name: asset_call_number_suffix_once_per_lib; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE UNIQUE INDEX asset_call_number_suffix_once_per_lib ON asset.call_number_suffix USING btree (label, owning_lib);


--
-- Name: asset_call_number_suffix_sortkey_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_call_number_suffix_sortkey_idx ON asset.call_number_suffix USING btree (label_sortkey);


--
-- Name: asset_call_number_upper_label_id_owning_lib_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_call_number_upper_label_id_owning_lib_idx ON asset.call_number USING btree (evergreen.oils_text_as_bytea(label), id, owning_lib);


--
-- Name: asset_copy_inventory_date_once_per_copy; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE UNIQUE INDEX asset_copy_inventory_date_once_per_copy ON asset.copy_inventory USING btree (inventory_date, copy);


--
-- Name: asset_copy_note_creator_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_copy_note_creator_idx ON asset.copy_note USING btree (creator);


--
-- Name: asset_copy_note_owning_copy_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_copy_note_owning_copy_idx ON asset.copy_note USING btree (owning_copy);


--
-- Name: asset_copy_tag_copy_map_copy_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_copy_tag_copy_map_copy_idx ON asset.copy_tag_copy_map USING btree (copy);


--
-- Name: asset_copy_tag_copy_map_tag_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_copy_tag_copy_map_tag_idx ON asset.copy_tag_copy_map USING btree (tag);


--
-- Name: asset_copy_tag_index_vector_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_copy_tag_index_vector_idx ON asset.copy_tag USING gin (index_vector);


--
-- Name: asset_copy_tag_label_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_copy_tag_label_idx ON asset.copy_tag USING btree (label);


--
-- Name: asset_copy_tag_label_lower_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_copy_tag_label_lower_idx ON asset.copy_tag USING btree (evergreen.lowercase(label));


--
-- Name: asset_copy_tag_owner_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_copy_tag_owner_idx ON asset.copy_tag USING btree (owner);


--
-- Name: asset_copy_tag_tag_type_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_copy_tag_tag_type_idx ON asset.copy_tag USING btree (tag_type);


--
-- Name: asset_uri_call_number_map_cn_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX asset_uri_call_number_map_cn_idx ON asset.uri_call_number_map USING btree (call_number);


--
-- Name: call_number_label_sortkey_owning_lib_not_deleted_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX call_number_label_sortkey_owning_lib_not_deleted_idx ON asset.call_number USING btree (owning_lib, evergreen.oils_text_as_bytea(label_sortkey)) WHERE (deleted = false);


--
-- Name: cn_record_not_deleted; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX cn_record_not_deleted ON asset.call_number USING btree (record) WHERE (deleted = false);


--
-- Name: copy_barcode_key; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE UNIQUE INDEX copy_barcode_key ON asset.copy USING btree (barcode) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: copy_circ_lib_status; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX copy_circ_lib_status ON asset.copy USING btree (circ_lib, status);


--
-- Name: copy_inventory_copy_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX copy_inventory_copy_idx ON asset.copy_inventory USING btree (copy);


--
-- Name: copy_part_map_cp_part_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE UNIQUE INDEX copy_part_map_cp_part_idx ON asset.copy_part_map USING btree (target_copy, part);


--
-- Name: copy_vis_attr_cache_copy_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX copy_vis_attr_cache_copy_idx ON asset.copy_vis_attr_cache USING btree (target_copy);


--
-- Name: copy_vis_attr_cache_record_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX copy_vis_attr_cache_record_idx ON asset.copy_vis_attr_cache USING btree (record);


--
-- Name: cp_avail_cn_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX cp_avail_cn_idx ON asset.copy USING btree (call_number);


--
-- Name: cp_cn_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX cp_cn_idx ON asset.copy USING btree (call_number);


--
-- Name: cp_cn_index_not_deleted; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX cp_cn_index_not_deleted ON asset.copy USING btree (call_number) WHERE (deleted = false);


--
-- Name: cp_create_date; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX cp_create_date ON asset.copy USING btree (create_date);


--
-- Name: cp_creator_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX cp_creator_idx ON asset.copy USING btree (creator);


--
-- Name: cp_edit_date; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX cp_edit_date ON asset.copy USING btree (edit_date);


--
-- Name: cp_editor_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX cp_editor_idx ON asset.copy USING btree (editor);


--
-- Name: scecm_owning_copy_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX scecm_owning_copy_idx ON asset.stat_cat_entry_copy_map USING btree (owning_copy);


--
-- Name: tmp_ac_status_idx; Type: INDEX; Schema: asset; Owner: evergreen
--

CREATE INDEX tmp_ac_status_idx ON asset.copy USING btree (status);


--
-- Name: aud_actor_usr_address_hist_id_idx; Type: INDEX; Schema: auditor; Owner: evergreen
--

CREATE INDEX aud_actor_usr_address_hist_id_idx ON auditor.actor_usr_address_history USING btree (id);


--
-- Name: aud_actor_usr_hist_id_idx; Type: INDEX; Schema: auditor; Owner: evergreen
--

CREATE INDEX aud_actor_usr_hist_id_idx ON auditor.actor_usr_history USING btree (id);


--
-- Name: aud_asset_cn_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: evergreen
--

CREATE INDEX aud_asset_cn_hist_creator_idx ON auditor.asset_call_number_history USING btree (creator);


--
-- Name: aud_asset_cn_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: evergreen
--

CREATE INDEX aud_asset_cn_hist_editor_idx ON auditor.asset_call_number_history USING btree (editor);


--
-- Name: aud_asset_cp_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: evergreen
--

CREATE INDEX aud_asset_cp_hist_creator_idx ON auditor.asset_copy_history USING btree (creator);


--
-- Name: aud_asset_cp_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: evergreen
--

CREATE INDEX aud_asset_cp_hist_editor_idx ON auditor.asset_copy_history USING btree (editor);


--
-- Name: aud_bib_rec_entry_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: evergreen
--

CREATE INDEX aud_bib_rec_entry_hist_creator_idx ON auditor.biblio_record_entry_history USING btree (creator);


--
-- Name: aud_bib_rec_entry_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: evergreen
--

CREATE INDEX aud_bib_rec_entry_hist_editor_idx ON auditor.biblio_record_entry_history USING btree (editor);


--
-- Name: aud_serial_unit_hist_creator_idx; Type: INDEX; Schema: auditor; Owner: evergreen
--

CREATE INDEX aud_serial_unit_hist_creator_idx ON auditor.serial_unit_history USING btree (creator);


--
-- Name: aud_serial_unit_hist_editor_idx; Type: INDEX; Schema: auditor; Owner: evergreen
--

CREATE INDEX aud_serial_unit_hist_editor_idx ON auditor.serial_unit_history USING btree (editor);


--
-- Name: authority_bl_bib_authority_once_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE UNIQUE INDEX authority_bl_bib_authority_once_idx ON authority.bib_linking USING btree (authority, bib);


--
-- Name: authority_bl_bib_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_bl_bib_idx ON authority.bib_linking USING btree (bib);


--
-- Name: authority_full_rec_index_vector_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_full_rec_index_vector_idx ON authority.full_rec USING gin (index_vector);


--
-- Name: authority_full_rec_record_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_full_rec_record_idx ON authority.full_rec USING btree (record);


--
-- Name: authority_full_rec_sort_value_index; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_full_rec_sort_value_index ON authority.full_rec USING btree (sort_value);


--
-- Name: authority_full_rec_subfield_a_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_full_rec_subfield_a_idx ON authority.full_rec USING btree (value) WHERE (subfield = 'a'::text);


--
-- Name: authority_full_rec_tag_part_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_full_rec_tag_part_idx ON authority.full_rec USING btree ("substring"((tag)::text, 2));


--
-- Name: authority_full_rec_tag_subfield_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_full_rec_tag_subfield_idx ON authority.full_rec USING btree (tag, subfield);


--
-- Name: authority_full_rec_value_index; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_full_rec_value_index ON authority.full_rec USING btree ("substring"(value, 1, 1024));


--
-- Name: authority_full_rec_value_tpo_index; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_full_rec_value_tpo_index ON authority.full_rec USING btree ("substring"(value, 1, 1024) text_pattern_ops);


--
-- Name: authority_rec_descriptor_record_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_rec_descriptor_record_idx ON authority.rec_descriptor USING btree (record);


--
-- Name: authority_record_deleted_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_record_deleted_idx ON authority.record_entry USING btree (deleted) WHERE ((deleted IS FALSE) OR (deleted = false));


--
-- Name: authority_record_entry_create_date; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_record_entry_create_date ON authority.record_entry USING btree (create_date);


--
-- Name: authority_record_entry_create_date_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_record_entry_create_date_idx ON authority.record_entry USING btree (create_date);


--
-- Name: authority_record_entry_creator_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_record_entry_creator_idx ON authority.record_entry USING btree (creator);


--
-- Name: authority_record_entry_edit_date_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_record_entry_edit_date_idx ON authority.record_entry USING btree (edit_date);


--
-- Name: authority_record_entry_editor_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_record_entry_editor_idx ON authority.record_entry USING btree (editor);


--
-- Name: authority_record_note_creator_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_record_note_creator_idx ON authority.record_note USING btree (creator);


--
-- Name: authority_record_note_editor_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_record_note_editor_idx ON authority.record_note USING btree (editor);


--
-- Name: authority_record_note_record_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_record_note_record_idx ON authority.record_note USING btree (record);


--
-- Name: authority_simple_heading_index_vector_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_simple_heading_index_vector_idx ON authority.simple_heading USING gin (index_vector);


--
-- Name: authority_simple_heading_record_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_simple_heading_record_idx ON authority.simple_heading USING btree (record);


--
-- Name: authority_simple_heading_sort_value_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_simple_heading_sort_value_idx ON authority.simple_heading USING btree (sort_value);


--
-- Name: authority_simple_heading_thesaurus_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_simple_heading_thesaurus_idx ON authority.simple_heading USING btree (thesaurus);


--
-- Name: authority_simple_heading_value_idx; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX authority_simple_heading_value_idx ON authority.simple_heading USING btree (value);


--
-- Name: by_heading; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX by_heading ON authority.record_entry USING btree (simple_heading) WHERE ((deleted IS FALSE) OR (deleted = false));


--
-- Name: by_heading_and_thesaurus; Type: INDEX; Schema: authority; Owner: evergreen
--

CREATE INDEX by_heading_and_thesaurus ON authority.record_entry USING btree (heading) WHERE ((deleted IS FALSE) OR (deleted = false));


--
-- Name: biblio_record_entry_create_date_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX biblio_record_entry_create_date_idx ON biblio.record_entry USING btree (create_date);


--
-- Name: biblio_record_entry_creator_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX biblio_record_entry_creator_idx ON biblio.record_entry USING btree (creator);


--
-- Name: biblio_record_entry_edit_date_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX biblio_record_entry_edit_date_idx ON biblio.record_entry USING btree (edit_date);


--
-- Name: biblio_record_entry_editor_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX biblio_record_entry_editor_idx ON biblio.record_entry USING btree (editor);


--
-- Name: biblio_record_entry_fp_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX biblio_record_entry_fp_idx ON biblio.record_entry USING btree (fingerprint);


--
-- Name: biblio_record_note_creator_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX biblio_record_note_creator_idx ON biblio.record_note USING btree (creator);


--
-- Name: biblio_record_note_editor_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX biblio_record_note_editor_idx ON biblio.record_note USING btree (editor);


--
-- Name: biblio_record_note_record_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX biblio_record_note_record_idx ON biblio.record_note USING btree (record);


--
-- Name: biblio_record_unique_tcn; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE UNIQUE INDEX biblio_record_unique_tcn ON biblio.record_entry USING btree (tcn_value) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: bre_merge_date_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX bre_merge_date_idx ON biblio.record_entry USING btree (merge_date);


--
-- Name: by_cataloging_date_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX by_cataloging_date_idx ON biblio.record_entry USING btree (cataloging_date) WHERE ((deleted IS FALSE) OR (deleted = false));


--
-- Name: peer_bib_copy_map_copy_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX peer_bib_copy_map_copy_idx ON biblio.peer_bib_copy_map USING btree (target_copy);


--
-- Name: peer_bib_copy_map_record_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE INDEX peer_bib_copy_map_record_idx ON biblio.peer_bib_copy_map USING btree (peer_record);


--
-- Name: record_label_unique_idx; Type: INDEX; Schema: biblio; Owner: evergreen
--

CREATE UNIQUE INDEX record_label_unique_idx ON biblio.monograph_part USING btree (record, label) WHERE (deleted = false);


--
-- Name: ccmm_once_per_paramset; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE UNIQUE INDEX ccmm_once_per_paramset ON config.circ_matrix_matchpoint USING btree (org_unit, grp, COALESCE(circ_modifier, ''::text), COALESCE((copy_location)::text, ''::text), COALESCE(marc_type, ''::text), COALESCE(marc_form, ''::text), COALESCE(marc_bib_level, ''::text), COALESCE(marc_vr_format, ''::text), COALESCE((copy_circ_lib)::text, ''::text), COALESCE((copy_owning_lib)::text, ''::text), COALESCE((user_home_ou)::text, ''::text), COALESCE((ref_flag)::text, ''::text), COALESCE((juvenile_flag)::text, ''::text), COALESCE((is_renewal)::text, ''::text), COALESCE((usr_age_lower_bound)::text, ''::text), COALESCE((usr_age_upper_bound)::text, ''::text), COALESCE((item_age)::text, ''::text)) WHERE active;


--
-- Name: chmm_once_per_paramset; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE UNIQUE INDEX chmm_once_per_paramset ON config.hold_matrix_matchpoint USING btree (COALESCE((user_home_ou)::text, ''::text), COALESCE((request_ou)::text, ''::text), COALESCE((pickup_ou)::text, ''::text), COALESCE((item_owning_ou)::text, ''::text), COALESCE((item_circ_ou)::text, ''::text), COALESCE((usr_grp)::text, ''::text), COALESCE((requestor_grp)::text, ''::text), COALESCE(circ_modifier, ''::text), COALESCE(marc_type, ''::text), COALESCE(marc_form, ''::text), COALESCE(marc_bib_level, ''::text), COALESCE(marc_vr_format, ''::text), COALESCE((juvenile_flag)::text, ''::text), COALESCE((ref_flag)::text, ''::text), COALESCE((item_age)::text, ''::text)) WHERE active;


--
-- Name: config_coded_value_map_ctype_idx; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE INDEX config_coded_value_map_ctype_idx ON config.coded_value_map USING btree (ctype);


--
-- Name: config_copy_tag_type_owner_idx; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE INDEX config_copy_tag_type_owner_idx ON config.copy_tag_type USING btree (owner);


--
-- Name: config_marc_field_owner_idx; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE INDEX config_marc_field_owner_idx ON config.marc_field USING btree (owner);


--
-- Name: config_marc_field_tag_idx; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE INDEX config_marc_field_tag_idx ON config.marc_field USING btree (tag);


--
-- Name: config_marc_subfield_tag_code_idx; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE INDEX config_marc_subfield_tag_code_idx ON config.marc_subfield USING btree (tag, code);


--
-- Name: config_metabib_field_class_name_idx; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE UNIQUE INDEX config_metabib_field_class_name_idx ON config.metabib_field USING btree (field_class, name);


--
-- Name: config_standard_marc_subfields_are_unique; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE UNIQUE INDEX config_standard_marc_subfields_are_unique ON config.marc_subfield USING btree (marc_format, marc_record_type, tag, code) WHERE (owner IS NULL);


--
-- Name: config_standard_marc_tags_are_unique; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE UNIQUE INDEX config_standard_marc_tags_are_unique ON config.marc_field USING btree (marc_format, marc_record_type, tag) WHERE (owner IS NULL);


--
-- Name: cwa_one_active_per_ou; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE UNIQUE INDEX cwa_one_active_per_ou ON config.weight_assoc USING btree (org_unit) WHERE active;


--
-- Name: i18n_identity; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE UNIQUE INDEX i18n_identity ON config.i18n_core USING btree (fq_field, identity_value, translation);


--
-- Name: idl_field_doc_identity; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE UNIQUE INDEX idl_field_doc_identity ON config.idl_field_doc USING btree (fm_class, field, owner);


--
-- Name: unique_wwh; Type: INDEX; Schema: config; Owner: evergreen
--

CREATE UNIQUE INDEX unique_wwh ON config.usr_activity_type USING btree (COALESCE(ewho, ''::text), COALESCE(ewhat, ''::text), COALESCE(ehow, ''::text));


--
-- Name: copy_bucket_item_bucket_idx; Type: INDEX; Schema: container; Owner: evergreen
--

CREATE INDEX copy_bucket_item_bucket_idx ON container.copy_bucket_item USING btree (bucket);


--
-- Name: user_bucket_item_target_user_idx; Type: INDEX; Schema: container; Owner: evergreen
--

CREATE INDEX user_bucket_item_target_user_idx ON container.user_bucket_item USING btree (target_user);


--
-- Name: esi_phasefx16756_xacts_id; Type: INDEX; Schema: esi; Owner: evergreen
--

CREATE UNIQUE INDEX esi_phasefx16756_xacts_id ON esi.phasefx16756_xacts USING btree (id);


--
-- Name: fw_item_idx; Type: INDEX; Schema: esi_14812; Owner: evergreen
--

CREATE INDEX fw_item_idx ON esi_14812.fw_items USING btree (item_id);


--
-- Name: nw_item_idx; Type: INDEX; Schema: esi_14812; Owner: evergreen
--

CREATE INDEX nw_item_idx ON esi_14812.nw_items_changed USING btree (id);


--
-- Name: rn_dvd_idx; Type: INDEX; Schema: esi_14812; Owner: evergreen
--

CREATE INDEX rn_dvd_idx ON esi_14812.rn_dvds USING btree (id);


--
-- Name: rn_item_idx; Type: INDEX; Schema: esi_14812; Owner: evergreen
--

CREATE INDEX rn_item_idx ON esi_14812.rn_missing_items USING btree (item_id);


--
-- Name: m_enum_base_copy_location_lf1_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_base_copy_location_lf1_idx ON m_enum.base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_enum_base_copy_location_lf2_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_base_copy_location_lf2_idx ON m_enum.base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_enum_base_copy_location_lf3_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_base_copy_location_lf3_idx ON m_enum.base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_enum_base_copy_location_loc_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_base_copy_location_loc_idx ON m_enum.base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_enum_callnum_label_once_per_lib; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE UNIQUE INDEX m_enum_callnum_label_once_per_lib ON m_enum.asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_enum_callnum_record_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_callnum_record_idx ON m_enum.asset_call_number USING btree (record);


--
-- Name: m_enum_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_callnum_upper_label_id_lib_idx ON m_enum.asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_enum_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_circ_dynamic_lf1_idx ON m_enum.base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_enum_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_circ_dynamic_lf2_idx ON m_enum.base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_enum_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_circ_dynamic_lf3_idx ON m_enum.base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_enum_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_circ_dynamic_lf4_idx ON m_enum.base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_enum_copy_barcode_key; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE UNIQUE INDEX m_enum_copy_barcode_key ON m_enum.asset_copy USING btree (barcode);


--
-- Name: m_enum_copy_id_key; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE UNIQUE INDEX m_enum_copy_id_key ON m_enum.asset_copy USING btree (id);


--
-- Name: m_enum_home_location_lf1_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_home_location_lf1_idx ON m_enum.home_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_enum_home_location_lf2_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_home_location_lf2_idx ON m_enum.home_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_enum_home_location_lf3_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_home_location_lf3_idx ON m_enum.home_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_enum_home_location_loc_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_home_location_loc_idx ON m_enum.home_location_map USING btree (transcribed_location);


--
-- Name: m_enum_item_dynamic_lf1_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_item_dynamic_lf1_idx ON m_enum.base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_enum_item_dynamic_lf2_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_item_dynamic_lf2_idx ON m_enum.base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_enum_item_dynamic_lf3_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_item_dynamic_lf3_idx ON m_enum.base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_enum_item_key_barcode_map_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_item_key_barcode_map_idx ON m_enum.item_key_barcode_map USING btree (key1, key2, key3);


--
-- Name: m_enum_patron_barcode_key; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE UNIQUE INDEX m_enum_patron_barcode_key ON m_enum.actor_card USING btree (barcode);


--
-- Name: m_enum_patron_usrname_key; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE UNIQUE INDEX m_enum_patron_usrname_key ON m_enum.actor_usr USING btree (usrname);


--
-- Name: m_enum_unicorn_item_dynamic_lf1_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_unicorn_item_dynamic_lf1_idx ON m_enum.item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_enum_unicorn_item_dynamic_lf2_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_unicorn_item_dynamic_lf2_idx ON m_enum.item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_enum_unicorn_item_dynamic_lf3_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_unicorn_item_dynamic_lf3_idx ON m_enum.item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_enum_user_key_barcode_map_idx; Type: INDEX; Schema: m_enum; Owner: evergreen
--

CREATE INDEX m_enum_user_key_barcode_map_idx ON m_enum.user_key_barcode_map USING btree (key);


--
-- Name: m_test_base_copy_location_lf1_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_base_copy_location_lf1_idx ON m_test.base_copy_location_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_test_base_copy_location_lf2_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_base_copy_location_lf2_idx ON m_test.base_copy_location_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_test_base_copy_location_lf3_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_base_copy_location_lf3_idx ON m_test.base_copy_location_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_test_base_copy_location_loc_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_base_copy_location_loc_idx ON m_test.base_copy_location_map USING btree (transcribed_location);


--
-- Name: m_test_callnum_label_once_per_lib; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE UNIQUE INDEX m_test_callnum_label_once_per_lib ON m_test.asset_call_number USING btree (record, owning_lib, label);


--
-- Name: m_test_callnum_record_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_callnum_record_idx ON m_test.asset_call_number USING btree (record);


--
-- Name: m_test_callnum_upper_label_id_lib_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_callnum_upper_label_id_lib_idx ON m_test.asset_call_number USING btree (upper(label), id, owning_lib);


--
-- Name: m_test_circ_dynamic_lf1_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_circ_dynamic_lf1_idx ON m_test.base_circ_field_map USING btree (item_field1, item_value1);


--
-- Name: m_test_circ_dynamic_lf2_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_circ_dynamic_lf2_idx ON m_test.base_circ_field_map USING btree (item_field2, item_value2);


--
-- Name: m_test_circ_dynamic_lf3_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_circ_dynamic_lf3_idx ON m_test.base_circ_field_map USING btree (patron_field1, patron_value1);


--
-- Name: m_test_circ_dynamic_lf4_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_circ_dynamic_lf4_idx ON m_test.base_circ_field_map USING btree (patron_field2, patron_value2);


--
-- Name: m_test_copy_barcode_key; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE UNIQUE INDEX m_test_copy_barcode_key ON m_test.asset_copy USING btree (barcode);


--
-- Name: m_test_item_dynamic_lf1_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_item_dynamic_lf1_idx ON m_test.base_item_dynamic_field_map USING btree (legacy_field1, legacy_value1);


--
-- Name: m_test_item_dynamic_lf2_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_item_dynamic_lf2_idx ON m_test.base_item_dynamic_field_map USING btree (legacy_field2, legacy_value2);


--
-- Name: m_test_item_dynamic_lf3_idx; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE INDEX m_test_item_dynamic_lf3_idx ON m_test.base_item_dynamic_field_map USING btree (legacy_field3, legacy_value3);


--
-- Name: m_test_patron_barcode_key; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE UNIQUE INDEX m_test_patron_barcode_key ON m_test.actor_card USING btree (barcode);


--
-- Name: m_test_patron_usrname_key; Type: INDEX; Schema: m_test; Owner: evergreen
--

CREATE UNIQUE INDEX m_test_patron_usrname_key ON m_test.actor_usr USING btree (usrname);


--
-- Name: browse_entry_def_map_def_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX browse_entry_def_map_def_idx ON metabib.browse_entry_def_map USING btree (def);


--
-- Name: browse_entry_def_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX browse_entry_def_map_entry_idx ON metabib.browse_entry_def_map USING btree (entry);


--
-- Name: browse_entry_def_map_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX browse_entry_def_map_source_idx ON metabib.browse_entry_def_map USING btree (source);


--
-- Name: browse_entry_sh_map_entry_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX browse_entry_sh_map_entry_idx ON metabib.browse_entry_simple_heading_map USING btree (entry);


--
-- Name: browse_entry_sh_map_sh_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX browse_entry_sh_map_sh_idx ON metabib.browse_entry_simple_heading_map USING btree (simple_heading);


--
-- Name: browse_entry_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX browse_entry_sort_value_idx ON metabib.browse_entry USING btree (md5(sort_value));


--
-- Name: browse_entry_sort_value_value_key; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE UNIQUE INDEX browse_entry_sort_value_value_key ON metabib.browse_entry USING btree (md5((value || sort_value)));


--
-- Name: browse_entry_truncated_sort_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX browse_entry_truncated_sort_value_idx ON metabib.browse_entry USING btree (truncated_sort_value);


--
-- Name: browse_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX browse_entry_value_idx ON metabib.browse_entry USING btree (md5(value));


--
-- Name: fki_normalized_author_to_ author_field_entry_FK; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX "fki_normalized_author_to_ author_field_entry_FK" ON metabib.normalized_author_field_entry USING btree (id);


--
-- Name: fki_normalized_keyword_to_ keyword_field_entry_FK; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX "fki_normalized_keyword_to_ keyword_field_entry_FK" ON metabib.normalized_keyword_field_entry USING btree (id);


--
-- Name: fki_normalized_series_to_ series_field_entry_FK; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX "fki_normalized_series_to_ series_field_entry_FK" ON metabib.normalized_series_field_entry USING btree (id);


--
-- Name: fki_normalized_subject_to_ subject_field_entry_FK; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX "fki_normalized_subject_to_ subject_field_entry_FK" ON metabib.normalized_subject_field_entry USING btree (id);


--
-- Name: fki_normalized_title_to_ title_field_entry_FK; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX "fki_normalized_title_to_ title_field_entry_FK" ON metabib.normalized_title_field_entry USING btree (id);


--
-- Name: full_rec_isbn_tpo_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX full_rec_isbn_tpo_idx ON metabib.real_full_rec USING btree ("substring"(value, 1, 1024) text_pattern_ops) WHERE (tag = ANY (ARRAY['020'::bpchar, '024'::bpchar]));


--
-- Name: full_rec_url_tpo_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX full_rec_url_tpo_idx ON metabib.real_full_rec USING btree (value text_pattern_ops) WHERE ((tag = '856'::bpchar) AND (subfield = 'u'::text));


--
-- Name: metabib_author_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_author_field_entry_index_vector_idx ON metabib.author_field_entry USING gin (index_vector);


--
-- Name: metabib_author_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_author_field_entry_source_idx ON metabib.author_field_entry USING btree (source);


--
-- Name: metabib_author_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_author_field_entry_value_idx ON metabib.author_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_browse_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_browse_entry_index_vector_idx ON metabib.browse_entry USING gin (index_vector);


--
-- Name: metabib_call_number_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_call_number_field_entry_index_vector_idx ON metabib.call_number_field_entry USING gist (index_vector);


--
-- Name: metabib_call_number_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_call_number_field_entry_source_idx ON metabib.call_number_field_entry USING btree (source);


--
-- Name: metabib_call_number_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_call_number_field_entry_value_idx ON metabib.call_number_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_combined_author_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE UNIQUE INDEX metabib_combined_author_field_entry_fakepk_idx ON metabib.combined_author_field_entry USING btree (record, COALESCE((metabib_field)::text, ''::text));


--
-- Name: metabib_combined_author_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_author_field_entry_index_vector_idx ON metabib.combined_author_field_entry USING gin (index_vector);


--
-- Name: metabib_combined_author_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_author_field_source_idx ON metabib.combined_author_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_identifier_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE UNIQUE INDEX metabib_combined_identifier_field_entry_fakepk_idx ON metabib.combined_identifier_field_entry USING btree (record, COALESCE((metabib_field)::text, ''::text));


--
-- Name: metabib_combined_identifier_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_identifier_field_entry_index_vector_idx ON metabib.combined_identifier_field_entry USING gin (index_vector);


--
-- Name: metabib_combined_identifier_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_identifier_field_source_idx ON metabib.combined_identifier_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_keyword_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE UNIQUE INDEX metabib_combined_keyword_field_entry_fakepk_idx ON metabib.combined_keyword_field_entry USING btree (record, COALESCE((metabib_field)::text, ''::text));


--
-- Name: metabib_combined_keyword_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_keyword_field_entry_index_vector_idx ON metabib.combined_keyword_field_entry USING gin (index_vector);


--
-- Name: metabib_combined_keyword_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_keyword_field_source_idx ON metabib.combined_keyword_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_series_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE UNIQUE INDEX metabib_combined_series_field_entry_fakepk_idx ON metabib.combined_series_field_entry USING btree (record, COALESCE((metabib_field)::text, ''::text));


--
-- Name: metabib_combined_series_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_series_field_entry_index_vector_idx ON metabib.combined_series_field_entry USING gin (index_vector);


--
-- Name: metabib_combined_series_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_series_field_source_idx ON metabib.combined_series_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_subject_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE UNIQUE INDEX metabib_combined_subject_field_entry_fakepk_idx ON metabib.combined_subject_field_entry USING btree (record, COALESCE((metabib_field)::text, ''::text));


--
-- Name: metabib_combined_subject_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_subject_field_entry_index_vector_idx ON metabib.combined_subject_field_entry USING gin (index_vector);


--
-- Name: metabib_combined_subject_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_subject_field_source_idx ON metabib.combined_subject_field_entry USING btree (metabib_field);


--
-- Name: metabib_combined_title_field_entry_fakepk_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE UNIQUE INDEX metabib_combined_title_field_entry_fakepk_idx ON metabib.combined_title_field_entry USING btree (record, COALESCE((metabib_field)::text, ''::text));


--
-- Name: metabib_combined_title_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_title_field_entry_index_vector_idx ON metabib.combined_title_field_entry USING gin (index_vector);


--
-- Name: metabib_combined_title_field_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_combined_title_field_source_idx ON metabib.combined_title_field_entry USING btree (metabib_field);


--
-- Name: metabib_display_entry_field_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_display_entry_field_idx ON metabib.display_entry USING btree (field);


--
-- Name: metabib_display_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_display_entry_source_idx ON metabib.display_entry USING btree (source);


--
-- Name: metabib_facet_entry_field_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_facet_entry_field_idx ON metabib.facet_entry USING btree (field);


--
-- Name: metabib_facet_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_facet_entry_source_idx ON metabib.facet_entry USING btree (source);


--
-- Name: metabib_facet_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_facet_entry_value_idx ON metabib.facet_entry USING btree ("substring"(value, 1, 1024));


--
-- Name: metabib_full_rec_02x_tag_subfield_lower_substring; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_full_rec_02x_tag_subfield_lower_substring ON metabib.real_full_rec USING btree (tag, subfield, lower("substring"(value, 1, 1024))) WHERE (tag = ANY (ARRAY['020'::bpchar, '022'::bpchar, '024'::bpchar]));


--
-- Name: metabib_full_rec_index_vector_gin; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_full_rec_index_vector_gin ON metabib.real_full_rec USING gin (index_vector);


--
-- Name: metabib_full_rec_isxn_caseless_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_full_rec_isxn_caseless_idx ON metabib.real_full_rec USING btree (lower(value)) WHERE (tag = ANY (ARRAY['020'::bpchar, '022'::bpchar, '024'::bpchar]));


--
-- Name: metabib_full_rec_record_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_full_rec_record_idx ON metabib.real_full_rec USING btree (record);


--
-- Name: metabib_full_rec_tag_record_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_full_rec_tag_record_idx ON metabib.real_full_rec USING btree (tag, record);


--
-- Name: metabib_full_rec_tag_subfield_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_full_rec_tag_subfield_idx ON metabib.real_full_rec USING btree (tag, subfield);


--
-- Name: metabib_full_rec_tnf_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_full_rec_tnf_idx ON metabib.real_full_rec USING btree (record, tag, subfield) WHERE ((tag = 'tnf'::bpchar) AND (subfield = 'a'::text));


--
-- Name: metabib_full_rec_value_tpo_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_full_rec_value_tpo_idx ON metabib.real_full_rec USING btree ("substring"(value, 1, 1024) text_pattern_ops);


--
-- Name: metabib_identifier_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_identifier_field_entry_index_vector_idx ON metabib.identifier_field_entry USING gin (index_vector);


--
-- Name: metabib_identifier_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_identifier_field_entry_source_idx ON metabib.identifier_field_entry USING btree (source);


--
-- Name: metabib_identifier_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_identifier_field_entry_value_idx ON metabib.identifier_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_keyword_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_keyword_field_entry_index_vector_idx ON metabib.keyword_field_entry USING gin (index_vector);


--
-- Name: metabib_keyword_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_keyword_field_entry_source_idx ON metabib.keyword_field_entry USING btree (source);


--
-- Name: metabib_keyword_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_keyword_field_entry_value_idx ON metabib.keyword_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_metarecord_fingerprint_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_metarecord_fingerprint_idx ON metabib.metarecord USING btree (fingerprint);


--
-- Name: metabib_metarecord_master_record_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_metarecord_master_record_idx ON metabib.metarecord USING btree (master_record);


--
-- Name: metabib_metarecord_source_map_metarecord_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_metarecord_source_map_metarecord_idx ON metabib.metarecord_source_map USING btree (metarecord);


--
-- Name: metabib_metarecord_source_map_source_record_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_metarecord_source_map_source_record_idx ON metabib.metarecord_source_map USING btree (source);


--
-- Name: metabib_series_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_series_field_entry_index_vector_idx ON metabib.series_field_entry USING gin (index_vector);


--
-- Name: metabib_series_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_series_field_entry_source_idx ON metabib.series_field_entry USING btree (source);


--
-- Name: metabib_series_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_series_field_entry_value_idx ON metabib.series_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_sorter_a_v_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_sorter_a_v_idx ON metabib.record_sorter USING btree (attr, value);


--
-- Name: metabib_sorter_s_a_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_sorter_s_a_idx ON metabib.record_sorter USING btree (source, attr);


--
-- Name: metabib_sorter_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_sorter_source_idx ON metabib.record_sorter USING btree (source);


--
-- Name: metabib_subject_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_subject_field_entry_index_vector_idx ON metabib.subject_field_entry USING gin (index_vector);


--
-- Name: metabib_subject_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_subject_field_entry_source_idx ON metabib.subject_field_entry USING btree (source);


--
-- Name: metabib_subject_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_subject_field_entry_value_idx ON metabib.subject_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: metabib_title_field_entry_index_vector_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_title_field_entry_index_vector_idx ON metabib.title_field_entry USING gin (index_vector);


--
-- Name: metabib_title_field_entry_source_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_title_field_entry_source_idx ON metabib.title_field_entry USING btree (source);


--
-- Name: metabib_title_field_entry_value_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX metabib_title_field_entry_value_idx ON metabib.title_field_entry USING btree ("substring"(value, 1, 1024)) WHERE (index_vector = ''::tsvector);


--
-- Name: mrca_vlist_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX mrca_vlist_idx ON metabib.record_attr_vector_list USING gin (vlist public.gin__int_ops);


--
-- Name: muv_once_idx; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE UNIQUE INDEX muv_once_idx ON metabib.uncontrolled_record_attr_value USING btree (attr, value);


--
-- Name: normalized_author_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX normalized_author_field_entry_gist_trgm ON metabib.normalized_author_field_entry USING gist (value COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_remove_insignificants_author_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX normalized_remove_insignificants_author_field_entry_gist_trgm ON metabib.normalized_author_field_entry USING gist (public.remove_insignificants(value) COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_remove_insignificants_series_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX normalized_remove_insignificants_series_field_entry_gist_trgm ON metabib.normalized_series_field_entry USING gist (public.remove_insignificants(value) COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_remove_insignificants_subject_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX normalized_remove_insignificants_subject_field_entry_gist_trgm ON metabib.normalized_subject_field_entry USING gist (public.remove_insignificants(value) COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_remove_insignificants_title_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX normalized_remove_insignificants_title_field_entry_gist_trgm ON metabib.normalized_title_field_entry USING gist (public.remove_insignificants(value) COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_series_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX normalized_series_field_entry_gist_trgm ON metabib.normalized_series_field_entry USING gist (value COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_subject_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX normalized_subject_field_entry_gist_trgm ON metabib.normalized_subject_field_entry USING gist (value COLLATE "C" public.gist_trgm_ops);


--
-- Name: normalized_title_field_entry_gist_trgm; Type: INDEX; Schema: metabib; Owner: evergreen
--

CREATE INDEX normalized_title_field_entry_gist_trgm ON metabib.normalized_title_field_entry USING gist (value COLLATE "C" public.gist_trgm_ops);


--
-- Name: aged_billing_billing_ts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX aged_billing_billing_ts_idx ON money.aged_billing USING btree (billing_ts);


--
-- Name: aged_billing_voider_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX aged_billing_voider_idx ON money.aged_billing USING btree (voider);


--
-- Name: aged_billing_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX aged_billing_xact_idx ON money.aged_billing USING btree (xact);


--
-- Name: aged_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX aged_payment_accepting_usr_idx ON money.aged_payment USING btree (accepting_usr);


--
-- Name: aged_payment_billing_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX aged_payment_billing_idx ON money.aged_payment USING btree (billing);


--
-- Name: aged_payment_cash_drawer_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX aged_payment_cash_drawer_idx ON money.aged_payment USING btree (cash_drawer);


--
-- Name: aged_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX aged_payment_payment_ts_idx ON money.aged_payment USING btree (payment_ts);


--
-- Name: aged_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX aged_payment_xact_idx ON money.aged_payment USING btree (xact);


--
-- Name: circ_open_date_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX circ_open_date_idx ON money.grocery USING btree (xact_start) WHERE (xact_finish IS NULL);


--
-- Name: m_b_create_date_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_b_create_date_idx ON money.billing USING btree (create_date);


--
-- Name: m_b_period_end_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_b_period_end_idx ON money.billing USING btree (period_end);


--
-- Name: m_b_period_start_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_b_period_start_idx ON money.billing USING btree (period_start);


--
-- Name: m_b_time_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_b_time_idx ON money.billing USING btree (billing_ts);


--
-- Name: m_b_voider_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_b_voider_idx ON money.billing USING btree (voider);


--
-- Name: m_b_x_open_xacts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_b_x_open_xacts_idx ON money.billable_xact USING btree (usr);


--
-- Name: m_b_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_b_xact_idx ON money.billing USING btree (xact);


--
-- Name: m_c_t_collector_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_c_t_collector_idx ON money.collections_tracker USING btree (collector);


--
-- Name: m_c_t_usr_collector_location_once_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE UNIQUE INDEX m_c_t_usr_collector_location_once_idx ON money.collections_tracker USING btree (usr, collector, location);


--
-- Name: m_g_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_g_usr_idx ON money.grocery USING btree (usr);


--
-- Name: m_p_time_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_p_time_idx ON money.payment USING btree (payment_ts);


--
-- Name: m_p_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_p_xact_idx ON money.payment USING btree (xact);


--
-- Name: m_r_p_payment_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_r_p_payment_idx ON money.refundable_payment USING btree (payment);


--
-- Name: m_r_x_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX m_r_x_xact_idx ON money.refundable_xact USING btree (xact);


--
-- Name: money_account_adjustment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_account_adjustment_accepting_usr_idx ON money.account_adjustment USING btree (accepting_usr);


--
-- Name: money_account_adjustment_bill_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_account_adjustment_bill_idx ON money.account_adjustment USING btree (billing);


--
-- Name: money_account_adjustment_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_account_adjustment_payment_ts_idx ON money.account_adjustment USING btree (payment_ts);


--
-- Name: money_account_adjustment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_account_adjustment_xact_idx ON money.account_adjustment USING btree (xact);


--
-- Name: money_adjustment_id_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_adjustment_id_idx ON money.account_adjustment USING btree (id);


--
-- Name: money_cash_id_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_cash_id_idx ON money.cash_payment USING btree (id);


--
-- Name: money_cash_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_cash_payment_accepting_usr_idx ON money.cash_payment USING btree (accepting_usr);


--
-- Name: money_cash_payment_cash_drawer_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_cash_payment_cash_drawer_idx ON money.cash_payment USING btree (cash_drawer);


--
-- Name: money_cash_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_cash_payment_ts_idx ON money.cash_payment USING btree (payment_ts);


--
-- Name: money_cash_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_cash_payment_xact_idx ON money.cash_payment USING btree (xact);


--
-- Name: money_check_id_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_check_id_idx ON money.check_payment USING btree (id);


--
-- Name: money_check_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_check_payment_accepting_usr_idx ON money.check_payment USING btree (accepting_usr);


--
-- Name: money_check_payment_cash_drawer_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_check_payment_cash_drawer_idx ON money.check_payment USING btree (cash_drawer);


--
-- Name: money_check_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_check_payment_ts_idx ON money.check_payment USING btree (payment_ts);


--
-- Name: money_check_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_check_payment_xact_idx ON money.check_payment USING btree (xact);


--
-- Name: money_credit_card_id_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_credit_card_id_idx ON money.credit_card_payment USING btree (id);


--
-- Name: money_credit_card_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_credit_card_payment_accepting_usr_idx ON money.credit_card_payment USING btree (accepting_usr);


--
-- Name: money_credit_card_payment_cash_drawer_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_credit_card_payment_cash_drawer_idx ON money.credit_card_payment USING btree (cash_drawer);


--
-- Name: money_credit_card_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_credit_card_payment_ts_idx ON money.credit_card_payment USING btree (payment_ts);


--
-- Name: money_credit_card_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_credit_card_payment_xact_idx ON money.credit_card_payment USING btree (xact);


--
-- Name: money_credit_id_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_credit_id_idx ON money.credit_payment USING btree (id);


--
-- Name: money_credit_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_credit_payment_accepting_usr_idx ON money.credit_payment USING btree (accepting_usr);


--
-- Name: money_credit_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_credit_payment_payment_ts_idx ON money.credit_payment USING btree (payment_ts);


--
-- Name: money_credit_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_credit_payment_xact_idx ON money.credit_payment USING btree (xact);


--
-- Name: money_debit_card_id_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_debit_card_id_idx ON money.debit_card_payment USING btree (id);


--
-- Name: money_debit_card_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_debit_card_payment_accepting_usr_idx ON money.debit_card_payment USING btree (accepting_usr);


--
-- Name: money_debit_card_payment_cash_drawer_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_debit_card_payment_cash_drawer_idx ON money.debit_card_payment USING btree (cash_drawer);


--
-- Name: money_debit_card_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_debit_card_payment_ts_idx ON money.debit_card_payment USING btree (payment_ts);


--
-- Name: money_debit_card_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_debit_card_payment_xact_idx ON money.debit_card_payment USING btree (xact);


--
-- Name: money_forgive_id_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_forgive_id_idx ON money.forgive_payment USING btree (id);


--
-- Name: money_forgive_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_forgive_payment_accepting_usr_idx ON money.forgive_payment USING btree (accepting_usr);


--
-- Name: money_forgive_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_forgive_payment_payment_ts_idx ON money.forgive_payment USING btree (payment_ts);


--
-- Name: money_forgive_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_forgive_payment_xact_idx ON money.forgive_payment USING btree (xact);


--
-- Name: money_goods_id_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_goods_id_idx ON money.goods_payment USING btree (id);


--
-- Name: money_goods_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_goods_payment_accepting_usr_idx ON money.goods_payment USING btree (accepting_usr);


--
-- Name: money_goods_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_goods_payment_payment_ts_idx ON money.goods_payment USING btree (payment_ts);


--
-- Name: money_goods_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_goods_payment_xact_idx ON money.goods_payment USING btree (xact);


--
-- Name: money_mat_summary_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_mat_summary_usr_idx ON money.materialized_billable_xact_summary USING btree (usr);


--
-- Name: money_mat_summary_xact_start_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_mat_summary_xact_start_idx ON money.materialized_billable_xact_summary USING btree (xact_start);


--
-- Name: money_work_id_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_work_id_idx ON money.work_payment USING btree (id);


--
-- Name: money_work_payment_accepting_usr_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_work_payment_accepting_usr_idx ON money.work_payment USING btree (accepting_usr);


--
-- Name: money_work_payment_payment_ts_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_work_payment_payment_ts_idx ON money.work_payment USING btree (payment_ts);


--
-- Name: money_work_payment_xact_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX money_work_payment_xact_idx ON money.work_payment USING btree (xact);


--
-- Name: mous_idx; Type: INDEX; Schema: money; Owner: evergreen
--

CREATE INDEX mous_idx ON money.materialized_billable_xact_summary USING btree (usr) WHERE (xact_finish IS NULL);


--
-- Name: offline_script_pkey; Type: INDEX; Schema: offline; Owner: evergreen
--

CREATE INDEX offline_script_pkey ON offline.script USING btree (id);


--
-- Name: offline_script_session; Type: INDEX; Schema: offline; Owner: evergreen
--

CREATE INDEX offline_script_session ON offline.script USING btree (session);


--
-- Name: offline_script_ws; Type: INDEX; Schema: offline; Owner: evergreen
--

CREATE INDEX offline_script_ws ON offline.script USING btree (workstation);


--
-- Name: offline_session_creation; Type: INDEX; Schema: offline; Owner: evergreen
--

CREATE INDEX offline_session_creation ON offline.session USING btree (create_time);


--
-- Name: offline_session_org; Type: INDEX; Schema: offline; Owner: evergreen
--

CREATE INDEX offline_session_org ON offline.session USING btree (org);


--
-- Name: offline_session_pkey; Type: INDEX; Schema: offline; Owner: evergreen
--

CREATE INDEX offline_session_pkey ON offline.session USING btree (key);


--
-- Name: grp_tree_parent_idx; Type: INDEX; Schema: permission; Owner: evergreen
--

CREATE INDEX grp_tree_parent_idx ON permission.grp_tree USING btree (parent);


--
-- Name: perm_list_code_idx; Type: INDEX; Schema: permission; Owner: evergreen
--

CREATE INDEX perm_list_code_idx ON permission.perm_list USING btree (code);


--
-- Name: uopm_usr_idx; Type: INDEX; Schema: permission; Owner: evergreen
--

CREATE INDEX uopm_usr_idx ON permission.usr_object_perm_map USING btree (usr);


--
-- Name: from_parent_seq; Type: INDEX; Schema: query; Owner: evergreen
--

CREATE UNIQUE INDEX from_parent_seq ON query.from_relation USING btree (parent_relation, seq_no) WHERE (parent_relation IS NOT NULL);


--
-- Name: query_expr_parent_seq; Type: INDEX; Schema: query; Owner: evergreen
--

CREATE UNIQUE INDEX query_expr_parent_seq ON query.expression USING btree (parent_expr, seq_no) WHERE (parent_expr IS NOT NULL);


--
-- Name: query_function_sig_name_idx; Type: INDEX; Schema: query; Owner: evergreen
--

CREATE INDEX query_function_sig_name_idx ON query.function_sig USING btree (function_name);


--
-- Name: record_badge_score_badge_idx; Type: INDEX; Schema: rating; Owner: evergreen
--

CREATE INDEX record_badge_score_badge_idx ON rating.record_badge_score USING btree (badge);


--
-- Name: record_badge_score_record_idx; Type: INDEX; Schema: rating; Owner: evergreen
--

CREATE INDEX record_badge_score_record_idx ON rating.record_badge_score USING btree (record);


--
-- Name: reporter_hold_request_record_bib_record_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE INDEX reporter_hold_request_record_bib_record_idx ON reporter.hold_request_record USING btree (bib_record);


--
-- Name: rmcbe_heading_date_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE INDEX rmcbe_heading_date_idx ON reporter.materialized_cataloged_browse_entry USING btree (heading_date);


--
-- Name: rpt_output_fldr_owner_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE INDEX rpt_output_fldr_owner_idx ON reporter.output_folder USING btree (owner);


--
-- Name: rpt_output_folder_once_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE UNIQUE INDEX rpt_output_folder_once_idx ON reporter.output_folder USING btree (name, owner, simple_reporter) WHERE (parent IS NULL);


--
-- Name: rpt_output_folder_once_parent_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE UNIQUE INDEX rpt_output_folder_once_parent_idx ON reporter.output_folder USING btree (name, parent);


--
-- Name: rpt_report_folder_once_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE UNIQUE INDEX rpt_report_folder_once_idx ON reporter.report_folder USING btree (name, owner, simple_reporter) WHERE (parent IS NULL);


--
-- Name: rpt_report_folder_once_parent_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE UNIQUE INDEX rpt_report_folder_once_parent_idx ON reporter.report_folder USING btree (name, parent);


--
-- Name: rpt_rpt_fldr_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE INDEX rpt_rpt_fldr_idx ON reporter.report USING btree (folder);


--
-- Name: rpt_rpt_fldr_owner_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE INDEX rpt_rpt_fldr_owner_idx ON reporter.report_folder USING btree (owner);


--
-- Name: rpt_rpt_owner_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE INDEX rpt_rpt_owner_idx ON reporter.report USING btree (owner);


--
-- Name: rpt_sched_folder_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE INDEX rpt_sched_folder_idx ON reporter.schedule USING btree (folder);


--
-- Name: rpt_sched_recurrence_once_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE UNIQUE INDEX rpt_sched_recurrence_once_idx ON reporter.schedule USING btree (report, folder, runner, run_time, COALESCE(email, ''::text));


--
-- Name: rpt_sched_runner_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE INDEX rpt_sched_runner_idx ON reporter.schedule USING btree (runner);


--
-- Name: rpt_template_folder_once_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE UNIQUE INDEX rpt_template_folder_once_idx ON reporter.template_folder USING btree (name, owner, simple_reporter) WHERE (parent IS NULL);


--
-- Name: rpt_template_folder_once_parent_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE UNIQUE INDEX rpt_template_folder_once_parent_idx ON reporter.template_folder USING btree (name, parent);


--
-- Name: rpt_tmpl_fldr_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE INDEX rpt_tmpl_fldr_idx ON reporter.template USING btree (folder);


--
-- Name: rpt_tmpl_fldr_owner_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE INDEX rpt_tmpl_fldr_owner_idx ON reporter.template_folder USING btree (owner);


--
-- Name: rpt_tmpl_owner_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE INDEX rpt_tmpl_owner_idx ON reporter.template USING btree (owner);


--
-- Name: rtp_report_folder_once_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE UNIQUE INDEX rtp_report_folder_once_idx ON reporter.report USING btree (name, folder);


--
-- Name: rtp_template_folder_once_idx; Type: INDEX; Schema: reporter; Owner: evergreen
--

CREATE UNIQUE INDEX rtp_template_folder_once_idx ON reporter.template USING btree (name, folder);


--
-- Name: bump_once_per_field_idx; Type: INDEX; Schema: search; Owner: evergreen
--

CREATE UNIQUE INDEX bump_once_per_field_idx ON search.relevance_adjustment USING btree (field, bump_type);


--
-- Name: symspell_dictionary_updates_tid_idx; Type: INDEX; Schema: search; Owner: evergreen
--

CREATE INDEX symspell_dictionary_updates_tid_idx ON search.symspell_dictionary_updates USING btree (transaction_id);


--
-- Name: assist_holdings_display; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX assist_holdings_display ON serial.materialized_holding_code USING btree (issuance, subfield);


--
-- Name: label_once_per_dist; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE UNIQUE INDEX label_once_per_dist ON serial.stream USING btree (distribution, routing_label) WHERE (routing_label IS NOT NULL);


--
-- Name: one_dist_per_sre_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE UNIQUE INDEX one_dist_per_sre_idx ON serial.distribution USING btree (record_entry);


--
-- Name: serial_basic_summary_dist_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_basic_summary_dist_idx ON serial.basic_summary USING btree (distribution);


--
-- Name: serial_caption_and_pattern_sub_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_caption_and_pattern_sub_idx ON serial.caption_and_pattern USING btree (subscription);


--
-- Name: serial_distribution_holding_lib_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_distribution_holding_lib_idx ON serial.distribution USING btree (holding_lib);


--
-- Name: serial_distribution_note_dist_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_distribution_note_dist_idx ON serial.distribution_note USING btree (distribution);


--
-- Name: serial_distribution_sub_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_distribution_sub_idx ON serial.distribution USING btree (subscription);


--
-- Name: serial_index_summary_dist_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_index_summary_dist_idx ON serial.index_summary USING btree (distribution);


--
-- Name: serial_issuance_caption_and_pattern_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_issuance_caption_and_pattern_idx ON serial.issuance USING btree (caption_and_pattern);


--
-- Name: serial_issuance_date_published_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_issuance_date_published_idx ON serial.issuance USING btree (date_published);


--
-- Name: serial_issuance_sub_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_issuance_sub_idx ON serial.issuance USING btree (subscription);


--
-- Name: serial_item_date_received_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_item_date_received_idx ON serial.item USING btree (date_received);


--
-- Name: serial_item_issuance_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_item_issuance_idx ON serial.item USING btree (issuance);


--
-- Name: serial_item_note_item_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_item_note_item_idx ON serial.item_note USING btree (item);


--
-- Name: serial_item_status_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_item_status_idx ON serial.item USING btree (status);


--
-- Name: serial_item_stream_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_item_stream_idx ON serial.item USING btree (stream);


--
-- Name: serial_item_unit_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_item_unit_idx ON serial.item USING btree (unit);


--
-- Name: serial_item_uri_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_item_uri_idx ON serial.item USING btree (uri);


--
-- Name: serial_pattern_template_name_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_pattern_template_name_idx ON serial.pattern_template USING btree (evergreen.lowercase(name));


--
-- Name: serial_record_entry_creator_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_record_entry_creator_idx ON serial.record_entry USING btree (creator);


--
-- Name: serial_record_entry_editor_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_record_entry_editor_idx ON serial.record_entry USING btree (editor);


--
-- Name: serial_record_entry_owning_lib_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_record_entry_owning_lib_idx ON serial.record_entry USING btree (owning_lib, deleted);


--
-- Name: serial_record_entry_record_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_record_entry_record_idx ON serial.record_entry USING btree (record);


--
-- Name: serial_routing_list_user_reader_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_routing_list_user_reader_idx ON serial.routing_list_user USING btree (reader);


--
-- Name: serial_routing_list_user_stream_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_routing_list_user_stream_idx ON serial.routing_list_user USING btree (stream);


--
-- Name: serial_stream_dist_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_stream_dist_idx ON serial.stream USING btree (distribution);


--
-- Name: serial_subscription_owner_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_subscription_owner_idx ON serial.subscription USING btree (owning_lib);


--
-- Name: serial_subscription_record_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_subscription_record_idx ON serial.subscription USING btree (record_entry);


--
-- Name: serial_supplement_summary_dist_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX serial_supplement_summary_dist_idx ON serial.supplement_summary USING btree (distribution);


--
-- Name: unit_avail_cn_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX unit_avail_cn_idx ON serial.unit USING btree (call_number);


--
-- Name: unit_barcode_key; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE UNIQUE INDEX unit_barcode_key ON serial.unit USING btree (barcode) WHERE ((deleted = false) OR (deleted IS FALSE));


--
-- Name: unit_cn_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX unit_cn_idx ON serial.unit USING btree (call_number);


--
-- Name: unit_creator_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX unit_creator_idx ON serial.unit USING btree (creator);


--
-- Name: unit_editor_idx; Type: INDEX; Schema: serial; Owner: evergreen
--

CREATE INDEX unit_editor_idx ON serial.unit USING btree (editor);


--
-- Name: bib_match_queued_record_idx; Type: INDEX; Schema: vandelay; Owner: evergreen
--

CREATE INDEX bib_match_queued_record_idx ON vandelay.bib_match USING btree (queued_record);


--
-- Name: import_item_record_idx; Type: INDEX; Schema: vandelay; Owner: evergreen
--

CREATE INDEX import_item_record_idx ON vandelay.import_item USING btree (record);


--
-- Name: queued_authority_record_attr_record_idx; Type: INDEX; Schema: vandelay; Owner: evergreen
--

CREATE INDEX queued_authority_record_attr_record_idx ON vandelay.queued_authority_record_attr USING btree (record);


--
-- Name: queued_authority_record_queue_idx; Type: INDEX; Schema: vandelay; Owner: evergreen
--

CREATE INDEX queued_authority_record_queue_idx ON vandelay.queued_authority_record USING btree (queue);


--
-- Name: queued_bib_record_attr_record_idx; Type: INDEX; Schema: vandelay; Owner: evergreen
--

CREATE INDEX queued_bib_record_attr_record_idx ON vandelay.queued_bib_record_attr USING btree (record);


--
-- Name: queued_bib_record_queue_idx; Type: INDEX; Schema: vandelay; Owner: evergreen
--

CREATE INDEX queued_bib_record_queue_idx ON vandelay.queued_bib_record USING btree (queue);


--
-- Name: vmsq_def_once_per_set; Type: INDEX; Schema: vandelay; Owner: evergreen
--

CREATE UNIQUE INDEX vmsq_def_once_per_set ON vandelay.match_set_quality USING btree (match_set, COALESCE(tag, ''::text), COALESCE(subfield, ''::text), COALESCE(svf, ''::text), value);


--
-- Name: usr protect_user_delete; Type: RULE; Schema: actor; Owner: evergreen
--

CREATE RULE protect_user_delete AS
    ON DELETE TO actor.usr DO INSTEAD  UPDATE actor.usr SET deleted = true
  WHERE (old.id = usr.id);


--
-- Name: usr_message protect_usr_message_delete; Type: RULE; Schema: actor; Owner: evergreen
--

CREATE RULE protect_usr_message_delete AS
    ON DELETE TO actor.usr_message DO INSTEAD  UPDATE actor.usr_message SET deleted = true
  WHERE (old.id = usr_message.id);


--
-- Name: copy_location protect_acl_id_1; Type: RULE; Schema: asset; Owner: evergreen
--

CREATE RULE protect_acl_id_1 AS
    ON UPDATE TO asset.copy_location
   WHERE (old.id = 1) DO INSTEAD NOTHING;


--
-- Name: call_number protect_acn_id_neg1; Type: RULE; Schema: asset; Owner: evergreen
--

CREATE RULE protect_acn_id_neg1 AS
    ON UPDATE TO asset.call_number
   WHERE (old.id = '-1'::integer) DO INSTEAD NOTHING;


--
-- Name: call_number protect_cn_delete; Type: RULE; Schema: asset; Owner: evergreen
--

CREATE RULE protect_cn_delete AS
    ON DELETE TO asset.call_number DO INSTEAD  UPDATE asset.call_number SET deleted = true
  WHERE (old.id = call_number.id);


--
-- Name: copy protect_copy_delete; Type: RULE; Schema: asset; Owner: evergreen
--

CREATE RULE protect_copy_delete AS
    ON DELETE TO asset.copy DO INSTEAD  UPDATE asset.copy SET deleted = true
  WHERE (old.id = copy.id);


--
-- Name: copy_location protect_copy_location_delete; Type: RULE; Schema: asset; Owner: evergreen
--

CREATE RULE protect_copy_location_delete AS
    ON DELETE TO asset.copy_location DO INSTEAD ( SELECT asset.check_delete_copy_location(old.id) AS check_delete_copy_location;
 UPDATE asset.copy_location SET deleted = true
  WHERE (old.id = copy_location.id);
 UPDATE acq.lineitem_detail SET location = NULL::integer
  WHERE (lineitem_detail.location = old.id);
 DELETE FROM asset.copy_location_order
  WHERE (copy_location_order.location = old.id);
 DELETE FROM asset.copy_location_group_map
  WHERE (copy_location_group_map.location = old.id);
 DELETE FROM config.circ_limit_set_copy_loc_map
  WHERE (circ_limit_set_copy_loc_map.copy_loc = old.id);
);


--
-- Name: record_entry protect_authority_rec_delete; Type: RULE; Schema: authority; Owner: evergreen
--

CREATE RULE protect_authority_rec_delete AS
    ON DELETE TO authority.record_entry DO INSTEAD ( UPDATE authority.record_entry SET deleted = true
  WHERE (old.id = record_entry.id);
 DELETE FROM authority.full_rec
  WHERE (full_rec.record = old.id);
);


--
-- Name: record_entry protect_bib_rec_delete; Type: RULE; Schema: biblio; Owner: evergreen
--

CREATE RULE protect_bib_rec_delete AS
    ON DELETE TO biblio.record_entry DO INSTEAD  UPDATE biblio.record_entry SET deleted = true
  WHERE (old.id = record_entry.id);


--
-- Name: record_entry protect_bre_id_neg1; Type: RULE; Schema: biblio; Owner: evergreen
--

CREATE RULE protect_bre_id_neg1 AS
    ON UPDATE TO biblio.record_entry
   WHERE (old.id = '-1'::integer) DO INSTEAD NOTHING;


--
-- Name: monograph_part protect_mono_part_delete; Type: RULE; Schema: biblio; Owner: evergreen
--

CREATE RULE protect_mono_part_delete AS
    ON DELETE TO biblio.monograph_part DO INSTEAD ( UPDATE biblio.monograph_part SET deleted = true
  WHERE (old.id = monograph_part.id);
 DELETE FROM asset.copy_part_map
  WHERE (copy_part_map.part = old.id);
);


--
-- Name: full_rec metabib_full_rec_delete_rule; Type: RULE; Schema: metabib; Owner: evergreen
--

CREATE RULE metabib_full_rec_delete_rule AS
    ON DELETE TO metabib.full_rec DO INSTEAD  DELETE FROM metabib.real_full_rec
  WHERE (real_full_rec.id = old.id);


--
-- Name: full_rec metabib_full_rec_insert_rule; Type: RULE; Schema: metabib; Owner: evergreen
--

CREATE RULE metabib_full_rec_insert_rule AS
    ON INSERT TO metabib.full_rec DO INSTEAD  INSERT INTO metabib.real_full_rec (id, record, tag, ind1, ind2, subfield, value, index_vector)
  VALUES (COALESCE(new.id, nextval('metabib.full_rec_id_seq'::regclass)), new.record, new.tag, new.ind1, new.ind2, new.subfield, new.value, new.index_vector);


--
-- Name: full_rec metabib_full_rec_update_rule; Type: RULE; Schema: metabib; Owner: evergreen
--

CREATE RULE metabib_full_rec_update_rule AS
    ON UPDATE TO metabib.full_rec DO INSTEAD  UPDATE metabib.real_full_rec SET id = new.id, record = new.record, tag = new.tag, ind1 = new.ind1, ind2 = new.ind2, subfield = new.subfield, value = new.value, index_vector = new.index_vector
  WHERE (real_full_rec.id = old.id);


--
-- Name: payment_view money_payment_view_update; Type: RULE; Schema: money; Owner: evergreen
--

CREATE RULE money_payment_view_update AS
    ON UPDATE TO money.payment_view DO INSTEAD  UPDATE money.payment SET xact = new.xact, payment_ts = new.payment_ts, voided = new.voided, amount = new.amount, note = new.note
  WHERE (payment.id = new.id);


--
-- Name: expr_xstr query_expr_string_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_string_delete_rule AS
    ON DELETE TO query.expr_xstr DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xstr query_expr_string_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_string_insert_rule AS
    ON INSERT TO query.expr_xstr DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, literal)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xstr'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.literal);


--
-- Name: expr_xstr query_expr_string_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_string_update_rule AS
    ON UPDATE TO query.expr_xstr DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, literal = new.literal
  WHERE (expression.id = old.id);


--
-- Name: expr_xbet query_expr_xbet_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbet_delete_rule AS
    ON DELETE TO query.expr_xbet DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xbet query_expr_xbet_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbet_insert_rule AS
    ON INSERT TO query.expr_xbet DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, left_operand, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xbet'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, COALESCE(new.negate, false));


--
-- Name: expr_xbet query_expr_xbet_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbet_update_rule AS
    ON UPDATE TO query.expr_xbet DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xbind query_expr_xbind_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbind_delete_rule AS
    ON DELETE TO query.expr_xbind DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xbind query_expr_xbind_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbind_insert_rule AS
    ON INSERT TO query.expr_xbind DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, bind_variable)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xbind'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.bind_variable);


--
-- Name: expr_xbind query_expr_xbind_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbind_update_rule AS
    ON UPDATE TO query.expr_xbind DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, bind_variable = new.bind_variable
  WHERE (expression.id = old.id);


--
-- Name: expr_xbool query_expr_xbool_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbool_delete_rule AS
    ON DELETE TO query.expr_xbool DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xbool query_expr_xbool_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbool_insert_rule AS
    ON INSERT TO query.expr_xbool DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, literal, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xbool'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.literal, COALESCE(new.negate, false));


--
-- Name: expr_xbool query_expr_xbool_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xbool_update_rule AS
    ON UPDATE TO query.expr_xbool DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, literal = new.literal, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xcase query_expr_xcase_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcase_delete_rule AS
    ON DELETE TO query.expr_xcase DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xcase query_expr_xcase_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcase_insert_rule AS
    ON INSERT TO query.expr_xcase DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, left_operand, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xcase'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, COALESCE(new.negate, false));


--
-- Name: expr_xcase query_expr_xcase_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcase_update_rule AS
    ON UPDATE TO query.expr_xcase DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xcast query_expr_xcast_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcast_delete_rule AS
    ON DELETE TO query.expr_xcast DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xcast query_expr_xcast_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcast_insert_rule AS
    ON INSERT TO query.expr_xcast DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, left_operand, cast_type, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xcast'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, new.cast_type, COALESCE(new.negate, false));


--
-- Name: expr_xcast query_expr_xcast_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcast_update_rule AS
    ON UPDATE TO query.expr_xcast DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, cast_type = new.cast_type, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xcol query_expr_xcol_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcol_delete_rule AS
    ON DELETE TO query.expr_xcol DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xcol query_expr_xcol_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcol_insert_rule AS
    ON INSERT TO query.expr_xcol DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, table_alias, column_name, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xcol'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.table_alias, new.column_name, COALESCE(new.negate, false));


--
-- Name: expr_xcol query_expr_xcol_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xcol_update_rule AS
    ON UPDATE TO query.expr_xcol DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, table_alias = new.table_alias, column_name = new.column_name, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xex query_expr_xex_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xex_delete_rule AS
    ON DELETE TO query.expr_xex DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xex query_expr_xex_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xex_insert_rule AS
    ON INSERT TO query.expr_xex DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, subquery, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xex'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.subquery, COALESCE(new.negate, false));


--
-- Name: expr_xex query_expr_xex_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xex_update_rule AS
    ON UPDATE TO query.expr_xex DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, subquery = new.subquery, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xfunc query_expr_xfunc_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xfunc_delete_rule AS
    ON DELETE TO query.expr_xfunc DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xfunc query_expr_xfunc_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xfunc_insert_rule AS
    ON INSERT TO query.expr_xfunc DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, column_name, function_id, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xfunc'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.column_name, new.function_id, COALESCE(new.negate, false));


--
-- Name: expr_xfunc query_expr_xfunc_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xfunc_update_rule AS
    ON UPDATE TO query.expr_xfunc DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, column_name = new.column_name, function_id = new.function_id, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xin query_expr_xin_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xin_delete_rule AS
    ON DELETE TO query.expr_xin DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xin query_expr_xin_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xin_insert_rule AS
    ON INSERT TO query.expr_xin DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, left_operand, subquery, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xin'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, new.subquery, COALESCE(new.negate, false));


--
-- Name: expr_xin query_expr_xin_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xin_update_rule AS
    ON UPDATE TO query.expr_xin DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, subquery = new.subquery, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xisnull query_expr_xisnull_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xisnull_delete_rule AS
    ON DELETE TO query.expr_xisnull DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xisnull query_expr_xisnull_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xisnull_insert_rule AS
    ON INSERT TO query.expr_xisnull DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, left_operand, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xisnull'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, COALESCE(new.negate, false));


--
-- Name: expr_xisnull query_expr_xisnull_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xisnull_update_rule AS
    ON UPDATE TO query.expr_xisnull DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xnull query_expr_xnull_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnull_delete_rule AS
    ON DELETE TO query.expr_xnull DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xnull query_expr_xnull_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnull_insert_rule AS
    ON INSERT TO query.expr_xnull DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xnull'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), COALESCE(new.negate, false));


--
-- Name: expr_xnull query_expr_xnull_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnull_update_rule AS
    ON UPDATE TO query.expr_xnull DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xnum query_expr_xnum_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnum_delete_rule AS
    ON DELETE TO query.expr_xnum DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xnum query_expr_xnum_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnum_insert_rule AS
    ON INSERT TO query.expr_xnum DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, literal)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xnum'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.literal);


--
-- Name: expr_xnum query_expr_xnum_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xnum_update_rule AS
    ON UPDATE TO query.expr_xnum DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, literal = new.literal
  WHERE (expression.id = old.id);


--
-- Name: expr_xop query_expr_xop_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xop_delete_rule AS
    ON DELETE TO query.expr_xop DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xop query_expr_xop_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xop_insert_rule AS
    ON INSERT TO query.expr_xop DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, left_operand, operator, right_operand, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xop'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.left_operand, new.operator, new.right_operand, COALESCE(new.negate, false));


--
-- Name: expr_xop query_expr_xop_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xop_update_rule AS
    ON UPDATE TO query.expr_xop DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, left_operand = new.left_operand, operator = new.operator, right_operand = new.right_operand, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xser query_expr_xser_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xser_delete_rule AS
    ON DELETE TO query.expr_xser DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xser query_expr_xser_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xser_insert_rule AS
    ON INSERT TO query.expr_xser DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, operator, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xser'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.operator, COALESCE(new.negate, false));


--
-- Name: expr_xser query_expr_xser_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xser_update_rule AS
    ON UPDATE TO query.expr_xser DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, operator = new.operator, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: expr_xsubq query_expr_xsubq_delete_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xsubq_delete_rule AS
    ON DELETE TO query.expr_xsubq DO INSTEAD  DELETE FROM query.expression
  WHERE (expression.id = old.id);


--
-- Name: expr_xsubq query_expr_xsubq_insert_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xsubq_insert_rule AS
    ON INSERT TO query.expr_xsubq DO INSTEAD  INSERT INTO query.expression (id, type, parenthesize, parent_expr, seq_no, subquery, negate)
  VALUES (COALESCE((new.id)::bigint, nextval('query.expression_id_seq'::regclass)), 'xsubq'::text, COALESCE(new.parenthesize, false), new.parent_expr, COALESCE(new.seq_no, 1), new.subquery, COALESCE(new.negate, false));


--
-- Name: expr_xsubq query_expr_xsubq_update_rule; Type: RULE; Schema: query; Owner: evergreen
--

CREATE RULE query_expr_xsubq_update_rule AS
    ON UPDATE TO query.expr_xsubq DO INSTEAD  UPDATE query.expression SET id = new.id, parenthesize = new.parenthesize, parent_expr = new.parent_expr, seq_no = new.seq_no, subquery = new.subquery, negate = new.negate
  WHERE (expression.id = old.id);


--
-- Name: record_entry protect_mfhd_delete; Type: RULE; Schema: serial; Owner: evergreen
--

CREATE RULE protect_mfhd_delete AS
    ON DELETE TO serial.record_entry DO INSTEAD  UPDATE serial.record_entry SET deleted = true
  WHERE (old.id = record_entry.id);


--
-- Name: unit protect_serial_unit_delete; Type: RULE; Schema: serial; Owner: evergreen
--

CREATE RULE protect_serial_unit_delete AS
    ON DELETE TO serial.unit DO INSTEAD  UPDATE serial.unit SET deleted = true
  WHERE (old.id = unit.id);


--
-- Name: fund_allocation_percent acq_fund_alloc_percent_val_trig; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER acq_fund_alloc_percent_val_trig BEFORE INSERT OR UPDATE ON acq.fund_allocation_percent FOR EACH ROW EXECUTE PROCEDURE acq.fund_alloc_percent_val();


--
-- Name: cancel_reason acq_no_deleted_reserved_cancel_reasons; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER acq_no_deleted_reserved_cancel_reasons BEFORE DELETE ON acq.cancel_reason FOR EACH ROW EXECUTE PROCEDURE evergreen.protect_reserved_rows_from_delete('2000');


--
-- Name: fund_allocation_percent acqfap_limit_100_trig; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER acqfap_limit_100_trig AFTER INSERT OR UPDATE ON acq.fund_allocation_percent FOR EACH ROW EXECUTE PROCEDURE acq.fap_limit_100();


--
-- Name: fund_debit audit_acq_fund_debit_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_fund_debit_update_trigger AFTER DELETE OR UPDATE ON acq.fund_debit FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_fund_debit_func();


--
-- Name: invoice_entry audit_acq_invoice_entry_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_invoice_entry_update_trigger AFTER DELETE OR UPDATE ON acq.invoice_entry FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_invoice_entry_func();


--
-- Name: invoice_item audit_acq_invoice_item_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_invoice_item_update_trigger AFTER DELETE OR UPDATE ON acq.invoice_item FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_invoice_item_func();


--
-- Name: invoice audit_acq_invoice_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_invoice_update_trigger AFTER DELETE OR UPDATE ON acq.invoice FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_invoice_func();


--
-- Name: lineitem_detail audit_acq_lineitem_detail_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_lineitem_detail_update_trigger AFTER DELETE OR UPDATE ON acq.lineitem_detail FOR EACH ROW EXECUTE PROCEDURE auditor.audit_acq_lineitem_detail_func();


--
-- Name: lineitem audit_acq_lineitem_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_lineitem_update_trigger AFTER DELETE OR UPDATE ON acq.lineitem FOR EACH ROW EXECUTE PROCEDURE acq.audit_acq_lineitem_func();


--
-- Name: purchase_order audit_acq_purchase_order_update_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER audit_acq_purchase_order_update_trigger AFTER DELETE OR UPDATE ON acq.purchase_order FOR EACH ROW EXECUTE PROCEDURE acq.audit_acq_purchase_order_func();


--
-- Name: lineitem cleanup_lineitem_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER cleanup_lineitem_trigger BEFORE DELETE OR UPDATE ON acq.lineitem FOR EACH ROW EXECUTE PROCEDURE public.cleanup_acq_marc();


--
-- Name: lineitem ingest_lineitem_trigger; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER ingest_lineitem_trigger AFTER INSERT OR UPDATE ON acq.lineitem FOR EACH ROW EXECUTE PROCEDURE public.ingest_acq_marc();


--
-- Name: purchase_order po_name_default_trg; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER po_name_default_trg BEFORE INSERT OR UPDATE ON acq.purchase_order FOR EACH ROW EXECUTE PROCEDURE acq.purchase_order_name_default();


--
-- Name: purchase_order po_org_name_date_unique_trg; Type: TRIGGER; Schema: acq; Owner: evergreen
--

CREATE TRIGGER po_org_name_date_unique_trg BEFORE INSERT OR UPDATE ON acq.purchase_order FOR EACH ROW EXECUTE PROCEDURE acq.po_org_name_date_unique();


--
-- Name: circulation action_circulation_aging_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER action_circulation_aging_tgr BEFORE DELETE ON action.circulation FOR EACH ROW EXECUTE PROCEDURE action.age_circ_on_delete();


--
-- Name: circulation action_circulation_stop_fines_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER action_circulation_stop_fines_tgr BEFORE UPDATE ON action.circulation FOR EACH ROW EXECUTE PROCEDURE action.circulation_claims_returned();


--
-- Name: circulation action_circulation_target_copy_trig; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER action_circulation_target_copy_trig AFTER INSERT OR UPDATE ON action.circulation FOR EACH ROW EXECUTE PROCEDURE evergreen.fake_fkey_tgr('target_copy');


--
-- Name: hold_request action_hold_request_aging_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER action_hold_request_aging_tgr BEFORE DELETE ON action.hold_request FOR EACH ROW EXECUTE PROCEDURE action.age_hold_on_delete();


--
-- Name: survey_response action_survey_response_answer_date_fixup_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER action_survey_response_answer_date_fixup_tgr BEFORE INSERT ON action.survey_response FOR EACH ROW EXECUTE PROCEDURE action.survey_response_answer_date_fixup();


--
-- Name: usr_circ_history action_usr_circ_history_target_copy_trig; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER action_usr_circ_history_target_copy_trig AFTER INSERT OR UPDATE ON action.usr_circ_history FOR EACH ROW EXECUTE PROCEDURE evergreen.fake_fkey_tgr('target_copy');


--
-- Name: circulation age_parent_circ; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER age_parent_circ AFTER DELETE ON action.circulation FOR EACH ROW EXECUTE PROCEDURE action.age_parent_circ_on_delete();


--
-- Name: circulation archive_stat_cats_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER archive_stat_cats_tgr AFTER INSERT ON action.circulation FOR EACH ROW EXECUTE PROCEDURE action.archive_stat_cats();


--
-- Name: archived_hold_request archived_hold_request_insert_triggerer; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER archived_hold_request_insert_triggerer BEFORE INSERT ON action.archived_hold_request FOR EACH ROW EXECUTE PROCEDURE action.archived_hold_request_insert_trigger();


--
-- Name: circulation circ_action_log_trigger; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER circ_action_log_trigger AFTER INSERT OR DELETE OR UPDATE ON action.circulation FOR EACH ROW EXECUTE PROCEDURE action_log.track_action_circulation();


--
-- Name: circulation fill_circ_copy_location_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER fill_circ_copy_location_tgr BEFORE INSERT ON action.circulation FOR EACH ROW EXECUTE PROCEDURE action.fill_circ_copy_location();


--
-- Name: hold_copy_map hold_copy_proximity_update_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER hold_copy_proximity_update_tgr BEFORE INSERT OR UPDATE ON action.hold_copy_map FOR EACH ROW EXECUTE PROCEDURE action.hold_copy_calculated_proximity_update();


--
-- Name: hold_request hold_request_clear_map_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER hold_request_clear_map_tgr AFTER UPDATE ON action.hold_request FOR EACH ROW WHEN ((((new.cancel_time IS NOT NULL) AND (old.cancel_time IS NULL)) OR ((new.fulfillment_time IS NOT NULL) AND (old.fulfillment_time IS NULL)))) EXECUTE PROCEDURE action.hold_request_clear_map();


--
-- Name: hold_transit_copy hold_transit_copy_is_unique_check; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER hold_transit_copy_is_unique_check AFTER INSERT ON action.hold_transit_copy NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE action.copy_transit_is_unique();


--
-- Name: circulation maintain_usr_circ_history_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER maintain_usr_circ_history_tgr AFTER INSERT OR UPDATE ON action.circulation FOR EACH ROW EXECUTE PROCEDURE action.maintain_usr_circ_history();


--
-- Name: circulation mat_summary_change_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER mat_summary_change_tgr AFTER UPDATE ON action.circulation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_update();


--
-- Name: circulation mat_summary_create_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER mat_summary_create_tgr AFTER INSERT ON action.circulation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_create('circulation');


--
-- Name: circulation mat_summary_remove_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER mat_summary_remove_tgr AFTER DELETE ON action.circulation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_delete();


--
-- Name: circulation push_due_date_tgr; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER push_due_date_tgr BEFORE INSERT OR UPDATE ON action.circulation FOR EACH ROW EXECUTE PROCEDURE action.push_circ_due_time();


--
-- Name: hold_request reporter_hold_request_record_trigger; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE TRIGGER reporter_hold_request_record_trigger AFTER INSERT OR UPDATE ON action.hold_request FOR EACH ROW EXECUTE PROCEDURE reporter.hold_request_record_mapper();


--
-- Name: reservation_transit_copy reservation_transit_copy_is_unique_check; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER reservation_transit_copy_is_unique_check AFTER INSERT ON action.reservation_transit_copy NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE action.copy_transit_is_unique();


--
-- Name: transit_copy transit_copy_is_unique_check; Type: TRIGGER; Schema: action; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER transit_copy_is_unique_check AFTER INSERT ON action.transit_copy NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE action.copy_transit_is_unique();


--
-- Name: event action_trigger_event_context_item_trig; Type: TRIGGER; Schema: action_trigger; Owner: evergreen
--

CREATE TRIGGER action_trigger_event_context_item_trig AFTER INSERT OR UPDATE ON action_trigger.event FOR EACH ROW EXECUTE PROCEDURE evergreen.fake_fkey_tgr('context_item');


--
-- Name: event_definition audit_action_trigger_event_definition_update_trigger; Type: TRIGGER; Schema: action_trigger; Owner: evergreen
--

CREATE TRIGGER audit_action_trigger_event_definition_update_trigger AFTER DELETE OR UPDATE ON action_trigger.event_definition FOR EACH ROW EXECUTE PROCEDURE auditor.audit_action_trigger_event_definition_func();


--
-- Name: event_definition is_valid_retention_interval; Type: TRIGGER; Schema: action_trigger; Owner: evergreen
--

CREATE TRIGGER is_valid_retention_interval BEFORE INSERT OR UPDATE ON action_trigger.event_definition FOR EACH ROW WHEN ((new.retention_interval IS NOT NULL)) EXECUTE PROCEDURE action_trigger.check_valid_retention_interval();


--
-- Name: usr actor_crypt_pw_insert_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_crypt_pw_insert_trigger BEFORE INSERT ON actor.usr FOR EACH ROW EXECUTE PROCEDURE actor.crypt_pw_insert();


--
-- Name: usr actor_crypt_pw_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_crypt_pw_update_trigger BEFORE UPDATE ON actor.usr FOR EACH ROW EXECUTE PROCEDURE actor.crypt_pw_update();


--
-- Name: usr_setting actor_ignore_no_default_pickup_location; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_ignore_no_default_pickup_location BEFORE INSERT OR UPDATE ON actor.usr_setting FOR EACH ROW EXECUTE PROCEDURE actor.ignore_update_default_pickup_location();


--
-- Name: usr_setting actor_only_kcls_for_default_search_location; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_only_kcls_for_default_search_location BEFORE INSERT OR UPDATE ON actor.usr_setting FOR EACH ROW EXECUTE PROCEDURE actor.ignore_update_default_search_location();


--
-- Name: org_unit actor_org_unit_parent_protect_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_org_unit_parent_protect_trigger BEFORE INSERT OR UPDATE ON actor.org_unit FOR EACH ROW EXECUTE PROCEDURE actor.org_unit_parent_protect();


--
-- Name: stat_cat actor_stat_cat_sip_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_stat_cat_sip_update_trigger BEFORE INSERT OR UPDATE ON actor.stat_cat FOR EACH ROW EXECUTE PROCEDURE actor.stat_cat_check();


--
-- Name: usr actor_update_default_pickup_location; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER actor_update_default_pickup_location AFTER INSERT OR UPDATE ON actor.usr FOR EACH ROW EXECUTE PROCEDURE actor.create_default_pickup_location();


--
-- Name: usr au_update_trig; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER au_update_trig BEFORE INSERT OR UPDATE ON actor.usr FOR EACH ROW EXECUTE PROCEDURE actor.au_updated();


--
-- Name: org_unit audit_actor_org_unit_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER audit_actor_org_unit_update_trigger AFTER DELETE OR UPDATE ON actor.org_unit FOR EACH ROW EXECUTE PROCEDURE auditor.audit_actor_org_unit_func();


--
-- Name: usr_address audit_actor_usr_address_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER audit_actor_usr_address_update_trigger AFTER DELETE OR UPDATE ON actor.usr_address FOR EACH ROW EXECUTE PROCEDURE auditor.audit_actor_usr_address_func();

ALTER TABLE actor.usr_address DISABLE TRIGGER audit_actor_usr_address_update_trigger;


--
-- Name: usr_setting audit_actor_usr_setting_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER audit_actor_usr_setting_update_trigger AFTER DELETE OR UPDATE ON actor.usr_setting FOR EACH ROW EXECUTE PROCEDURE auditor.audit_actor_usr_setting_func();


--
-- Name: usr audit_actor_usr_update_trigger; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER audit_actor_usr_update_trigger AFTER DELETE OR UPDATE ON actor.usr FOR EACH ROW EXECUTE PROCEDURE auditor.audit_actor_usr_func();


--
-- Name: org_unit_setting log_ous_change; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER log_ous_change BEFORE INSERT OR UPDATE ON actor.org_unit_setting FOR EACH ROW EXECUTE PROCEDURE evergreen.ous_change_log();


--
-- Name: org_unit_setting log_ous_del; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER log_ous_del BEFORE DELETE ON actor.org_unit_setting FOR EACH ROW EXECUTE PROCEDURE evergreen.ous_delete_log();


--
-- Name: org_unit proximity_update_tgr; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER proximity_update_tgr AFTER INSERT OR DELETE OR UPDATE ON actor.org_unit FOR EACH ROW EXECUTE PROCEDURE actor.org_unit_prox_update();


--
-- Name: usr_activity remove_transient_usr_activity; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER remove_transient_usr_activity BEFORE INSERT ON actor.usr_activity FOR EACH ROW EXECUTE PROCEDURE actor.usr_activity_transient_trg();


--
-- Name: usr user_ingest_name_keywords_tgr; Type: TRIGGER; Schema: actor; Owner: evergreen
--

CREATE TRIGGER user_ingest_name_keywords_tgr BEFORE INSERT OR UPDATE ON actor.usr FOR EACH ROW EXECUTE PROCEDURE actor.user_ingest_name_keywords();


--
-- Name: copy acp_created_trig; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER acp_created_trig BEFORE INSERT ON asset.copy FOR EACH ROW EXECUTE PROCEDURE asset.acp_created();


--
-- Name: copy acp_location_fixer_trig; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER acp_location_fixer_trig BEFORE INSERT OR UPDATE OF location, call_number, circ_lib ON asset.copy FOR EACH ROW EXECUTE PROCEDURE asset.acp_location_fixer();


--
-- Name: copy acp_status_changed_trig; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER acp_status_changed_trig BEFORE UPDATE ON asset.copy FOR EACH ROW EXECUTE PROCEDURE asset.acp_status_changed();


--
-- Name: copy_inventory asset_copy_inventory_allowed_trig; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER asset_copy_inventory_allowed_trig AFTER INSERT OR UPDATE ON asset.copy_inventory DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE asset.copy_may_float_to_inventory_workstation();


--
-- Name: copy_tag asset_copy_tag_do_value; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER asset_copy_tag_do_value BEFORE INSERT OR UPDATE ON asset.copy_tag FOR EACH ROW EXECUTE PROCEDURE asset.set_copy_tag_value();


--
-- Name: copy_tag asset_copy_tag_fti_trigger; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER asset_copy_tag_fti_trigger BEFORE INSERT OR UPDATE ON asset.copy_tag FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('default');


--
-- Name: call_number asset_label_sortkey_trigger; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER asset_label_sortkey_trigger BEFORE INSERT OR UPDATE ON asset.call_number FOR EACH ROW EXECUTE PROCEDURE asset.label_normalizer();


--
-- Name: stat_cat asset_stat_cat_sip_update_trigger; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER asset_stat_cat_sip_update_trigger BEFORE INSERT OR UPDATE ON asset.stat_cat FOR EACH ROW EXECUTE PROCEDURE asset.stat_cat_check();


--
-- Name: call_number audit_asset_call_number_update_trigger; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER audit_asset_call_number_update_trigger AFTER DELETE OR UPDATE ON asset.call_number FOR EACH ROW EXECUTE PROCEDURE auditor.audit_asset_call_number_func();


--
-- Name: copy audit_asset_copy_update_trigger; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER audit_asset_copy_update_trigger AFTER DELETE OR UPDATE ON asset.copy FOR EACH ROW EXECUTE PROCEDURE auditor.audit_asset_copy_func();


--
-- Name: copy autogenerate_placeholder_barcode; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER autogenerate_placeholder_barcode BEFORE INSERT OR UPDATE ON asset.copy FOR EACH ROW EXECUTE PROCEDURE asset.autogenerate_placeholder_barcode();


--
-- Name: copy_alert inherit_asset_copy_alert_copy_fkey; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER inherit_asset_copy_alert_copy_fkey AFTER INSERT OR UPDATE ON asset.copy_alert DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE evergreen.asset_copy_alert_copy_inh_fkey();


--
-- Name: copy_inventory inherit_asset_copy_inventory_copy_fkey; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER inherit_asset_copy_inventory_copy_fkey AFTER INSERT OR UPDATE ON asset.copy_inventory DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE evergreen.asset_copy_inventory_copy_inh_fkey();


--
-- Name: copy_note inherit_asset_copy_note_copy_fkey; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER inherit_asset_copy_note_copy_fkey AFTER INSERT OR UPDATE ON asset.copy_note DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE evergreen.asset_copy_note_owning_copy_inh_fkey();


--
-- Name: copy_tag_copy_map inherit_asset_copy_tag_copy_map_copy_fkey; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER inherit_asset_copy_tag_copy_map_copy_fkey AFTER INSERT OR UPDATE ON asset.copy_tag_copy_map DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE evergreen.asset_copy_tag_copy_map_copy_inh_fkey();


--
-- Name: call_number_prefix prefix_normalize_tgr; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER prefix_normalize_tgr BEFORE INSERT OR UPDATE ON asset.call_number_prefix FOR EACH ROW EXECUTE PROCEDURE asset.normalize_affix_sortkey();


--
-- Name: call_number_suffix suffix_normalize_tgr; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER suffix_normalize_tgr BEFORE INSERT OR UPDATE ON asset.call_number_suffix FOR EACH ROW EXECUTE PROCEDURE asset.normalize_affix_sortkey();


--
-- Name: copy z_opac_vis_mat_view_del_tgr; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER z_opac_vis_mat_view_del_tgr BEFORE DELETE ON asset.copy FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: call_number z_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER z_opac_vis_mat_view_tgr AFTER UPDATE ON asset.call_number FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: copy z_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: asset; Owner: evergreen
--

CREATE TRIGGER z_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON asset.copy FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: record_entry a_marcxml_is_well_formed; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER a_marcxml_is_well_formed BEFORE INSERT OR UPDATE ON authority.record_entry FOR EACH ROW EXECUTE PROCEDURE biblio.check_marcxml_well_formed();


--
-- Name: record_entry aaa_auth_ingest_or_delete; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER aaa_auth_ingest_or_delete AFTER INSERT OR UPDATE ON authority.record_entry FOR EACH ROW EXECUTE PROCEDURE authority.indexing_ingest_or_delete();


--
-- Name: full_rec authority_full_rec_fti_trigger; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER authority_full_rec_fti_trigger BEFORE INSERT OR UPDATE ON authority.full_rec FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: simple_heading authority_simple_heading_fti_trigger; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER authority_simple_heading_fti_trigger BEFORE INSERT OR UPDATE ON authority.simple_heading FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: record_entry b_maintain_901; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER b_maintain_901 BEFORE INSERT OR UPDATE ON authority.record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_901();


--
-- Name: record_entry c_maintain_control_numbers; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER c_maintain_control_numbers BEFORE INSERT OR UPDATE ON authority.record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_control_numbers();


--
-- Name: record_entry map_thesaurus_to_control_set; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER map_thesaurus_to_control_set BEFORE INSERT OR UPDATE ON authority.record_entry FOR EACH ROW EXECUTE PROCEDURE authority.map_thesaurus_to_control_set();


--
-- Name: thesaurus thes_code_tracking_trigger; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER thes_code_tracking_trigger AFTER UPDATE ON authority.thesaurus FOR EACH ROW EXECUTE PROCEDURE evergreen.oils_i18n_code_tracking('at');


--
-- Name: record_entry update_headings_tgr; Type: TRIGGER; Schema: authority; Owner: evergreen
--

CREATE TRIGGER update_headings_tgr BEFORE INSERT OR UPDATE ON authority.record_entry FOR EACH ROW EXECUTE PROCEDURE authority.normalize_heading_for_upsert();


--
-- Name: record_entry a_marcxml_is_well_formed; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER a_marcxml_is_well_formed BEFORE INSERT OR UPDATE ON biblio.record_entry FOR EACH ROW EXECUTE PROCEDURE biblio.check_marcxml_well_formed();


--
-- Name: record_entry aaa_indexing_ingest_or_delete; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER aaa_indexing_ingest_or_delete AFTER INSERT OR UPDATE ON biblio.record_entry FOR EACH ROW EXECUTE PROCEDURE biblio.indexing_ingest_or_delete();


--
-- Name: record_entry audit_biblio_record_entry_update_trigger; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER audit_biblio_record_entry_update_trigger AFTER DELETE OR UPDATE ON biblio.record_entry FOR EACH ROW EXECUTE PROCEDURE auditor.audit_biblio_record_entry_func();


--
-- Name: record_entry b_maintain_901; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER b_maintain_901 BEFORE INSERT OR UPDATE ON biblio.record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_901();


--
-- Name: record_entry bbb_simple_rec_trigger; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER bbb_simple_rec_trigger AFTER INSERT OR DELETE OR UPDATE ON biblio.record_entry FOR EACH ROW EXECUTE PROCEDURE reporter.simple_rec_trigger();


--
-- Name: record_entry c_maintain_control_numbers; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER c_maintain_control_numbers BEFORE INSERT OR UPDATE ON biblio.record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_control_numbers();


--
-- Name: record_entry fingerprint_tgr; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER fingerprint_tgr BEFORE INSERT OR UPDATE ON biblio.record_entry FOR EACH ROW EXECUTE PROCEDURE biblio.fingerprint_trigger('eng', 'BKS');


--
-- Name: monograph_part norm_sort_label; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER norm_sort_label BEFORE INSERT OR UPDATE ON biblio.monograph_part FOR EACH ROW EXECUTE PROCEDURE biblio.normalize_biblio_monograph_part_sortkey();


--
-- Name: peer_bib_copy_map z_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER z_opac_vis_mat_view_tgr AFTER INSERT OR DELETE ON biblio.peer_bib_copy_map FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: record_entry z_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: biblio; Owner: evergreen
--

CREATE TRIGGER z_opac_vis_mat_view_tgr BEFORE INSERT OR UPDATE ON biblio.record_entry FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: reservation mat_summary_change_tgr; Type: TRIGGER; Schema: booking; Owner: evergreen
--

CREATE TRIGGER mat_summary_change_tgr AFTER UPDATE ON booking.reservation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_update();


--
-- Name: reservation mat_summary_create_tgr; Type: TRIGGER; Schema: booking; Owner: evergreen
--

CREATE TRIGGER mat_summary_create_tgr AFTER INSERT ON booking.reservation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_create('reservation');


--
-- Name: reservation mat_summary_remove_tgr; Type: TRIGGER; Schema: booking; Owner: evergreen
--

CREATE TRIGGER mat_summary_remove_tgr AFTER DELETE ON booking.reservation FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_delete();


--
-- Name: composite_attr_entry_definition ccraed_cache_inval_tgr; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE TRIGGER ccraed_cache_inval_tgr AFTER INSERT OR DELETE OR UPDATE ON config.composite_attr_entry_definition FOR EACH STATEMENT EXECUTE PROCEDURE metabib.composite_attr_def_cache_inval_tgr();


--
-- Name: usr_setting_type check_setting_is_usr_or_ws; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER check_setting_is_usr_or_ws AFTER INSERT OR UPDATE ON config.usr_setting_type NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE config.setting_is_user_or_ws();


--
-- Name: workstation_setting_type check_setting_is_usr_or_ws; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER check_setting_is_usr_or_ws AFTER INSERT OR UPDATE ON config.workstation_setting_type NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE config.setting_is_user_or_ws();


--
-- Name: coded_value_map create_or_update_code_unknown; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE TRIGGER create_or_update_code_unknown AFTER INSERT OR UPDATE ON config.coded_value_map FOR EACH ROW EXECUTE PROCEDURE config.create_or_update_code_unknown();


--
-- Name: org_unit_setting_type_log limit_logs_oust; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE TRIGGER limit_logs_oust BEFORE INSERT OR UPDATE ON config.org_unit_setting_type_log FOR EACH ROW EXECUTE PROCEDURE evergreen.limit_oustl();


--
-- Name: db_patch_dependencies no_overlapping_deps; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE TRIGGER no_overlapping_deps BEFORE INSERT OR UPDATE ON config.db_patch_dependencies FOR EACH ROW EXECUTE PROCEDURE evergreen.array_overlap_check('deprecates');


--
-- Name: db_patch_dependencies no_overlapping_sups; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE TRIGGER no_overlapping_sups BEFORE INSERT OR UPDATE ON config.db_patch_dependencies FOR EACH ROW EXECUTE PROCEDURE evergreen.array_overlap_check('supersedes');


--
-- Name: z3950_index_field_map valid_z3950_attr_type; Type: TRIGGER; Schema: config; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER valid_z3950_attr_type AFTER INSERT OR UPDATE ON config.z3950_index_field_map DEFERRABLE INITIALLY DEFERRED FOR EACH ROW WHEN ((new.z3950_attr_type IS NOT NULL)) EXECUTE PROCEDURE evergreen.z3950_attr_name_is_valid();


--
-- Name: copy_bucket_item inherit_copy_bucket_item_target_copy_fkey; Type: TRIGGER; Schema: container; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER inherit_copy_bucket_item_target_copy_fkey AFTER INSERT OR UPDATE ON container.copy_bucket_item DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE evergreen.container_copy_bucket_item_target_copy_inh_fkey();


--
-- Name: display_entry display_field_force_nfc_tgr; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER display_field_force_nfc_tgr BEFORE INSERT OR UPDATE ON metabib.display_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.display_field_force_nfc();


--
-- Name: display_entry display_field_normalize_tgr; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER display_field_normalize_tgr BEFORE INSERT OR UPDATE ON metabib.display_entry FOR EACH ROW EXECUTE PROCEDURE metabib.display_field_normalize_trigger();


--
-- Name: facet_entry facet_force_nfc_tgr; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER facet_force_nfc_tgr BEFORE INSERT OR UPDATE ON metabib.facet_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.facet_force_nfc();


--
-- Name: facet_entry facet_normalize_tgr; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER facet_normalize_tgr BEFORE INSERT OR UPDATE ON metabib.facet_entry FOR EACH ROW EXECUTE PROCEDURE metabib.facet_normalize_trigger();


--
-- Name: browse_entry_simple_heading_map maintain_browse_metabib_fields_cache_auth_tgr; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER maintain_browse_metabib_fields_cache_auth_tgr AFTER INSERT OR DELETE ON metabib.browse_entry_simple_heading_map FOR EACH ROW EXECUTE PROCEDURE metabib.maintain_browse_metabib_fields_cache();


--
-- Name: browse_entry_def_map maintain_browse_metabib_fields_cache_bib_tgr; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER maintain_browse_metabib_fields_cache_bib_tgr AFTER INSERT OR DELETE ON metabib.browse_entry_def_map FOR EACH ROW EXECUTE PROCEDURE metabib.maintain_browse_metabib_fields_cache();


--
-- Name: author_field_entry metabib_author_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_author_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON metabib.author_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('author');


--
-- Name: browse_entry metabib_browse_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_browse_entry_fti_trigger BEFORE INSERT OR UPDATE ON metabib.browse_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: call_number_field_entry metabib_call_number_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_call_number_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON metabib.call_number_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('call_number');


--
-- Name: real_full_rec metabib_full_rec_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_full_rec_fti_trigger BEFORE INSERT OR UPDATE ON metabib.real_full_rec FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('default');


--
-- Name: identifier_field_entry metabib_identifier_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_identifier_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON metabib.identifier_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('identifier');


--
-- Name: keyword_field_entry metabib_keyword_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_keyword_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON metabib.keyword_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('keyword');


--
-- Name: series_field_entry metabib_series_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_series_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON metabib.series_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('series');


--
-- Name: subject_field_entry metabib_subject_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_subject_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON metabib.subject_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('subject');


--
-- Name: title_field_entry metabib_title_field_entry_fti_trigger; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER metabib_title_field_entry_fti_trigger BEFORE INSERT OR UPDATE ON metabib.title_field_entry FOR EACH ROW EXECUTE PROCEDURE public.oils_tsearch2('title');


--
-- Name: author_field_entry normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON metabib.author_field_entry FOR EACH ROW EXECUTE PROCEDURE metabib.normalized_field_entry_view();

ALTER TABLE metabib.author_field_entry DISABLE TRIGGER normalize_field_entry;


--
-- Name: call_number_field_entry normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON metabib.call_number_field_entry FOR EACH ROW EXECUTE PROCEDURE metabib.normalized_field_entry_view();

ALTER TABLE metabib.call_number_field_entry DISABLE TRIGGER normalize_field_entry;


--
-- Name: keyword_field_entry normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON metabib.keyword_field_entry FOR EACH ROW EXECUTE PROCEDURE metabib.normalized_field_entry_view();

ALTER TABLE metabib.keyword_field_entry DISABLE TRIGGER normalize_field_entry;


--
-- Name: series_field_entry normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON metabib.series_field_entry FOR EACH ROW EXECUTE PROCEDURE metabib.normalized_field_entry_view();

ALTER TABLE metabib.series_field_entry DISABLE TRIGGER normalize_field_entry;


--
-- Name: subject_field_entry normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON metabib.subject_field_entry FOR EACH ROW EXECUTE PROCEDURE metabib.normalized_field_entry_view();

ALTER TABLE metabib.subject_field_entry DISABLE TRIGGER normalize_field_entry;


--
-- Name: title_field_entry normalize_field_entry; Type: TRIGGER; Schema: metabib; Owner: evergreen
--

CREATE TRIGGER normalize_field_entry AFTER INSERT OR UPDATE ON metabib.title_field_entry FOR EACH ROW EXECUTE PROCEDURE metabib.normalized_field_entry_view();

ALTER TABLE metabib.title_field_entry DISABLE TRIGGER normalize_field_entry;


--
-- Name: refundable_payment gen_refundable_payment_number_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER gen_refundable_payment_number_tgr BEFORE INSERT ON money.refundable_payment FOR EACH ROW EXECUTE PROCEDURE evergreen.gen_refundable_payment_number();


--
-- Name: billing maintain_billing_ts_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER maintain_billing_ts_tgr BEFORE INSERT OR UPDATE ON money.billing FOR EACH ROW EXECUTE PROCEDURE money.maintain_billing_ts();


--
-- Name: account_adjustment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.account_adjustment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('account_adjustment');


--
-- Name: billing mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.billing FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_billing_add();


--
-- Name: bnm_desk_payment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.bnm_desk_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('bnm_desk_payment');


--
-- Name: bnm_payment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.bnm_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('bnm_payment');


--
-- Name: cash_payment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.cash_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('cash_payment');


--
-- Name: check_payment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.check_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('check_payment');


--
-- Name: credit_card_payment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.credit_card_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('credit_card_payment');


--
-- Name: credit_payment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.credit_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('credit_payment');


--
-- Name: debit_card_payment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.debit_card_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('debit_card_payment');


--
-- Name: forgive_payment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.forgive_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('forgive_payment');


--
-- Name: goods_payment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.goods_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('goods_payment');


--
-- Name: payment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('payment');


--
-- Name: work_payment mat_summary_add_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_add_tgr AFTER INSERT ON money.work_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_add('work_payment');


--
-- Name: grocery mat_summary_change_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_change_tgr AFTER UPDATE ON money.grocery FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_update();


--
-- Name: grocery mat_summary_create_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_create_tgr AFTER INSERT ON money.grocery FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_create('grocery');


--
-- Name: account_adjustment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.account_adjustment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('account_adjustment');


--
-- Name: billing mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.billing FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_billing_del();


--
-- Name: bnm_desk_payment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.bnm_desk_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('bnm_desk_payment');


--
-- Name: bnm_payment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.bnm_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('bnm_payment');


--
-- Name: cash_payment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.cash_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('cash_payment');


--
-- Name: check_payment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.check_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('check_payment');


--
-- Name: credit_card_payment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.credit_card_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('credit_card_payment');


--
-- Name: credit_payment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.credit_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('credit_payment');


--
-- Name: debit_card_payment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.debit_card_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('debit_card_payment');


--
-- Name: forgive_payment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.forgive_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('forgive_payment');


--
-- Name: goods_payment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.goods_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('goods_payment');


--
-- Name: payment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('payment');


--
-- Name: work_payment mat_summary_del_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_del_tgr BEFORE DELETE ON money.work_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_del('work_payment');


--
-- Name: grocery mat_summary_remove_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_remove_tgr AFTER DELETE ON money.grocery FOR EACH ROW EXECUTE PROCEDURE money.mat_summary_delete();


--
-- Name: account_adjustment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.account_adjustment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('account_adjustment');


--
-- Name: billing mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.billing FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_billing_update();


--
-- Name: bnm_desk_payment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.bnm_desk_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('bnm_desk_payment');


--
-- Name: bnm_payment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.bnm_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('bnm_payment');


--
-- Name: cash_payment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.cash_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('cash_payment');


--
-- Name: check_payment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.check_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('check_payment');


--
-- Name: credit_card_payment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.credit_card_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('credit_card_payment');


--
-- Name: credit_payment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.credit_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('credit_payment');


--
-- Name: debit_card_payment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.debit_card_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('debit_card_payment');


--
-- Name: forgive_payment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.forgive_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('forgive_payment');


--
-- Name: goods_payment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.goods_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('goods_payment');


--
-- Name: payment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('payment');


--
-- Name: work_payment mat_summary_upd_tgr; Type: TRIGGER; Schema: money; Owner: evergreen
--

CREATE TRIGGER mat_summary_upd_tgr AFTER UPDATE ON money.work_payment FOR EACH ROW EXECUTE PROCEDURE money.materialized_summary_payment_update('work_payment');


--
-- Name: perm_list maintain_perm_i18n_tgr; Type: TRIGGER; Schema: permission; Owner: evergreen
--

CREATE TRIGGER maintain_perm_i18n_tgr AFTER UPDATE ON permission.perm_list FOR EACH ROW EXECUTE PROCEDURE evergreen.oils_i18n_id_tracking('ppl');


--
-- Name: unit audit_serial_unit_update_trigger; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER audit_serial_unit_update_trigger AFTER DELETE OR UPDATE ON serial.unit FOR EACH ROW EXECUTE PROCEDURE auditor.audit_serial_unit_func();


--
-- Name: unit autogenerate_placeholder_barcode; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER autogenerate_placeholder_barcode BEFORE INSERT OR UPDATE ON serial.unit FOR EACH ROW EXECUTE PROCEDURE asset.autogenerate_placeholder_barcode();


--
-- Name: record_entry b_maintain_901; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER b_maintain_901 BEFORE INSERT OR UPDATE ON serial.record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_901();


--
-- Name: record_entry c_maintain_control_numbers; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER c_maintain_control_numbers BEFORE INSERT OR UPDATE ON serial.record_entry FOR EACH ROW EXECUTE PROCEDURE evergreen.maintain_control_numbers();


--
-- Name: issuance materialize_holding_code; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER materialize_holding_code AFTER INSERT OR UPDATE ON serial.issuance FOR EACH ROW EXECUTE PROCEDURE serial.materialize_holding_code();


--
-- Name: unit sunit_created_trig; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER sunit_created_trig BEFORE INSERT ON serial.unit FOR EACH ROW EXECUTE PROCEDURE asset.acp_created();


--
-- Name: unit sunit_status_changed_trig; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER sunit_status_changed_trig BEFORE UPDATE ON serial.unit FOR EACH ROW EXECUTE PROCEDURE asset.acp_status_changed();


--
-- Name: unit z_opac_vis_mat_view_del_tgr; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER z_opac_vis_mat_view_del_tgr BEFORE DELETE ON serial.unit FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: unit z_opac_vis_mat_view_tgr; Type: TRIGGER; Schema: serial; Owner: evergreen
--

CREATE TRIGGER z_opac_vis_mat_view_tgr AFTER INSERT OR UPDATE ON serial.unit FOR EACH ROW EXECUTE PROCEDURE asset.cache_copy_visibility();


--
-- Name: url ingest_url_tgr; Type: TRIGGER; Schema: url_verify; Owner: evergreen
--

CREATE TRIGGER ingest_url_tgr BEFORE INSERT ON url_verify.url FOR EACH ROW EXECUTE PROCEDURE url_verify.ingest_url();


--
-- Name: queued_authority_record cleanup_authority_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER cleanup_authority_trigger BEFORE DELETE OR UPDATE ON vandelay.queued_authority_record FOR EACH ROW EXECUTE PROCEDURE vandelay.cleanup_authority_marc();


--
-- Name: queued_bib_record cleanup_bib_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER cleanup_bib_trigger BEFORE DELETE OR UPDATE ON vandelay.queued_bib_record FOR EACH ROW EXECUTE PROCEDURE vandelay.cleanup_bib_marc();


--
-- Name: queued_authority_record ingest_authority_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER ingest_authority_trigger AFTER INSERT OR UPDATE ON vandelay.queued_authority_record FOR EACH ROW EXECUTE PROCEDURE vandelay.ingest_authority_marc();


--
-- Name: queued_bib_record ingest_bib_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER ingest_bib_trigger AFTER INSERT OR UPDATE ON vandelay.queued_bib_record FOR EACH ROW EXECUTE PROCEDURE vandelay.ingest_bib_marc();


--
-- Name: queued_bib_record ingest_item_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER ingest_item_trigger AFTER INSERT OR UPDATE ON vandelay.queued_bib_record FOR EACH ROW EXECUTE PROCEDURE vandelay.ingest_bib_items();


--
-- Name: import_item inherit_import_item_imported_as_fkey; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE CONSTRAINT TRIGGER inherit_import_item_imported_as_fkey AFTER INSERT OR UPDATE ON vandelay.import_item DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE evergreen.vandelay_import_item_imported_as_inh_fkey();


--
-- Name: queued_authority_record zz_match_auth_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER zz_match_auth_trigger BEFORE INSERT OR UPDATE ON vandelay.queued_authority_record FOR EACH ROW EXECUTE PROCEDURE vandelay.match_auth_record();


--
-- Name: queued_authority_record zz_match_auths_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER zz_match_auths_trigger BEFORE INSERT OR UPDATE ON vandelay.queued_authority_record FOR EACH ROW EXECUTE PROCEDURE vandelay.match_authority_record();


--
-- Name: queued_bib_record zz_match_bibs_trigger; Type: TRIGGER; Schema: vandelay; Owner: evergreen
--

CREATE TRIGGER zz_match_bibs_trigger BEFORE INSERT OR UPDATE ON vandelay.queued_bib_record FOR EACH ROW EXECUTE PROCEDURE vandelay.match_bib_record();


--
-- Name: provider acq_provider_primary_contact_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider
    ADD CONSTRAINT acq_provider_primary_contact_fkey FOREIGN KEY (primary_contact) REFERENCES acq.provider_contact(id) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: cancel_reason cancel_reason_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.cancel_reason
    ADD CONSTRAINT cancel_reason_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event claim_event_claim_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_event
    ADD CONSTRAINT claim_event_claim_fkey FOREIGN KEY (claim) REFERENCES acq.claim(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event claim_event_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_event
    ADD CONSTRAINT claim_event_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event claim_event_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_event
    ADD CONSTRAINT claim_event_type_fkey FOREIGN KEY (type) REFERENCES acq.claim_event_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_event_type claim_event_type_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_event_type
    ADD CONSTRAINT claim_event_type_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim claim_lineitem_detail_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim
    ADD CONSTRAINT claim_lineitem_detail_fkey FOREIGN KEY (lineitem_detail) REFERENCES acq.lineitem_detail(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_policy_action claim_policy_action_action_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_policy_action
    ADD CONSTRAINT claim_policy_action_action_fkey FOREIGN KEY (action) REFERENCES acq.claim_event_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_policy_action claim_policy_action_claim_policy_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_policy_action
    ADD CONSTRAINT claim_policy_action_claim_policy_fkey FOREIGN KEY (claim_policy) REFERENCES acq.claim_policy(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_policy claim_policy_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_policy
    ADD CONSTRAINT claim_policy_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim claim_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim
    ADD CONSTRAINT claim_type_fkey FOREIGN KEY (type) REFERENCES acq.claim_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: claim_type claim_type_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.claim_type
    ADD CONSTRAINT claim_type_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: debit_attribution debit_attribution_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.debit_attribution
    ADD CONSTRAINT debit_attribution_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES acq.fund_debit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: debit_attribution debit_attribution_funding_source_credit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.debit_attribution
    ADD CONSTRAINT debit_attribution_funding_source_credit_fkey FOREIGN KEY (funding_source_credit) REFERENCES acq.funding_source_credit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_application distribution_formula_application_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_application distribution_formula_application_formula_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_formula_fkey FOREIGN KEY (formula) REFERENCES acq.distribution_formula(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_application distribution_formula_application_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_application
    ADD CONSTRAINT distribution_formula_application_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES acq.lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_entry distribution_formula_entry_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES config.circ_modifier(code);


--
-- Name: distribution_formula_entry distribution_formula_entry_formula_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_formula_fkey FOREIGN KEY (formula) REFERENCES acq.distribution_formula(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula_entry distribution_formula_entry_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_fund_fkey FOREIGN KEY (fund) REFERENCES acq.fund(id);


--
-- Name: distribution_formula_entry distribution_formula_entry_location_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_location_fkey FOREIGN KEY (location) REFERENCES asset.copy_location(id);


--
-- Name: distribution_formula_entry distribution_formula_entry_owning_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula_entry
    ADD CONSTRAINT distribution_formula_entry_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_formula distribution_formula_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.distribution_formula
    ADD CONSTRAINT distribution_formula_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: edi_account edi_account_attr_set_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_account
    ADD CONSTRAINT edi_account_attr_set_fkey FOREIGN KEY (attr_set) REFERENCES acq.edi_attr_set(id);


--
-- Name: edi_account edi_account_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_account
    ADD CONSTRAINT edi_account_provider_fkey FOREIGN KEY (provider) REFERENCES acq.provider(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: edi_attr_set_map edi_attr_set_map_attr_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_attr_set_map
    ADD CONSTRAINT edi_attr_set_map_attr_fkey FOREIGN KEY (attr) REFERENCES acq.edi_attr(key) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: edi_attr_set_map edi_attr_set_map_attr_set_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_attr_set_map
    ADD CONSTRAINT edi_attr_set_map_attr_set_fkey FOREIGN KEY (attr_set) REFERENCES acq.edi_attr_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: edi_message edi_message_account_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_message
    ADD CONSTRAINT edi_message_account_fkey FOREIGN KEY (account) REFERENCES acq.edi_account(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: edi_message edi_message_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.edi_message
    ADD CONSTRAINT edi_message_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES acq.purchase_order(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: exchange_rate exchange_rate_from_currency_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.exchange_rate
    ADD CONSTRAINT exchange_rate_from_currency_fkey FOREIGN KEY (from_currency) REFERENCES acq.currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: exchange_rate exchange_rate_to_currency_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.exchange_rate
    ADD CONSTRAINT exchange_rate_to_currency_fkey FOREIGN KEY (to_currency) REFERENCES acq.currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fiscal_year fiscal_year_calendar_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fiscal_year
    ADD CONSTRAINT fiscal_year_calendar_fkey FOREIGN KEY (calendar) REFERENCES acq.fiscal_calendar(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation fund_allocation_allocator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_allocation
    ADD CONSTRAINT fund_allocation_allocator_fkey FOREIGN KEY (allocator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation fund_allocation_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_allocation
    ADD CONSTRAINT fund_allocation_fund_fkey FOREIGN KEY (fund) REFERENCES acq.fund(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation fund_allocation_funding_source_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_allocation
    ADD CONSTRAINT fund_allocation_funding_source_fkey FOREIGN KEY (funding_source) REFERENCES acq.funding_source(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_percent fund_allocation_percent_allocator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_allocator_fkey FOREIGN KEY (allocator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_percent fund_allocation_percent_funding_source_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_funding_source_fkey FOREIGN KEY (funding_source) REFERENCES acq.funding_source(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_allocation_percent fund_allocation_percent_org_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_allocation_percent
    ADD CONSTRAINT fund_allocation_percent_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund fund_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund
    ADD CONSTRAINT fund_currency_type_fkey FOREIGN KEY (currency_type) REFERENCES acq.currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_debit fund_debit_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_debit
    ADD CONSTRAINT fund_debit_fund_fkey FOREIGN KEY (fund) REFERENCES acq.fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_debit fund_debit_invoice_entry_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_debit
    ADD CONSTRAINT fund_debit_invoice_entry_fkey FOREIGN KEY (invoice_entry) REFERENCES acq.invoice_entry(id) ON DELETE SET NULL;


--
-- Name: fund_debit fund_debit_origin_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_debit
    ADD CONSTRAINT fund_debit_origin_currency_type_fkey FOREIGN KEY (origin_currency_type) REFERENCES acq.currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_debit fund_debit_xfer_destination_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_debit
    ADD CONSTRAINT fund_debit_xfer_destination_fkey FOREIGN KEY (xfer_destination) REFERENCES acq.fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund fund_org_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund
    ADD CONSTRAINT fund_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_tag_map fund_tag_map_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_tag_map
    ADD CONSTRAINT fund_tag_map_fund_fkey FOREIGN KEY (fund) REFERENCES acq.fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_tag_map fund_tag_map_tag_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_tag_map
    ADD CONSTRAINT fund_tag_map_tag_fkey FOREIGN KEY (tag) REFERENCES acq.fund_tag(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_tag fund_tag_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_tag
    ADD CONSTRAINT fund_tag_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer fund_transfer_dest_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_transfer
    ADD CONSTRAINT fund_transfer_dest_fund_fkey FOREIGN KEY (dest_fund) REFERENCES acq.fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer fund_transfer_funding_source_credit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_transfer
    ADD CONSTRAINT fund_transfer_funding_source_credit_fkey FOREIGN KEY (funding_source_credit) REFERENCES acq.funding_source_credit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer fund_transfer_src_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_transfer
    ADD CONSTRAINT fund_transfer_src_fund_fkey FOREIGN KEY (src_fund) REFERENCES acq.fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fund_transfer fund_transfer_transfer_user_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.fund_transfer
    ADD CONSTRAINT fund_transfer_transfer_user_fkey FOREIGN KEY (transfer_user) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: funding_source_credit funding_source_credit_funding_source_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.funding_source_credit
    ADD CONSTRAINT funding_source_credit_funding_source_fkey FOREIGN KEY (funding_source) REFERENCES acq.funding_source(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: funding_source funding_source_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.funding_source
    ADD CONSTRAINT funding_source_currency_type_fkey FOREIGN KEY (currency_type) REFERENCES acq.currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: funding_source funding_source_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.funding_source
    ADD CONSTRAINT funding_source_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice invoice_closed_by_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice
    ADD CONSTRAINT invoice_closed_by_fkey FOREIGN KEY (closed_by) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice_entry invoice_entry_invoice_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_entry
    ADD CONSTRAINT invoice_entry_invoice_fkey FOREIGN KEY (invoice) REFERENCES acq.invoice(id) ON DELETE CASCADE;


--
-- Name: invoice_entry invoice_entry_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_entry
    ADD CONSTRAINT invoice_entry_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES acq.lineitem(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: invoice_entry invoice_entry_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_entry
    ADD CONSTRAINT invoice_entry_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES acq.purchase_order(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: invoice_item invoice_item_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_item
    ADD CONSTRAINT invoice_item_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES acq.fund_debit(id);


--
-- Name: invoice_item invoice_item_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_item
    ADD CONSTRAINT invoice_item_fund_fkey FOREIGN KEY (fund) REFERENCES acq.fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice_item invoice_item_inv_item_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_item
    ADD CONSTRAINT invoice_item_inv_item_type_fkey FOREIGN KEY (inv_item_type) REFERENCES acq.invoice_item_type(code);


--
-- Name: invoice_item invoice_item_invoice_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_item
    ADD CONSTRAINT invoice_item_invoice_fkey FOREIGN KEY (invoice) REFERENCES acq.invoice(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: invoice_item invoice_item_po_item_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_item
    ADD CONSTRAINT invoice_item_po_item_fkey FOREIGN KEY (po_item) REFERENCES acq.po_item(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice_item invoice_item_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice_item
    ADD CONSTRAINT invoice_item_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES acq.purchase_order(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: invoice invoice_payment_method_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice
    ADD CONSTRAINT invoice_payment_method_fkey FOREIGN KEY (payment_method) REFERENCES acq.invoice_payment_method(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: invoice invoice_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice
    ADD CONSTRAINT invoice_provider_fkey FOREIGN KEY (provider) REFERENCES acq.provider(id);


--
-- Name: invoice invoice_receiver_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice
    ADD CONSTRAINT invoice_receiver_fkey FOREIGN KEY (receiver) REFERENCES actor.org_unit(id);


--
-- Name: invoice invoice_recv_method_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice
    ADD CONSTRAINT invoice_recv_method_fkey FOREIGN KEY (recv_method) REFERENCES acq.invoice_method(code);


--
-- Name: invoice invoice_shipper_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.invoice
    ADD CONSTRAINT invoice_shipper_fkey FOREIGN KEY (shipper) REFERENCES acq.provider(id);


--
-- Name: lineitem_alert_text lineitem_alert_text_owning_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_alert_text
    ADD CONSTRAINT lineitem_alert_text_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_attr lineitem_attr_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_attr
    ADD CONSTRAINT lineitem_attr_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES acq.lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem lineitem_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem
    ADD CONSTRAINT lineitem_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES acq.cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem lineitem_claim_policy_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem
    ADD CONSTRAINT lineitem_claim_policy_fkey FOREIGN KEY (claim_policy) REFERENCES acq.claim_policy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem lineitem_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem
    ADD CONSTRAINT lineitem_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail lineitem_detail_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_detail
    ADD CONSTRAINT lineitem_detail_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES acq.cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail lineitem_detail_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_detail
    ADD CONSTRAINT lineitem_detail_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES config.circ_modifier(code) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail lineitem_detail_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_detail
    ADD CONSTRAINT lineitem_detail_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES acq.fund_debit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail lineitem_detail_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_detail
    ADD CONSTRAINT lineitem_detail_fund_fkey FOREIGN KEY (fund) REFERENCES acq.fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail lineitem_detail_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_detail
    ADD CONSTRAINT lineitem_detail_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES acq.lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail lineitem_detail_location_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_detail
    ADD CONSTRAINT lineitem_detail_location_fkey FOREIGN KEY (location) REFERENCES asset.copy_location(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail lineitem_detail_owning_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_detail
    ADD CONSTRAINT lineitem_detail_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_detail lineitem_detail_receiver_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_detail
    ADD CONSTRAINT lineitem_detail_receiver_fkey FOREIGN KEY (receiver) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem lineitem_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem
    ADD CONSTRAINT lineitem_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem lineitem_eg_bib_id_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem
    ADD CONSTRAINT lineitem_eg_bib_id_fkey FOREIGN KEY (eg_bib_id) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note lineitem_note_alert_text_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_note
    ADD CONSTRAINT lineitem_note_alert_text_fkey FOREIGN KEY (alert_text) REFERENCES acq.lineitem_alert_text(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note lineitem_note_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_note
    ADD CONSTRAINT lineitem_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note lineitem_note_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_note
    ADD CONSTRAINT lineitem_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_note lineitem_note_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_note
    ADD CONSTRAINT lineitem_note_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES acq.lineitem(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem lineitem_picklist_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem
    ADD CONSTRAINT lineitem_picklist_fkey FOREIGN KEY (picklist) REFERENCES acq.picklist(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_provider_attr_definition lineitem_provider_attr_definition_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_provider_attr_definition
    ADD CONSTRAINT lineitem_provider_attr_definition_provider_fkey FOREIGN KEY (provider) REFERENCES acq.provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem lineitem_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem
    ADD CONSTRAINT lineitem_provider_fkey FOREIGN KEY (provider) REFERENCES acq.provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem lineitem_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem
    ADD CONSTRAINT lineitem_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES acq.purchase_order(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem lineitem_queued_record_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem
    ADD CONSTRAINT lineitem_queued_record_fkey FOREIGN KEY (queued_record) REFERENCES vandelay.queued_bib_record(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem lineitem_selector_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem
    ADD CONSTRAINT lineitem_selector_fkey FOREIGN KEY (selector) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: lineitem_usr_attr_definition lineitem_usr_attr_definition_usr_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.lineitem_usr_attr_definition
    ADD CONSTRAINT lineitem_usr_attr_definition_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist picklist_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.picklist
    ADD CONSTRAINT picklist_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist picklist_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.picklist
    ADD CONSTRAINT picklist_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist picklist_org_unit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.picklist
    ADD CONSTRAINT picklist_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: picklist picklist_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.picklist
    ADD CONSTRAINT picklist_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item po_item_fund_debit_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.po_item
    ADD CONSTRAINT po_item_fund_debit_fkey FOREIGN KEY (fund_debit) REFERENCES acq.fund_debit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item po_item_fund_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.po_item
    ADD CONSTRAINT po_item_fund_fkey FOREIGN KEY (fund) REFERENCES acq.fund(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item po_item_inv_item_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.po_item
    ADD CONSTRAINT po_item_inv_item_type_fkey FOREIGN KEY (inv_item_type) REFERENCES acq.invoice_item_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_item po_item_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.po_item
    ADD CONSTRAINT po_item_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES acq.purchase_order(id) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_note po_note_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.po_note
    ADD CONSTRAINT po_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_note po_note_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.po_note
    ADD CONSTRAINT po_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: po_note po_note_purchase_order_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.po_note
    ADD CONSTRAINT po_note_purchase_order_fkey FOREIGN KEY (purchase_order) REFERENCES acq.purchase_order(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_address provider_address_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_address
    ADD CONSTRAINT provider_address_provider_fkey FOREIGN KEY (provider) REFERENCES acq.provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_contact_address provider_contact_address_contact_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_contact_address
    ADD CONSTRAINT provider_contact_address_contact_fkey FOREIGN KEY (contact) REFERENCES acq.provider_contact(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_contact provider_contact_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_contact
    ADD CONSTRAINT provider_contact_provider_fkey FOREIGN KEY (provider) REFERENCES acq.provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider provider_currency_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider
    ADD CONSTRAINT provider_currency_type_fkey FOREIGN KEY (currency_type) REFERENCES acq.currency_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider provider_default_claim_policy_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider
    ADD CONSTRAINT provider_default_claim_policy_fkey FOREIGN KEY (default_claim_policy) REFERENCES acq.claim_policy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider provider_edi_default_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider
    ADD CONSTRAINT provider_edi_default_fkey FOREIGN KEY (edi_default) REFERENCES acq.edi_account(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_holding_subfield_map provider_holding_subfield_map_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_holding_subfield_map
    ADD CONSTRAINT provider_holding_subfield_map_provider_fkey FOREIGN KEY (provider) REFERENCES acq.provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_note provider_note_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_note
    ADD CONSTRAINT provider_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_note provider_note_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_note
    ADD CONSTRAINT provider_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider_note provider_note_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider_note
    ADD CONSTRAINT provider_note_provider_fkey FOREIGN KEY (provider) REFERENCES acq.provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: provider provider_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.provider
    ADD CONSTRAINT provider_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order purchase_order_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.purchase_order
    ADD CONSTRAINT purchase_order_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES acq.cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order purchase_order_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.purchase_order
    ADD CONSTRAINT purchase_order_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order purchase_order_editor_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.purchase_order
    ADD CONSTRAINT purchase_order_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order purchase_order_ordering_agency_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.purchase_order
    ADD CONSTRAINT purchase_order_ordering_agency_fkey FOREIGN KEY (ordering_agency) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order purchase_order_owner_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.purchase_order
    ADD CONSTRAINT purchase_order_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: purchase_order purchase_order_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.purchase_order
    ADD CONSTRAINT purchase_order_provider_fkey FOREIGN KEY (provider) REFERENCES acq.provider(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_event serial_claim_event_claim_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.serial_claim_event
    ADD CONSTRAINT serial_claim_event_claim_fkey FOREIGN KEY (claim) REFERENCES acq.serial_claim(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_event serial_claim_event_creator_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.serial_claim_event
    ADD CONSTRAINT serial_claim_event_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim_event serial_claim_event_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.serial_claim_event
    ADD CONSTRAINT serial_claim_event_type_fkey FOREIGN KEY (type) REFERENCES acq.claim_event_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim serial_claim_item_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.serial_claim
    ADD CONSTRAINT serial_claim_item_fkey FOREIGN KEY (item) REFERENCES serial.item(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: serial_claim serial_claim_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.serial_claim
    ADD CONSTRAINT serial_claim_type_fkey FOREIGN KEY (type) REFERENCES acq.claim_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: shipment_notification_entry shipment_notification_entry_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification_entry
    ADD CONSTRAINT shipment_notification_entry_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES acq.lineitem(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: shipment_notification_entry shipment_notification_entry_shipment_notification_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification_entry
    ADD CONSTRAINT shipment_notification_entry_shipment_notification_fkey FOREIGN KEY (shipment_notification) REFERENCES acq.shipment_notification(id) ON DELETE CASCADE;


--
-- Name: shipment_notification shipment_notification_processed_by_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification
    ADD CONSTRAINT shipment_notification_processed_by_fkey FOREIGN KEY (processed_by) REFERENCES actor.usr(id) ON DELETE SET NULL;


--
-- Name: shipment_notification shipment_notification_provider_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification
    ADD CONSTRAINT shipment_notification_provider_fkey FOREIGN KEY (provider) REFERENCES acq.provider(id);


--
-- Name: shipment_notification shipment_notification_receiver_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification
    ADD CONSTRAINT shipment_notification_receiver_fkey FOREIGN KEY (receiver) REFERENCES actor.org_unit(id);


--
-- Name: shipment_notification shipment_notification_recv_method_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification
    ADD CONSTRAINT shipment_notification_recv_method_fkey FOREIGN KEY (recv_method) REFERENCES acq.invoice_method(code);


--
-- Name: shipment_notification shipment_notification_shipper_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.shipment_notification
    ADD CONSTRAINT shipment_notification_shipper_fkey FOREIGN KEY (shipper) REFERENCES acq.provider(id);


--
-- Name: user_request user_request_cancel_reason_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request
    ADD CONSTRAINT user_request_cancel_reason_fkey FOREIGN KEY (cancel_reason) REFERENCES acq.cancel_reason(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_request user_request_eg_bib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request
    ADD CONSTRAINT user_request_eg_bib_fkey FOREIGN KEY (eg_bib) REFERENCES biblio.record_entry(id) ON DELETE CASCADE;


--
-- Name: user_request user_request_lineitem_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request
    ADD CONSTRAINT user_request_lineitem_fkey FOREIGN KEY (lineitem) REFERENCES acq.lineitem(id) ON DELETE CASCADE;


--
-- Name: user_request user_request_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request
    ADD CONSTRAINT user_request_pickup_lib_fkey FOREIGN KEY (pickup_lib) REFERENCES actor.org_unit(id);


--
-- Name: user_request user_request_request_type_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request
    ADD CONSTRAINT user_request_request_type_fkey FOREIGN KEY (request_type) REFERENCES acq.user_request_type(id);


--
-- Name: user_request user_request_usr_fkey; Type: FK CONSTRAINT; Schema: acq; Owner: evergreen
--

ALTER TABLE ONLY acq.user_request
    ADD CONSTRAINT user_request_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id);


--
-- Name: circulation action_circulation_circ_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.circulation
    ADD CONSTRAINT action_circulation_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation action_circulation_usr_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.circulation
    ADD CONSTRAINT action_circulation_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_transit_copy artc_tc_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.reservation_transit_copy
    ADD CONSTRAINT artc_tc_fkey FOREIGN KEY (target_copy) REFERENCES booking.resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: batch_hold_event batch_hold_event_bucket_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.batch_hold_event
    ADD CONSTRAINT batch_hold_event_bucket_fkey FOREIGN KEY (bucket) REFERENCES container.user_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: batch_hold_event_map batch_hold_event_map_batch_hold_event_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.batch_hold_event_map
    ADD CONSTRAINT batch_hold_event_map_batch_hold_event_fkey FOREIGN KEY (batch_hold_event) REFERENCES action.batch_hold_event(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: batch_hold_event_map batch_hold_event_map_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.batch_hold_event_map
    ADD CONSTRAINT batch_hold_event_map_hold_fkey FOREIGN KEY (hold) REFERENCES action.hold_request(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: batch_hold_event batch_hold_event_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.batch_hold_event
    ADD CONSTRAINT batch_hold_event_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: circulation circulation_checkin_workstation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.circulation
    ADD CONSTRAINT circulation_checkin_workstation_fkey FOREIGN KEY (checkin_workstation) REFERENCES actor.workstation(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation circulation_copy_location_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.circulation
    ADD CONSTRAINT circulation_copy_location_fkey FOREIGN KEY (copy_location) REFERENCES asset.copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_limit_group_map circulation_limit_group_map_circ_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.circulation_limit_group_map
    ADD CONSTRAINT circulation_limit_group_map_circ_fkey FOREIGN KEY (circ) REFERENCES action.circulation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation_limit_group_map circulation_limit_group_map_limit_group_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.circulation_limit_group_map
    ADD CONSTRAINT circulation_limit_group_map_limit_group_fkey FOREIGN KEY (limit_group) REFERENCES config.circ_limit_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation circulation_parent_circ_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.circulation
    ADD CONSTRAINT circulation_parent_circ_fkey FOREIGN KEY (parent_circ) REFERENCES action.circulation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circulation circulation_workstation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.circulation
    ADD CONSTRAINT circulation_workstation_fkey FOREIGN KEY (workstation) REFERENCES actor.workstation(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: curbside curbside_delivery_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.curbside
    ADD CONSTRAINT curbside_delivery_staff_fkey FOREIGN KEY (delivery_staff) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: curbside curbside_org_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.curbside
    ADD CONSTRAINT curbside_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: curbside curbside_patron_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.curbside
    ADD CONSTRAINT curbside_patron_fkey FOREIGN KEY (patron) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: curbside curbside_stage_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.curbside
    ADD CONSTRAINT curbside_stage_staff_fkey FOREIGN KEY (stage_staff) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: emergency_closing_circulation emergency_closing_circulation_circulation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_circulation
    ADD CONSTRAINT emergency_closing_circulation_circulation_fkey FOREIGN KEY (circulation) REFERENCES action.circulation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: emergency_closing_circulation emergency_closing_circulation_emergency_closing_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_circulation
    ADD CONSTRAINT emergency_closing_circulation_emergency_closing_fkey FOREIGN KEY (emergency_closing) REFERENCES action.emergency_closing(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: emergency_closing emergency_closing_creator_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing
    ADD CONSTRAINT emergency_closing_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: emergency_closing_hold emergency_closing_hold_emergency_closing_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_hold
    ADD CONSTRAINT emergency_closing_hold_emergency_closing_fkey FOREIGN KEY (emergency_closing) REFERENCES action.emergency_closing(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: emergency_closing_hold emergency_closing_hold_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_hold
    ADD CONSTRAINT emergency_closing_hold_hold_fkey FOREIGN KEY (hold) REFERENCES action.hold_request(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: emergency_closing_reservation emergency_closing_reservation_emergency_closing_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_reservation
    ADD CONSTRAINT emergency_closing_reservation_emergency_closing_fkey FOREIGN KEY (emergency_closing) REFERENCES action.emergency_closing(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: emergency_closing_reservation emergency_closing_reservation_reservation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.emergency_closing_reservation
    ADD CONSTRAINT emergency_closing_reservation_reservation_fkey FOREIGN KEY (reservation) REFERENCES booking.reservation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_col_val fieldset_col_val_fieldset_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset_col_val
    ADD CONSTRAINT fieldset_col_val_fieldset_fkey FOREIGN KEY (fieldset) REFERENCES action.fieldset(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset fieldset_fieldset_group_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset
    ADD CONSTRAINT fieldset_fieldset_group_fkey FOREIGN KEY (fieldset_group) REFERENCES action.fieldset_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_group fieldset_group_creator_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset_group
    ADD CONSTRAINT fieldset_group_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_group fieldset_group_owning_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset_group
    ADD CONSTRAINT fieldset_group_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset_group fieldset_group_rollback_group_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset_group
    ADD CONSTRAINT fieldset_group_rollback_group_fkey FOREIGN KEY (rollback_group) REFERENCES action.fieldset_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset fieldset_owner_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset
    ADD CONSTRAINT fieldset_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset fieldset_owning_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset
    ADD CONSTRAINT fieldset_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: fieldset fieldset_stored_query_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.fieldset
    ADD CONSTRAINT fieldset_stored_query_fkey FOREIGN KEY (stored_query) REFERENCES query.stored_query(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_copy_map hold_copy_map_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_copy_map
    ADD CONSTRAINT hold_copy_map_hold_fkey FOREIGN KEY (hold) REFERENCES action.hold_request(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_notification hold_notification_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_notification
    ADD CONSTRAINT hold_notification_hold_fkey FOREIGN KEY (hold) REFERENCES action.hold_request(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_notification hold_notification_notify_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_notification
    ADD CONSTRAINT hold_notification_notify_staff_fkey FOREIGN KEY (notify_staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request hold_request_acq_request_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_acq_request_fkey FOREIGN KEY (acq_request) REFERENCES acq.user_request(id);


--
-- Name: hold_request hold_request_cancel_cause_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_cancel_cause_fkey FOREIGN KEY (cancel_cause) REFERENCES action.hold_request_cancel_cause(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request hold_request_current_shelf_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_current_shelf_lib_fkey FOREIGN KEY (current_shelf_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request hold_request_fulfillment_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_fulfillment_lib_fkey FOREIGN KEY (fulfillment_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request hold_request_fulfillment_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_fulfillment_staff_fkey FOREIGN KEY (fulfillment_staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request hold_request_hold_type_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_hold_type_fkey FOREIGN KEY (hold_type) REFERENCES config.hold_type(hold_type) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_note hold_request_note_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request_note
    ADD CONSTRAINT hold_request_note_hold_fkey FOREIGN KEY (hold) REFERENCES action.hold_request(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request hold_request_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_pickup_lib_fkey FOREIGN KEY (pickup_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request hold_request_request_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_request_lib_fkey FOREIGN KEY (request_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request hold_request_requestor_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_requestor_fkey FOREIGN KEY (requestor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request hold_request_sms_carrier_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_sms_carrier_fkey FOREIGN KEY (sms_carrier) REFERENCES config.sms_carrier(id);


--
-- Name: hold_request hold_request_usr_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_request
    ADD CONSTRAINT hold_request_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_transit_copy hold_transit_copy_hold_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.hold_transit_copy
    ADD CONSTRAINT hold_transit_copy_hold_fkey FOREIGN KEY (hold) REFERENCES action.hold_request(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: in_house_use in_house_use_org_unit_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.in_house_use
    ADD CONSTRAINT in_house_use_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: in_house_use in_house_use_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.in_house_use
    ADD CONSTRAINT in_house_use_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: in_house_use in_house_use_workstation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.in_house_use
    ADD CONSTRAINT in_house_use_workstation_fkey FOREIGN KEY (workstation) REFERENCES actor.workstation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cat_in_house_use non_cat_in_house_use_item_type_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_item_type_fkey FOREIGN KEY (item_type) REFERENCES config.non_cataloged_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cat_in_house_use non_cat_in_house_use_org_unit_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cat_in_house_use non_cat_in_house_use_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cat_in_house_use non_cat_in_house_use_workstation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cat_in_house_use
    ADD CONSTRAINT non_cat_in_house_use_workstation_fkey FOREIGN KEY (workstation) REFERENCES actor.workstation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation non_cataloged_circulation_circ_lib_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation non_cataloged_circulation_item_type_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_item_type_fkey FOREIGN KEY (item_type) REFERENCES config.non_cataloged_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation non_cataloged_circulation_patron_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_patron_fkey FOREIGN KEY (patron) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: non_cataloged_circulation non_cataloged_circulation_staff_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.non_cataloged_circulation
    ADD CONSTRAINT non_cataloged_circulation_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_transit_copy reservation_transit_copy_reservation_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.reservation_transit_copy
    ADD CONSTRAINT reservation_transit_copy_reservation_fkey FOREIGN KEY (reservation) REFERENCES booking.reservation(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_answer survey_answer_question_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey_answer
    ADD CONSTRAINT survey_answer_question_fkey FOREIGN KEY (question) REFERENCES action.survey_question(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey survey_owner_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey
    ADD CONSTRAINT survey_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_question survey_question_survey_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey_question
    ADD CONSTRAINT survey_question_survey_fkey FOREIGN KEY (survey) REFERENCES action.survey(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_response survey_response_answer_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey_response
    ADD CONSTRAINT survey_response_answer_fkey FOREIGN KEY (answer) REFERENCES action.survey_answer(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_response survey_response_question_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey_response
    ADD CONSTRAINT survey_response_question_fkey FOREIGN KEY (question) REFERENCES action.survey_question(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: survey_response survey_response_survey_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.survey_response
    ADD CONSTRAINT survey_response_survey_fkey FOREIGN KEY (survey) REFERENCES action.survey(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy transit_copy_copy_status_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.transit_copy
    ADD CONSTRAINT transit_copy_copy_status_fkey FOREIGN KEY (copy_status) REFERENCES config.copy_status(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy transit_copy_dest_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.transit_copy
    ADD CONSTRAINT transit_copy_dest_fkey FOREIGN KEY (dest) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy transit_copy_prev_dest_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.transit_copy
    ADD CONSTRAINT transit_copy_prev_dest_fkey FOREIGN KEY (prev_dest) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy transit_copy_prev_hop_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.transit_copy
    ADD CONSTRAINT transit_copy_prev_hop_fkey FOREIGN KEY (prev_hop) REFERENCES action.transit_copy(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: transit_copy transit_copy_source_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.transit_copy
    ADD CONSTRAINT transit_copy_source_fkey FOREIGN KEY (source) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_circ_history usr_circ_history_source_circ_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.usr_circ_history
    ADD CONSTRAINT usr_circ_history_source_circ_fkey FOREIGN KEY (source_circ) REFERENCES action.circulation(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_circ_history usr_circ_history_usr_fkey; Type: FK CONSTRAINT; Schema: action; Owner: evergreen
--

ALTER TABLE ONLY action.usr_circ_history
    ADD CONSTRAINT usr_circ_history_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: alternate_template alternate_template_event_def_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.alternate_template
    ADD CONSTRAINT alternate_template_event_def_fkey FOREIGN KEY (event_def) REFERENCES action_trigger.event_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: alternate_template alternate_template_locale_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.alternate_template
    ADD CONSTRAINT alternate_template_locale_fkey FOREIGN KEY (locale) REFERENCES config.i18n_locale(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: environment environment_collector_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.environment
    ADD CONSTRAINT environment_collector_fkey FOREIGN KEY (collector) REFERENCES action_trigger.collector(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: environment environment_event_def_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.environment
    ADD CONSTRAINT environment_event_def_fkey FOREIGN KEY (event_def) REFERENCES action_trigger.event_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event event_async_output_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event
    ADD CONSTRAINT event_async_output_fkey FOREIGN KEY (async_output) REFERENCES action_trigger.event_output(id);


--
-- Name: event event_context_bib_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event
    ADD CONSTRAINT event_context_bib_fkey FOREIGN KEY (context_bib) REFERENCES biblio.record_entry(id);


--
-- Name: event event_context_library_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event
    ADD CONSTRAINT event_context_library_fkey FOREIGN KEY (context_library) REFERENCES actor.org_unit(id);


--
-- Name: event event_context_user_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event
    ADD CONSTRAINT event_context_user_fkey FOREIGN KEY (context_user) REFERENCES actor.usr(id);


--
-- Name: event_def_group event_def_group_hook_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_def_group
    ADD CONSTRAINT event_def_group_hook_fkey FOREIGN KEY (hook) REFERENCES action_trigger.hook(key) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_def_group_member event_def_group_member_event_def_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_def_group_member
    ADD CONSTRAINT event_def_group_member_event_def_fkey FOREIGN KEY (event_def) REFERENCES action_trigger.event_definition(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_def_group_member event_def_group_member_grp_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_def_group_member
    ADD CONSTRAINT event_def_group_member_grp_fkey FOREIGN KEY (grp) REFERENCES action_trigger.event_def_group(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_def_group event_def_group_owner_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_def_group
    ADD CONSTRAINT event_def_group_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition event_definition_cleanup_failure_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_definition
    ADD CONSTRAINT event_definition_cleanup_failure_fkey FOREIGN KEY (cleanup_failure) REFERENCES action_trigger.cleanup(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition event_definition_cleanup_success_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_definition
    ADD CONSTRAINT event_definition_cleanup_success_fkey FOREIGN KEY (cleanup_success) REFERENCES action_trigger.cleanup(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition event_definition_hook_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_definition
    ADD CONSTRAINT event_definition_hook_fkey FOREIGN KEY (hook) REFERENCES action_trigger.hook(key) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition event_definition_opt_in_setting_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_definition
    ADD CONSTRAINT event_definition_opt_in_setting_fkey FOREIGN KEY (opt_in_setting) REFERENCES config.usr_setting_type(name) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition event_definition_owner_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_definition
    ADD CONSTRAINT event_definition_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition event_definition_reactor_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_definition
    ADD CONSTRAINT event_definition_reactor_fkey FOREIGN KEY (reactor) REFERENCES action_trigger.reactor(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_definition event_definition_validator_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_definition
    ADD CONSTRAINT event_definition_validator_fkey FOREIGN KEY (validator) REFERENCES action_trigger.validator(module) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event event_error_output_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event
    ADD CONSTRAINT event_error_output_fkey FOREIGN KEY (error_output) REFERENCES action_trigger.event_output(id);


--
-- Name: event event_event_def_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event
    ADD CONSTRAINT event_event_def_fkey FOREIGN KEY (event_def) REFERENCES action_trigger.event_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event_params event_params_event_def_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event_params
    ADD CONSTRAINT event_params_event_def_fkey FOREIGN KEY (event_def) REFERENCES action_trigger.event_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: event event_template_output_fkey; Type: FK CONSTRAINT; Schema: action_trigger; Owner: evergreen
--

ALTER TABLE ONLY action_trigger.event
    ADD CONSTRAINT event_template_output_fkey FOREIGN KEY (template_output) REFERENCES action_trigger.event_output(id);


--
-- Name: org_unit actor_org_unit_billing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit
    ADD CONSTRAINT actor_org_unit_billing_address_fkey FOREIGN KEY (billing_address) REFERENCES actor.org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit actor_org_unit_holds_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit
    ADD CONSTRAINT actor_org_unit_holds_address_fkey FOREIGN KEY (holds_address) REFERENCES actor.org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit actor_org_unit_ill_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit
    ADD CONSTRAINT actor_org_unit_ill_address_fkey FOREIGN KEY (ill_address) REFERENCES actor.org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit actor_org_unit_mailing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit
    ADD CONSTRAINT actor_org_unit_mailing_address_fkey FOREIGN KEY (mailing_address) REFERENCES actor.org_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_proximity_adjustment actor_org_unit_proximity_adjustment_circ_mod_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_proximity_adjustment
    ADD CONSTRAINT actor_org_unit_proximity_adjustment_circ_mod_fkey FOREIGN KEY (circ_mod) REFERENCES config.circ_modifier(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_usr_map actor_sceum_sc_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry_usr_map
    ADD CONSTRAINT actor_sceum_sc_fkey FOREIGN KEY (stat_cat) REFERENCES actor.stat_cat(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_usr_map actor_sceum_tu_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry_usr_map
    ADD CONSTRAINT actor_sceum_tu_fkey FOREIGN KEY (target_usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry actor_stat_cat_entry_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry
    ADD CONSTRAINT actor_stat_cat_entry_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry actor_stat_cat_entry_stat_cat_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry
    ADD CONSTRAINT actor_stat_cat_entry_stat_cat_fkey FOREIGN KEY (stat_cat) REFERENCES actor.stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat actor_stat_cat_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat
    ADD CONSTRAINT actor_stat_cat_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr actor_usr_billing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT actor_usr_billing_address_fkey FOREIGN KEY (billing_address) REFERENCES actor.usr_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr actor_usr_home_ou_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT actor_usr_home_ou_fkey FOREIGN KEY (home_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr actor_usr_mailing_address_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT actor_usr_mailing_address_fkey FOREIGN KEY (mailing_address) REFERENCES actor.usr_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr actor_usr_profile_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT actor_usr_profile_fkey FOREIGN KEY (profile) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: ada_request ada_request_approved_by_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.ada_request
    ADD CONSTRAINT ada_request_approved_by_fkey FOREIGN KEY (approved_by) REFERENCES actor.usr(id);


--
-- Name: ada_request ada_request_rejected_by_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.ada_request
    ADD CONSTRAINT ada_request_rejected_by_fkey FOREIGN KEY (rejected_by) REFERENCES actor.usr(id);


--
-- Name: ada_request ada_request_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.ada_request
    ADD CONSTRAINT ada_request_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id);


--
-- Name: address_alert address_alert_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.address_alert
    ADD CONSTRAINT address_alert_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: card card_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.card
    ADD CONSTRAINT card_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_alert_suppress copy_alert_suppress_alert_type_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.copy_alert_suppress
    ADD CONSTRAINT copy_alert_suppress_alert_type_fkey FOREIGN KEY (alert_type) REFERENCES config.copy_alert_type(id) ON DELETE CASCADE;


--
-- Name: copy_alert_suppress copy_alert_suppress_org_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.copy_alert_suppress
    ADD CONSTRAINT copy_alert_suppress_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) ON DELETE CASCADE;


--
-- Name: hours_of_operation hours_of_operation_id_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.hours_of_operation
    ADD CONSTRAINT hours_of_operation_id_fkey FOREIGN KEY (id) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_address org_address_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_address
    ADD CONSTRAINT org_address_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_lasso_map org_lasso_map_lasso_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_lasso_map
    ADD CONSTRAINT org_lasso_map_lasso_fkey FOREIGN KEY (lasso) REFERENCES actor.org_lasso(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_lasso_map org_lasso_map_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_lasso_map
    ADD CONSTRAINT org_lasso_map_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_closed org_unit_closed_emergency_closing_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_closed
    ADD CONSTRAINT org_unit_closed_emergency_closing_fkey FOREIGN KEY (emergency_closing) REFERENCES action.emergency_closing(id) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_closed org_unit_closed_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_closed
    ADD CONSTRAINT org_unit_closed_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_custom_tree_node org_unit_custom_tree_node_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_custom_tree_node org_unit_custom_tree_node_parent_node_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_parent_node_fkey FOREIGN KEY (parent_node) REFERENCES actor.org_unit_custom_tree_node(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_custom_tree_node org_unit_custom_tree_node_tree_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_custom_tree_node
    ADD CONSTRAINT org_unit_custom_tree_node_tree_fkey FOREIGN KEY (tree) REFERENCES actor.org_unit_custom_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit org_unit_fiscal_calendar_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit
    ADD CONSTRAINT org_unit_fiscal_calendar_fkey FOREIGN KEY (fiscal_calendar) REFERENCES acq.fiscal_calendar(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit org_unit_ou_type_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit
    ADD CONSTRAINT org_unit_ou_type_fkey FOREIGN KEY (ou_type) REFERENCES actor.org_unit_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit org_unit_parent_ou_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit
    ADD CONSTRAINT org_unit_parent_ou_fkey FOREIGN KEY (parent_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_proximity_adjustment org_unit_proximity_adjustment_copy_location_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_copy_location_fkey FOREIGN KEY (copy_location) REFERENCES asset.copy_location(id);


--
-- Name: org_unit_proximity_adjustment org_unit_proximity_adjustment_hold_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_hold_pickup_lib_fkey FOREIGN KEY (hold_pickup_lib) REFERENCES actor.org_unit(id);


--
-- Name: org_unit_proximity_adjustment org_unit_proximity_adjustment_hold_request_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_hold_request_lib_fkey FOREIGN KEY (hold_request_lib) REFERENCES actor.org_unit(id);


--
-- Name: org_unit_proximity_adjustment org_unit_proximity_adjustment_item_circ_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_item_circ_lib_fkey FOREIGN KEY (item_circ_lib) REFERENCES actor.org_unit(id);


--
-- Name: org_unit_proximity_adjustment org_unit_proximity_adjustment_item_owning_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_proximity_adjustment
    ADD CONSTRAINT org_unit_proximity_adjustment_item_owning_lib_fkey FOREIGN KEY (item_owning_lib) REFERENCES actor.org_unit(id);


--
-- Name: org_unit_setting org_unit_setting_name_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_setting
    ADD CONSTRAINT org_unit_setting_name_fkey FOREIGN KEY (name) REFERENCES config.org_unit_setting_type(name) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_setting org_unit_setting_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_setting
    ADD CONSTRAINT org_unit_setting_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_type org_unit_type_parent_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.org_unit_type
    ADD CONSTRAINT org_unit_type_parent_fkey FOREIGN KEY (parent) REFERENCES actor.org_unit_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: passwd passwd_passwd_type_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.passwd
    ADD CONSTRAINT passwd_passwd_type_fkey FOREIGN KEY (passwd_type) REFERENCES actor.passwd_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: passwd passwd_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.passwd
    ADD CONSTRAINT passwd_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: search_filter_group_entry search_filter_group_entry_grp_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_filter_group_entry
    ADD CONSTRAINT search_filter_group_entry_grp_fkey FOREIGN KEY (grp) REFERENCES actor.search_filter_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: search_filter_group_entry search_filter_group_entry_query_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_filter_group_entry
    ADD CONSTRAINT search_filter_group_entry_query_fkey FOREIGN KEY (query) REFERENCES actor.search_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: search_filter_group search_filter_group_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.search_filter_group
    ADD CONSTRAINT search_filter_group_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_default stat_cat_entry_default_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_default stat_cat_entry_default_stat_cat_entry_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_stat_cat_entry_fkey FOREIGN KEY (stat_cat_entry) REFERENCES actor.stat_cat_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_default stat_cat_entry_default_stat_cat_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat_entry_default
    ADD CONSTRAINT stat_cat_entry_default_stat_cat_fkey FOREIGN KEY (stat_cat) REFERENCES actor.stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat stat_cat_sip_field_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.stat_cat
    ADD CONSTRAINT stat_cat_sip_field_fkey FOREIGN KEY (sip_field) REFERENCES actor.stat_cat_sip_fields(field) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: toolbar toolbar_org_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.toolbar
    ADD CONSTRAINT toolbar_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) ON DELETE CASCADE;


--
-- Name: toolbar toolbar_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.toolbar
    ADD CONSTRAINT toolbar_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE;


--
-- Name: toolbar toolbar_ws_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.toolbar
    ADD CONSTRAINT toolbar_ws_fkey FOREIGN KEY (ws) REFERENCES actor.workstation(id) ON DELETE CASCADE;


--
-- Name: usr_activity usr_activity_etype_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_activity
    ADD CONSTRAINT usr_activity_etype_fkey FOREIGN KEY (etype) REFERENCES config.usr_activity_type(id) ON DELETE CASCADE;


--
-- Name: usr_activity usr_activity_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_activity
    ADD CONSTRAINT usr_activity_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE SET NULL;


--
-- Name: usr_address usr_address_replaces_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_address
    ADD CONSTRAINT usr_address_replaces_fkey FOREIGN KEY (replaces) REFERENCES actor.usr_address(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_address usr_address_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_address
    ADD CONSTRAINT usr_address_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr usr_ident_type2_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT usr_ident_type2_fkey FOREIGN KEY (ident_type2) REFERENCES config.identification_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr usr_ident_type_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT usr_ident_type_fkey FOREIGN KEY (ident_type) REFERENCES config.identification_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr usr_locale_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT usr_locale_fkey FOREIGN KEY (locale) REFERENCES config.i18n_locale(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_message usr_message_editor_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_message
    ADD CONSTRAINT usr_message_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id);


--
-- Name: usr_message usr_message_sending_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_message
    ADD CONSTRAINT usr_message_sending_lib_fkey FOREIGN KEY (sending_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_message usr_message_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_message
    ADD CONSTRAINT usr_message_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr usr_net_access_level_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT usr_net_access_level_fkey FOREIGN KEY (net_access_level) REFERENCES config.net_access_level(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in usr_org_unit_opt_in_opt_in_ws_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_opt_in_ws_fkey FOREIGN KEY (opt_in_ws) REFERENCES actor.workstation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in usr_org_unit_opt_in_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in usr_org_unit_opt_in_staff_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_org_unit_opt_in usr_org_unit_opt_in_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_org_unit_opt_in
    ADD CONSTRAINT usr_org_unit_opt_in_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_password_reset usr_password_reset_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_password_reset
    ADD CONSTRAINT usr_password_reset_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_privacy_waiver usr_privacy_waiver_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_privacy_waiver
    ADD CONSTRAINT usr_privacy_waiver_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_saved_search usr_saved_search_owner_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_saved_search
    ADD CONSTRAINT usr_saved_search_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_setting usr_setting_name_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_setting
    ADD CONSTRAINT usr_setting_name_fkey FOREIGN KEY (name) REFERENCES config.usr_setting_type(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_setting usr_setting_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_setting
    ADD CONSTRAINT usr_setting_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr usr_standing_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr
    ADD CONSTRAINT usr_standing_fkey FOREIGN KEY (standing) REFERENCES config.standing(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty usr_standing_penalty_org_unit_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty usr_standing_penalty_staff_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_staff_fkey FOREIGN KEY (staff) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty usr_standing_penalty_standing_penalty_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_standing_penalty_fkey FOREIGN KEY (standing_penalty) REFERENCES config.standing_penalty(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty usr_standing_penalty_usr_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_standing_penalty usr_standing_penalty_usr_message_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.usr_standing_penalty
    ADD CONSTRAINT usr_standing_penalty_usr_message_fkey FOREIGN KEY (usr_message) REFERENCES actor.usr_message(id);


--
-- Name: workstation workstation_owning_lib_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.workstation
    ADD CONSTRAINT workstation_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: workstation_setting workstation_setting_name_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.workstation_setting
    ADD CONSTRAINT workstation_setting_name_fkey FOREIGN KEY (name) REFERENCES config.workstation_setting_type(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: workstation_setting workstation_setting_workstation_fkey; Type: FK CONSTRAINT; Schema: actor; Owner: evergreen
--

ALTER TABLE ONLY actor.workstation_setting
    ADD CONSTRAINT workstation_setting_workstation_fkey FOREIGN KEY (workstation) REFERENCES actor.workstation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat a_sc_owner_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat
    ADD CONSTRAINT a_sc_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_copy_map a_sc_sc_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry_copy_map
    ADD CONSTRAINT a_sc_sc_fkey FOREIGN KEY (stat_cat) REFERENCES asset.stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry_copy_map a_sc_sce_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry_copy_map
    ADD CONSTRAINT a_sc_sce_fkey FOREIGN KEY (stat_cat_entry) REFERENCES asset.stat_cat_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry a_sce_owner_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry
    ADD CONSTRAINT a_sce_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stat_cat_entry a_sce_sc_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat_entry
    ADD CONSTRAINT a_sce_sc_fkey FOREIGN KEY (stat_cat) REFERENCES asset.stat_cat(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number asset_call_number_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number
    ADD CONSTRAINT asset_call_number_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number asset_call_number_editor_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number
    ADD CONSTRAINT asset_call_number_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_note asset_call_number_note_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_note
    ADD CONSTRAINT asset_call_number_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_note asset_call_number_note_record_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_note
    ADD CONSTRAINT asset_call_number_note_record_fkey FOREIGN KEY (call_number) REFERENCES asset.call_number(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number asset_call_number_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number
    ADD CONSTRAINT asset_call_number_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number asset_call_number_record_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number
    ADD CONSTRAINT asset_call_number_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy asset_copy_call_number_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy
    ADD CONSTRAINT asset_copy_call_number_fkey FOREIGN KEY (call_number) REFERENCES asset.call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy asset_copy_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy
    ADD CONSTRAINT asset_copy_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy asset_copy_editor_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy
    ADD CONSTRAINT asset_copy_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy asset_copy_floating_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy
    ADD CONSTRAINT asset_copy_floating_fkey FOREIGN KEY (floating) REFERENCES config.floating_group(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_note asset_copy_note_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_note
    ADD CONSTRAINT asset_copy_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template asset_copy_template_floating_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_template
    ADD CONSTRAINT asset_copy_template_floating_fkey FOREIGN KEY (floating) REFERENCES config.floating_group(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number call_number_label_class_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number
    ADD CONSTRAINT call_number_label_class_fkey FOREIGN KEY (label_class) REFERENCES asset.call_number_class(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number call_number_prefix_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number
    ADD CONSTRAINT call_number_prefix_fkey FOREIGN KEY (prefix) REFERENCES asset.call_number_prefix(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_prefix call_number_prefix_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_prefix
    ADD CONSTRAINT call_number_prefix_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id);


--
-- Name: call_number call_number_suffix_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number
    ADD CONSTRAINT call_number_suffix_fkey FOREIGN KEY (suffix) REFERENCES asset.call_number_suffix(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_suffix call_number_suffix_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.call_number_suffix
    ADD CONSTRAINT call_number_suffix_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id);


--
-- Name: copy circ_mod_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy
    ADD CONSTRAINT circ_mod_fkey FOREIGN KEY (circ_modifier) REFERENCES config.circ_modifier(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_alert copy_alert_ack_staff_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_alert
    ADD CONSTRAINT copy_alert_ack_staff_fkey FOREIGN KEY (ack_staff) REFERENCES actor.usr(id) ON DELETE SET NULL;


--
-- Name: copy_alert copy_alert_alert_type_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_alert
    ADD CONSTRAINT copy_alert_alert_type_fkey FOREIGN KEY (alert_type) REFERENCES config.copy_alert_type(id) ON DELETE CASCADE;


--
-- Name: copy_alert copy_alert_create_staff_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_alert
    ADD CONSTRAINT copy_alert_create_staff_fkey FOREIGN KEY (create_staff) REFERENCES actor.usr(id) ON DELETE SET NULL;


--
-- Name: copy copy_circ_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy
    ADD CONSTRAINT copy_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_inventory copy_inventory_inventory_workstation_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_inventory
    ADD CONSTRAINT copy_inventory_inventory_workstation_fkey FOREIGN KEY (inventory_workstation) REFERENCES actor.workstation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy copy_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy
    ADD CONSTRAINT copy_location_fkey FOREIGN KEY (location) REFERENCES asset.copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_group_map copy_location_group_map_lgroup_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_group_map
    ADD CONSTRAINT copy_location_group_map_lgroup_fkey FOREIGN KEY (lgroup) REFERENCES asset.copy_location_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_group_map copy_location_group_map_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_group_map
    ADD CONSTRAINT copy_location_group_map_location_fkey FOREIGN KEY (location) REFERENCES asset.copy_location(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_group copy_location_group_owner_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_group
    ADD CONSTRAINT copy_location_group_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_order copy_location_order_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_order
    ADD CONSTRAINT copy_location_order_location_fkey FOREIGN KEY (location) REFERENCES asset.copy_location(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location_order copy_location_order_org_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location_order
    ADD CONSTRAINT copy_location_order_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_location copy_location_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_location
    ADD CONSTRAINT copy_location_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_part_map copy_part_map_part_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_part_map
    ADD CONSTRAINT copy_part_map_part_fkey FOREIGN KEY (part) REFERENCES biblio.monograph_part(id) ON DELETE CASCADE;


--
-- Name: copy copy_status_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy
    ADD CONSTRAINT copy_status_fkey FOREIGN KEY (status) REFERENCES config.copy_status(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_tag_copy_map copy_tag_copy_map_tag_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_tag_copy_map
    ADD CONSTRAINT copy_tag_copy_map_tag_fkey FOREIGN KEY (tag) REFERENCES asset.copy_tag(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: copy_tag copy_tag_owner_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_tag
    ADD CONSTRAINT copy_tag_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id);


--
-- Name: copy_tag copy_tag_tag_type_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_tag
    ADD CONSTRAINT copy_tag_tag_type_fkey FOREIGN KEY (tag_type) REFERENCES config.copy_tag_type(code) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: copy_template copy_template_circ_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_template
    ADD CONSTRAINT copy_template_circ_lib_fkey FOREIGN KEY (circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template copy_template_creator_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_template
    ADD CONSTRAINT copy_template_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template copy_template_editor_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_template
    ADD CONSTRAINT copy_template_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template copy_template_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_template
    ADD CONSTRAINT copy_template_location_fkey FOREIGN KEY (location) REFERENCES asset.copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template copy_template_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_template
    ADD CONSTRAINT copy_template_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_template copy_template_status_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.copy_template
    ADD CONSTRAINT copy_template_status_fkey FOREIGN KEY (status) REFERENCES config.copy_status(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: course_module_course_materials course_module_course_materials_course_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_materials
    ADD CONSTRAINT course_module_course_materials_course_fkey FOREIGN KEY (course) REFERENCES asset.course_module_course(id);


--
-- Name: course_module_course_materials course_module_course_materials_item_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_materials
    ADD CONSTRAINT course_module_course_materials_item_fkey FOREIGN KEY (item) REFERENCES asset.copy(id);


--
-- Name: course_module_course_materials course_module_course_materials_original_callnumber_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_materials
    ADD CONSTRAINT course_module_course_materials_original_callnumber_fkey FOREIGN KEY (original_callnumber) REFERENCES asset.call_number(id);


--
-- Name: course_module_course_materials course_module_course_materials_original_circ_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_materials
    ADD CONSTRAINT course_module_course_materials_original_circ_lib_fkey FOREIGN KEY (original_circ_lib) REFERENCES actor.org_unit(id);


--
-- Name: course_module_course_materials course_module_course_materials_original_location_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_materials
    ADD CONSTRAINT course_module_course_materials_original_location_fkey FOREIGN KEY (original_location) REFERENCES asset.copy_location(id);


--
-- Name: course_module_course_materials course_module_course_materials_original_status_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_materials
    ADD CONSTRAINT course_module_course_materials_original_status_fkey FOREIGN KEY (original_status) REFERENCES config.copy_status(id);


--
-- Name: course_module_course_materials course_module_course_materials_record_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_materials
    ADD CONSTRAINT course_module_course_materials_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id);


--
-- Name: course_module_course course_module_course_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course
    ADD CONSTRAINT course_module_course_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id);


--
-- Name: course_module_course_users course_module_course_users_course_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_users
    ADD CONSTRAINT course_module_course_users_course_fkey FOREIGN KEY (course) REFERENCES asset.course_module_course(id);


--
-- Name: course_module_course_users course_module_course_users_usr_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_users
    ADD CONSTRAINT course_module_course_users_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id);


--
-- Name: course_module_course_users course_module_course_users_usr_role_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_course_users
    ADD CONSTRAINT course_module_course_users_usr_role_fkey FOREIGN KEY (usr_role) REFERENCES asset.course_module_role(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: course_module_term_course_map course_module_term_course_map_course_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_term_course_map
    ADD CONSTRAINT course_module_term_course_map_course_fkey FOREIGN KEY (course) REFERENCES asset.course_module_course(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: course_module_term_course_map course_module_term_course_map_term_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_term_course_map
    ADD CONSTRAINT course_module_term_course_map_term_fkey FOREIGN KEY (term) REFERENCES asset.course_module_term(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: course_module_term course_module_term_owning_lib_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.course_module_term
    ADD CONSTRAINT course_module_term_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id);


--
-- Name: stat_cat stat_cat_sip_field_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.stat_cat
    ADD CONSTRAINT stat_cat_sip_field_fkey FOREIGN KEY (sip_field) REFERENCES asset.stat_cat_sip_fields(field) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: uri_call_number_map uri_call_number_map_call_number_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.uri_call_number_map
    ADD CONSTRAINT uri_call_number_map_call_number_fkey FOREIGN KEY (call_number) REFERENCES asset.call_number(id);


--
-- Name: uri_call_number_map uri_call_number_map_uri_fkey; Type: FK CONSTRAINT; Schema: asset; Owner: evergreen
--

ALTER TABLE ONLY asset.uri_call_number_map
    ADD CONSTRAINT uri_call_number_map_uri_fkey FOREIGN KEY (uri) REFERENCES asset.uri(id);


--
-- Name: authority_linking authority_linking_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.authority_linking
    ADD CONSTRAINT authority_linking_field_fkey FOREIGN KEY (field) REFERENCES authority.control_set_authority_field(id);


--
-- Name: authority_linking authority_linking_source_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.authority_linking
    ADD CONSTRAINT authority_linking_source_fkey FOREIGN KEY (source) REFERENCES authority.record_entry(id);


--
-- Name: authority_linking authority_linking_target_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.authority_linking
    ADD CONSTRAINT authority_linking_target_fkey FOREIGN KEY (target) REFERENCES authority.record_entry(id);


--
-- Name: bib_linking bib_linking_authority_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.bib_linking
    ADD CONSTRAINT bib_linking_authority_fkey FOREIGN KEY (authority) REFERENCES authority.record_entry(id);


--
-- Name: bib_linking bib_linking_bib_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.bib_linking
    ADD CONSTRAINT bib_linking_bib_fkey FOREIGN KEY (bib) REFERENCES biblio.record_entry(id);


--
-- Name: browse_axis_authority_field_map browse_axis_authority_field_map_axis_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.browse_axis_authority_field_map
    ADD CONSTRAINT browse_axis_authority_field_map_axis_fkey FOREIGN KEY (axis) REFERENCES authority.browse_axis(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: browse_axis_authority_field_map browse_axis_authority_field_map_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.browse_axis_authority_field_map
    ADD CONSTRAINT browse_axis_authority_field_map_field_fkey FOREIGN KEY (field) REFERENCES authority.control_set_authority_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: browse_axis browse_axis_sorter_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.browse_axis
    ADD CONSTRAINT browse_axis_sorter_fkey FOREIGN KEY (sorter) REFERENCES config.record_attr_definition(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_authority_field control_set_authority_field_control_set_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_authority_field
    ADD CONSTRAINT control_set_authority_field_control_set_fkey FOREIGN KEY (control_set) REFERENCES authority.control_set(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_authority_field control_set_authority_field_heading_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_authority_field
    ADD CONSTRAINT control_set_authority_field_heading_field_fkey FOREIGN KEY (heading_field) REFERENCES authority.heading_field(id);


--
-- Name: control_set_authority_field control_set_authority_field_main_entry_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_authority_field
    ADD CONSTRAINT control_set_authority_field_main_entry_fkey FOREIGN KEY (main_entry) REFERENCES authority.control_set_authority_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_bib_field control_set_bib_field_authority_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_bib_field
    ADD CONSTRAINT control_set_bib_field_authority_field_fkey FOREIGN KEY (authority_field) REFERENCES authority.control_set_authority_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_bib_field_metabib_field_map control_set_bib_field_metabib_field_map_bib_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_bib_field_metabib_field_map
    ADD CONSTRAINT control_set_bib_field_metabib_field_map_bib_field_fkey FOREIGN KEY (bib_field) REFERENCES authority.control_set_bib_field(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: control_set_bib_field_metabib_field_map control_set_bib_field_metabib_field_map_metabib_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.control_set_bib_field_metabib_field_map
    ADD CONSTRAINT control_set_bib_field_metabib_field_map_metabib_field_fkey FOREIGN KEY (metabib_field) REFERENCES config.metabib_field(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: heading_field heading_field_format_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.heading_field
    ADD CONSTRAINT heading_field_format_fkey FOREIGN KEY (format) REFERENCES config.xml_transform(name);


--
-- Name: heading_field_norm_map heading_field_norm_map_field_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.heading_field_norm_map
    ADD CONSTRAINT heading_field_norm_map_field_fkey FOREIGN KEY (field) REFERENCES authority.heading_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: heading_field_norm_map heading_field_norm_map_norm_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.heading_field_norm_map
    ADD CONSTRAINT heading_field_norm_map_norm_fkey FOREIGN KEY (norm) REFERENCES config.index_normalizer(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_entry record_entry_control_set_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.record_entry
    ADD CONSTRAINT record_entry_control_set_fkey FOREIGN KEY (control_set) REFERENCES authority.control_set(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_note record_note_record_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.record_note
    ADD CONSTRAINT record_note_record_fkey FOREIGN KEY (record) REFERENCES authority.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: simple_heading simple_heading_atag_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.simple_heading
    ADD CONSTRAINT simple_heading_atag_fkey FOREIGN KEY (atag) REFERENCES authority.control_set_authority_field(id);


--
-- Name: simple_heading simple_heading_record_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.simple_heading
    ADD CONSTRAINT simple_heading_record_fkey FOREIGN KEY (record) REFERENCES authority.record_entry(id);


--
-- Name: thesaurus thesaurus_control_set_fkey; Type: FK CONSTRAINT; Schema: authority; Owner: evergreen
--

ALTER TABLE ONLY authority.thesaurus
    ADD CONSTRAINT thesaurus_control_set_fkey FOREIGN KEY (control_set) REFERENCES authority.control_set(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_entry biblio_record_entry_creator_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.record_entry
    ADD CONSTRAINT biblio_record_entry_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_entry biblio_record_entry_editor_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.record_entry
    ADD CONSTRAINT biblio_record_entry_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_entry biblio_record_entry_owner_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.record_entry
    ADD CONSTRAINT biblio_record_entry_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_note biblio_record_note_creator_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.record_note
    ADD CONSTRAINT biblio_record_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_note biblio_record_note_editor_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.record_note
    ADD CONSTRAINT biblio_record_note_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_note biblio_record_note_record_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.record_note
    ADD CONSTRAINT biblio_record_note_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: monograph_part monograph_part_record_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.monograph_part
    ADD CONSTRAINT monograph_part_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id);


--
-- Name: peer_bib_copy_map peer_bib_copy_map_peer_record_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.peer_bib_copy_map
    ADD CONSTRAINT peer_bib_copy_map_peer_record_fkey FOREIGN KEY (peer_record) REFERENCES biblio.record_entry(id);


--
-- Name: peer_bib_copy_map peer_bib_copy_map_peer_type_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.peer_bib_copy_map
    ADD CONSTRAINT peer_bib_copy_map_peer_type_fkey FOREIGN KEY (peer_type) REFERENCES biblio.peer_type(id);


--
-- Name: record_entry record_entry_merged_to_fkey; Type: FK CONSTRAINT; Schema: biblio; Owner: evergreen
--

ALTER TABLE ONLY biblio.record_entry
    ADD CONSTRAINT record_entry_merged_to_fkey FOREIGN KEY (merged_to) REFERENCES biblio.record_entry(id);


--
-- Name: reservation booking_reservation_usr_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation
    ADD CONSTRAINT booking_reservation_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_attr_value_map reservation_attr_value_map_attr_value_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation_attr_value_map
    ADD CONSTRAINT reservation_attr_value_map_attr_value_fkey FOREIGN KEY (attr_value) REFERENCES booking.resource_attr_value(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation_attr_value_map reservation_attr_value_map_reservation_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation_attr_value_map
    ADD CONSTRAINT reservation_attr_value_map_reservation_fkey FOREIGN KEY (reservation) REFERENCES booking.reservation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation reservation_capture_staff_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation
    ADD CONSTRAINT reservation_capture_staff_fkey FOREIGN KEY (capture_staff) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation reservation_current_resource_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation
    ADD CONSTRAINT reservation_current_resource_fkey FOREIGN KEY (current_resource) REFERENCES booking.resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation reservation_pickup_lib_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation
    ADD CONSTRAINT reservation_pickup_lib_fkey FOREIGN KEY (pickup_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation reservation_request_lib_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation
    ADD CONSTRAINT reservation_request_lib_fkey FOREIGN KEY (request_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation reservation_target_resource_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation
    ADD CONSTRAINT reservation_target_resource_fkey FOREIGN KEY (target_resource) REFERENCES booking.resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: reservation reservation_target_resource_type_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.reservation
    ADD CONSTRAINT reservation_target_resource_type_fkey FOREIGN KEY (target_resource_type) REFERENCES booking.resource_type(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_map resource_attr_map_resource_attr_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr_map
    ADD CONSTRAINT resource_attr_map_resource_attr_fkey FOREIGN KEY (resource_attr) REFERENCES booking.resource_attr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_map resource_attr_map_resource_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr_map
    ADD CONSTRAINT resource_attr_map_resource_fkey FOREIGN KEY (resource) REFERENCES booking.resource(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_map resource_attr_map_value_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr_map
    ADD CONSTRAINT resource_attr_map_value_fkey FOREIGN KEY (value) REFERENCES booking.resource_attr_value(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr resource_attr_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr
    ADD CONSTRAINT resource_attr_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr resource_attr_resource_type_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr
    ADD CONSTRAINT resource_attr_resource_type_fkey FOREIGN KEY (resource_type) REFERENCES booking.resource_type(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_value resource_attr_value_attr_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr_value
    ADD CONSTRAINT resource_attr_value_attr_fkey FOREIGN KEY (attr) REFERENCES booking.resource_attr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_attr_value resource_attr_value_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_attr_value
    ADD CONSTRAINT resource_attr_value_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource resource_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource
    ADD CONSTRAINT resource_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource resource_type_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource
    ADD CONSTRAINT resource_type_fkey FOREIGN KEY (type) REFERENCES booking.resource_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_type resource_type_owner_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_type
    ADD CONSTRAINT resource_type_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: resource_type resource_type_record_fkey; Type: FK CONSTRAINT; Schema: booking; Owner: evergreen
--

ALTER TABLE ONLY booking.resource_type
    ADD CONSTRAINT resource_type_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: barcode_completion barcode_completion_org_unit_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.barcode_completion
    ADD CONSTRAINT barcode_completion_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: geolocation_service cgs_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.geolocation_service
    ADD CONSTRAINT cgs_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_circ_mod_map circ_limit_set_circ_mod_map_circ_mod_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_circ_mod_map
    ADD CONSTRAINT circ_limit_set_circ_mod_map_circ_mod_fkey FOREIGN KEY (circ_mod) REFERENCES config.circ_modifier(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_circ_mod_map circ_limit_set_circ_mod_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_circ_mod_map
    ADD CONSTRAINT circ_limit_set_circ_mod_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES config.circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_copy_loc_map circ_limit_set_copy_loc_map_copy_loc_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_copy_loc_map
    ADD CONSTRAINT circ_limit_set_copy_loc_map_copy_loc_fkey FOREIGN KEY (copy_loc) REFERENCES asset.copy_location(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_copy_loc_map circ_limit_set_copy_loc_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_copy_loc_map
    ADD CONSTRAINT circ_limit_set_copy_loc_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES config.circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_group_map circ_limit_set_group_map_limit_group_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_group_map
    ADD CONSTRAINT circ_limit_set_group_map_limit_group_fkey FOREIGN KEY (limit_group) REFERENCES config.circ_limit_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set_group_map circ_limit_set_group_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set_group_map
    ADD CONSTRAINT circ_limit_set_group_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES config.circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_limit_set circ_limit_set_owning_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_limit_set
    ADD CONSTRAINT circ_limit_set_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_circ_mod_test_map circ_matrix_circ_mod_test_map_circ_mod_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_circ_mod_test_map
    ADD CONSTRAINT circ_matrix_circ_mod_test_map_circ_mod_fkey FOREIGN KEY (circ_mod) REFERENCES config.circ_modifier(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_circ_mod_test_map circ_matrix_circ_mod_test_map_circ_mod_test_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_circ_mod_test_map
    ADD CONSTRAINT circ_matrix_circ_mod_test_map_circ_mod_test_fkey FOREIGN KEY (circ_mod_test) REFERENCES config.circ_matrix_circ_mod_test(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_circ_mod_test circ_matrix_circ_mod_test_matchpoint_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_circ_mod_test
    ADD CONSTRAINT circ_matrix_circ_mod_test_matchpoint_fkey FOREIGN KEY (matchpoint) REFERENCES config.circ_matrix_matchpoint(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_limit_set_map circ_matrix_limit_set_map_limit_set_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_limit_set_map
    ADD CONSTRAINT circ_matrix_limit_set_map_limit_set_fkey FOREIGN KEY (limit_set) REFERENCES config.circ_limit_set(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_limit_set_map circ_matrix_limit_set_map_matchpoint_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_limit_set_map
    ADD CONSTRAINT circ_matrix_limit_set_map_matchpoint_fkey FOREIGN KEY (matchpoint) REFERENCES config.circ_matrix_matchpoint(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES config.circ_modifier(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_copy_circ_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_copy_circ_lib_fkey FOREIGN KEY (copy_circ_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_copy_location_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_copy_location_fkey FOREIGN KEY (copy_location) REFERENCES asset.copy_location(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_copy_owning_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_copy_owning_lib_fkey FOREIGN KEY (copy_owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_duration_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_duration_rule_fkey FOREIGN KEY (duration_rule) REFERENCES config.rule_circ_duration(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_grp_fkey FOREIGN KEY (grp) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_hard_due_date_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_hard_due_date_fkey FOREIGN KEY (hard_due_date) REFERENCES config.hard_due_date(id);


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_max_fine_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_max_fine_rule_fkey FOREIGN KEY (max_fine_rule) REFERENCES config.rule_max_fine(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_org_unit_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_recurring_fine_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_recurring_fine_rule_fkey FOREIGN KEY (recurring_fine_rule) REFERENCES config.rule_recurring_fine(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: circ_matrix_matchpoint circ_matrix_matchpoint_user_home_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.circ_matrix_matchpoint
    ADD CONSTRAINT circ_matrix_matchpoint_user_home_ou_fkey FOREIGN KEY (user_home_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: coded_value_map coded_value_map_ctype_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.coded_value_map
    ADD CONSTRAINT coded_value_map_ctype_fkey FOREIGN KEY (ctype) REFERENCES config.record_attr_definition(name) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: composite_attr_entry_definition composite_attr_entry_definition_coded_value_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.composite_attr_entry_definition
    ADD CONSTRAINT composite_attr_entry_definition_coded_value_fkey FOREIGN KEY (coded_value) REFERENCES config.coded_value_map(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: billing_type config_billing_type_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.billing_type
    ADD CONSTRAINT config_billing_type_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: remote_account config_remote_account_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.remote_account
    ADD CONSTRAINT config_remote_account_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_alert_type copy_alert_type_scope_org_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.copy_alert_type
    ADD CONSTRAINT copy_alert_type_scope_org_fkey FOREIGN KEY (scope_org) REFERENCES actor.org_unit(id) ON DELETE CASCADE;


--
-- Name: copy_tag_type copy_tag_type_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.copy_tag_type
    ADD CONSTRAINT copy_tag_type_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: ui_staff_portal_page_entry cusppe_entry_type_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.ui_staff_portal_page_entry
    ADD CONSTRAINT cusppe_entry_type_fkey FOREIGN KEY (entry_type) REFERENCES config.ui_staff_portal_page_entry_type(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: ui_staff_portal_page_entry cusppe_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.ui_staff_portal_page_entry
    ADD CONSTRAINT cusppe_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: display_field_map display_field_map_field_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.display_field_map
    ADD CONSTRAINT display_field_map_field_fkey FOREIGN KEY (field) REFERENCES config.metabib_field(id);


--
-- Name: filter_dialog_filter_set filter_dialog_filter_set_creator_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.filter_dialog_filter_set
    ADD CONSTRAINT filter_dialog_filter_set_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: filter_dialog_filter_set filter_dialog_filter_set_interface_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.filter_dialog_filter_set
    ADD CONSTRAINT filter_dialog_filter_set_interface_fkey FOREIGN KEY (interface) REFERENCES config.filter_dialog_interface(key) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: filter_dialog_filter_set filter_dialog_filter_set_owning_lib_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.filter_dialog_filter_set
    ADD CONSTRAINT filter_dialog_filter_set_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: floating_group_member floating_group_member_floating_group_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.floating_group_member
    ADD CONSTRAINT floating_group_member_floating_group_fkey FOREIGN KEY (floating_group) REFERENCES config.floating_group(id);


--
-- Name: floating_group_member floating_group_member_org_unit_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.floating_group_member
    ADD CONSTRAINT floating_group_member_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id);


--
-- Name: hard_due_date_values hard_due_date_values_hard_due_date_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hard_due_date_values
    ADD CONSTRAINT hard_due_date_values_hard_due_date_fkey FOREIGN KEY (hard_due_date) REFERENCES config.hard_due_date(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint hold_matrix_matchpoint_age_hold_protect_rule_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_age_hold_protect_rule_fkey FOREIGN KEY (age_hold_protect_rule) REFERENCES config.rule_age_hold_protect(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint hold_matrix_matchpoint_circ_modifier_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_circ_modifier_fkey FOREIGN KEY (circ_modifier) REFERENCES config.circ_modifier(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint hold_matrix_matchpoint_item_circ_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_item_circ_ou_fkey FOREIGN KEY (item_circ_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint hold_matrix_matchpoint_item_owning_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_item_owning_ou_fkey FOREIGN KEY (item_owning_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint hold_matrix_matchpoint_pickup_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_pickup_ou_fkey FOREIGN KEY (pickup_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint hold_matrix_matchpoint_request_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_request_ou_fkey FOREIGN KEY (request_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint hold_matrix_matchpoint_requestor_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_requestor_grp_fkey FOREIGN KEY (requestor_grp) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint hold_matrix_matchpoint_transit_range_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_transit_range_fkey FOREIGN KEY (transit_range) REFERENCES actor.org_unit_type(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint hold_matrix_matchpoint_user_home_ou_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_user_home_ou_fkey FOREIGN KEY (user_home_ou) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_matrix_matchpoint hold_matrix_matchpoint_usr_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.hold_matrix_matchpoint
    ADD CONSTRAINT hold_matrix_matchpoint_usr_grp_fkey FOREIGN KEY (usr_grp) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: i18n_core i18n_core_translation_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.i18n_core
    ADD CONSTRAINT i18n_core_translation_fkey FOREIGN KEY (translation) REFERENCES config.i18n_locale(code) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: idl_field_doc idl_field_doc_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.idl_field_doc
    ADD CONSTRAINT idl_field_doc_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: marc21_physical_characteristic_subfield_map marc21_physical_characteristic_subfield_map_ptype_key_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc21_physical_characteristic_subfield_map
    ADD CONSTRAINT marc21_physical_characteristic_subfield_map_ptype_key_fkey FOREIGN KEY (ptype_key) REFERENCES config.marc21_physical_characteristic_type_map(ptype_key) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: marc21_physical_characteristic_value_map marc21_physical_characteristic_value_map_ptype_subfield_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc21_physical_characteristic_value_map
    ADD CONSTRAINT marc21_physical_characteristic_value_map_ptype_subfield_fkey FOREIGN KEY (ptype_subfield) REFERENCES config.marc21_physical_characteristic_subfield_map(id);


--
-- Name: marc_field marc_field_marc_format_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc_field
    ADD CONSTRAINT marc_field_marc_format_fkey FOREIGN KEY (marc_format) REFERENCES config.marc_format(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: marc_field marc_field_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc_field
    ADD CONSTRAINT marc_field_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id);


--
-- Name: marc_subfield marc_subfield_marc_format_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc_subfield
    ADD CONSTRAINT marc_subfield_marc_format_fkey FOREIGN KEY (marc_format) REFERENCES config.marc_format(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: marc_subfield marc_subfield_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc_subfield
    ADD CONSTRAINT marc_subfield_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id);


--
-- Name: marc_subfield marc_subfield_value_ctype_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.marc_subfield
    ADD CONSTRAINT marc_subfield_value_ctype_fkey FOREIGN KEY (value_ctype) REFERENCES config.record_attr_definition(name) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_class_ts_map metabib_class_ts_map_field_class_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_class_ts_map
    ADD CONSTRAINT metabib_class_ts_map_field_class_fkey FOREIGN KEY (field_class) REFERENCES config.metabib_class(name);


--
-- Name: metabib_class_ts_map metabib_class_ts_map_ts_config_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_class_ts_map
    ADD CONSTRAINT metabib_class_ts_map_ts_config_fkey FOREIGN KEY (ts_config) REFERENCES config.ts_config_list(id);


--
-- Name: metabib_field metabib_field_field_class_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field
    ADD CONSTRAINT metabib_field_field_class_fkey FOREIGN KEY (field_class) REFERENCES config.metabib_class(name);


--
-- Name: metabib_field metabib_field_format_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field
    ADD CONSTRAINT metabib_field_format_fkey FOREIGN KEY (format) REFERENCES config.xml_transform(name);


--
-- Name: metabib_field_index_norm_map metabib_field_index_norm_map_field_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_index_norm_map
    ADD CONSTRAINT metabib_field_index_norm_map_field_fkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_field_index_norm_map metabib_field_index_norm_map_norm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_index_norm_map
    ADD CONSTRAINT metabib_field_index_norm_map_norm_fkey FOREIGN KEY (norm) REFERENCES config.index_normalizer(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_field_ts_map metabib_field_ts_map_metabib_field_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_ts_map
    ADD CONSTRAINT metabib_field_ts_map_metabib_field_fkey FOREIGN KEY (metabib_field) REFERENCES config.metabib_field(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metabib_field_ts_map metabib_field_ts_map_ts_config_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_ts_map
    ADD CONSTRAINT metabib_field_ts_map_ts_config_fkey FOREIGN KEY (ts_config) REFERENCES config.ts_config_list(id);


--
-- Name: metabib_field_virtual_map metabib_field_virtual_map_real_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_virtual_map
    ADD CONSTRAINT metabib_field_virtual_map_real_fkey FOREIGN KEY ("real") REFERENCES config.metabib_field(id);


--
-- Name: metabib_field_virtual_map metabib_field_virtual_map_virtual_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_field_virtual_map
    ADD CONSTRAINT metabib_field_virtual_map_virtual_fkey FOREIGN KEY (virtual) REFERENCES config.metabib_field(id);


--
-- Name: metabib_search_alias metabib_search_alias_field_class_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_search_alias
    ADD CONSTRAINT metabib_search_alias_field_class_fkey FOREIGN KEY (field_class) REFERENCES config.metabib_class(name);


--
-- Name: metabib_search_alias metabib_search_alias_field_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.metabib_search_alias
    ADD CONSTRAINT metabib_search_alias_field_fkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_setting_type org_unit_setting_type_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.org_unit_setting_type
    ADD CONSTRAINT org_unit_setting_type_grp_fkey FOREIGN KEY (grp) REFERENCES config.settings_group(name);


--
-- Name: org_unit_setting_type_log org_unit_setting_type_log_field_name_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.org_unit_setting_type_log
    ADD CONSTRAINT org_unit_setting_type_log_field_name_fkey FOREIGN KEY (field_name) REFERENCES config.org_unit_setting_type(name) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_setting_type_log org_unit_setting_type_log_org_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.org_unit_setting_type_log
    ADD CONSTRAINT org_unit_setting_type_log_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id);


--
-- Name: print_template print_template_locale_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.print_template
    ADD CONSTRAINT print_template_locale_fkey FOREIGN KEY (locale) REFERENCES config.i18n_locale(code) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: print_template print_template_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.print_template
    ADD CONSTRAINT print_template_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id);


--
-- Name: record_attr_definition record_attr_definition_format_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.record_attr_definition
    ADD CONSTRAINT record_attr_definition_format_fkey FOREIGN KEY (format) REFERENCES config.xml_transform(name) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_attr_definition record_attr_definition_phys_char_sf_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.record_attr_definition
    ADD CONSTRAINT record_attr_definition_phys_char_sf_fkey FOREIGN KEY (phys_char_sf) REFERENCES config.marc21_physical_characteristic_subfield_map(id);


--
-- Name: record_attr_index_norm_map record_attr_index_norm_map_attr_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.record_attr_index_norm_map
    ADD CONSTRAINT record_attr_index_norm_map_attr_fkey FOREIGN KEY (attr) REFERENCES config.record_attr_definition(name) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_attr_index_norm_map record_attr_index_norm_map_norm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.record_attr_index_norm_map
    ADD CONSTRAINT record_attr_index_norm_map_norm_fkey FOREIGN KEY (norm) REFERENCES config.index_normalizer(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: remoteauth_profile remoteauth_profile_context_org_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.remoteauth_profile
    ADD CONSTRAINT remoteauth_profile_context_org_fkey FOREIGN KEY (context_org) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: remoteauth_profile remoteauth_profile_perm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.remoteauth_profile
    ADD CONSTRAINT remoteauth_profile_perm_fkey FOREIGN KEY (perm) REFERENCES permission.perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: remoteauth_profile remoteauth_profile_usr_activity_type_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.remoteauth_profile
    ADD CONSTRAINT remoteauth_profile_usr_activity_type_fkey FOREIGN KEY (usr_activity_type) REFERENCES config.usr_activity_type(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: org_unit_setting_type update_perm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.org_unit_setting_type
    ADD CONSTRAINT update_perm_fkey FOREIGN KEY (update_perm) REFERENCES permission.perm_list(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_setting_type usr_setting_type_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.usr_setting_type
    ADD CONSTRAINT usr_setting_type_grp_fkey FOREIGN KEY (grp) REFERENCES config.settings_group(name);


--
-- Name: org_unit_setting_type view_perm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.org_unit_setting_type
    ADD CONSTRAINT view_perm_fkey FOREIGN KEY (view_perm) REFERENCES permission.perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: weight_assoc weight_assoc_circ_weights_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.weight_assoc
    ADD CONSTRAINT weight_assoc_circ_weights_fkey FOREIGN KEY (circ_weights) REFERENCES config.circ_matrix_weights(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: weight_assoc weight_assoc_hold_weights_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.weight_assoc
    ADD CONSTRAINT weight_assoc_hold_weights_fkey FOREIGN KEY (hold_weights) REFERENCES config.hold_matrix_weights(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: weight_assoc weight_assoc_org_unit_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.weight_assoc
    ADD CONSTRAINT weight_assoc_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: workstation_setting_type workstation_setting_type_grp_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.workstation_setting_type
    ADD CONSTRAINT workstation_setting_type_grp_fkey FOREIGN KEY (grp) REFERENCES config.settings_group(name);


--
-- Name: z3950_attr z3950_attr_source_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_attr
    ADD CONSTRAINT z3950_attr_source_fkey FOREIGN KEY (source) REFERENCES config.z3950_source(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: z3950_index_field_map z3950_index_field_map_metabib_field_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_index_field_map
    ADD CONSTRAINT z3950_index_field_map_metabib_field_fkey FOREIGN KEY (metabib_field) REFERENCES config.metabib_field(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: z3950_index_field_map z3950_index_field_map_record_attr_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_index_field_map
    ADD CONSTRAINT z3950_index_field_map_record_attr_fkey FOREIGN KEY (record_attr) REFERENCES config.record_attr_definition(name);


--
-- Name: z3950_index_field_map z3950_index_field_map_z3950_attr_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_index_field_map
    ADD CONSTRAINT z3950_index_field_map_z3950_attr_fkey FOREIGN KEY (z3950_attr) REFERENCES config.z3950_attr(id);


--
-- Name: z3950_source_credentials z3950_source_credentials_owner_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_source_credentials
    ADD CONSTRAINT z3950_source_credentials_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id);


--
-- Name: z3950_source_credentials z3950_source_credentials_source_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_source_credentials
    ADD CONSTRAINT z3950_source_credentials_source_fkey FOREIGN KEY (source) REFERENCES config.z3950_source(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: z3950_source z3950_source_use_perm_fkey; Type: FK CONSTRAINT; Schema: config; Owner: evergreen
--

ALTER TABLE ONLY config.z3950_source
    ADD CONSTRAINT z3950_source_use_perm_fkey FOREIGN KEY (use_perm) REFERENCES permission.perm_list(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket biblio_record_entry_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket
    ADD CONSTRAINT biblio_record_entry_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES container.biblio_record_entry_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_item biblio_record_entry_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_item
    ADD CONSTRAINT biblio_record_entry_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES container.biblio_record_entry_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_item_note biblio_record_entry_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_item_note
    ADD CONSTRAINT biblio_record_entry_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES container.biblio_record_entry_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_item biblio_record_entry_bucket_item_target_biblio_record_entry_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_item
    ADD CONSTRAINT biblio_record_entry_bucket_item_target_biblio_record_entry_fkey FOREIGN KEY (target_biblio_record_entry) REFERENCES biblio.record_entry(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket_note biblio_record_entry_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket_note
    ADD CONSTRAINT biblio_record_entry_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES container.biblio_record_entry_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket biblio_record_entry_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket
    ADD CONSTRAINT biblio_record_entry_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: biblio_record_entry_bucket biblio_record_entry_bucket_owning_lib_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.biblio_record_entry_bucket
    ADD CONSTRAINT biblio_record_entry_bucket_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket call_number_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket
    ADD CONSTRAINT call_number_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES container.call_number_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_item call_number_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_item
    ADD CONSTRAINT call_number_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES container.call_number_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_item_note call_number_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_item_note
    ADD CONSTRAINT call_number_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES container.call_number_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_item call_number_bucket_item_target_call_number_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_item
    ADD CONSTRAINT call_number_bucket_item_target_call_number_fkey FOREIGN KEY (target_call_number) REFERENCES asset.call_number(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket_note call_number_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket_note
    ADD CONSTRAINT call_number_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES container.call_number_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket call_number_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket
    ADD CONSTRAINT call_number_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: call_number_bucket call_number_bucket_owning_lib_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.call_number_bucket
    ADD CONSTRAINT call_number_bucket_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: carousel carousel_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.carousel
    ADD CONSTRAINT carousel_bucket_fkey FOREIGN KEY (bucket) REFERENCES container.biblio_record_entry_bucket(id);


--
-- Name: carousel carousel_creator_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.carousel
    ADD CONSTRAINT carousel_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id);


--
-- Name: carousel carousel_editor_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.carousel
    ADD CONSTRAINT carousel_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id);


--
-- Name: carousel_org_unit carousel_org_unit_carousel_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.carousel_org_unit
    ADD CONSTRAINT carousel_org_unit_carousel_fkey FOREIGN KEY (carousel) REFERENCES container.carousel(id) ON DELETE CASCADE;


--
-- Name: carousel_org_unit carousel_org_unit_org_unit_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.carousel_org_unit
    ADD CONSTRAINT carousel_org_unit_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id);


--
-- Name: carousel carousel_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.carousel
    ADD CONSTRAINT carousel_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id);


--
-- Name: carousel carousel_type_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.carousel
    ADD CONSTRAINT carousel_type_fkey FOREIGN KEY (type) REFERENCES config.carousel_type(id);


--
-- Name: copy_bucket copy_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket
    ADD CONSTRAINT copy_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES container.copy_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_item copy_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket_item
    ADD CONSTRAINT copy_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES container.copy_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_item_note copy_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket_item_note
    ADD CONSTRAINT copy_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES container.copy_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket_note copy_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket_note
    ADD CONSTRAINT copy_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES container.copy_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket copy_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket
    ADD CONSTRAINT copy_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: copy_bucket copy_bucket_owning_lib_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.copy_bucket
    ADD CONSTRAINT copy_bucket_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket user_bucket_btype_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket
    ADD CONSTRAINT user_bucket_btype_fkey FOREIGN KEY (btype) REFERENCES container.user_bucket_type(code) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_item user_bucket_item_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_item
    ADD CONSTRAINT user_bucket_item_bucket_fkey FOREIGN KEY (bucket) REFERENCES container.user_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_item_note user_bucket_item_note_item_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_item_note
    ADD CONSTRAINT user_bucket_item_note_item_fkey FOREIGN KEY (item) REFERENCES container.user_bucket_item(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_item user_bucket_item_target_user_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_item
    ADD CONSTRAINT user_bucket_item_target_user_fkey FOREIGN KEY (target_user) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket_note user_bucket_note_bucket_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket_note
    ADD CONSTRAINT user_bucket_note_bucket_fkey FOREIGN KEY (bucket) REFERENCES container.user_bucket(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket user_bucket_owner_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket
    ADD CONSTRAINT user_bucket_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_bucket user_bucket_owning_lib_fkey; Type: FK CONSTRAINT; Schema: container; Owner: evergreen
--

ALTER TABLE ONLY container.user_bucket
    ADD CONSTRAINT user_bucket_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: node node_cluster_fkey; Type: FK CONSTRAINT; Schema: elastic; Owner: evergreen
--

ALTER TABLE ONLY elastic.node
    ADD CONSTRAINT node_cluster_fkey FOREIGN KEY (cluster) REFERENCES elastic.cluster(code) ON DELETE CASCADE;


--
-- Name: bib_export_data bib_export_data_bib_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.bib_export_data
    ADD CONSTRAINT bib_export_data_bib_fkey FOREIGN KEY (bib) REFERENCES biblio.record_entry(id);


--
-- Name: browse_entry_def_map browse_entry_def_map_authority_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_authority_fkey FOREIGN KEY (authority) REFERENCES authority.record_entry(id) ON DELETE SET NULL;


--
-- Name: browse_entry_def_map browse_entry_def_map_def_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_def_fkey FOREIGN KEY (def) REFERENCES config.metabib_field(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: browse_entry_def_map browse_entry_def_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_entry_fkey FOREIGN KEY (entry) REFERENCES metabib.browse_entry(id);


--
-- Name: browse_entry_def_map browse_entry_def_map_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry_def_map
    ADD CONSTRAINT browse_entry_def_map_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id);


--
-- Name: browse_entry_simple_heading_map browse_entry_simple_heading_map_entry_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry_simple_heading_map
    ADD CONSTRAINT browse_entry_simple_heading_map_entry_fkey FOREIGN KEY (entry) REFERENCES metabib.browse_entry(id);


--
-- Name: browse_entry_simple_heading_map browse_entry_simple_heading_map_simple_heading_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.browse_entry_simple_heading_map
    ADD CONSTRAINT browse_entry_simple_heading_map_simple_heading_fkey FOREIGN KEY (simple_heading) REFERENCES authority.simple_heading(id) ON DELETE CASCADE;


--
-- Name: display_entry display_entry_field_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.display_entry
    ADD CONSTRAINT display_entry_field_fkey FOREIGN KEY (field) REFERENCES config.metabib_field(id);


--
-- Name: display_entry display_entry_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.display_entry
    ADD CONSTRAINT display_entry_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id);


--
-- Name: identifier_field_entry metabib_identifier_field_entry_field_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.identifier_field_entry
    ADD CONSTRAINT metabib_identifier_field_entry_field_pkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: identifier_field_entry metabib_identifier_field_entry_source_pkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.identifier_field_entry
    ADD CONSTRAINT metabib_identifier_field_entry_source_pkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metarecord metabib_metarecord_master_record_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.metarecord
    ADD CONSTRAINT metabib_metarecord_master_record_fkey FOREIGN KEY (master_record) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metarecord_source_map metabib_metarecord_source_map_metarecord_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.metarecord_source_map
    ADD CONSTRAINT metabib_metarecord_source_map_metarecord_fkey FOREIGN KEY (metarecord) REFERENCES metabib.metarecord(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: metarecord_source_map metabib_metarecord_source_map_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.metarecord_source_map
    ADD CONSTRAINT metabib_metarecord_source_map_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: normalized_author_field_entry normalized_author_to_ author_field_entry_FK; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.normalized_author_field_entry
    ADD CONSTRAINT "normalized_author_to_ author_field_entry_FK" FOREIGN KEY (id) REFERENCES metabib.author_field_entry(id) ON DELETE CASCADE;


--
-- Name: normalized_keyword_field_entry normalized_keyword_to_ keyword_field_entry_FK; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.normalized_keyword_field_entry
    ADD CONSTRAINT "normalized_keyword_to_ keyword_field_entry_FK" FOREIGN KEY (id) REFERENCES metabib.keyword_field_entry(id) ON DELETE CASCADE;


--
-- Name: normalized_series_field_entry normalized_series_to_ series_field_entry_FK; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.normalized_series_field_entry
    ADD CONSTRAINT "normalized_series_to_ series_field_entry_FK" FOREIGN KEY (id) REFERENCES metabib.series_field_entry(id) ON DELETE CASCADE;


--
-- Name: normalized_subject_field_entry normalized_subject_to_ subject_field_entry_FK; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.normalized_subject_field_entry
    ADD CONSTRAINT "normalized_subject_to_ subject_field_entry_FK" FOREIGN KEY (id) REFERENCES metabib.subject_field_entry(id) ON DELETE CASCADE;


--
-- Name: normalized_title_field_entry normalized_title_to_ title_field_entry_FK; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.normalized_title_field_entry
    ADD CONSTRAINT "normalized_title_to_ title_field_entry_FK" FOREIGN KEY (id) REFERENCES metabib.title_field_entry(id) ON DELETE CASCADE;


--
-- Name: record_attr_vector_list record_attr_vector_list_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.record_attr_vector_list
    ADD CONSTRAINT record_attr_vector_list_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id);


--
-- Name: record_sorter record_sorter_attr_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.record_sorter
    ADD CONSTRAINT record_sorter_attr_fkey FOREIGN KEY (attr) REFERENCES config.record_attr_definition(name) ON DELETE CASCADE;


--
-- Name: record_sorter record_sorter_source_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.record_sorter
    ADD CONSTRAINT record_sorter_source_fkey FOREIGN KEY (source) REFERENCES biblio.record_entry(id) ON DELETE CASCADE;


--
-- Name: uncontrolled_record_attr_value uncontrolled_record_attr_value_attr_fkey; Type: FK CONSTRAINT; Schema: metabib; Owner: evergreen
--

ALTER TABLE ONLY metabib.uncontrolled_record_attr_value
    ADD CONSTRAINT uncontrolled_record_attr_value_attr_fkey FOREIGN KEY (attr) REFERENCES config.record_attr_definition(name);


--
-- Name: account_adjustment account_adjustment_billing_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.account_adjustment
    ADD CONSTRAINT account_adjustment_billing_fkey FOREIGN KEY (billing) REFERENCES money.billing(id);


--
-- Name: billing billing_btype_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.billing
    ADD CONSTRAINT billing_btype_fkey FOREIGN KEY (btype) REFERENCES config.billing_type(id) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bnm_desk_payment bnm_desk_payment_cash_drawer_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.bnm_desk_payment
    ADD CONSTRAINT bnm_desk_payment_cash_drawer_fkey FOREIGN KEY (cash_drawer) REFERENCES actor.workstation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: collections_tracker collections_tracker_collector_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.collections_tracker
    ADD CONSTRAINT collections_tracker_collector_fkey FOREIGN KEY (collector) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: collections_tracker collections_tracker_location_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.collections_tracker
    ADD CONSTRAINT collections_tracker_location_fkey FOREIGN KEY (location) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: collections_tracker collections_tracker_usr_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.collections_tracker
    ADD CONSTRAINT collections_tracker_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: billable_xact money_billable_xact_usr_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.billable_xact
    ADD CONSTRAINT money_billable_xact_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: refund_action refund_action_refundable_xact_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refund_action
    ADD CONSTRAINT refund_action_refundable_xact_fkey FOREIGN KEY (refundable_xact) REFERENCES money.refundable_xact(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: refund_action refund_action_session_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refund_action
    ADD CONSTRAINT refund_action_session_fkey FOREIGN KEY (session) REFERENCES money.refund_session(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: refundable_payment refundable_payment_payment_ou_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refundable_payment
    ADD CONSTRAINT refundable_payment_payment_ou_fkey FOREIGN KEY (payment_ou) REFERENCES actor.org_unit(id);


--
-- Name: refundable_payment refundable_payment_refundable_xact_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refundable_payment
    ADD CONSTRAINT refundable_payment_refundable_xact_fkey FOREIGN KEY (refundable_xact) REFERENCES money.refundable_xact(id);


--
-- Name: refundable_xact refundable_xact_approved_by_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refundable_xact
    ADD CONSTRAINT refundable_xact_approved_by_fkey FOREIGN KEY (approved_by) REFERENCES actor.usr(id);


--
-- Name: refundable_xact refundable_xact_paused_by_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refundable_xact
    ADD CONSTRAINT refundable_xact_paused_by_fkey FOREIGN KEY (paused_by) REFERENCES actor.usr(id);


--
-- Name: refundable_xact refundable_xact_refund_session_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refundable_xact
    ADD CONSTRAINT refundable_xact_refund_session_fkey FOREIGN KEY (refund_session) REFERENCES money.refund_session(id) ON DELETE SET NULL;


--
-- Name: refundable_xact refundable_xact_rejected_by_fkey; Type: FK CONSTRAINT; Schema: money; Owner: evergreen
--

ALTER TABLE ONLY money.refundable_xact
    ADD CONSTRAINT refundable_xact_rejected_by_fkey FOREIGN KEY (rejected_by) REFERENCES actor.usr(id);


--
-- Name: grp_penalty_threshold grp_penalty_threshold_grp_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_grp_fkey FOREIGN KEY (grp) REFERENCES permission.grp_tree(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_penalty_threshold grp_penalty_threshold_org_unit_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_org_unit_fkey FOREIGN KEY (org_unit) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_penalty_threshold grp_penalty_threshold_penalty_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_penalty_threshold
    ADD CONSTRAINT grp_penalty_threshold_penalty_fkey FOREIGN KEY (penalty) REFERENCES config.standing_penalty(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_perm_map grp_perm_map_grp_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_perm_map
    ADD CONSTRAINT grp_perm_map_grp_fkey FOREIGN KEY (grp) REFERENCES permission.grp_tree(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_perm_map grp_perm_map_perm_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_perm_map
    ADD CONSTRAINT grp_perm_map_perm_fkey FOREIGN KEY (perm) REFERENCES permission.perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_tree_display_entry grp_tree_display_entry_grp_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_tree_display_entry
    ADD CONSTRAINT grp_tree_display_entry_grp_fkey FOREIGN KEY (grp) REFERENCES permission.grp_tree(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_tree_display_entry grp_tree_display_entry_org_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_tree_display_entry
    ADD CONSTRAINT grp_tree_display_entry_org_fkey FOREIGN KEY (org) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_tree_display_entry grp_tree_display_entry_parent_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_tree_display_entry
    ADD CONSTRAINT grp_tree_display_entry_parent_fkey FOREIGN KEY (parent) REFERENCES permission.grp_tree_display_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: grp_tree grp_tree_parent_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.grp_tree
    ADD CONSTRAINT grp_tree_parent_fkey FOREIGN KEY (parent) REFERENCES permission.grp_tree(id) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_grp_map usr_grp_map_grp_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_grp_map
    ADD CONSTRAINT usr_grp_map_grp_fkey FOREIGN KEY (grp) REFERENCES permission.grp_tree(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_grp_map usr_grp_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_grp_map
    ADD CONSTRAINT usr_grp_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_object_perm_map usr_object_perm_map_perm_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_object_perm_map
    ADD CONSTRAINT usr_object_perm_map_perm_fkey FOREIGN KEY (perm) REFERENCES permission.perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_object_perm_map usr_object_perm_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_object_perm_map
    ADD CONSTRAINT usr_object_perm_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_perm_map usr_perm_map_perm_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_perm_map
    ADD CONSTRAINT usr_perm_map_perm_fkey FOREIGN KEY (perm) REFERENCES permission.perm_list(id) ON UPDATE CASCADE ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_perm_map usr_perm_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_perm_map
    ADD CONSTRAINT usr_perm_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_work_ou_map usr_work_ou_map_usr_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_map_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_work_ou_map usr_work_ou_map_work_ou_fkey; Type: FK CONSTRAINT; Schema: permission; Owner: evergreen
--

ALTER TABLE ONLY permission.usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_map_work_ou_fkey FOREIGN KEY (work_ou) REFERENCES actor.org_unit(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: card card_usr_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.card
    ADD CONSTRAINT card_usr_fkey FOREIGN KEY (usr) REFERENCES prod_staff_users.usr(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_address usr_address_replaces_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.usr_address
    ADD CONSTRAINT usr_address_replaces_fkey FOREIGN KEY (replaces) REFERENCES prod_staff_users.usr_address(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_address usr_address_usr_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.usr_address
    ADD CONSTRAINT usr_address_usr_fkey FOREIGN KEY (usr) REFERENCES prod_staff_users.usr(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr usr_billing_address_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.usr
    ADD CONSTRAINT usr_billing_address_fkey FOREIGN KEY (billing_address) REFERENCES prod_staff_users.usr_address(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr usr_card_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.usr
    ADD CONSTRAINT usr_card_fkey FOREIGN KEY (card) REFERENCES prod_staff_users.card(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr usr_mailing_address_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.usr
    ADD CONSTRAINT usr_mailing_address_fkey FOREIGN KEY (mailing_address) REFERENCES prod_staff_users.usr_address(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_perm_map usr_perm_map_usr_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.usr_perm_map
    ADD CONSTRAINT usr_perm_map_usr_fkey FOREIGN KEY (usr) REFERENCES prod_staff_users.usr(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_setting usr_setting_usr_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.usr_setting
    ADD CONSTRAINT usr_setting_usr_fkey FOREIGN KEY (usr) REFERENCES prod_staff_users.usr(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: usr_work_ou_map usr_work_ou_map_usr_fkey; Type: FK CONSTRAINT; Schema: prod_staff_users; Owner: evergreen
--

ALTER TABLE ONLY prod_staff_users.usr_work_ou_map
    ADD CONSTRAINT usr_work_ou_map_usr_fkey FOREIGN KEY (usr) REFERENCES prod_staff_users.usr(id) ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: case_branch case_branch_condition_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.case_branch
    ADD CONSTRAINT case_branch_condition_fkey FOREIGN KEY (condition) REFERENCES query.expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: case_branch case_branch_parent_expr_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.case_branch
    ADD CONSTRAINT case_branch_parent_expr_fkey FOREIGN KEY (parent_expr) REFERENCES query.expression(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: case_branch case_branch_result_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.case_branch
    ADD CONSTRAINT case_branch_result_fkey FOREIGN KEY (result) REFERENCES query.expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression expression_bind_variable_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.expression
    ADD CONSTRAINT expression_bind_variable_fkey FOREIGN KEY (bind_variable) REFERENCES query.bind_variable(name) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression expression_cast_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.expression
    ADD CONSTRAINT expression_cast_type_fkey FOREIGN KEY (cast_type) REFERENCES query.datatype(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression expression_function_id_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.expression
    ADD CONSTRAINT expression_function_id_fkey FOREIGN KEY (function_id) REFERENCES query.function_sig(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression expression_left_operand_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.expression
    ADD CONSTRAINT expression_left_operand_fkey FOREIGN KEY (left_operand) REFERENCES query.expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression expression_parent_expr_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.expression
    ADD CONSTRAINT expression_parent_expr_fkey FOREIGN KEY (parent_expr) REFERENCES query.expression(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression expression_right_operand_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.expression
    ADD CONSTRAINT expression_right_operand_fkey FOREIGN KEY (right_operand) REFERENCES query.expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: expression expression_subquery_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.expression
    ADD CONSTRAINT expression_subquery_fkey FOREIGN KEY (subquery) REFERENCES query.stored_query(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: from_relation from_relation_function_call_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.from_relation
    ADD CONSTRAINT from_relation_function_call_fkey FOREIGN KEY (function_call) REFERENCES query.expression(id);


--
-- Name: from_relation from_relation_on_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.from_relation
    ADD CONSTRAINT from_relation_on_clause_fkey FOREIGN KEY (on_clause) REFERENCES query.expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: from_relation from_relation_parent_relation_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.from_relation
    ADD CONSTRAINT from_relation_parent_relation_fkey FOREIGN KEY (parent_relation) REFERENCES query.from_relation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: from_relation from_relation_subquery_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.from_relation
    ADD CONSTRAINT from_relation_subquery_fkey FOREIGN KEY (subquery) REFERENCES query.stored_query(id);


--
-- Name: function_param_def function_param_def_datatype_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.function_param_def
    ADD CONSTRAINT function_param_def_datatype_fkey FOREIGN KEY (datatype) REFERENCES query.datatype(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: function_param_def function_param_def_function_id_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.function_param_def
    ADD CONSTRAINT function_param_def_function_id_fkey FOREIGN KEY (function_id) REFERENCES query.function_sig(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: function_sig function_sig_return_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.function_sig
    ADD CONSTRAINT function_sig_return_type_fkey FOREIGN KEY (return_type) REFERENCES query.datatype(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: order_by_item order_by_item_expression_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.order_by_item
    ADD CONSTRAINT order_by_item_expression_fkey FOREIGN KEY (expression) REFERENCES query.expression(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: order_by_item order_by_item_stored_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.order_by_item
    ADD CONSTRAINT order_by_item_stored_query_fkey FOREIGN KEY (stored_query) REFERENCES query.stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: query_sequence query_sequence_child_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.query_sequence
    ADD CONSTRAINT query_sequence_child_query_fkey FOREIGN KEY (child_query) REFERENCES query.stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: query_sequence query_sequence_parent_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.query_sequence
    ADD CONSTRAINT query_sequence_parent_query_fkey FOREIGN KEY (parent_query) REFERENCES query.stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_column record_column_column_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.record_column
    ADD CONSTRAINT record_column_column_type_fkey FOREIGN KEY (column_type) REFERENCES query.datatype(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_column record_column_from_relation_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.record_column
    ADD CONSTRAINT record_column_from_relation_fkey FOREIGN KEY (from_relation) REFERENCES query.from_relation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: select_item select_item_expression_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.select_item
    ADD CONSTRAINT select_item_expression_fkey FOREIGN KEY (expression) REFERENCES query.expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: select_item select_item_stored_query_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.select_item
    ADD CONSTRAINT select_item_stored_query_fkey FOREIGN KEY (stored_query) REFERENCES query.stored_query(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query stored_query_from_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.stored_query
    ADD CONSTRAINT stored_query_from_clause_fkey FOREIGN KEY (from_clause) REFERENCES query.from_relation(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query stored_query_having_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.stored_query
    ADD CONSTRAINT stored_query_having_clause_fkey FOREIGN KEY (having_clause) REFERENCES query.expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query stored_query_limit_count_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.stored_query
    ADD CONSTRAINT stored_query_limit_count_fkey FOREIGN KEY (limit_count) REFERENCES query.expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query stored_query_offset_count_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.stored_query
    ADD CONSTRAINT stored_query_offset_count_fkey FOREIGN KEY (offset_count) REFERENCES query.expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stored_query stored_query_where_clause_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.stored_query
    ADD CONSTRAINT stored_query_where_clause_fkey FOREIGN KEY (where_clause) REFERENCES query.expression(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subfield subfield_composite_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.subfield
    ADD CONSTRAINT subfield_composite_type_fkey FOREIGN KEY (composite_type) REFERENCES query.datatype(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subfield subfield_subfield_type_fkey; Type: FK CONSTRAINT; Schema: query; Owner: evergreen
--

ALTER TABLE ONLY query.subfield
    ADD CONSTRAINT subfield_subfield_type_fkey FOREIGN KEY (subfield_type) REFERENCES query.datatype(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: badge badge_circ_mod_filter_fkey; Type: FK CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.badge
    ADD CONSTRAINT badge_circ_mod_filter_fkey FOREIGN KEY (circ_mod_filter) REFERENCES config.circ_modifier(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: badge badge_loc_grp_filter_fkey; Type: FK CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.badge
    ADD CONSTRAINT badge_loc_grp_filter_fkey FOREIGN KEY (loc_grp_filter) REFERENCES asset.copy_location_group(id) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: badge badge_popularity_parameter_fkey; Type: FK CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.badge
    ADD CONSTRAINT badge_popularity_parameter_fkey FOREIGN KEY (popularity_parameter) REFERENCES rating.popularity_parameter(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: badge badge_scope_fkey; Type: FK CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.badge
    ADD CONSTRAINT badge_scope_fkey FOREIGN KEY (scope) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: badge badge_src_filter_fkey; Type: FK CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.badge
    ADD CONSTRAINT badge_src_filter_fkey FOREIGN KEY (src_filter) REFERENCES config.bib_source(id) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_badge_score record_badge_score_badge_fkey; Type: FK CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.record_badge_score
    ADD CONSTRAINT record_badge_score_badge_fkey FOREIGN KEY (badge) REFERENCES rating.badge(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_badge_score record_badge_score_record_fkey; Type: FK CONSTRAINT; Schema: rating; Owner: evergreen
--

ALTER TABLE ONLY rating.record_badge_score
    ADD CONSTRAINT record_badge_score_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: hold_request_record ahrfk; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.hold_request_record
    ADD CONSTRAINT ahrfk FOREIGN KEY (id) REFERENCES action.hold_request(id) ON DELETE CASCADE;


--
-- Name: output_folder output_folder_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.output_folder
    ADD CONSTRAINT output_folder_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: output_folder output_folder_parent_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.output_folder
    ADD CONSTRAINT output_folder_parent_fkey FOREIGN KEY (parent) REFERENCES reporter.output_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: output_folder output_folder_share_with_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.output_folder
    ADD CONSTRAINT output_folder_share_with_fkey FOREIGN KEY (share_with) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report report_folder_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.report
    ADD CONSTRAINT report_folder_fkey FOREIGN KEY (folder) REFERENCES reporter.report_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_folder report_folder_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.report_folder
    ADD CONSTRAINT report_folder_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_folder report_folder_parent_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.report_folder
    ADD CONSTRAINT report_folder_parent_fkey FOREIGN KEY (parent) REFERENCES reporter.report_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report_folder report_folder_share_with_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.report_folder
    ADD CONSTRAINT report_folder_share_with_fkey FOREIGN KEY (share_with) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report report_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.report
    ADD CONSTRAINT report_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: report report_template_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.report
    ADD CONSTRAINT report_template_fkey FOREIGN KEY (template) REFERENCES reporter.template(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: schedule schedule_folder_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.schedule
    ADD CONSTRAINT schedule_folder_fkey FOREIGN KEY (folder) REFERENCES reporter.output_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: schedule schedule_report_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.schedule
    ADD CONSTRAINT schedule_report_fkey FOREIGN KEY (report) REFERENCES reporter.report(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: schedule schedule_runner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.schedule
    ADD CONSTRAINT schedule_runner_fkey FOREIGN KEY (runner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template template_folder_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.template
    ADD CONSTRAINT template_folder_fkey FOREIGN KEY (folder) REFERENCES reporter.template_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_folder template_folder_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.template_folder
    ADD CONSTRAINT template_folder_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_folder template_folder_parent_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.template_folder
    ADD CONSTRAINT template_folder_parent_fkey FOREIGN KEY (parent) REFERENCES reporter.template_folder(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template_folder template_folder_share_with_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.template_folder
    ADD CONSTRAINT template_folder_share_with_fkey FOREIGN KEY (share_with) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: template template_owner_fkey; Type: FK CONSTRAINT; Schema: reporter; Owner: evergreen
--

ALTER TABLE ONLY reporter.template
    ADD CONSTRAINT template_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: relevance_adjustment relevance_adjustment_field_fkey; Type: FK CONSTRAINT; Schema: search; Owner: evergreen
--

ALTER TABLE ONLY search.relevance_adjustment
    ADD CONSTRAINT relevance_adjustment_field_fkey FOREIGN KEY (field) REFERENCES config.metabib_field(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: basic_summary bib_summary_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.basic_summary
    ADD CONSTRAINT bib_summary_distribution_fkey FOREIGN KEY (distribution) REFERENCES serial.distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: caption_and_pattern caption_and_pattern_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.caption_and_pattern
    ADD CONSTRAINT caption_and_pattern_subscription_fkey FOREIGN KEY (subscription) REFERENCES serial.subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution distribution_bind_call_number_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution
    ADD CONSTRAINT distribution_bind_call_number_fkey FOREIGN KEY (bind_call_number) REFERENCES asset.call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution distribution_bind_unit_template_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution
    ADD CONSTRAINT distribution_bind_unit_template_fkey FOREIGN KEY (bind_unit_template) REFERENCES asset.copy_template(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution distribution_holding_lib_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution
    ADD CONSTRAINT distribution_holding_lib_fkey FOREIGN KEY (holding_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_note distribution_note_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution_note
    ADD CONSTRAINT distribution_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution_note distribution_note_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution_note
    ADD CONSTRAINT distribution_note_distribution_fkey FOREIGN KEY (distribution) REFERENCES serial.distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution distribution_receive_call_number_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution
    ADD CONSTRAINT distribution_receive_call_number_fkey FOREIGN KEY (receive_call_number) REFERENCES asset.call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution distribution_receive_unit_template_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution
    ADD CONSTRAINT distribution_receive_unit_template_fkey FOREIGN KEY (receive_unit_template) REFERENCES asset.copy_template(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution distribution_record_entry_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution
    ADD CONSTRAINT distribution_record_entry_fkey FOREIGN KEY (record_entry) REFERENCES serial.record_entry(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: distribution distribution_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.distribution
    ADD CONSTRAINT distribution_subscription_fkey FOREIGN KEY (subscription) REFERENCES serial.subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: index_summary index_summary_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.index_summary
    ADD CONSTRAINT index_summary_distribution_fkey FOREIGN KEY (distribution) REFERENCES serial.distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance issuance_caption_and_pattern_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.issuance
    ADD CONSTRAINT issuance_caption_and_pattern_fkey FOREIGN KEY (caption_and_pattern) REFERENCES serial.caption_and_pattern(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance issuance_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.issuance
    ADD CONSTRAINT issuance_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance issuance_editor_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.issuance
    ADD CONSTRAINT issuance_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: issuance issuance_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.issuance
    ADD CONSTRAINT issuance_subscription_fkey FOREIGN KEY (subscription) REFERENCES serial.subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item item_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item
    ADD CONSTRAINT item_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item item_editor_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item
    ADD CONSTRAINT item_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item item_issuance_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item
    ADD CONSTRAINT item_issuance_fkey FOREIGN KEY (issuance) REFERENCES serial.issuance(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_note item_note_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item_note
    ADD CONSTRAINT item_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item_note item_note_item_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item_note
    ADD CONSTRAINT item_note_item_fkey FOREIGN KEY (item) REFERENCES serial.item(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item item_stream_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item
    ADD CONSTRAINT item_stream_fkey FOREIGN KEY (stream) REFERENCES serial.stream(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item item_unit_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item
    ADD CONSTRAINT item_unit_fkey FOREIGN KEY (unit) REFERENCES serial.unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: item item_uri_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.item
    ADD CONSTRAINT item_uri_fkey FOREIGN KEY (uri) REFERENCES asset.uri(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: materialized_holding_code materialized_holding_code_issuance_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.materialized_holding_code
    ADD CONSTRAINT materialized_holding_code_issuance_fkey FOREIGN KEY (issuance) REFERENCES serial.issuance(id) ON DELETE CASCADE;


--
-- Name: pattern_template pattern_template_owning_lib_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.pattern_template
    ADD CONSTRAINT pattern_template_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_entry record_entry_owning_lib_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.record_entry
    ADD CONSTRAINT record_entry_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: record_entry record_entry_record_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.record_entry
    ADD CONSTRAINT record_entry_record_fkey FOREIGN KEY (record) REFERENCES biblio.record_entry(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: routing_list_user routing_list_user_reader_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.routing_list_user
    ADD CONSTRAINT routing_list_user_reader_fkey FOREIGN KEY (reader) REFERENCES actor.usr(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: routing_list_user routing_list_user_stream_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.routing_list_user
    ADD CONSTRAINT routing_list_user_stream_fkey FOREIGN KEY (stream) REFERENCES serial.stream(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: unit serial_unit_call_number_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit
    ADD CONSTRAINT serial_unit_call_number_fkey FOREIGN KEY (call_number) REFERENCES asset.call_number(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: unit serial_unit_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit
    ADD CONSTRAINT serial_unit_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: unit serial_unit_editor_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.unit
    ADD CONSTRAINT serial_unit_editor_fkey FOREIGN KEY (editor) REFERENCES actor.usr(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: stream stream_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.stream
    ADD CONSTRAINT stream_distribution_fkey FOREIGN KEY (distribution) REFERENCES serial.distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription_note subscription_note_creator_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.subscription_note
    ADD CONSTRAINT subscription_note_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription_note subscription_note_subscription_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.subscription_note
    ADD CONSTRAINT subscription_note_subscription_fkey FOREIGN KEY (subscription) REFERENCES serial.subscription(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription subscription_owning_lib_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.subscription
    ADD CONSTRAINT subscription_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: subscription subscription_record_entry_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.subscription
    ADD CONSTRAINT subscription_record_entry_fkey FOREIGN KEY (record_entry) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: supplement_summary sup_summary_distribution_fkey; Type: FK CONSTRAINT; Schema: serial; Owner: evergreen
--

ALTER TABLE ONLY serial.supplement_summary
    ADD CONSTRAINT sup_summary_distribution_fkey FOREIGN KEY (distribution) REFERENCES serial.distribution(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: account account_setting_group_fkey; Type: FK CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.account
    ADD CONSTRAINT account_setting_group_fkey FOREIGN KEY (setting_group) REFERENCES sip.setting_group(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: account account_usr_fkey; Type: FK CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.account
    ADD CONSTRAINT account_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: account account_workstation_fkey; Type: FK CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.account
    ADD CONSTRAINT account_workstation_fkey FOREIGN KEY (workstation) REFERENCES actor.workstation(id);


--
-- Name: session session_account_fkey; Type: FK CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.session
    ADD CONSTRAINT session_account_fkey FOREIGN KEY (account) REFERENCES sip.account(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: setting setting_setting_group_fkey; Type: FK CONSTRAINT; Schema: sip; Owner: evergreen
--

ALTER TABLE ONLY sip.setting
    ADD CONSTRAINT setting_setting_group_fkey FOREIGN KEY (setting_group) REFERENCES sip.setting_group(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: user_stage user_stage_net_access_level_fkey; Type: FK CONSTRAINT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.user_stage
    ADD CONSTRAINT user_stage_net_access_level_fkey FOREIGN KEY (net_access_level) REFERENCES config.net_access_level(id);


--
-- Name: user_stage user_stage_requesting_usr_fkey; Type: FK CONSTRAINT; Schema: staging; Owner: evergreen
--

ALTER TABLE ONLY staging.user_stage
    ADD CONSTRAINT user_stage_requesting_usr_fkey FOREIGN KEY (requesting_usr) REFERENCES actor.usr(id) ON DELETE SET NULL;


--
-- Name: bre_output_layout bre_output_layout_transform_fkey; Type: FK CONSTRAINT; Schema: unapi; Owner: evergreen
--

ALTER TABLE ONLY unapi.bre_output_layout
    ADD CONSTRAINT bre_output_layout_transform_fkey FOREIGN KEY (transform) REFERENCES config.xml_transform(name) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: session session_container_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.session
    ADD CONSTRAINT session_container_fkey FOREIGN KEY (container) REFERENCES container.biblio_record_entry_bucket(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: session session_creator_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.session
    ADD CONSTRAINT session_creator_fkey FOREIGN KEY (creator) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: session session_owning_lib_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.session
    ADD CONSTRAINT session_owning_lib_fkey FOREIGN KEY (owning_lib) REFERENCES actor.org_unit(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url url_item_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url
    ADD CONSTRAINT url_item_fkey FOREIGN KEY (item) REFERENCES container.biblio_record_entry_bucket_item(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url url_redirect_from_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url
    ADD CONSTRAINT url_redirect_from_fkey FOREIGN KEY (redirect_from) REFERENCES url_verify.url(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_selector url_selector_session_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url_selector
    ADD CONSTRAINT url_selector_session_fkey FOREIGN KEY (session) REFERENCES url_verify.session(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url url_session_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url
    ADD CONSTRAINT url_session_fkey FOREIGN KEY (session) REFERENCES url_verify.session(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url url_url_selector_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url
    ADD CONSTRAINT url_url_selector_fkey FOREIGN KEY (url_selector) REFERENCES url_verify.url_selector(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_verification url_verification_attempt_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url_verification
    ADD CONSTRAINT url_verification_attempt_fkey FOREIGN KEY (attempt) REFERENCES url_verify.verification_attempt(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_verification url_verification_redirect_to_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url_verification
    ADD CONSTRAINT url_verification_redirect_to_fkey FOREIGN KEY (redirect_to) REFERENCES url_verify.url(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: url_verification url_verification_url_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.url_verification
    ADD CONSTRAINT url_verification_url_fkey FOREIGN KEY (url) REFERENCES url_verify.url(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: verification_attempt verification_attempt_session_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.verification_attempt
    ADD CONSTRAINT verification_attempt_session_fkey FOREIGN KEY (session) REFERENCES url_verify.session(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: verification_attempt verification_attempt_usr_fkey; Type: FK CONSTRAINT; Schema: url_verify; Owner: evergreen
--

ALTER TABLE ONLY url_verify.verification_attempt
    ADD CONSTRAINT verification_attempt_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: authority_match authority_match_eg_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.authority_match
    ADD CONSTRAINT authority_match_eg_record_fkey FOREIGN KEY (eg_record) REFERENCES authority.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: authority_match authority_match_queued_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.authority_match
    ADD CONSTRAINT authority_match_queued_record_fkey FOREIGN KEY (queued_record) REFERENCES vandelay.queued_authority_record(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bib_match bib_match_eg_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_match
    ADD CONSTRAINT bib_match_eg_record_fkey FOREIGN KEY (eg_record) REFERENCES biblio.record_entry(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bib_match bib_match_queued_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_match
    ADD CONSTRAINT bib_match_queued_record_fkey FOREIGN KEY (queued_record) REFERENCES vandelay.queued_bib_record(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bib_queue bib_queue_item_attr_def_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_queue
    ADD CONSTRAINT bib_queue_item_attr_def_fkey FOREIGN KEY (item_attr_def) REFERENCES vandelay.import_item_attr_definition(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: bib_queue bib_queue_match_bucket_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.bib_queue
    ADD CONSTRAINT bib_queue_match_bucket_fkey FOREIGN KEY (match_bucket) REFERENCES container.biblio_record_entry_bucket(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_bib_trash_fields import_bib_trash_fields_grp_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_bib_trash_fields
    ADD CONSTRAINT import_bib_trash_fields_grp_fkey FOREIGN KEY (grp) REFERENCES vandelay.import_bib_trash_group(id);


--
-- Name: import_bib_trash_group import_bib_trash_group_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_bib_trash_group
    ADD CONSTRAINT import_bib_trash_group_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id);


--
-- Name: import_item_attr_definition import_item_attr_definition_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_item_attr_definition
    ADD CONSTRAINT import_item_attr_definition_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_item import_item_definition_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_item
    ADD CONSTRAINT import_item_definition_fkey FOREIGN KEY (definition) REFERENCES vandelay.import_item_attr_definition(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_item import_item_import_error_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_item
    ADD CONSTRAINT import_item_import_error_fkey FOREIGN KEY (import_error) REFERENCES vandelay.import_error(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: import_item import_item_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.import_item
    ADD CONSTRAINT import_item_record_fkey FOREIGN KEY (record) REFERENCES vandelay.queued_bib_record(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: match_set match_set_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set
    ADD CONSTRAINT match_set_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON DELETE CASCADE;


--
-- Name: match_set_point match_set_point_match_set_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set_point
    ADD CONSTRAINT match_set_point_match_set_fkey FOREIGN KEY (match_set) REFERENCES vandelay.match_set(id) ON DELETE CASCADE;


--
-- Name: match_set_point match_set_point_parent_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set_point
    ADD CONSTRAINT match_set_point_parent_fkey FOREIGN KEY (parent) REFERENCES vandelay.match_set_point(id);


--
-- Name: match_set_point match_set_point_svf_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set_point
    ADD CONSTRAINT match_set_point_svf_fkey FOREIGN KEY (svf) REFERENCES config.record_attr_definition(name);


--
-- Name: match_set_quality match_set_quality_match_set_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set_quality
    ADD CONSTRAINT match_set_quality_match_set_fkey FOREIGN KEY (match_set) REFERENCES vandelay.match_set(id) ON DELETE CASCADE;


--
-- Name: match_set_quality match_set_quality_svf_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.match_set_quality
    ADD CONSTRAINT match_set_quality_svf_fkey FOREIGN KEY (svf) REFERENCES config.record_attr_definition(name);


--
-- Name: merge_profile merge_profile_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.merge_profile
    ADD CONSTRAINT merge_profile_owner_fkey FOREIGN KEY (owner) REFERENCES actor.org_unit(id) ON UPDATE CASCADE ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queue queue_match_set_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queue
    ADD CONSTRAINT queue_match_set_fkey FOREIGN KEY (match_set) REFERENCES vandelay.match_set(id) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queue queue_owner_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queue
    ADD CONSTRAINT queue_owner_fkey FOREIGN KEY (owner) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_attr queued_authority_record_attr_field_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record_attr
    ADD CONSTRAINT queued_authority_record_attr_field_fkey FOREIGN KEY (field) REFERENCES vandelay.authority_attr_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record_attr queued_authority_record_attr_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record_attr
    ADD CONSTRAINT queued_authority_record_attr_record_fkey FOREIGN KEY (record) REFERENCES vandelay.queued_authority_record(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record queued_authority_record_import_error_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record
    ADD CONSTRAINT queued_authority_record_import_error_fkey FOREIGN KEY (import_error) REFERENCES vandelay.import_error(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record queued_authority_record_imported_as_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record
    ADD CONSTRAINT queued_authority_record_imported_as_fkey FOREIGN KEY (imported_as) REFERENCES authority.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_authority_record queued_authority_record_queue_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_authority_record
    ADD CONSTRAINT queued_authority_record_queue_fkey FOREIGN KEY (queue) REFERENCES vandelay.authority_queue(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_attr queued_bib_record_attr_field_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record_attr
    ADD CONSTRAINT queued_bib_record_attr_field_fkey FOREIGN KEY (field) REFERENCES vandelay.bib_attr_definition(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record_attr queued_bib_record_attr_record_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record_attr
    ADD CONSTRAINT queued_bib_record_attr_record_fkey FOREIGN KEY (record) REFERENCES vandelay.queued_bib_record(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record queued_bib_record_bib_source_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record
    ADD CONSTRAINT queued_bib_record_bib_source_fkey FOREIGN KEY (bib_source) REFERENCES config.bib_source(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record queued_bib_record_import_error_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record
    ADD CONSTRAINT queued_bib_record_import_error_fkey FOREIGN KEY (import_error) REFERENCES vandelay.import_error(code) ON UPDATE CASCADE ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record queued_bib_record_imported_as_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record
    ADD CONSTRAINT queued_bib_record_imported_as_fkey FOREIGN KEY (imported_as) REFERENCES biblio.record_entry(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: queued_bib_record queued_bib_record_queue_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.queued_bib_record
    ADD CONSTRAINT queued_bib_record_queue_fkey FOREIGN KEY (queue) REFERENCES vandelay.bib_queue(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: session_tracker session_tracker_usr_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.session_tracker
    ADD CONSTRAINT session_tracker_usr_fkey FOREIGN KEY (usr) REFERENCES actor.usr(id) DEFERRABLE INITIALLY DEFERRED;


--
-- Name: session_tracker session_tracker_workstation_fkey; Type: FK CONSTRAINT; Schema: vandelay; Owner: evergreen
--

ALTER TABLE ONLY vandelay.session_tracker
    ADD CONSTRAINT session_tracker_workstation_fkey FOREIGN KEY (workstation) REFERENCES actor.workstation(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


--
-- Name: TABLE cdr; Type: ACL; Schema: extend_reporter; Owner: postgres
--

GRANT ALL ON TABLE extend_reporter.cdr TO evergreen;


--
-- PostgreSQL database dump complete
--

